#define V_COMMIT_HASH "1991220"

#ifndef V_COMMIT_HASH
#define V_COMMIT_HASH "ef38777"
#endif


#ifndef V_CURRENT_COMMIT_HASH
#define V_CURRENT_COMMIT_HASH "1991220"
#endif




// V typedefs:

typedef struct {
	void* _object;
	int _interface_idx;
} _Interface;

typedef struct strings__Builder strings__Builder;
typedef struct strconv__ftoa__Dec32 strconv__ftoa__Dec32;
typedef union strconv__ftoa__Uf32 strconv__ftoa__Uf32;
typedef struct strconv__ftoa__Uint128 strconv__ftoa__Uint128;
typedef struct strconv__ftoa__Dec64 strconv__ftoa__Dec64;
typedef union strconv__ftoa__Uf64 strconv__ftoa__Uf64;
typedef union strconv__Float64u strconv__Float64u;
typedef struct strconv__PrepNumber strconv__PrepNumber;
typedef enum {
	strconv__Char_parse_state_start, // 
	strconv__Char_parse_state_norm_char, // +1
	strconv__Char_parse_state_field_char, // +2
	strconv__Char_parse_state_pad_ch, // +3
	strconv__Char_parse_state_len_set_start, // +4
	strconv__Char_parse_state_len_set_in, // +5
	strconv__Char_parse_state_check_type, // +6
	strconv__Char_parse_state_check_float, // +7
	strconv__Char_parse_state_check_float_in, // +8
	strconv__Char_parse_state_reset_params, // +9
} strconv__Char_parse_state;

typedef enum {
	strconv__Align_text_right = 0, // 0
	strconv__Align_text_left, // 0+1
	strconv__Align_text_center, // 0+2
} strconv__Align_text;

typedef struct strconv__BF_param strconv__BF_param;
typedef struct array array;
typedef struct DenseArray DenseArray;
typedef struct map map;
typedef struct Option Option;
typedef struct SortedMap SortedMap;
typedef struct mapnode mapnode;
typedef struct string string;
typedef struct ustring ustring;
typedef struct RepIndex RepIndex;
typedef enum {
	os__FileType_regular, // 
	os__FileType_directory, // +1
	os__FileType_character_device, // +2
	os__FileType_block_device, // +3
	os__FileType_fifo, // +4
	os__FileType_symbolic_link, // +5
	os__FileType_socket, // +6
} os__FileType;

typedef struct os__FilePermission os__FilePermission;
typedef struct os__FileMode os__FileMode;
typedef struct os__File os__File;
typedef struct os__FileInfo os__FileInfo;
typedef struct os__Foo2 os__Foo2;
typedef struct os__Result os__Result;
typedef struct v__token__Position v__token__Position;
typedef struct v__token__Token v__token__Token;
typedef enum {
	v__token__Kind_eof, // 
	v__token__Kind_name, // +1
	v__token__Kind_number, // +2
	v__token__Kind_string, // +3
	v__token__Kind_str_inter, // +4
	v__token__Kind_chartoken, // +5
	v__token__Kind_plus, // +6
	v__token__Kind_minus, // +7
	v__token__Kind_mul, // +8
	v__token__Kind_div, // +9
	v__token__Kind_mod, // +10
	v__token__Kind_xor, // +11
	v__token__Kind_pipe, // +12
	v__token__Kind_inc, // +13
	v__token__Kind_dec, // +14
	v__token__Kind_and, // +15
	v__token__Kind_logical_or, // +16
	v__token__Kind_not, // +17
	v__token__Kind_bit_not, // +18
	v__token__Kind_question, // +19
	v__token__Kind_comma, // +20
	v__token__Kind_semicolon, // +21
	v__token__Kind_colon, // +22
	v__token__Kind_arrow, // +23
	v__token__Kind_amp, // +24
	v__token__Kind_hash, // +25
	v__token__Kind_dollar, // +26
	v__token__Kind_str_dollar, // +27
	v__token__Kind_left_shift, // +28
	v__token__Kind_right_shift, // +29
	v__token__Kind_not_in, // +30
	v__token__Kind_assign, // +31
	v__token__Kind_decl_assign, // +32
	v__token__Kind_plus_assign, // +33
	v__token__Kind_minus_assign, // +34
	v__token__Kind_div_assign, // +35
	v__token__Kind_mult_assign, // +36
	v__token__Kind_xor_assign, // +37
	v__token__Kind_mod_assign, // +38
	v__token__Kind_or_assign, // +39
	v__token__Kind_and_assign, // +40
	v__token__Kind_right_shift_assign, // +41
	v__token__Kind_left_shift_assign, // +42
	v__token__Kind_lcbr, // +43
	v__token__Kind_rcbr, // +44
	v__token__Kind_lpar, // +45
	v__token__Kind_rpar, // +46
	v__token__Kind_lsbr, // +47
	v__token__Kind_rsbr, // +48
	v__token__Kind_eq, // +49
	v__token__Kind_ne, // +50
	v__token__Kind_gt, // +51
	v__token__Kind_lt, // +52
	v__token__Kind_ge, // +53
	v__token__Kind_le, // +54
	v__token__Kind_comment, // +55
	v__token__Kind_nl, // +56
	v__token__Kind_dot, // +57
	v__token__Kind_dotdot, // +58
	v__token__Kind_ellipsis, // +59
	v__token__Kind_keyword_beg, // +60
	v__token__Kind_key_as, // +61
	v__token__Kind_key_asm, // +62
	v__token__Kind_key_assert, // +63
	v__token__Kind_key_atomic, // +64
	v__token__Kind_key_break, // +65
	v__token__Kind_key_const, // +66
	v__token__Kind_key_continue, // +67
	v__token__Kind_key_defer, // +68
	v__token__Kind_key_else, // +69
	v__token__Kind_key_embed, // +70
	v__token__Kind_key_enum, // +71
	v__token__Kind_key_false, // +72
	v__token__Kind_key_for, // +73
	v__token__Kind_key_fn, // +74
	v__token__Kind_key_global, // +75
	v__token__Kind_key_go, // +76
	v__token__Kind_key_goto, // +77
	v__token__Kind_key_if, // +78
	v__token__Kind_key_import, // +79
	v__token__Kind_key_in, // +80
	v__token__Kind_key_interface, // +81
	v__token__Kind_key_is, // +82
	v__token__Kind_key_match, // +83
	v__token__Kind_key_module, // +84
	v__token__Kind_key_mut, // +85
	v__token__Kind_key_none, // +86
	v__token__Kind_key_return, // +87
	v__token__Kind_key_select, // +88
	v__token__Kind_key_sizeof, // +89
	v__token__Kind_key_offsetof, // +90
	v__token__Kind_key_struct, // +91
	v__token__Kind_key_switch, // +92
	v__token__Kind_key_true, // +93
	v__token__Kind_key_type, // +94
	v__token__Kind_key_typeof, // +95
	v__token__Kind_key_orelse, // +96
	v__token__Kind_key_union, // +97
	v__token__Kind_key_pub, // +98
	v__token__Kind_key_static, // +99
	v__token__Kind_key_unsafe, // +100
	v__token__Kind_keyword_end, // +101
	v__token__Kind__end_, // +102
} v__token__Kind;

typedef enum {
	v__token__Precedence_lowest, // 
	v__token__Precedence_cond, // +1
	v__token__Precedence_in_as, // +2
	v__token__Precedence_assign, // +3
	v__token__Precedence_eq, // +4
	v__token__Precedence_sum, // +5
	v__token__Precedence_product, // +6
	v__token__Precedence_prefix, // +7
	v__token__Precedence_postfix, // +8
	v__token__Precedence_call, // +9
	v__token__Precedence_index, // +10
} v__token__Precedence;

typedef struct time__StopWatch time__StopWatch;
typedef struct time__Time time__Time;
typedef enum {
	time__FormatTime_hhmm12, // 
	time__FormatTime_hhmm24, // +1
	time__FormatTime_hhmmss12, // +2
	time__FormatTime_hhmmss24, // +3
	time__FormatTime_no_time, // +4
} time__FormatTime;

typedef enum {
	time__FormatDate_ddmmyy, // 
	time__FormatDate_ddmmyyyy, // +1
	time__FormatDate_mmddyy, // +2
	time__FormatDate_mmddyyyy, // +3
	time__FormatDate_mmmd, // +4
	time__FormatDate_mmmdd, // +5
	time__FormatDate_mmmddyyyy, // +6
	time__FormatDate_no_date, // +7
	time__FormatDate_yyyymmdd, // +8
} time__FormatDate;

typedef enum {
	time__FormatDelimiter_dot, // 
	time__FormatDelimiter_hyphen, // +1
	time__FormatDelimiter_slash, // +2
	time__FormatDelimiter_space, // +3
} time__FormatDelimiter;

typedef struct v__depgraph__DepGraphNode v__depgraph__DepGraphNode;
typedef struct v__depgraph__DepGraph v__depgraph__DepGraph;
typedef struct v__depgraph__OrderedDepMap v__depgraph__OrderedDepMap;
typedef struct v__cflag__CFlag v__cflag__CFlag;
typedef struct v__vmod__ModFileAndFolder v__vmod__ModFileAndFolder;
typedef struct v__vmod__ModFileCacher v__vmod__ModFileCacher;
typedef enum {
	v__errors__Reporter_scanner, // 
	v__errors__Reporter_parser, // +1
	v__errors__Reporter_checker, // +2
	v__errors__Reporter_gen, // +3
} v__errors__Reporter;

typedef struct v__errors__Error v__errors__Error;
typedef struct v__errors__Warning v__errors__Warning;
typedef struct v__table__TypeSymbol v__table__TypeSymbol;
typedef enum {
	v__table__TypeFlag_unset, // 
	v__table__TypeFlag_optional, // +1
	v__table__TypeFlag_variadic, // +2
} v__table__TypeFlag;

typedef struct v__table__MultiReturn v__table__MultiReturn;
typedef struct v__table__FnType v__table__FnType;
typedef enum {
	v__table__Kind_placeholder, // 
	v__table__Kind_void, // +1
	v__table__Kind_voidptr, // +2
	v__table__Kind_byteptr, // +3
	v__table__Kind_charptr, // +4
	v__table__Kind_i8, // +5
	v__table__Kind_i16, // +6
	v__table__Kind_int, // +7
	v__table__Kind_i64, // +8
	v__table__Kind_byte, // +9
	v__table__Kind_u16, // +10
	v__table__Kind_u32, // +11
	v__table__Kind_u64, // +12
	v__table__Kind_f32, // +13
	v__table__Kind_f64, // +14
	v__table__Kind_char, // +15
	v__table__Kind_size_t, // +16
	v__table__Kind_bool, // +17
	v__table__Kind_none_, // +18
	v__table__Kind_string, // +19
	v__table__Kind_ustring, // +20
	v__table__Kind_array, // +21
	v__table__Kind_array_fixed, // +22
	v__table__Kind_map, // +23
	v__table__Kind_any, // +24
	v__table__Kind_struct_, // +25
	v__table__Kind_multi_return, // +26
	v__table__Kind_sum_type, // +27
	v__table__Kind_alias, // +28
	v__table__Kind_enum_, // +29
	v__table__Kind_function, // +30
	v__table__Kind_interface_, // +31
} v__table__Kind;

typedef struct v__table__Struct v__table__Struct;
typedef struct v__table__Interface v__table__Interface;
typedef struct v__table__Enum v__table__Enum;
typedef struct v__table__Alias v__table__Alias;
typedef struct v__table__Field v__table__Field;
typedef struct v__table__Array v__table__Array;
typedef struct v__table__ArrayFixed v__table__ArrayFixed;
typedef struct v__table__Map v__table__Map;
typedef struct v__table__SumType v__table__SumType;
typedef struct v__table__Table v__table__Table;
typedef struct v__table__Fn v__table__Fn;
typedef struct v__table__Arg v__table__Arg;
typedef struct v__table__Var v__table__Var;
typedef enum {
	v__pref__OS__auto, // 
	v__pref__OS_mac, // +1
	v__pref__OS_linux, // +2
	v__pref__OS_windows, // +3
	v__pref__OS_freebsd, // +4
	v__pref__OS_openbsd, // +5
	v__pref__OS_netbsd, // +6
	v__pref__OS_dragonfly, // +7
	v__pref__OS_js, // +8
	v__pref__OS_android, // +9
	v__pref__OS_solaris, // +10
	v__pref__OS_haiku, // +11
} v__pref__OS;

typedef enum {
	v__pref__BuildMode_default_mode, // 
	v__pref__BuildMode_build_module, // +1
} v__pref__BuildMode;

typedef enum {
	v__pref__Backend_c, // 
	v__pref__Backend_js, // +1
	v__pref__Backend_x64, // +2
} v__pref__Backend;

typedef struct v__pref__Preferences v__pref__Preferences;
typedef struct v__util__EManager v__util__EManager;
typedef struct v__ast__Type v__ast__Type;
typedef struct v__ast__Block v__ast__Block;
typedef struct v__ast__ExprStmt v__ast__ExprStmt;
typedef struct v__ast__IntegerLiteral v__ast__IntegerLiteral;
typedef struct v__ast__FloatLiteral v__ast__FloatLiteral;
typedef struct v__ast__StringLiteral v__ast__StringLiteral;
typedef struct v__ast__StringInterLiteral v__ast__StringInterLiteral;
typedef struct v__ast__CharLiteral v__ast__CharLiteral;
typedef struct v__ast__BoolLiteral v__ast__BoolLiteral;
typedef struct v__ast__SelectorExpr v__ast__SelectorExpr;
typedef struct v__ast__Module v__ast__Module;
typedef struct v__ast__StructField v__ast__StructField;
typedef struct v__ast__Field v__ast__Field;
typedef struct v__ast__ConstField v__ast__ConstField;
typedef struct v__ast__ConstDecl v__ast__ConstDecl;
typedef struct v__ast__StructDecl v__ast__StructDecl;
typedef struct v__ast__InterfaceDecl v__ast__InterfaceDecl;
typedef struct v__ast__StructInitField v__ast__StructInitField;
typedef struct v__ast__StructInit v__ast__StructInit;
typedef struct v__ast__Import v__ast__Import;
typedef struct v__ast__AnonFn v__ast__AnonFn;
typedef struct v__ast__FnDecl v__ast__FnDecl;
typedef struct v__ast__BranchStmt v__ast__BranchStmt;
typedef struct v__ast__CallExpr v__ast__CallExpr;
typedef struct v__ast__CallArg v__ast__CallArg;
typedef struct v__ast__Return v__ast__Return;
typedef struct v__ast__Var v__ast__Var;
typedef struct v__ast__GlobalDecl v__ast__GlobalDecl;
typedef struct v__ast__File v__ast__File;
typedef struct v__ast__IdentFn v__ast__IdentFn;
typedef struct v__ast__IdentVar v__ast__IdentVar;
typedef enum {
	v__ast__IdentKind_unresolved, // 
	v__ast__IdentKind_blank_ident, // +1
	v__ast__IdentKind_variable, // +2
	v__ast__IdentKind_constant, // +3
	v__ast__IdentKind_global, // +4
	v__ast__IdentKind_function, // +5
} v__ast__IdentKind;

typedef struct v__ast__Ident v__ast__Ident;
typedef struct v__ast__InfixExpr v__ast__InfixExpr;
typedef struct v__ast__PostfixExpr v__ast__PostfixExpr;
typedef struct v__ast__PrefixExpr v__ast__PrefixExpr;
typedef struct v__ast__IndexExpr v__ast__IndexExpr;
typedef struct v__ast__IfExpr v__ast__IfExpr;
typedef struct v__ast__IfBranch v__ast__IfBranch;
typedef struct v__ast__MatchExpr v__ast__MatchExpr;
typedef struct v__ast__MatchBranch v__ast__MatchBranch;
typedef struct v__ast__CompIf v__ast__CompIf;
typedef struct v__ast__ForStmt v__ast__ForStmt;
typedef struct v__ast__ForInStmt v__ast__ForInStmt;
typedef struct v__ast__ForCStmt v__ast__ForCStmt;
typedef struct v__ast__ReturnStmt v__ast__ReturnStmt;
typedef struct v__ast__HashStmt v__ast__HashStmt;
typedef struct v__ast__Lambda v__ast__Lambda;
typedef struct v__ast__AssignStmt v__ast__AssignStmt;
typedef struct v__ast__AsCast v__ast__AsCast;
typedef struct v__ast__Attr v__ast__Attr;
typedef struct v__ast__EnumVal v__ast__EnumVal;
typedef struct v__ast__EnumField v__ast__EnumField;
typedef struct v__ast__EnumDecl v__ast__EnumDecl;
typedef struct v__ast__AliasTypeDecl v__ast__AliasTypeDecl;
typedef struct v__ast__SumTypeDecl v__ast__SumTypeDecl;
typedef struct v__ast__FnTypeDecl v__ast__FnTypeDecl;
typedef struct v__ast__DeferStmt v__ast__DeferStmt;
typedef struct v__ast__UnsafeStmt v__ast__UnsafeStmt;
typedef struct v__ast__ParExpr v__ast__ParExpr;
typedef struct v__ast__AssignExpr v__ast__AssignExpr;
typedef struct v__ast__GoStmt v__ast__GoStmt;
typedef struct v__ast__GotoLabel v__ast__GotoLabel;
typedef struct v__ast__GotoStmt v__ast__GotoStmt;
typedef struct v__ast__ArrayInit v__ast__ArrayInit;
typedef struct v__ast__MapInit v__ast__MapInit;
typedef struct v__ast__RangeExpr v__ast__RangeExpr;
typedef struct v__ast__CastExpr v__ast__CastExpr;
typedef struct v__ast__AssertStmt v__ast__AssertStmt;
typedef struct v__ast__IfGuardExpr v__ast__IfGuardExpr;
typedef struct v__ast__OrExpr v__ast__OrExpr;
typedef struct v__ast__Assoc v__ast__Assoc;
typedef struct v__ast__SizeOf v__ast__SizeOf;
typedef struct v__ast__TypeOf v__ast__TypeOf;
typedef struct v__ast__Comment v__ast__Comment;
typedef struct v__ast__ConcatExpr v__ast__ConcatExpr;
typedef struct v__ast__None v__ast__None;
typedef struct v__ast__Scope v__ast__Scope;
typedef struct v__checker__Checker v__checker__Checker;
typedef struct v__gen__Gen v__gen__Gen;
typedef struct v__gen__ProfileCounterMeta v__gen__ProfileCounterMeta;
typedef struct v__gen__js__JsGen v__gen__js__JsGen;
typedef struct v__gen__js__JsDoc v__gen__js__JsDoc;
typedef enum {
	v__gen__x64__SectionType_null = 0, // 0
	v__gen__x64__SectionType_progbits = 1, // 1
	v__gen__x64__SectionType_symtab = 2, // 2
	v__gen__x64__SectionType_strtab = 3, // 3
	v__gen__x64__SectionType_rela = 4, // 4
} v__gen__x64__SectionType;

typedef struct v__gen__x64__SectionConfig v__gen__x64__SectionConfig;
typedef struct v__gen__x64__Gen v__gen__x64__Gen;
typedef enum {
	v__gen__x64__Register_rax, // 
	v__gen__x64__Register_rcx, // +1
	v__gen__x64__Register_rdx, // +2
	v__gen__x64__Register_rbx, // +3
	v__gen__x64__Register_rsp, // +4
	v__gen__x64__Register_rbp, // +5
	v__gen__x64__Register_rsi, // +6
	v__gen__x64__Register_rdi, // +7
	v__gen__x64__Register_eax, // +8
	v__gen__x64__Register_edi, // +9
	v__gen__x64__Register_edx, // +10
	v__gen__x64__Register_r8, // +11
	v__gen__x64__Register_r9, // +12
	v__gen__x64__Register_r10, // +13
	v__gen__x64__Register_r11, // +14
	v__gen__x64__Register_r12, // +15
	v__gen__x64__Register_r13, // +16
	v__gen__x64__Register_r14, // +17
	v__gen__x64__Register_r15, // +18
} v__gen__x64__Register;

typedef enum {
	v__gen__x64__Size__8, // 
	v__gen__x64__Size__16, // +1
	v__gen__x64__Size__32, // +2
	v__gen__x64__Size__64, // +3
} v__gen__x64__Size;

typedef struct v__scanner__Scanner v__scanner__Scanner;
typedef enum {
	v__scanner__CommentsMode_skip_comments, // 
	v__scanner__CommentsMode_parse_comments, // +1
} v__scanner__CommentsMode;

typedef struct v__parser__Parser v__parser__Parser;
typedef struct v__doc__Doc v__doc__Doc;
typedef struct v__builder__Builder v__builder__Builder;
typedef struct v__builder__MsvcResult v__builder__MsvcResult;
typedef struct v__builder__WindowsKit v__builder__WindowsKit;
typedef struct v__builder__VsInstallation v__builder__VsInstallation;
typedef struct v__builder__MsvcStringFlags v__builder__MsvcStringFlags;
typedef struct varg_voidptr varg_voidptr;
typedef struct varg_string varg_string;
typedef struct varg_int varg_int;


// V typedefs2:
typedef Option Option_int;
typedef Option Option_array_byte;
typedef Option Option_string;
typedef Option Option_bool;
typedef Option Option_array_string;
typedef Option Option_array_ustring;
typedef Option Option_os__File;
typedef Option Option_os__Result;
typedef Option Option_time__Time;
typedef Option Option_v__table__Fn;
typedef Option Option_v__table__Field;
typedef Option Option_v__table__TypeSymbol;
typedef Option Option_v__pref__OS;
typedef Option Option_v__pref__Backend;
typedef Option Option_multi_return_v__ast__ScopeObject_v__ast__Scope;
typedef Option Option_v__ast__ScopeObject;
typedef Option Option_v__ast__Var_ptr;
typedef Option Option_v__ast__ConstField_ptr;
typedef Option Option_v__ast__IntegerLiteral;
typedef Option Option_v__builder__WindowsKit;
typedef Option Option_v__builder__VsInstallation;
typedef Option Option_v__builder__MsvcResult;


// V cheaders:
// Generated by the V compiler
#include <inttypes.h>


//================================== builtin types ================================*/

typedef int64_t i64;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t byte;
typedef uint32_t rune;
typedef float f32;
typedef double f64;
typedef unsigned char* byteptr;
typedef void* voidptr;
typedef char* charptr;
typedef struct array array;
typedef struct map map;
typedef array array_string;
typedef array array_int;
typedef array array_byte;
typedef array array_f32;
typedef array array_f64;
typedef array array_u16;
typedef array array_u32;
typedef array array_u64;
typedef map map_int;
typedef map map_string;
typedef byte array_fixed_byte_300 [300];
typedef byte array_fixed_byte_400 [400];
#ifndef bool
	typedef int bool;
	#define true 1
	#define false 0
#endif




// c_headers
#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually
#include <stdlib.h>

//#include "fns.h"
#include <signal.h>
#include <stdarg.h> // for va_list
#include <string.h> // memcpy

#if INTPTR_MAX == INT32_MAX
    #define TARGET_IS_32BIT 1
#elif INTPTR_MAX == INT64_MAX
    #define TARGET_IS_64BIT 1
#else
    #error "The environment is not 32 or 64-bit."
#endif

#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
    #define TARGET_ORDER_IS_BIG
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_X64) || defined(_M_IX86)
    #define TARGET_ORDER_IS_LITTLE
#else
    #error "Unknown architecture endianness"
#endif

#ifndef _WIN32
#include <ctype.h>
#include <locale.h> // tolower
#include <sys/time.h>
#include <unistd.h> // sleep
extern char **environ;
#endif

#if defined(__CYGWIN__) && !defined(_WIN32)
#error Cygwin is not supported, please use MinGW or Visual Studio.
#endif


#ifdef __linux__
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __FreeBSD__
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __DragonFly__
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __OpenBSD__
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __NetBSD__
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __sun
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif


#define EMPTY_STRUCT_DECLARATION
#define EMPTY_STRUCT_INITIALIZATION 0
// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...
#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])
#define TCCSKIP(x) x

#ifdef __TINYC__
#undef EMPTY_STRUCT_DECLARATION
#undef EMPTY_STRUCT_INITIALIZATION
#define EMPTY_STRUCT_DECLARATION char _dummy
#define EMPTY_STRUCT_INITIALIZATION 0
#undef EMPTY_ARRAY_OF_ELEMS
#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])
#undef TCCSKIP
#define TCCSKIP(x)
#include <byteswap.h>
#endif

// for __offset_of
#ifndef __offsetof
#define __offsetof(s,memb) ((size_t)((char *)&((s *)0)->memb - (char *)0))
#endif

#define OPTION_CAST(x) (x)

#ifndef V64_PRINTFORMAT
#ifdef PRIx64
#define V64_PRINTFORMAT "0x%"PRIx64
#elif defined(__WIN32__)
#define V64_PRINTFORMAT "0x%I64x"
#elif defined(__linux__) && defined(__LP64__)
#define V64_PRINTFORMAT "0x%lx"
#else
#define V64_PRINTFORMAT "0x%llx"
#endif
#endif



#ifdef _WIN32
#define WINVER 0x0600
#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif
#define _WIN32_WINNT 0x0600
#define WIN32_LEAN_AND_MEAN
#define _UNICODE
#define UNICODE
#include <windows.h>

#include <io.h> // _waccess
#include <direct.h> // _wgetcwd
//#include <WinSock2.h>
#ifdef _MSC_VER

// On MSVC these are the same (as long as /volatile:ms is passed)
#define _Atomic volatile

// MSVC cannot parse some things properly
#undef EMPTY_STRUCT_DECLARATION
#undef OPTION_CAST

#define EMPTY_STRUCT_DECLARATION int ____dummy_variable
#define OPTION_CAST(x)

#include <dbghelp.h>
#pragma comment(lib, "Dbghelp.lib")

extern wchar_t **_wenviron;

#endif

#else
#include <pthread.h>
#endif

// g_live_info is used by live.info()
void* g_live_info = NULL;

//============================== HELPER C MACROS =============================*/
//#define tos4(s, slen) ((string){.str=(s), .len=(slen)})
#define _SLIT(s) ((string){.str=(s), .len=(strlen(s))})
#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}
#define _IN(typ, val, arr) array_##typ##_contains(arr, val)
#define _IN_MAP(val, m) map_exists(m, val)
#define DEFAULT_EQUAL(a, b) (a == b)
#define DEFAULT_NOT_EQUAL(a, b) (a != b)
#define DEFAULT_LT(a, b) (a < b)
#define DEFAULT_LE(a, b) (a <= b)
#define DEFAULT_GT(a, b) (a > b)
#define DEFAULT_GE(a, b) (a >= b)

// NB: macro_fXX_eq and macro_fXX_ne are NOT used
// in the generated C code. They are here just for
// completeness/testing.

#define macro_f64_eq(a, b) (a == b)
#define macro_f64_ne(a, b) (a != b)
#define macro_f64_lt(a, b) (a <  b)
#define macro_f64_le(a, b) (a <= b)
#define macro_f64_gt(a, b) (a >  b)
#define macro_f64_ge(a, b) (a >= b)

#define macro_f32_eq(a, b) (a == b)
#define macro_f32_ne(a, b) (a != b)
#define macro_f32_lt(a, b) (a <  b)
#define macro_f32_le(a, b) (a <= b)
#define macro_f32_gt(a, b) (a >  b)
#define macro_f32_ge(a, b) (a >= b)

#if defined(__MINGW32__) || defined(__MINGW64__)
#undef PRId64
#undef PRIi64
#undef PRIo64
#undef PRIu64
#undef PRIx64
#undef PRIX64
#define PRId64 "lld"
#define PRIi64 "lli"
#define PRIo64 "llo"
#define PRIu64 "llu"
#define PRIx64 "llx"
#define PRIX64 "llX"
#endif

//================================== GLOBALS =================================*/
byte g_str_buf[1024];
int load_so(byteptr);
void reload_so();
void _vinit();
void _vcleanup();
#define sigaction_size sizeof(sigaction);
#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )

// ============== wyhash ==============
//Author: Wang Yi
#ifndef wyhash_version_gamma
#define wyhash_version_gamma
#define WYHASH_CONDOM 0
#include <stdint.h>
#include <string.h>
#if defined(_MSC_VER) && defined(_M_X64)
#include <intrin.h>
#pragma intrinsic(_umul128)
#endif

//const uint64_t _wyp0=0xa0761d6478bd642full, _wyp1=0xe7037ed1a0b428dbull;
#define _wyp0 ((uint64_t)0xa0761d6478bd642full)
#define _wyp1 ((uint64_t)0xe7037ed1a0b428dbull)


#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__) || defined(__TINYC__)
#define _likely_(x) __builtin_expect(x, 1)
#else
#define _likely_(x) (x)
#endif

#if defined(TARGET_ORDER_IS_LITTLE)
#define WYHASH_LITTLE_ENDIAN 1
#elif defined(TARGET_ORDER_IS_BIG)
#define WYHASH_LITTLE_ENDIAN 0
#endif

#if (WYHASH_LITTLE_ENDIAN)
  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return v;}
#else
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#elif defined(__TINYC__)
  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return bswap_64(v);}
  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return bswap_32(v);}
#endif
#endif

static inline uint64_t _wyr3(const uint8_t *p, unsigned k) { return (((uint64_t)p[0]) << 16) | (((uint64_t)p[k >> 1]) << 8) | p[k - 1];}
static inline uint64_t _wyrotr(uint64_t v, unsigned k) { return (v >> k) | (v << (64 - k));}
static inline void _wymix128(uint64_t A, uint64_t B, uint64_t *C, uint64_t *D){
	A^=*C;	B^=*D;
#ifdef UNOFFICIAL_WYHASH_32BIT
	uint64_t hh=(A>>32)*(B>>32), hl=(A>>32)*(unsigned)B, lh=(unsigned)A*(B>>32), ll=(uint64_t)(unsigned)A*(unsigned)B;
	*C=_wyrotr(hl,32)^hh; *D=_wyrotr(lh,32)^ll;
#else
#ifdef __SIZEOF_INT128__
	__uint128_t r=A; r*=B; *C=(uint64_t)r; *D=(uint64_t)(r>>64);
#elif defined(_MSC_VER) && defined(_M_X64)
	A=_umul128(A,B,&B); *C=A; *D=B;
#else
	uint64_t ha=A>>32, hb=B>>32, la=(uint32_t)A, lb=(uint32_t)B, hi, lo;
	uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
	lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
	*C=lo;	*D=hi;
#endif
#endif
}
static inline uint64_t wyhash(const void *key, uint64_t len, uint64_t seed){
	const uint8_t *p=(const uint8_t *)key;
	uint64_t i=len, see1=seed;
	start:
	if(_likely_(i<=16)){
	#ifndef	WYHASH_CONDOM
		uint64_t shift=(i<8)*((8-i)<<3);
		//WARNING: intended reading outside buffer, trading for speed.
		_wymix128((_wyr8(p)<<shift)^_wyp0,(_wyr8(p+i-8)>>shift)^_wyp1, &seed, &see1);
	#else
		if(_likely_(i<=8)){
			if(_likely_(i>=4))	_wymix128(_wyr4(p)^_wyp0,_wyr4(p+i-4)^_wyp1, &seed, &see1);
			else if (_likely_(i))	_wymix128(_wyr3(p,i)^_wyp0,_wyp1, &seed, &see1);
			else	_wymix128(_wyp0,_wyp1, &seed, &see1);
		}
  		else	_wymix128(_wyr8(p)^_wyp0,_wyr8(p+i-8)^_wyp1, &seed, &see1);
	#endif
		_wymix128(len,_wyp0, &seed, &see1);
		return	seed^see1;
	}
	_wymix128(_wyr8(p)^_wyp0,_wyr8(p+8)^_wyp1, &seed, &see1);
	i-=16;	p+=16;	goto start;
}
static inline uint64_t wyhash64(uint64_t A, uint64_t B){
	_wymix128(_wyp0,_wyp1,&A,&B);
	_wymix128(0,0,&A,&B);
	return	A^B;
}
static inline uint64_t wyrand(uint64_t *seed){
	*seed+=_wyp0;
	uint64_t	a=0, b=0;
	_wymix128(*seed,*seed^_wyp1,&a,&b);
	return	a^b;
}
static inline double wy2u01(uint64_t r) {
	const double _wynorm=1.0/(1ull<<52);
	return (r>>12)*_wynorm;
}
static inline double wy2gau(uint64_t r) {
	const double _wynorm=1.0/(1ull<<20);
	return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;
}
#endif




// V includes:
// added by module `builtin`:
#include <float.h>
// added by module `os`:
#include <sys/stat.h> // #include <signal.h>
// added by module `os`:
#include <errno.h>
// added by module `os`:
#include <dirent.h>
// added by module `os`:
#include <unistd.h>
// added by module `os`:
#include <fcntl.h>
// added by module `time`:
#include <time.h>
// added by module `term`:
#include <sys/ioctl.h>
// added by module `term`:
#include <termios.h> // TIOCGWINSZ


// V definitions:

void _STR_PRINT_ARG(const char*, char**, int*, int*, int, ...);


string _STR(const char*, int, ...);


string _STR_TMP(const char*, ...);

struct string {
	byteptr str;
	int len;
};

struct array {
	int element_size;
	voidptr data;
	int len;
	int cap;
};

struct DenseArray {
	int value_bytes;
	u32 cap;
	u32 size;
	u32 deletes;
	string* keys;
	byteptr values;
};

struct map {
	int value_bytes;
	u32 cap;
	byte cached_hashbits;
	byte shift;
	DenseArray key_values;
	u32* metas;
	u32 extra_metas;
	int size;
};

struct Option {
	array_fixed_byte_400 data;
	string v_error;
	int ecode;
	bool ok;
	bool is_none;
};

typedef map map_string_string;
typedef map map_string_int;
typedef map_string_string map_string;
typedef map_string_int map_int;
typedef array array_string;
typedef array array_byte;
typedef array array_int;
typedef array array_char;
typedef int (*anon_fn_7_7_7)(int,int);
typedef array array_voidptr;
typedef array array_RepIndex;
typedef array array_ustring;
typedef void (*anon_fn_18_1)(string);
typedef int v__table__Type;
typedef array array_v__table__Fn;
typedef array array_v__table__Type;
typedef array array_v__table__Kind;
typedef array array_v__table__Field;
typedef array array_v__table__TypeSymbol;
typedef map map_string_v__table__Fn;
typedef array array_v__cflag__CFlag;
typedef array array_v__table__Arg;
typedef array array_v__ast__Stmt;
typedef bool (*v__doc__FilterFn)(v__ast__FnDecl);
typedef array array_v__ast__File;
typedef voidptr v__builder__RegKey;
typedef array array_v__ast__Ident;
typedef array array_v__ast__Expr;
typedef array array_v__ast__CallArg;
typedef array array_v__ast__IfBranch;
typedef array array_v__ast__MatchBranch;
typedef array array_v__ast__Import;
typedef array array_v__ast__ConstField;
typedef array array_v__ast__EnumField;
typedef array array_v__ast__StructField;
typedef array array_v__ast__StructInitField;
typedef array array_v__ast__FnDecl;
typedef array array_v__ast__Scope_ptr;
typedef map map_string_v__ast__ScopeObject;
typedef array array_v__token__Kind;
typedef array array_v__token__Precedence;
typedef i64 time__Duration;
typedef voidptr time__time_t;
typedef map map_string_v__vmod__ModFileAndFolder;
typedef map map_string_array_string;
typedef array array_v__errors__Error;
typedef array array_v__errors__Warning;
typedef array array_v__ast__DeferStmt;
typedef array array_v__gen__ProfileCounterMeta;
typedef map map_string_strings__Builder;
typedef map map_string_array_v__ast__Stmt;
typedef array array_i64;
typedef map map_string_i64;
typedef array array_v__depgraph__DepGraphNode;
typedef map map_string_v__depgraph__DepGraphNode;
typedef array array_u32;
typedef array array_u64;
typedef array array_strconv__ftoa__Uint128;
typedef array array_f64;
typedef array array_v__gen__x64__Register;
typedef array array_v__pref__OS;
// builtin types:
//------------------ #endbuiltin
typedef string array_fixed_string_11 [11];
struct v__table__Alias {
	string foo;
};


// Sum type v__table__TypeInfo = 
//          |   79 = v__table__Alias     
//          |   80 = v__table__Array     
//          |   81 = v__table__ArrayFixed
//          |   82 = v__table__Enum      
//          |   83 = v__table__FnType    
//          |   84 = v__table__Interface 
//          |   85 = v__table__Map       
//          |   86 = v__table__MultiReturn
//          |   87 = v__table__Struct    
//          |   88 = v__table__SumType   
typedef struct {
    void* obj;
    int typ;
} v__table__TypeInfo;


// Sum type v__table__FExpr = 
//          |    3 = byteptr             
//          |    2 = voidptr             
typedef struct {
    void* obj;
    int typ;
} v__table__FExpr;

struct v__cflag__CFlag {
	string mod;
	string os;
	string name;
	string value;
};


// Sum type v__ast__Stmt = 
//          |  170 = v__ast__AssertStmt  
//          |  132 = v__ast__AssignStmt  
//          |  178 = v__ast__Attr        
//          |  169 = v__ast__Block       
//          |  171 = v__ast__BranchStmt  
//          |  157 = v__ast__Comment     
//          |  141 = v__ast__CompIf      
//          |  188 = v__ast__ConstDecl   
//          |  173 = v__ast__DeferStmt   
//          |  193 = v__ast__EnumDecl    
//          |  177 = v__ast__ExprStmt    
//          |  111 = v__ast__FnDecl      
//          |  152 = v__ast__ForCStmt    
//          |  153 = v__ast__ForInStmt   
//          |  151 = v__ast__ForStmt     
//          |  192 = v__ast__GlobalDecl  
//          |  174 = v__ast__GoStmt      
//          |  176 = v__ast__GotoLabel   
//          |  175 = v__ast__GotoStmt    
//          |  140 = v__ast__HashStmt    
//          |  165 = v__ast__Import      
//          |  217 = v__ast__InterfaceDecl
//          |  187 = v__ast__Module      
//          |  191 = v__ast__Return      
//          |  211 = v__ast__StructDecl  
//          |  196 = v__ast__TypeDecl    
//          |  172 = v__ast__UnsafeStmt  
typedef struct {
    void* obj;
    int typ;
} v__ast__Stmt;

struct v__builder__MsvcResult {
	string full_cl_exe_path;
	string exe_path;
	string um_lib_path;
	string ucrt_lib_path;
	string vs_lib_path;
	string um_include_path;
	string ucrt_include_path;
	string vs_include_path;
	string shared_include_path;
};

struct v__builder__WindowsKit {
	string um_lib_path;
	string ucrt_lib_path;
	string um_include_path;
	string ucrt_include_path;
	string shared_include_path;
};

struct v__builder__VsInstallation {
	string include_path;
	string lib_path;
	string exe_path;
};


// Sum type v__ast__Expr = 
//          |  149 = v__ast__AnonFn      
//          |  142 = v__ast__ArrayInit   
//          |  207 = v__ast__AsCast      
//          |  134 = v__ast__AssignExpr  
//          |  200 = v__ast__Assoc       
//          |  201 = v__ast__BoolLiteral 
//          |  144 = v__ast__CallExpr    
//          |  179 = v__ast__CastExpr    
//          |  202 = v__ast__CharLiteral 
//          |  219 = v__ast__ConcatExpr  
//          |  180 = v__ast__EnumVal     
//          |  185 = v__ast__FloatLiteral
//          |  136 = v__ast__Ident       
//          |  154 = v__ast__IfExpr      
//          |  158 = v__ast__IfGuardExpr 
//          |  135 = v__ast__IndexExpr   
//          |  208 = v__ast__InfixExpr   
//          |  186 = v__ast__IntegerLiteral
//          |  143 = v__ast__MapInit     
//          |  159 = v__ast__MatchExpr   
//          |  204 = v__ast__None        
//          |  145 = v__ast__OrExpr      
//          |  203 = v__ast__ParExpr     
//          |  209 = v__ast__PostfixExpr 
//          |  210 = v__ast__PrefixExpr  
//          |  181 = v__ast__RangeExpr   
//          |  182 = v__ast__SelectorExpr
//          |  205 = v__ast__SizeOf      
//          |  184 = v__ast__StringInterLiteral
//          |  183 = v__ast__StringLiteral
//          |  214 = v__ast__StructInit  
//          |  162 = v__ast__Type        
//          |  206 = v__ast__TypeOf      
typedef struct {
    void* obj;
    int typ;
} v__ast__Expr;

struct v__ast__HashStmt {
	string val;
	string mod;
};

struct v__ast__GotoStmt {
	string name;
};

struct v__ast__GotoLabel {
	string name;
};

struct v__ast__Attr {
	string name;
};


// Sum type v__ast__TypeDecl = 
//          |  199 = v__ast__AliasTypeDecl
//          |  197 = v__ast__FnTypeDecl  
//          |  198 = v__ast__SumTypeDecl 
typedef struct {
    void* obj;
    int typ;
} v__ast__TypeDecl;


// Sum type v__ast__ScopeObject = 
//          |  189 = v__ast__ConstField  
//          |  192 = v__ast__GlobalDecl  
//          |  131 = v__ast__Var         
typedef struct {
    void* obj;
    int typ;
} v__ast__ScopeObject;


// Sum type v__ast__IdentInfo = 
//          |  221 = v__ast__IdentFn     
//          |  138 = v__ast__IdentVar    
typedef struct {
    void* obj;
    int typ;
} v__ast__IdentInfo;

struct v__ast__Lambda {
	string name;
};

struct v__vmod__ModFileAndFolder {
	string vmod_file;
	string vmod_folder;
};

struct v__gen__ProfileCounterMeta {
	string fn_name;
	string vpc_name;
	string vpc_calls;
};

struct ustring {
	string s;
	array_int runes;
	int len;
};

typedef byte array_fixed_byte_400 [400];
struct SortedMap {
	int value_bytes;
	mapnode* root;
	int size;
};

typedef voidptr array_fixed_voidptr_11 [11];
struct RepIndex {
	int idx;
	int val_idx;
};

struct v__pref__Preferences {
	v__pref__OS os;
	v__pref__Backend backend;
	v__pref__BuildMode build_mode;
	bool is_verbose;
	bool is_test;
	bool is_script;
	bool is_livemain;
	bool is_liveshared;
	bool is_shared;
	bool is_prof;
	string profile_file;
	bool translated;
	bool is_prod;
	bool obfuscate;
	bool is_repl;
	bool is_run;
	bool sanitize;
	bool is_debug;
	bool is_vlines;
	bool keep_c;
	bool show_cc;
	bool use_cache;
	bool is_stats;
	bool no_auto_free;
	string cflags;
	string ccompiler;
	string third_party_option;
	bool building_v;
	bool autofree;
	bool compress;
	bool fast;
	bool enable_globals;
	bool is_fmt;
	bool is_bare;
	array_string lookup_path;
	bool output_cross_c;
	bool prealloc;
	string vroot;
	string out_name;
	string path;
	array_string compile_defines;
	array_string compile_defines_all;
	string mod;
	array_string run_args;
	array_string printfn_list;
	bool print_v_files;
};

struct strings__Builder {
	array_byte buf;
	int str_calls;
	int len;
	int initial_size;
};

struct strconv__ftoa__Dec32 {
	u32 m;
	int e;
};

union strconv__ftoa__Uf32 {
	f32 f;
	u32 u;
};

struct strconv__ftoa__Uint128 {
	u64 lo;
	u64 hi;
};

struct strconv__ftoa__Dec64 {
	u64 m;
	int e;
};

union strconv__ftoa__Uf64 {
	f64 f;
	u64 u;
};

union strconv__Float64u {
	f64 f;
	u64 u;
};

struct strconv__PrepNumber {
	bool negative;
	int exponent;
	u64 mantissa;
};

struct strconv__BF_param {
	byte pad_ch;
	int len0;
	int len1;
	bool positive;
	bool sign_flag;
	strconv__Align_text allign;
	bool rm_tail_zero;
};

struct os__FilePermission {
	bool read;
	bool write;
	bool execute;
};

struct os__File {
	voidptr cfile;
	int fd;
	bool opened;
};

struct os__FileInfo {
	string name;
	int size;
};

struct os__Foo2 {
	int x;
};

struct os__Result {
	int exit_code;
	string output;
};

struct v__table__Array {
	int nr_dims;
	v__table__Type elem_type;
};

struct v__table__ArrayFixed {
	int nr_dims;
	int size;
	v__table__Type elem_type;
};

struct v__table__Enum {
	array_string vals;
};

struct v__table__Interface {
	array_v__table__Type types;
};

struct v__table__Map {
	v__table__Type key_type;
	v__table__Type value_type;
};

struct v__table__MultiReturn {
	string name;
	array_v__table__Type types;
};

struct v__table__Struct {
	array_v__table__Field fields;
	bool is_typedef;
	bool is_union;
};

struct v__table__SumType {
	array_v__table__Type variants;
};

struct v__table__Fn {
	array_v__table__Arg args;
	v__table__Type return_type;
	bool is_variadic;
	bool is_c;
	bool is_js;
	bool is_generic;
	bool is_pub;
	string mod;
	string ctdefine;
	string name;
};

struct v__table__TypeSymbol {
	int parent_idx;
	v__table__TypeInfo info;
	v__table__Kind kind;
	string name;
	array_v__table__Fn methods;
	string mod;
	bool is_public;
};

struct v__table__Table {
	array_v__table__TypeSymbol types;
	map_string_int type_idxs;
	map_string_v__table__Fn fns;
	array_string imports;
	array_string modules;
	array_v__cflag__CFlag cflags;
};

struct v__table__Field {
	string name;
	v__table__Type typ;
	v__table__FExpr default_expr;
	bool has_default_expr;
	string default_val;
	string attr;
	bool is_pub;
	bool is_mut;
	bool is_global;
};

struct v__table__Arg {
	string name;
	bool is_mut;
	v__table__Type typ;
	bool is_hidden;
};

struct v__table__Var {
	string name;
	bool is_mut;
	v__table__Type typ;
};

struct v__ast__Scope {
	v__ast__Scope* parent;
	array_v__ast__Scope_ptr children;
	int start_pos;
	int end_pos;
	map_string_v__ast__ScopeObject objects;
};

struct v__util__EManager {
	bool support_color;
};

struct v__token__Position {
	int line_nr;
	int pos;
	int len;
};

struct v__depgraph__DepGraph {
	bool acyclic;
	array_v__depgraph__DepGraphNode nodes;
};

struct v__builder__MsvcStringFlags {
	array_string real_libs;
	array_string inc_paths;
	array_string lib_paths;
	array_string other_flags;
};

struct v__ast__IdentVar {
	v__table__Type typ;
	bool is_mut;
	bool is_static;
	bool is_optional;
};

struct v__ast__OrExpr {
	array_v__ast__Stmt stmts;
	bool is_used;
};

struct v__ast__CallArg {
	bool is_mut;
	v__ast__Expr expr;
	v__table__Type typ;
};

struct v__ast__IfGuardExpr {
	string var_name;
	v__ast__Expr expr;
	v__table__Type expr_type;
};

struct v__scanner__Scanner {
	string file_path;
	string text;
	int pos;
	int line_nr;
	int last_nl_pos;
	bool is_inside_string;
	bool is_inter_start;
	bool is_inter_end;
	bool is_debug;
	string line_comment;
	bool is_started;
	string fn_name;
	bool is_print_line_on_error;
	bool is_print_colored_error;
	bool is_print_rel_paths_on_error;
	byte quote;
	array_int line_ends;
	int nr_lines;
	bool is_vh;
	bool is_fmt;
	v__scanner__CommentsMode comments_mode;
};

struct v__token__Token {
	v__token__Kind kind;
	string lit;
	int line_nr;
	int pos;
	int len;
};

struct v__ast__Block {
	array_v__ast__Stmt stmts;
};

struct v__ast__UnsafeStmt {
	array_v__ast__Stmt stmts;
};

struct v__ast__DeferStmt {
	array_v__ast__Stmt stmts;
	string ifdef;
};

struct v__ast__GoStmt {
	v__ast__Expr call_expr;
};

struct v__ast__RangeExpr {
	v__ast__Expr low;
	v__ast__Expr high;
	bool has_high;
	bool has_low;
};

struct v__ast__Module {
	string name;
	string path;
	v__ast__Expr expr;
	bool is_skipped;
};

struct v__ast__GlobalDecl {
	string name;
	v__ast__Expr expr;
	bool has_expr;
	v__table__Type typ;
};

struct v__ast__ParExpr {
	v__ast__Expr expr;
};

struct v__ast__None {
	int foo;
};

struct v__ast__SizeOf {
	v__table__Type typ;
	string type_name;
};

struct v__ast__TypeOf {
	v__ast__Expr expr;
	v__table__Type expr_type;
};

struct v__ast__ConcatExpr {
	array_v__ast__Expr vals;
};

struct v__ast__IdentFn {
	v__table__Type typ;
};

struct time__Time {
	int year;
	int month;
	int day;
	int hour;
	int minute;
	int second;
	u64 v_unix;
};

struct time__StopWatch {
	u64 pause_time;
	u64 start;
	u64 end;
};

struct v__vmod__ModFileCacher {
	map_string_v__vmod__ModFileAndFolder cache;
	map_string_array_string folder_files;
};

struct v__gen__x64__Gen {
	string out_name;
	array_byte buf;
	int sect_header_name_pos;
	i64 offset;
	array_i64 str_pos;
	array_string strings;
	i64 file_size_pos;
	i64 main_fn_addr;
	i64 code_start_pos;
	map_string_i64 fn_addr;
	map_string_int var_offset;
	int stack_var_pos;
	int debug_pos;
};

struct v__gen__x64__SectionConfig {
	string name;
	v__gen__x64__SectionType typ;
	i64 flags;
	voidptr data;
	bool is_saa;
	i64 datalen;
	int link;
	int info;
	i64 align;
	i64 entsize;
};

struct v__depgraph__DepGraphNode {
	string name;
	array_string deps;
};

struct v__depgraph__OrderedDepMap {
	array_string keys;
	map_string_array_string data;
};

typedef byte array_fixed_byte_26 [26];
typedef byteptr array_fixed_byteptr_100 [100];
typedef byte array_fixed_byte_1000 [1000];
typedef byte array_fixed_byte_4096 [4096];
typedef byte array_fixed_byte_50 [50];
struct mapnode {
	array_fixed_string_11 keys;
	array_fixed_voidptr_11 values;
	voidptr* children;
	int size;
};

struct os__FileMode {
	os__FileType typ;
	os__FilePermission owner;
	os__FilePermission group;
	os__FilePermission others;
};

struct v__table__FnType {
	bool is_anon;
	bool has_decl;
	v__table__Fn func;
};

struct v__doc__Doc {
	strings__Builder out;
	v__table__Table* table;
	string mod;
	array_v__ast__Stmt stmts;
};

struct v__ast__File {
	string path;
	v__ast__Module mod;
	array_v__ast__Stmt stmts;
	v__ast__Scope* scope;
	v__ast__Scope* global_scope;
	array_v__ast__Import imports;
};

struct v__parser__Parser {
	v__scanner__Scanner* scanner;
	string file_name;
	string file_name_dir;
	v__token__Token tok;
	v__token__Token prev_tok;
	v__token__Token peek_tok;
	v__token__Token peek_tok2;
	v__table__Table* table;
	bool is_c;
	bool is_js;
	bool inside_if;
	bool inside_for;
	bool inside_fn;
	v__pref__Preferences* pref;
	bool builtin_mod;
	string mod;
	string attr;
	string attr_ctdefine;
	string expr_mod;
	v__ast__Scope* scope;
	v__ast__Scope* global_scope;
	map_string_string imports;
	array_v__ast__Import ast_imports;
	bool is_amp;
	bool returns;
	bool inside_match;
	bool inside_match_case;
	bool is_stmt_ident;
	bool expecting_type;
};

struct v__ast__Var {
	string name;
	v__ast__Expr expr;
	bool is_mut;
	bool is_arg;
	v__table__Type typ;
	v__token__Position pos;
	bool is_used;
};

struct v__ast__AssignStmt {
	array_v__ast__Expr right;
	v__token__Kind op;
	v__token__Position pos;
	array_v__ast__Ident left;
	array_v__table__Type left_types;
	array_v__table__Type right_types;
	bool is_static;
};

struct v__ast__AssignExpr {
	v__token__Kind op;
	v__token__Position pos;
	v__ast__Expr left;
	v__ast__Expr val;
	v__table__Type left_type;
	v__table__Type right_type;
};

struct v__ast__IndexExpr {
	v__token__Position pos;
	v__ast__Expr left;
	v__ast__Expr index;
	v__table__Type left_type;
	bool is_setter;
};

struct v__ast__Ident {
	string value;
	bool is_c;
	bool is_js;
	v__token__Kind tok_kind;
	string mod;
	v__token__Position pos;
	string name;
	v__ast__IdentKind kind;
	v__ast__IdentInfo info;
	bool is_mut;
};

struct v__ast__CompIf {
	string val;
	array_v__ast__Stmt stmts;
	bool is_not;
	v__token__Position pos;
	bool is_opt;
	bool has_else;
	array_v__ast__Stmt else_stmts;
};

struct v__ast__ArrayInit {
	v__token__Position pos;
	array_v__ast__Expr exprs;
	bool is_fixed;
	bool has_val;
	string mod;
	v__ast__Expr len_expr;
	bool has_len;
	bool has_cap;
	v__ast__Expr cap_expr;
	bool is_interface;
	array_v__table__Type interface_types;
	v__table__Type interface_type;
	v__table__Type elem_type;
	v__table__Type typ;
};

struct v__ast__MapInit {
	v__token__Position pos;
	array_v__ast__Expr keys;
	array_v__ast__Expr vals;
	v__table__Type typ;
	v__table__Type key_type;
	v__table__Type value_type;
};

struct v__ast__CallExpr {
	v__token__Position pos;
	v__ast__Expr left;
	string mod;
	string name;
	bool is_method;
	array_v__ast__CallArg args;
	array_v__table__Type expected_arg_types;
	bool is_c;
	bool is_js;
	v__ast__OrExpr or_block;
	v__table__Type left_type;
	v__table__Type receiver_type;
	v__table__Type return_type;
	bool should_be_skipped;
};

struct v__ast__Field {
	string name;
	v__token__Position pos;
	v__table__Type typ;
};

struct v__ast__ForStmt {
	v__ast__Expr cond;
	array_v__ast__Stmt stmts;
	bool is_inf;
	v__token__Position pos;
};

struct v__ast__ForCStmt {
	v__ast__Stmt init;
	bool has_init;
	v__ast__Expr cond;
	bool has_cond;
	v__ast__Expr inc;
	bool has_inc;
	array_v__ast__Stmt stmts;
	v__token__Position pos;
};

struct v__ast__ForInStmt {
	string key_var;
	string val_var;
	v__ast__Expr cond;
	bool is_range;
	v__ast__Expr high;
	array_v__ast__Stmt stmts;
	v__token__Position pos;
	v__table__Type key_type;
	v__table__Type val_type;
	v__table__Type cond_type;
	v__table__Kind kind;
};

struct v__ast__IfExpr {
	v__token__Kind tok_kind;
	array_v__ast__IfBranch branches;
	v__ast__Expr left;
	v__token__Position pos;
	bool is_expr;
	v__table__Type typ;
	bool has_else;
};

struct v__ast__Comment {
	string text;
	bool is_multi;
	int line_nr;
	v__token__Position pos;
};

struct v__ast__MatchExpr {
	v__token__Kind tok_kind;
	v__ast__Expr cond;
	array_v__ast__MatchBranch branches;
	v__token__Position pos;
	bool is_mut;
	bool is_expr;
	v__table__Type return_type;
	v__table__Type cond_type;
	v__table__Type expected_type;
	bool is_sum_type;
};

struct v__ast__Type {
	v__table__Type typ;
	v__token__Position pos;
};

struct v__ast__Import {
	v__token__Position pos;
	string mod;
	string alias;
};

struct v__ast__AssertStmt {
	v__ast__Expr expr;
	v__token__Position pos;
};

struct v__ast__BranchStmt {
	v__token__Token tok;
};

struct v__ast__ExprStmt {
	v__ast__Expr expr;
	v__table__Type typ;
	v__token__Position pos;
};

struct v__ast__CastExpr {
	v__ast__Expr expr;
	v__ast__Expr arg;
	v__table__Type typ;
	v__token__Position pos;
	string typname;
	v__table__Type expr_type;
	bool has_arg;
};

struct v__ast__EnumVal {
	string enum_name;
	string val;
	string mod;
	v__token__Position pos;
	v__table__Type typ;
};

struct v__ast__SelectorExpr {
	v__token__Position pos;
	v__ast__Expr expr;
	string field;
	v__table__Type expr_type;
};

struct v__ast__StringLiteral {
	string val;
	bool is_raw;
	bool is_c;
	bool is_js;
	v__token__Position pos;
};

struct v__ast__StringInterLiteral {
	array_string vals;
	array_v__ast__Expr exprs;
	array_string expr_fmts;
	v__token__Position pos;
	array_v__table__Type expr_types;
};

struct v__ast__FloatLiteral {
	string val;
	v__token__Position pos;
};

struct v__ast__IntegerLiteral {
	string val;
	v__token__Position pos;
};

struct v__ast__ConstDecl {
	bool is_pub;
	v__token__Position pos;
	array_v__ast__ConstField fields;
};

struct v__ast__ConstField {
	string name;
	v__ast__Expr expr;
	bool is_pub;
	v__token__Position pos;
	v__table__Type typ;
};

struct v__ast__Return {
	v__token__Position pos;
	array_v__ast__Expr exprs;
	array_v__table__Type types;
};

struct v__ast__EnumDecl {
	string name;
	bool is_pub;
	array_v__ast__EnumField fields;
	v__token__Position pos;
};

struct v__ast__EnumField {
	string name;
	v__token__Position pos;
	v__ast__Expr expr;
	bool has_expr;
};

struct v__ast__FnTypeDecl {
	string name;
	bool is_pub;
	v__table__Type typ;
	v__token__Position pos;
};

struct v__ast__SumTypeDecl {
	string name;
	bool is_pub;
	array_v__table__Type sub_types;
	v__token__Position pos;
};

struct v__ast__AliasTypeDecl {
	string name;
	bool is_pub;
	v__table__Type parent_type;
	v__token__Position pos;
};

struct v__ast__Assoc {
	string var_name;
	array_string fields;
	array_v__ast__Expr exprs;
	v__token__Position pos;
	v__table__Type typ;
};

struct v__ast__BoolLiteral {
	bool val;
	v__token__Position pos;
};

struct v__ast__CharLiteral {
	string val;
	v__token__Position pos;
};

struct v__ast__AsCast {
	v__ast__Expr expr;
	v__table__Type typ;
	v__token__Position pos;
	v__table__Type expr_type;
};

struct v__ast__InfixExpr {
	v__token__Kind op;
	v__token__Position pos;
	v__ast__Expr left;
	v__ast__Expr right;
	v__table__Type left_type;
	v__table__Type right_type;
};

struct v__ast__PostfixExpr {
	v__token__Kind op;
	v__ast__Expr expr;
	v__token__Position pos;
};

struct v__ast__PrefixExpr {
	v__token__Kind op;
	v__ast__Expr right;
	v__token__Position pos;
};

struct v__ast__StructDecl {
	v__token__Position pos;
	string name;
	array_v__ast__StructField fields;
	bool is_pub;
	int mut_pos;
	int pub_pos;
	int pub_mut_pos;
	bool is_c;
	bool is_js;
	bool is_union;
};

struct v__ast__StructInit {
	v__token__Position pos;
	bool is_short;
	v__table__Type typ;
	array_v__ast__StructInitField fields;
};

struct v__ast__StructInitField {
	v__ast__Expr expr;
	v__token__Position pos;
	string name;
	v__table__Type typ;
	v__table__Type expected_type;
};

struct v__ast__InterfaceDecl {
	string name;
	array_string field_names;
	array_v__ast__FnDecl methods;
	v__token__Position pos;
};

struct v__ast__ReturnStmt {
	v__token__Kind tok_kind;
	array_v__ast__Expr results;
	v__token__Position pos;
};

struct v__errors__Error {
	string message;
	string file_path;
	v__token__Position pos;
	v__errors__Reporter reporter;
	string backtrace;
};

struct v__errors__Warning {
	string message;
	string file_path;
	v__token__Position pos;
	v__errors__Reporter reporter;
};

struct v__gen__js__JsDoc {
	v__gen__js__JsGen* gen;
	strings__Builder out;
	bool empty_line;
};

struct v__ast__FnDecl {
	string name;
	array_v__ast__Stmt stmts;
	array_v__table__Arg args;
	bool is_deprecated;
	bool is_pub;
	bool is_variadic;
	bool is_anon;
	v__ast__Field receiver;
	v__token__Position receiver_pos;
	bool is_method;
	bool rec_mut;
	bool is_c;
	bool is_js;
	bool no_body;
	bool is_builtin;
	string ctdefine;
	v__token__Position pos;
	v__token__Position body_pos;
	string file;
	v__table__Type return_type;
};

struct v__checker__Checker {
	v__table__Table* table;
	v__ast__File file;
	int nr_errors;
	int nr_warnings;
	array_v__errors__Error errors;
	array_v__errors__Warning warnings;
	array_int error_lines;
	v__table__Type expected_type;
	v__table__Type fn_return_type;
	string const_decl;
	array_string const_deps;
	array_string const_names;
	v__pref__Preferences* pref;
	int in_for_count;
	string var_decl_name;
	bool returns;
	bool scope_returns;
	string mod;
	bool is_builtin_mod;
};

struct v__ast__IfBranch {
	v__ast__Expr cond;
	array_v__ast__Stmt stmts;
	v__token__Position pos;
	v__ast__Comment comment;
};

struct v__ast__MatchBranch {
	array_v__ast__Expr exprs;
	array_v__ast__Stmt stmts;
	v__token__Position pos;
	v__ast__Comment comment;
	bool is_else;
};

struct v__ast__StructField {
	string name;
	v__token__Position pos;
	v__ast__Comment comment;
	v__ast__Expr default_expr;
	bool has_default_expr;
	string attr;
	v__table__Type typ;
};

struct v__gen__Gen {
	strings__Builder out;
	strings__Builder cheaders;
	strings__Builder includes;
	strings__Builder typedefs;
	strings__Builder typedefs2;
	strings__Builder definitions;
	strings__Builder inits;
	strings__Builder gowrappers;
	strings__Builder stringliterals;
	strings__Builder auto_str_funcs;
	strings__Builder comptime_defines;
	strings__Builder pcs_declarations;
	strings__Builder hotcode_definitions;
	v__table__Table* table;
	v__pref__Preferences* pref;
	string module_built;
	v__ast__File file;
	v__ast__FnDecl* fn_decl;
	string last_fn_c_name;
	int tmp_count;
	map_string_int variadic_args;
	bool is_c_call;
	bool is_assign_lhs;
	bool is_assign_rhs;
	bool is_array_set;
	bool is_amp;
	array_string optionals;
	bool inside_ternary;
	int stmt_start_pos;
	bool right_is_opt;
	bool autofree;
	int indent;
	bool empty_line;
	bool is_test;
	v__token__Kind assign_op;
	array_v__ast__DeferStmt defer_stmts;
	string defer_ifdef;
	string defer_profile_code;
	array_string str_types;
	array_string threaded_fns;
	array_string array_fn_definitions;
	bool is_json_fn;
	array_string json_types;
	array_v__gen__ProfileCounterMeta pcs;
	string attr;
	bool is_builtin_mod;
	array_string hotcode_fn_names;
	v__ast__FnDecl* fn_main;
};

struct v__gen__js__JsGen {
	v__table__Table* table;
	strings__Builder definitions;
	v__pref__Preferences* pref;
	strings__Builder out;
	map_string_strings__Builder namespaces;
	map_string_array_string namespaces_pub;
	string namespace;
	v__gen__js__JsDoc* doc;
	strings__Builder constants;
	v__ast__File file;
	int tmp_count;
	bool inside_ternary;
	bool inside_loop;
	bool is_test;
	map_string_int indents;
	int stmt_start_pos;
	array_v__ast__DeferStmt defer_stmts;
	v__ast__FnDecl* fn_decl;
	array_string str_types;
	map_string_array_v__ast__Stmt method_fn_decls;
	bool empty_line;
};

struct v__builder__Builder {
	v__table__Table* table;
	v__checker__Checker checker;
	string compiled_dir;
	string module_path;
	v__pref__Preferences* pref;
	array_string module_search_paths;
	array_v__ast__File parsed_files;
	v__ast__Scope* global_scope;
	string out_name_c;
	string out_name_js;
};

struct v__ast__AnonFn {
	v__ast__FnDecl decl;
	v__table__Type typ;
};

// multi return structs
typedef struct {
	u32 arg0;
	u32 arg1;
} multi_return_u32_u32;

typedef struct {
	v__pref__Preferences* arg0;
	string arg1;
} multi_return_v__pref__Preferences_string;

typedef struct {
	strconv__ftoa__Dec32 arg0;
	bool arg1;
} multi_return_strconv__ftoa__Dec32_bool;

typedef struct {
	strconv__ftoa__Dec64 arg0;
	bool arg1;
} multi_return_strconv__ftoa__Dec64_bool;

typedef struct {
	u32 arg0;
	u32 arg1;
	u32 arg2;
} multi_return_u32_u32_u32;

typedef struct {
	int arg0;
	strconv__PrepNumber arg1;
} multi_return_int_strconv__PrepNumber;

typedef struct {
	int arg0;
	bool arg1;
} multi_return_int_bool;

typedef struct {
	u64 arg0;
	u64 arg1;
} multi_return_u64_u64;

typedef struct {
	array_v__table__Arg arg0;
	bool arg1;
} multi_return_array_v__table__Arg_bool;

typedef struct {
	v__ast__ScopeObject arg0;
	v__ast__Scope* arg1;
} multi_return_v__ast__ScopeObject_v__ast__Scope;

typedef struct {
	int arg0;
	int arg1;
} multi_return_int_int;

typedef struct {
	int arg0;
	int arg1;
	int arg2;
} multi_return_int_int_int;

typedef struct {
	array_string arg0;
	v__vmod__ModFileAndFolder arg1;
} multi_return_array_string_v__vmod__ModFileAndFolder;

typedef struct {
	string arg0;
	string arg1;
} multi_return_string_string;

typedef struct {
	array_string arg0;
	array_string arg1;
} multi_return_array_string_array_string;

// end of definitions #endif
strings__Builder strings__new_builder(int initial_size);
void strings__Builder_write_bytes(strings__Builder* b, byteptr bytes, int howmany);
void strings__Builder_write_b(strings__Builder* b, byte data);
void strings__Builder_write(strings__Builder* b, string s);
void strings__Builder_go_back(strings__Builder* b, int n);
void strings__Builder_go_back_to(strings__Builder* b, int pos);
void strings__Builder_writeln(strings__Builder* b, string s);
string strings__Builder_last_n(strings__Builder* b, int n);
string strings__Builder_after(strings__Builder* b, int n);
string strings__Builder_str(strings__Builder* b);
void strings__Builder_free(strings__Builder* b);
int strings__levenshtein_distance(string a, string b);
f32 strings__levenshtein_distance_percentage(string a, string b);
f32 strings__dice_coefficient(string s1, string s2);
string strings__repeat(byte c, int n);
string strings__repeat_string(string s, int n);
u64 hash__wyhash__rand_u64(u64* seed);
u64 _const_hash__wyhash__wyp0; // inited later
u64 _const_hash__wyhash__wyp1; // inited later
u64 _const_hash__wyhash__wyp2; // inited later
u64 _const_hash__wyhash__wyp3; // inited later
u64 _const_hash__wyhash__wyp4; // inited later
u64 hash__wyhash__wyhash_c(byteptr key, u64 len, u64 seed);
u64 hash__wyhash__sum64_string(string key, u64 seed);
u64 hash__wyhash__sum64(array_byte key, u64 seed);
static u64 hash__wyhash__wyhash64(byteptr key, u64 len, u64 seed_);
static u64 hash__wyhash__wyrotr(u64 v, u32 k);
static u64 hash__wyhash__wymum(u64 a, u64 b);
static u64 hash__wyhash__wyr3(byteptr p, u64 k);
static u64 hash__wyhash__wyr4(byteptr p);
static u64 hash__wyhash__wyr8(byteptr p);
u32 _const_math__bits__de_bruijn32; // inited later
array_byte _const_math__bits__de_bruijn32tab; // inited later
u64 _const_math__bits__de_bruijn64; // inited later
array_byte _const_math__bits__de_bruijn64tab; // inited later
u64 _const_math__bits__m0; // inited later
u64 _const_math__bits__m1; // inited later
u64 _const_math__bits__m2; // inited later
u64 _const_math__bits__m3; // inited later
u64 _const_math__bits__m4; // inited later
u32 _const_math__bits__max_u32; // inited later
u64 _const_math__bits__max_u64; // inited later
int math__bits__leading_zeros_8(byte x);
int math__bits__leading_zeros_16(u16 x);
int math__bits__leading_zeros_32(u32 x);
int math__bits__leading_zeros_64(u64 x);
int math__bits__trailing_zeros_8(byte x);
int math__bits__trailing_zeros_16(u16 x);
int math__bits__trailing_zeros_32(u32 x);
int math__bits__trailing_zeros_64(u64 x);
int math__bits__ones_count_8(byte x);
int math__bits__ones_count_16(u16 x);
int math__bits__ones_count_32(u32 x);
int math__bits__ones_count_64(u64 x);
byte math__bits__rotate_left_8(byte x, int k);
u16 math__bits__rotate_left_16(u16 x, int k);
u32 math__bits__rotate_left_32(u32 x, int k);
u64 math__bits__rotate_left_64(u64 x, int k);
byte math__bits__reverse_8(byte x);
u16 math__bits__reverse_16(u16 x);
u32 math__bits__reverse_32(u32 x);
u64 math__bits__reverse_64(u64 x);
u16 math__bits__reverse_bytes_16(u16 x);
u32 math__bits__reverse_bytes_32(u32 x);
u64 math__bits__reverse_bytes_64(u64 x);
int math__bits__len_8(byte x);
int math__bits__len_16(u16 x);
int math__bits__len_32(u32 x);
int math__bits__len_64(u64 x);
multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry);
multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry);
multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow);
multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow);
u64 _const_math__bits__two32; // inited later
u64 _const_math__bits__mask32; // inited later
string _const_math__bits__overflow_error; // a string literal, inited later
string _const_math__bits__divide_error; // a string literal, inited later
multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y);
multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y);
multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y);
multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1);
u32 math__bits__rem_32(u32 hi, u32 lo, u32 y);
u64 math__bits__rem_64(u64 hi, u64 lo, u64 y);
array_byte _const_math__bits__ntz_8_tab; // inited later
array_byte _const_math__bits__pop_8_tab; // inited later
array_byte _const_math__bits__rev_8_tab; // inited later
array_byte _const_math__bits__len_8_tab; // inited later
array_u32 _const_strconv__ftoa__ten_pow_table_32; // inited later
u32 _const_strconv__ftoa__mantbits32; // inited later
u32 _const_strconv__ftoa__expbits32; // inited later
u32 _const_strconv__ftoa__bias32; // inited later
#define _const_strconv__ftoa__maxexp32 255
static string strconv__ftoa__Dec32_get_string_32(strconv__ftoa__Dec32 d, bool neg, int i_n_digit, int i_pad_digit);
static multi_return_strconv__ftoa__Dec32_bool strconv__ftoa__f32_to_decimal_exact_int(u32 i_mant, u32 exp);
strconv__ftoa__Dec32 strconv__ftoa__f32_to_decimal(u32 mant, u32 exp);
string strconv__ftoa__f32_to_str(f32 f, int n_digit);
string strconv__ftoa__f32_to_str_pad(f32 f, int n_digit);
array_u64 _const_strconv__ftoa__ten_pow_table_64; // inited later
u32 _const_strconv__ftoa__mantbits64; // inited later
u32 _const_strconv__ftoa__expbits64; // inited later
u32 _const_strconv__ftoa__bias64; // inited later
#define _const_strconv__ftoa__maxexp64 2047
static string strconv__ftoa__Dec64_get_string_64(strconv__ftoa__Dec64 d, bool neg, int i_n_digit, int i_pad_digit);
static multi_return_strconv__ftoa__Dec64_bool strconv__ftoa__f64_to_decimal_exact_int(u64 i_mant, u64 exp);
static strconv__ftoa__Dec64 strconv__ftoa__f64_to_decimal(u64 mant, u64 exp);
string strconv__ftoa__f64_to_str(f64 f, int n_digit);
string strconv__ftoa__f64_to_str_pad(f64 f, int n_digit);
string strconv__ftoa__ftoa_64(f64 f);
string strconv__ftoa__ftoa_long_64(f64 f);
string strconv__ftoa__ftoa_32(f32 f);
string strconv__ftoa__ftoa_long_32(f32 f);
#define _const_strconv__ftoa__pow5_num_bits_32 61
#define _const_strconv__ftoa__pow5_inv_num_bits_32 59
#define _const_strconv__ftoa__pow5_num_bits_64 121
#define _const_strconv__ftoa__pow5_inv_num_bits_64 122
array_u64 _const_strconv__ftoa__powers_of_10; // inited later
array_u64 _const_strconv__ftoa__pow5_split_32; // inited later
array_u64 _const_strconv__ftoa__pow5_inv_split_32; // inited later
array_strconv__ftoa__Uint128 _const_strconv__ftoa__pow5_split_64; // inited later
array_strconv__ftoa__Uint128 _const_strconv__ftoa__pow5_inv_split_64; // inited later
static void strconv__ftoa__assert1(bool t, string msg);
static int strconv__ftoa__bool_to_int(bool b);
static u32 strconv__ftoa__bool_to_u32(bool b);
static u64 strconv__ftoa__bool_to_u64(bool b);
static string strconv__ftoa__get_string_special(bool neg, bool expZero, bool mantZero);
static int strconv__ftoa__decimal_len_32(u32 u);
static u32 strconv__ftoa__mul_shift_32(u32 m, u64 mul, int ishift);
static u32 strconv__ftoa__mul_pow5_invdiv_pow2(u32 m, u32 q, int j);
static u32 strconv__ftoa__mul_pow5_div_pow2(u32 m, u32 i, int j);
static u32 strconv__ftoa__pow5_factor_32(u32 i_v);
static bool strconv__ftoa__multiple_of_power_of_five_32(u32 v, u32 p);
static bool strconv__ftoa__multiple_of_power_of_two_32(u32 v, u32 p);
static u32 strconv__ftoa__log10_pow2(int e);
static u32 strconv__ftoa__log10_pow5(int e);
static int strconv__ftoa__pow5_bits(int e);
static int strconv__ftoa__decimal_len_64(u64 u);
static u64 strconv__ftoa__shift_right_128(strconv__ftoa__Uint128 v, int shift);
static u64 strconv__ftoa__mul_shift_64(u64 m, strconv__ftoa__Uint128 mul, int shift);
static u32 strconv__ftoa__pow5_factor_64(u64 v_i);
static bool strconv__ftoa__multiple_of_power_of_five_64(u64 v, u32 p);
static bool strconv__ftoa__multiple_of_power_of_two_64(u64 v, u32 p);
string strconv__ftoa__f32_to_str_l(f64 f);
string strconv__ftoa__f64_to_str_l(f64 f);
static multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0);
static multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0);
static multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
static multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
#define _const_strconv__DIGITS 18
u64 _const_strconv__DOUBLE_PLUS_ZERO; // inited later
u64 _const_strconv__DOUBLE_MINUS_ZERO; // inited later
u64 _const_strconv__DOUBLE_PLUS_INFINITY; // inited later
u64 _const_strconv__DOUBLE_MINUS_INFINITY; // inited later
#define _const_strconv__fsm_a 0
#define _const_strconv__fsm_b 1
#define _const_strconv__fsm_c 2
#define _const_strconv__fsm_d 3
#define _const_strconv__fsm_e 4
#define _const_strconv__fsm_f 5
#define _const_strconv__fsm_g 6
#define _const_strconv__fsm_h 7
#define _const_strconv__fsm_i 8
#define _const_strconv__FSM_STOP 9
#define _const_strconv__parser_ok 0
#define _const_strconv__parser_pzero 1
#define _const_strconv__parser_mzero 2
#define _const_strconv__parser_pinf 3
#define _const_strconv__parser_minf 4
#define _const_strconv__DPOINT '.'
#define _const_strconv__PLUS '+'
#define _const_strconv__MINUS '-'
#define _const_strconv__ZERO '0'
#define _const_strconv__NINE '9'
u32 _const_strconv__TEN; // inited later
static bool strconv__is_digit(byte x);
static bool strconv__is_space(byte x);
static bool strconv__is_exp(byte x);
static multi_return_int_strconv__PrepNumber strconv__parser(string s);
static u64 strconv__converter(strconv__PrepNumber* pn);
f64 strconv__atof64(string s);
#define _const_strconv__int_size 32
u64 _const_strconv__max_u64; // inited later
static byte strconv__byte_to_lower(byte c);
u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
u64 strconv__parse_uint(string s, int _base, int _bit_size);
i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
i64 strconv__parse_int(string _s, int base, int _bit_size);
int strconv__atoi(string s);
static bool strconv__underscore_ok(string s);
array_f64 _const_strconv__dec_round; // inited later
string strconv__f64_to_str_lnd(f64 f, int dec_digit);
string strconv__format_str(string s, strconv__BF_param p);
string strconv__format_dec(u64 d, strconv__BF_param p);
string strconv__format_fl(f64 f, strconv__BF_param p);
string strconv__format_es(f64 f, strconv__BF_param p);
string strconv__remove_tail_zeros(string s);
void strconv__v_printf(string str, varg_voidptr pt);
string strconv__v_sprintf(string str, varg_voidptr pt);
static f64 strconv__fabs(f64 x);
static array __new_array(int mylen, int cap, int elm_size);
static array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array);
static array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array);
static void array_ensure_cap(array* a, int required);
array array_repeat(array a, int count);
void array_sort_with_compare(array* a, voidptr compare);
void array_insert(array* a, int i, voidptr val);
void array_prepend(array* a, voidptr val);
void array_delete(array* a, int i);
void array_clear(array* a);
void array_trim(array* a, int index);
static voidptr array_get(array a, int i);
voidptr array_first(array a);
voidptr array_last(array a);
static array array_slice(array a, int start, int _end);
static array array_slice2(array a, int start, int _end, bool end_max);
static array array_clone_static(array a);
array array_clone(array* a);
static array array_slice_clone(array* a, int start, int _end);
static void array_set(array* a, int i, voidptr val);
static void array_push(array* a, voidptr val);
void array_push_many(array* a3, voidptr val, int size);
array array_reverse(array a);
void array_free(array* a);
string array_string_str(array_string a);
string array_byte_hex(array_byte b);
int copy(array_byte dst, array_byte src);
static int compare_ints(int* a, int* b);
void array_int_sort(array_int* a);
int array_string_index(array_string a, string v);
int array_int_index(array_int a, int v);
int array_byte_index(array_byte a, byte v);
int array_char_index(array_char a, char v);
int array_int_reduce(array_int a, int (*iter)(int accum, int curr), int accum_start);
bool array_string_eq(array_string a1, array_string a2);
int compare_i64(i64* a, i64* b);
int compare_f64(f64* a, f64* b);
int compare_f32(f32* a, f32* b);
array_voidptr array_pointers(array a);
byteptr g_m2_buf; // global
byteptr g_m2_ptr; // global
void v_exit(int code);
bool isnil(voidptr v);
void print_backtrace();
static void panic_debug(int line_no, string file, string mod, string fn_name, string s);
void v_panic(string s);
void eprintln(string s);
void eprint(string s);
void print(string s);
i64 total_m; // global
int nr_mallocs; // global
static void looo();
byteptr v_malloc(int n);
byteptr v_calloc(int n);
byteptr vcalloc(int n);
void v_free(voidptr ptr);
voidptr memdup(voidptr src, int sz);
static void v_ptr_free(voidptr ptr);
int is_atty(int fd);
static voidptr __as_cast(voidptr obj, int obj_type, int expected_type);
static void builtin_init();
void println(string s);
static bool print_backtrace_skipping_top_frames(int xskipframes);
static bool print_backtrace_skipping_top_frames_mac(int skipframes);
static bool print_backtrace_skipping_top_frames_freebsd(int skipframes);
static bool print_backtrace_skipping_top_frames_linux(int skipframes);
static int backtrace(voidptr a, int b);
static byteptr* backtrace_symbols(voidptr, int);
static void backtrace_symbols_fd(voidptr, int, int);
static int proc_pidpath(int, voidptr, int);
string f64_str(f64 d);
string f64_strsci(f64 x, int digit_num);
string f64_strlong(f64 x);
string f32_str(f32 d);
string f32_strsci(f32 x, int digit_num);
string f32_strlong(f32 x);
static f32 f32_abs(f32 a);
static f64 f64_abs(f64 a);
bool f64_eq(f64 a, f64 b);
bool f32_eq(f32 a, f32 b);
bool f64_eqbit(f64 a, f64 b);
bool f32_eqbit(f32 a, f32 b);
static bool f64_ne(f64 a, f64 b);
static bool f32_ne(f32 a, f32 b);
bool f64_nebit(f64 a, f64 b);
bool f32_nebit(f32 a, f32 b);
static bool f64_lt(f64 a, f64 b);
static bool f32_lt(f32 a, f32 b);
static bool f64_ltbit(f64 a, f64 b);
static bool f32_ltbit(f32 a, f32 b);
static bool f64_le(f64 a, f64 b);
static bool f32_le(f32 a, f32 b);
static bool f64_lebit(f64 a, f64 b);
static bool f32_lebit(f32 a, f32 b);
static bool f64_gt(f64 a, f64 b);
static bool f32_gt(f32 a, f32 b);
static bool f64_gtbit(f64 a, f64 b);
static bool f32_gtbit(f32 a, f32 b);
static bool f64_ge(f64 a, f64 b);
static bool f32_ge(f32 a, f32 b);
static bool f64_gebit(f64 a, f64 b);
static bool f32_gebit(f32 a, f32 b);
string ptr_str(voidptr ptr);
string _const_digit_pairs; // a string literal, inited later
string int_str_l(int nn, int max);
string i8_str(i8 n);
string i16_str(i16 n);
string u16_str(u16 n);
string int_str(int n);
string u32_str(u32 nn);
string i64_str(i64 nn);
string u64_str(u64 nn);
string bool_str(bool b);
string byte_hex(byte nn);
string i8_hex(i8 nn);
string u16_hex(u16 nn);
string i16_hex(i16 nn);
string u32_hex(u32 nn);
string int_hex(int nn);
string u64_hex(u64 nn);
string i64_hex(i64 nn);
string voidptr_str(voidptr nn);
string byteptr_str(byteptr nn);
bool array_byte_contains(array_byte a, byte val);
string byte_str(byte c);
bool byte_is_capital(byte c);
array_byte array_byte_clone(array_byte b);
#define _const_hashbits 24
#define _const_max_cached_hashbits 16
#define _const_init_log_capicity 5
int _const_init_capicity; // inited later
#define _const_max_load_factor 0.8
int _const_init_cap; // inited later
#define _const_extra_metas_inc 4
u32 _const_hash_mask; // inited later
u32 _const_probe_inc; // inited later
static bool fast_string_eq(string a, string b);
static DenseArray new_dense_array(int value_bytes);
static u32 DenseArray_push(DenseArray* d, string key, voidptr value);
static voidptr DenseArray_get(DenseArray d, int i);
static void DenseArray_zeros_to_end(DenseArray* d);
static map new_map_1(int value_bytes);
static map new_map_init(int n, int value_bytes, string* keys, voidptr values);
static multi_return_u32_u32 map_key_to_index(map* m, string key);
static multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas);
static void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi);
static void map_set(map* m, string key, voidptr value);
static void map_expand(map* m);
static void map_rehash(map* m);
static void map_cached_rehash(map* m, u32 old_cap);
static voidptr map_get3(map m, string key, voidptr zero);
static bool map_exists(map m, string key);
void map_delete(map* m, string key);
array_string map_keys(map* m);
void map_free(map* m);
string map_string_str(map_string m);
string Option_str(Option o);
static Option opt_ok(voidptr data, int size);
static Option opt_none();
Option v_error(string s);
Option error_with_code(string s, int code);
#define _const_degree 6
int _const_mid_index; // inited later
int _const_max_size; // inited later
int _const_children_bytes; // inited later
static SortedMap new_sorted_map(int n, int value_bytes);
static SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values);
static mapnode* new_node();
static void SortedMap_set(SortedMap* m, string key, voidptr value);
static void mapnode_split_child(mapnode* n, int child_index, mapnode* y);
static bool SortedMap_get(SortedMap m, string key, voidptr out);
static bool SortedMap_exists(SortedMap m, string key);
static int mapnode_find_key(mapnode* n, string k);
static bool mapnode_remove_key(mapnode* n, string k);
static void mapnode_remove_from_leaf(mapnode* n, int idx);
static void mapnode_remove_from_non_leaf(mapnode* n, int idx);
static void mapnode_fill(mapnode* n, int idx);
static void mapnode_borrow_from_prev(mapnode* n, int idx);
static void mapnode_borrow_from_next(mapnode* n, int idx);
static void mapnode_merge(mapnode* n, int idx);
void SortedMap_delete(SortedMap* m, string key);
static int mapnode_subkeys(mapnode* n, array_string* keys, int at);
array_string SortedMap_keys(SortedMap* m);
static void mapnode_free(mapnode* n);
void SortedMap_free(SortedMap* m);
void SortedMap_print(SortedMap m);
int vstrlen(byteptr s);
string tos(byteptr s, int len);
string tos_clone(byteptr s);
string tos2(byteptr s);
string tos3(charptr s);
static string string_clone_static(string a);
string string_clone(string a);
string cstring_to_vstring(byteptr cstr);
string string_replace_once(string s, string rep, string with);
string string_replace(string s, string rep, string with);
static int compare_rep_index(RepIndex* a, RepIndex* b);
static void array_RepIndex_sort(array_RepIndex* a);
string string_replace_each(string s, array_string vals);
bool string_bool(string s);
int string_int(string s);
i64 string_i64(string s);
i8 string_i8(string s);
i16 string_i16(string s);
f32 string_f32(string s);
f64 string_f64(string s);
u16 string_u16(string s);
u32 string_u32(string s);
u64 string_u64(string s);
static bool string_eq(string s, string a);
static bool string_ne(string s, string a);
static bool string_lt(string s, string a);
static bool string_le(string s, string a);
static bool string_gt(string s, string a);
static bool string_ge(string s, string a);
static string string_add(string s, string a);
array_string string_split(string s, string delim);
array_string string_split_nth(string s, string delim, int nth);
array_string string_split_into_lines(string s);
static string string_left(string s, int n);
static string string_right(string s, int n);
static string string_substr2(string s, int start, int _end, bool end_max);
string string_substr(string s, int start, int end);
int string_index_old(string s, string p);
Option_int string_index(string s, string p);
static int string_index_kmp(string s, string p);
int string_index_any(string s, string chars);
Option_int string_last_index(string s, string p);
int string_index_after(string s, string p, int start);
int string_index_byte(string s, byte c);
int string_last_index_byte(string s, byte c);
int string_count(string s, string substr);
bool string_contains(string s, string p);
bool string_starts_with(string s, string p);
bool string_ends_with(string s, string p);
string string_to_lower(string s);
bool string_is_lower(string s);
string string_to_upper(string s);
bool string_is_upper(string s);
string string_capitalize(string s);
bool string_is_capital(string s);
string string_title(string s);
bool string_is_title(string s);
string string_find_between(string s, string start, string end);
static bool array_string_contains(array_string ar, string val);
static bool array_int_contains(array_int ar, int val);
bool byte_is_space(byte c);
string string_trim_space(string s);
string string_trim(string s, string cutset);
string string_trim_left(string s, string cutset);
string string_trim_right(string s, string cutset);
static int compare_strings(string* a, string* b);
static int compare_strings_by_len(string* a, string* b);
static int compare_lower_strings(string* a, string* b);
void array_string_sort(array_string* s);
void array_string_sort_ignore_case(array_string* s);
void array_string_sort_by_len(array_string* s);
string string_str(string s);
string ustring_str(ustring s);
ustring string_ustring(string s);
array_int g_ustring_runes; // global
ustring string_ustring_tmp(string s);
static bool ustring_eq(ustring u, ustring a);
static bool ustring_ne(ustring u, ustring a);
static bool ustring_lt(ustring u, ustring a);
static bool ustring_le(ustring u, ustring a);
static bool ustring_gt(ustring u, ustring a);
static bool ustring_ge(ustring u, ustring a);
ustring ustring_add(ustring u, ustring a);
int ustring_index_after(ustring u, ustring p, int start);
int ustring_count(ustring u, ustring substr);
string ustring_substr(ustring u, int _start, int _end);
string ustring_left(ustring u, int pos);
string ustring_right(ustring u, int pos);
static byte string_at(string s, int idx);
string ustring_at(ustring u, int idx);
static void ustring_free(ustring* u);
bool byte_is_digit(byte c);
bool byte_is_hex_digit(byte c);
bool byte_is_oct_digit(byte c);
bool byte_is_bin_digit(byte c);
bool byte_is_letter(byte c);
void string_free(string* s);
string string_all_before(string s, string dot);
string string_all_before_last(string s, string dot);
string string_all_after(string s, string dot);
string string_after(string s, string dot);
string array_string_join(array_string a, string del);
string array_string_join_lines(array_string s);
string string_reverse(string s);
string string_limit(string s, int max);
bool byte_is_white(byte c);
int string_hash(string s);
array_byte string_bytes(string s);
string string_repeat(string s, int count);
string string_strip_margin(string s);
string string_strip_margin_custom(string s, byte del);
int utf8_char_len(byte b);
string utf32_to_str(u32 code);
string utf32_to_str_no_malloc(u32 code, voidptr buf);
int string_utf32_code(string _rune);
#define _const_CP_UTF8 65001
u16* string_to_wide(string _str);
string string_from_wide(u16* _wstr);
string string_from_wide2(u16* _wstr, int len);
static int utf8_len(byte c);
static int utf8_str_len(string s);
static int utf8_str_visible_length(string s);
int utf8_getchar();
#define _const_os__S_IFMT 0xF000
#define _const_os__S_IFDIR 0x4000
#define _const_os__S_IFLNK 0xa000
#define _const_os__S_IXUSR 0100
#define _const_os__S_IXGRP 0010
#define _const_os__S_IXOTH 0001
int _const_os__STD_INPUT_HANDLE; // inited later
int _const_os__STD_OUTPUT_HANDLE; // inited later
int _const_os__STD_ERROR_HANDLE; // inited later
#define _const_os__O_RDONLY 0
#define _const_os__O_WRONLY 1
#define _const_os__O_RDWR 2
#define _const_os__O_CREATE 100
#define _const_os__O_EXCL 200
#define _const_os__O_NOCTTY 400
#define _const_os__O_TRUNC 1000
#define _const_os__O_APPEND 2000
#define _const_os__O_NONBLOCK 4000
#define _const_os__O_SYNC 10000
string os__getenv(string key);
int os__setenv(string name, string value, bool overwrite);
int os__unsetenv(string name);
map_string_string os__environ();
os__FileMode os__inode(string path);
array_string _const_os__args; // inited later
#define _const_os__MAX_PATH 4096
bool os__File_is_opened(os__File f);
array_byte os__File_read_bytes(os__File* f, int size);
array_byte os__File_read_bytes_at(os__File* f, int size, int pos);
Option_array_byte os__read_bytes(string path);
Option_string os__read_file(string path);
int os__file_size(string path);
void os__mv(string old, string v_new);
Option_bool os__cp(string old, string v_new);
Option_bool os__cp_r(string osource_path, string odest_path, bool overwrite);
Option_bool os__cp_all(string osource_path, string odest_path, bool overwrite);
Option_bool os__mv_by_cp(string source, string target);
static FILE* os__vfopen(string path, string mode);
Option_array_string os__read_lines(string path);
static Option_array_ustring os__read_ulines(string path);
Option_os__File os__open_append(string path);
Option_os__File os__open_file(string path, string mode, varg_int options);
void os__File_write_bytes_at(os__File* f, voidptr data, int size, int pos);
void os__File_flush(os__File* f);
static voidptr os__vpopen(string path);
static multi_return_int_bool os__posix_wait4_to_exit_status(int waitret);
string os__posix_get_error_msg(int code);
static int os__vpclose(voidptr f);
int os__system(string cmd);
string os__sigint_to_signal_name(int si);
#define _const_os__F_OK 0
#define _const_os__X_OK 1
#define _const_os__W_OK 2
#define _const_os__R_OK 4
bool os__exists(string path);
bool os__is_executable(string path);
Option_bool os__is_writable_folder(string folder);
bool os__is_writable(string path);
bool os__is_readable(string path);
bool os__file_exists(string _path);
void os__rm(string path);
void os__rmdir(string path);
void os__rmdir_recursive(string path);
void os__rmdir_all(string path);
bool os__is_dir_empty(string path);
static void os__print_c_errno();
string os__file_ext(string path);
string os__dir(string path);
string os__base_dir(string path);
string os__file_name(string path);
string os__input(string prompt);
string os__get_line();
string os__get_raw_line();
array_string os__get_lines();
string os__get_lines_joined();
string os__user_os();
string os__home_dir();
void os__write_file(string path, string text);
void os__clear();
void os__on_segfault(voidptr f);
string os__executable();
static string os__executable_fallback();
Option_string os__find_abs_path_of_executable(string exepath);
bool os__dir_exists(string path);
bool os__is_dir(string path);
bool os__is_link(string path);
void os__chdir(string path);
string os__getwd();
string os__real_path(string fpath);
bool os__is_abs_path(string path);
string os__join_path(string base, varg_string dirs);
array_string os__walk_ext(string path, string ext);
void os__walk(string path, void (*f)(string path));
void os__signal(int signum, voidptr handler);
int os__fork();
int os__wait();
int os__file_last_mod_unix(string path);
void os__log(string s);
void os__flush_stdout();
void os__flush();
void os__mkdir_all(string path);
string os__cache_dir();
string os__temp_dir();
void os__chmod(string path, int mode);
string _const_os__wd_at_startup; // inited later
string os__resource_abs_path(string path);
#define _const_os__PROT_READ 1
#define _const_os__PROT_WRITE 2
#define _const_os__MAP_PRIVATE 0x02
#define _const_os__MAP_ANONYMOUS 0x20
#define _const_os__sys_write 1
#define _const_os__sys_open 2
#define _const_os__sys_close 3
#define _const_os__sys_mkdir 83
#define _const_os__sys_creat 85
string _const_os__path_separator; // a string literal, inited later
#define _const_os__stdin_value 0
#define _const_os__stdout_value 1
#define _const_os__stderr_value 2
static array_string os__init_os_args(int argc, byte** argv);
Option_array_string os__ls(string path);
Option_os__File os__open(string path);
Option_os__File os__create(string path);
void os__File_write(os__File* f, string s);
void os__File_writeln(os__File* f, string s);
Option_bool os__mkdir(string path);
Option_os__Result os__exec(string cmd);
Option_bool os__symlink(string origin, string target);
string os__get_error_msg(int code);
void os__File_write_bytes(os__File* f, voidptr data, int size);
void os__File_close(os__File* f);
array_string os__cmdline__options(array_string args, string param);
string os__cmdline__option(array_string args, string param, string def);
array_string os__cmdline__options_before(array_string args, array_string what);
array_string os__cmdline__options_after(array_string args, array_string what);
array_string os__cmdline__only_non_options(array_string args);
array_string os__cmdline__only_options(array_string args);
string v__token__Position_str(v__token__Position pos);
v__token__Position v__token__Position_extend(v__token__Position pos, v__token__Position end);
v__token__Position v__token__Token_position(v__token__Token* tok);
array_v__token__Kind _const_v__token__assign_tokens; // inited later
int _const_v__token__nr_tokens; // inited later
static map_string_int v__token__build_keys();
static array_string v__token__build_token_str();
array_string _const_v__token__token_str; // inited later
map_string_int _const_v__token__keywords; // inited later
v__token__Kind v__token__key_to_token(string key);
bool v__token__is_key(string key);
bool v__token__is_decl(v__token__Kind t);
bool v__token__Kind_is_assign(v__token__Kind t);
static bool array_v__token__Kind_contains(array_v__token__Kind t, v__token__Kind val);
string v__token__Kind_str(v__token__Kind t);
string v__token__Token_str(v__token__Token t);
array_v__token__Precedence v__token__build_precedences();
array_v__token__Precedence _const_v__token__precedences; // inited later
int v__token__Token_precedence(v__token__Token tok);
bool v__token__Token_is_scalar(v__token__Token tok);
bool v__token__Token_is_unary(v__token__Token tok);
bool v__token__Kind_is_relational(v__token__Kind tok);
bool v__token__Kind_is_start_of_type(v__token__Kind k);
bool v__token__Kind_is_infix(v__token__Kind kind);
string time__Time_format(time__Time t);
string time__Time_format_ss(time__Time t);
string time__Time_hhmm(time__Time t);
string time__Time_hhmmss(time__Time t);
string time__Time_hhmm12(time__Time t);
string time__Time_ymmdd(time__Time t);
string time__Time_ddmmy(time__Time t);
string time__Time_md(time__Time t);
string time__Time_clean(time__Time t);
string time__Time_clean12(time__Time t);
string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time);
string time__FormatTime_str(time__FormatTime it); // auto
string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date);
string time__FormatDate_str(time__FormatDate it); // auto
string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date);
Option_time__Time time__parse(string s);
Option_time__Time time__parse_rfc2822(string s);
time__StopWatch time__new_stopwatch();
void time__StopWatch_start(time__StopWatch* t);
void time__StopWatch_restart(time__StopWatch* t);
void time__StopWatch_stop(time__StopWatch* t);
void time__StopWatch_pause(time__StopWatch* t);
time__Duration time__StopWatch_elapsed(time__StopWatch t);
string _const_time__days_string; // a string literal, inited later
array_int _const_time__month_days; // inited later
string _const_time__months_string; // a string literal, inited later
i64 _const_time__absolute_zero_year; // inited later
#define _const_time__seconds_per_minute 60
int _const_time__seconds_per_hour; // inited later
int _const_time__seconds_per_day; // inited later
int _const_time__seconds_per_week; // inited later
int _const_time__days_per_400_years; // inited later
int _const_time__days_per_100_years; // inited later
int _const_time__days_per_4_years; // inited later
array_int _const_time__days_before; // inited later
time__Time time__now();
string time__Time_smonth(time__Time t);
time__Time time__new_time(time__Time t);
int time__Time_unix_time(time__Time t);
time__Time time__Time_add_seconds(time__Time t, int seconds);
time__Time time__Time_add_days(time__Time t, int days);
static int time__since(time__Time t);
string time__Time_relative(time__Time t);
int time__day_of_week(int y, int m, int d);
int time__Time_day_of_week(time__Time t);
string time__Time_weekday_str(time__Time t);
i64 time__ticks();
void time__sleep(int seconds);
void time__sleep_ms(int milliseconds);
void time__usleep(int microseconds);
bool time__is_leap_year(int year);
Option_int time__days_in_month(int month, int year);
string time__Time_str(time__Time t);
static time__Time time__convert_ctime(struct tm t);
time__Duration _const_time__nanosecond; // inited later
time__Duration _const_time__microsecond; // inited later
time__Duration _const_time__millisecond; // inited later
time__Duration _const_time__second; // inited later
time__Duration _const_time__minute; // inited later
time__Duration _const_time__hour; // inited later
i64 time__Duration_nanoseconds(time__Duration d);
i64 time__Duration_microseconds(time__Duration d);
i64 time__Duration_milliseconds(time__Duration d);
f64 time__Duration_seconds(time__Duration d);
f64 time__Duration_minutes(time__Duration d);
f64 time__Duration_hours(time__Duration d);
static u64 time__sys_mono_now_darwin();
static int time__make_unix_time(struct tm t);
static u64 time__sys_mono_now();
static u64 time__vpc_now();
time__Time time__unix(int abs);
static multi_return_int_int_int time__calculate_date_from_offset(int day_offset_);
static multi_return_int_int_int time__calculate_time_from_offset(int second_offset_);
void v__depgraph__OrderedDepMap_set(v__depgraph__OrderedDepMap* o, string name, array_string deps);
void v__depgraph__OrderedDepMap_add(v__depgraph__OrderedDepMap* o, string name, array_string deps);
array_string v__depgraph__OrderedDepMap_get(v__depgraph__OrderedDepMap* o, string name);
void v__depgraph__OrderedDepMap_delete(v__depgraph__OrderedDepMap* o, string name);
void v__depgraph__OrderedDepMap_apply_diff(v__depgraph__OrderedDepMap* o, string name, array_string deps);
int v__depgraph__OrderedDepMap_size(v__depgraph__OrderedDepMap* o);
v__depgraph__DepGraph* v__depgraph__new_dep_graph();
void v__depgraph__DepGraph_add(v__depgraph__DepGraph* graph, string mod, array_string deps);
v__depgraph__DepGraph* v__depgraph__DepGraph_resolve(v__depgraph__DepGraph* graph);
v__depgraph__DepGraphNode v__depgraph__DepGraph_last_node(v__depgraph__DepGraph* graph);
string v__depgraph__DepGraph_display(v__depgraph__DepGraph* graph);
string v__depgraph__DepGraph_display_cycles(v__depgraph__DepGraph* graph);
string v__cflag__CFlag_str(v__cflag__CFlag* c);
string v__cflag__CFlag_format(v__cflag__CFlag* cf);
static string array_v__cflag__CFlag_c_options_before_target_msvc(array_v__cflag__CFlag cflags);
static string array_v__cflag__CFlag_c_options_after_target_msvc(array_v__cflag__CFlag cflags);
static string array_v__cflag__CFlag_c_options_before_target(array_v__cflag__CFlag cflags);
static string array_v__cflag__CFlag_c_options_after_target(array_v__cflag__CFlag cflags);
static string array_v__cflag__CFlag_c_options_without_object_files(array_v__cflag__CFlag cflags);
static string array_v__cflag__CFlag_c_options_only_object_files(array_v__cflag__CFlag cflags);
string term__format(string msg, string open, string close);
string term__format_rgb(int r, int g, int b, string msg, string open, string close);
string term__rgb(int r, int g, int b, string msg);
string term__bg_rgb(int r, int g, int b, string msg);
string term__hex(int hex, string msg);
string term__bg_hex(int hex, string msg);
string term__bg_black(string msg);
string term__bright_bg_black(string msg);
string term__bg_blue(string msg);
string term__bright_bg_blue(string msg);
string term__bg_cyan(string msg);
string term__bright_bg_cyan(string msg);
string term__bg_green(string msg);
string term__bright_bg_green(string msg);
string term__bg_magenta(string msg);
string term__bright_bg_magenta(string msg);
string term__bg_red(string msg);
string term__bright_bg_red(string msg);
string term__bg_white(string msg);
string term__bright_bg_white(string msg);
string term__bg_yellow(string msg);
string term__bright_bg_yellow(string msg);
string term__black(string msg);
string term__bright_black(string msg);
string term__blue(string msg);
string term__bright_blue(string msg);
string term__bold(string msg);
string term__cyan(string msg);
string term__bright_cyan(string msg);
string term__dim(string msg);
string term__green(string msg);
string term__bright_green(string msg);
string term__gray(string msg);
string term__hidden(string msg);
string term__italic(string msg);
string term__inverse(string msg);
string term__magenta(string msg);
string term__bright_magenta(string msg);
string term__reset(string msg);
string term__red(string msg);
string term__bright_red(string msg);
string term__strikethrough(string msg);
string term__underline(string msg);
string term__white(string msg);
string term__bright_white(string msg);
string term__yellow(string msg);
string term__bright_yellow(string msg);
void term__set_cursor_position(int x, int y);
void term__move(int n, string direction);
void term__cursor_up(int n);
void term__cursor_down(int n);
void term__cursor_forward(int n);
void term__cursor_back(int n);
void term__erase_display(string t);
void term__erase_toend();
void term__erase_tobeg();
void term__erase_clear();
void term__erase_del_clear();
void term__erase_line(string t);
void term__erase_line_toend();
void term__erase_line_tobeg();
void term__erase_line_clear();
void term__show_cursor();
void term__hide_cursor();
#define _const_term__default_columns_size 80
#define _const_term__default_rows_size 25
bool term__can_show_color_on_stdout();
bool term__can_show_color_on_stderr();
string term__ok_message(string s);
string term__fail_message(string s);
string term__warn_message(string s);
string term__h_divider(string divider);
string term__header(string text, string divider);
static bool term__supports_escape_sequences(int fd);
multi_return_int_int term__get_terminal_size();
v__vmod__ModFileCacher* v__vmod__new_mod_file_cacher();
void v__vmod__ModFileCacher_dump(v__vmod__ModFileCacher* mcache);
v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get(v__vmod__ModFileCacher* mcache, string mfolder);
static void v__vmod__ModFileCacher_add(v__vmod__ModFileCacher* cacher, string path, v__vmod__ModFileAndFolder result);
static multi_return_array_string_v__vmod__ModFileAndFolder v__vmod__ModFileCacher_traverse(v__vmod__ModFileCacher* mcache, string mfolder);
static void v__vmod__ModFileCacher_mark_folders_with_vmod(v__vmod__ModFileCacher* mcache, array_string folders_so_far, v__vmod__ModFileAndFolder vmod);
static void v__vmod__ModFileCacher_mark_folders_as_vmod_free(v__vmod__ModFileCacher* mcache, array_string folders_so_far);
array_string _const_v__vmod__MOD_FILE_STOP_PATHS; // inited later
static bool v__vmod__ModFileCacher_check_for_stop(v__vmod__ModFileCacher* mcache, string cfolder, array_string files);
static array_string v__vmod__ModFileCacher_get_files(v__vmod__ModFileCacher* mcache, string cfolder);
v__vmod__ModFileCacher* _const_v__vmod__mod_file_cacher; // inited later
bool array_v__table__Type_contains(array_v__table__Type types, v__table__Type typ);
int v__table__Type_idx(v__table__Type t);
int v__table__Type_nr_muls(v__table__Type t);
bool v__table__Type_is_ptr(v__table__Type t);
v__table__Type v__table__Type_set_nr_muls(v__table__Type t, int nr_muls);
v__table__Type v__table__Type_to_ptr(v__table__Type t);
v__table__Type v__table__Type_deref(v__table__Type t);
v__table__TypeFlag v__table__Type_flag(v__table__Type t);
v__table__Type v__table__Type_set_flag(v__table__Type t, v__table__TypeFlag flag);
bool v__table__Type_flag_is(v__table__Type t, v__table__TypeFlag flag);
v__table__Type v__table__new_type(int idx);
v__table__Type v__table__new_type_ptr(int idx, int nr_muls);
bool v__table__Type_is_pointer(v__table__Type typ);
bool v__table__Type_is_float(v__table__Type typ);
bool v__table__Type_is_int(v__table__Type typ);
bool v__table__Type_is_signed(v__table__Type typ);
bool v__table__Type_is_unsigned(v__table__Type typ);
bool v__table__Type_is_number(v__table__Type typ);
#define _const_v__table__void_type_idx 1
#define _const_v__table__voidptr_type_idx 2
#define _const_v__table__byteptr_type_idx 3
#define _const_v__table__charptr_type_idx 4
#define _const_v__table__i8_type_idx 5
#define _const_v__table__i16_type_idx 6
#define _const_v__table__int_type_idx 7
#define _const_v__table__i64_type_idx 8
#define _const_v__table__byte_type_idx 9
#define _const_v__table__u16_type_idx 10
#define _const_v__table__u32_type_idx 11
#define _const_v__table__u64_type_idx 12
#define _const_v__table__f32_type_idx 13
#define _const_v__table__f64_type_idx 14
#define _const_v__table__char_type_idx 15
#define _const_v__table__bool_type_idx 16
#define _const_v__table__none_type_idx 17
#define _const_v__table__string_type_idx 18
#define _const_v__table__ustring_type_idx 19
#define _const_v__table__array_type_idx 20
#define _const_v__table__map_type_idx 21
#define _const_v__table__any_type_idx 22
array_int _const_v__table__integer_type_idxs; // inited later
array_int _const_v__table__signed_integer_type_idxs; // inited later
array_int _const_v__table__unsigned_integer_type_idxs; // inited later
array_int _const_v__table__float_type_idxs; // inited later
array_int _const_v__table__number_type_idxs; // inited later
array_int _const_v__table__pointer_type_idxs; // inited later
array_int _const_v__table__string_type_idxs; // inited later
v__table__Type _const_v__table__void_type; // inited later
v__table__Type _const_v__table__voidptr_type; // inited later
v__table__Type _const_v__table__byteptr_type; // inited later
v__table__Type _const_v__table__charptr_type; // inited later
v__table__Type _const_v__table__i8_type; // inited later
v__table__Type _const_v__table__int_type; // inited later
v__table__Type _const_v__table__i16_type; // inited later
v__table__Type _const_v__table__i64_type; // inited later
v__table__Type _const_v__table__byte_type; // inited later
v__table__Type _const_v__table__u16_type; // inited later
v__table__Type _const_v__table__u32_type; // inited later
v__table__Type _const_v__table__u64_type; // inited later
v__table__Type _const_v__table__f32_type; // inited later
v__table__Type _const_v__table__f64_type; // inited later
v__table__Type _const_v__table__char_type; // inited later
v__table__Type _const_v__table__bool_type; // inited later
v__table__Type _const_v__table__none_type; // inited later
v__table__Type _const_v__table__string_type; // inited later
v__table__Type _const_v__table__ustring_type; // inited later
v__table__Type _const_v__table__array_type; // inited later
v__table__Type _const_v__table__map_type; // inited later
v__table__Type _const_v__table__any_type; // inited later
array_string _const_v__table__builtin_type_names; // inited later
string v__table__TypeSymbol_str(v__table__TypeSymbol* t);
v__table__Enum v__table__TypeSymbol_enum_info(v__table__TypeSymbol* t);
v__table__MultiReturn v__table__TypeSymbol_mr_info(v__table__TypeSymbol* t);
v__table__Array v__table__TypeSymbol_array_info(v__table__TypeSymbol* t);
v__table__ArrayFixed v__table__TypeSymbol_array_fixed_info(v__table__TypeSymbol* t);
v__table__Map v__table__TypeSymbol_map_info(v__table__TypeSymbol* t);
v__table__Struct v__table__TypeSymbol_struct_info(v__table__TypeSymbol* t);
void v__table__Table_register_builtin_type_symbols(v__table__Table* t);
bool v__table__TypeSymbol_is_pointer(v__table__TypeSymbol* t);
bool v__table__TypeSymbol_is_int(v__table__TypeSymbol* t);
bool v__table__TypeSymbol_is_float(v__table__TypeSymbol* t);
bool v__table__TypeSymbol_is_number(v__table__TypeSymbol* t);
string v__table__Kind_str(v__table__Kind k);
string array_v__table__Kind_str(array_v__table__Kind kinds);
string v__table__Table_type_to_str(v__table__Table* table, v__table__Type t);
string v__table__Table_fn_to_str(v__table__Table* t, v__table__Fn* func);
bool v__table__TypeSymbol_has_method(v__table__TypeSymbol* t, string name);
Option_v__table__Fn v__table__TypeSymbol_find_method(v__table__TypeSymbol* t, string name);
Option_v__table__Field v__table__Struct_find_field(v__table__Struct s, string name);
v__table__Field v__table__Struct_get_field(v__table__Struct s, string name);
static bool v__table__Table_has_cflag(v__table__Table* table, v__cflag__CFlag flag);
Option_bool v__table__Table_parse_cflag(v__table__Table* table, string cflg, string mod, array_string ctimedefines);
v__table__Table* v__table__new_table();
string v__table__Fn_signature(v__table__Fn* f);
bool v__table__Fn_is_same_method_as(v__table__Fn* f, v__table__Fn* func);
Option_v__table__Fn v__table__Table_find_fn(v__table__Table* t, string name);
bool v__table__Table_known_fn(v__table__Table* t, string name);
void v__table__Table_register_fn(v__table__Table* t, v__table__Fn new_fn);
void v__table__TypeSymbol_register_method(v__table__TypeSymbol* t, v__table__Fn new_fn);
bool v__table__Table_type_has_method(v__table__Table* t, v__table__TypeSymbol* s, string name);
Option_v__table__Fn v__table__Table_type_find_method(v__table__Table* t, v__table__TypeSymbol* s, string name);
bool v__table__Table_struct_has_field(v__table__Table* t, v__table__TypeSymbol* s, string name);
Option_v__table__Field v__table__Table_struct_find_field(v__table__Table* t, v__table__TypeSymbol* s, string name);
int v__table__Table_find_type_idx(v__table__Table* t, string name);
Option_v__table__TypeSymbol v__table__Table_find_type(v__table__Table* t, string name);
v__table__TypeSymbol* v__table__Table_get_type_symbol(v__table__Table* t, v__table__Type typ);
string v__table__Table_get_type_name(v__table__Table* t, v__table__Type typ);
int v__table__Table_register_builtin_type_symbol(v__table__Table* t, v__table__TypeSymbol typ);
int v__table__Table_register_type_symbol(v__table__Table* t, v__table__TypeSymbol typ);
bool v__table__Table_known_type(v__table__Table* t, string name);
string v__table__Table_array_name(v__table__Table* t, v__table__Type elem_type, int nr_dims);
string v__table__Table_array_fixed_name(v__table__Table* t, v__table__Type elem_type, int size, int nr_dims);
string v__table__Table_map_name(v__table__Table* t, v__table__Type key_type, v__table__Type value_type);
int v__table__Table_find_or_register_map(v__table__Table* t, v__table__Type key_type, v__table__Type value_type);
int v__table__Table_find_or_register_array(v__table__Table* t, v__table__Type elem_type, int nr_dims);
int v__table__Table_find_or_register_array_fixed(v__table__Table* t, v__table__Type elem_type, int size, int nr_dims);
int v__table__Table_find_or_register_multi_return(v__table__Table* t, array_v__table__Type mr_typs);
int v__table__Table_find_or_register_fn_type(v__table__Table* t, v__table__Fn f, bool is_anon, bool has_decl);
int v__table__Table_add_placeholder_type(v__table__Table* t, string name);
v__table__Type v__table__Table_value_type(v__table__Table* t, v__table__Type typ);
bool v__table__Table_check(v__table__Table* t, v__table__Type got, v__table__Type expected);
string v__table__Table_qualify_module(v__table__Table* table, string mod, string file_path);
string _const_v__pref__default_module_path; // inited later
static string v__pref__mpath();
v__pref__Preferences v__pref__new_preferences();
void v__pref__Preferences_fill_with_defaults(v__pref__Preferences* p);
static string v__pref__default_c_compiler();
string v__pref__vexe_path();
Option_v__pref__OS v__pref__os_from_string(string os_str);
string v__pref__OS_str(v__pref__OS o);
v__pref__OS v__pref__get_host_os();
Option_v__pref__Backend v__pref__backend_from_string(string s);
array_string v__pref__Preferences_should_compile_filtered_files(v__pref__Preferences* prefs, string dir, array_string files);
bool v__pref__Preferences_should_compile_c(v__pref__Preferences* prefs, string file);
bool v__pref__Preferences_should_compile_js(v__pref__Preferences* prefs, string file);
string _const_help__unknown_topic; // a string literal, inited later
void help__print_and_exit(string topic);
#define _const_v__util__error_context_before 2
#define _const_v__util__error_context_after 2
v__util__EManager* _const_v__util__emanager; // inited later
void v__util__EManager_set_support_color(v__util__EManager* e, bool b);
v__util__EManager* v__util__new_error_manager();
string v__util__formatted_error(string kind, string emsg, string filepath, v__token__Position pos);
array_string v__util__source_context(string kind, string source, int column, v__token__Position pos);
void v__util__verror(string kind, string s);
Option_string v__util__find_working_diff_command();
string v__util__color_compare_files(string diff_cmd, string file1, string file2);
static string v__util__color_compare_strings(string diff_cmd, string expected, string found);
static bool v__util__is_name_char(byte c);
static bool v__util__is_nl(byte c);
static bool v__util__contains_capital(string s);
static bool v__util__good_type_name(string s);
string v__util__cescaped_path(string s);
bool v__util__is_fmt();
string _const_v__util__v_version; // a string literal, inited later
array_string _const_v__util__builtin_module_parts; // inited later
string v__util__vhash();
string v__util__full_hash();
string v__util__full_v_version();
string v__util__githash(bool should_get_from_filesystem);
static void v__util__set_vroot_folder(string vroot_path);
void v__util__launch_tool(bool is_verbose, string tool_name);
string v__util__path_of_executable(string path);
Option_string v__util__read_file(string file_path);
static int v__util__imin(int a, int b);
static int v__util__imax(int a, int b);
static string v__util__replace_op(string s);
array_string v__util__join_env_vflags_and_os_args();
static array_string v__util__non_empty(array_string arg);
v__ast__IdentVar v__ast__Ident_var_info(v__ast__Ident* i);
bool v__ast__expr_is_blank_ident(v__ast__Expr expr);
bool v__ast__expr_is_call(v__ast__Expr expr);
static v__token__Position v__ast__Expr_position(v__ast__Expr expr);
static v__token__Position v__ast__Stmt_position(v__ast__Stmt stmt);
v__ast__Expr v__ast__fe2ex(v__table__FExpr x);
v__table__FExpr v__ast__ex2fe(v__ast__Expr x);
v__ast__Scope* v__ast__new_scope(v__ast__Scope* parent, int start_pos);
Option_multi_return_v__ast__ScopeObject_v__ast__Scope v__ast__Scope_find_with_scope(v__ast__Scope* s, string name);
Option_v__ast__ScopeObject v__ast__Scope_find(v__ast__Scope* s, string name);
bool v__ast__Scope_is_known(v__ast__Scope* s, string name);
Option_v__ast__Var_ptr v__ast__Scope_find_var(v__ast__Scope* s, string name);
Option_v__ast__ConstField_ptr v__ast__Scope_find_const(v__ast__Scope* s, string name);
bool v__ast__Scope_known_var(v__ast__Scope* s, string name);
void v__ast__Scope_update_var_type(v__ast__Scope* s, string name, v__table__Type typ);
void v__ast__Scope_register(v__ast__Scope* s, string name, v__ast__ScopeObject obj);
v__ast__Scope* v__ast__Scope_outermost(v__ast__Scope* s);
v__ast__Scope* v__ast__Scope_innermost(v__ast__Scope* s, int pos);
static bool v__ast__Scope_contains(v__ast__Scope* s, int pos);
string v__ast__Scope_show(v__ast__Scope* sc, int depth, int max_depth);
string v__ast__Scope_str(v__ast__Scope* sc);
string v__ast__FnDecl_str(v__ast__FnDecl* node, v__table__Table* t);
string v__ast__Expr_str(v__ast__Expr x);
string v__ast__CallArg_str(v__ast__CallArg a);
string v__ast__args2str(array_v__ast__CallArg args);
string v__ast__Stmt_str(v__ast__Stmt node);
#define _const_v__checker__max_nr_errors 300
v__checker__Checker v__checker__new_checker(v__table__Table* table, v__pref__Preferences* pref);
void v__checker__Checker_check(v__checker__Checker* c, v__ast__File ast_file);
array_v__errors__Error v__checker__Checker_check2(v__checker__Checker* c, v__ast__File ast_file);
void v__checker__Checker_check_files(v__checker__Checker* c, array_v__ast__File ast_files);
string _const_v__checker__no_pub_in_main_warning; // a string literal, inited later
static bool v__checker__Checker_check_file_in_main(v__checker__Checker* c, v__ast__File file);
void v__checker__Checker_type_decl(v__checker__Checker* c, v__ast__TypeDecl node);
void v__checker__Checker_struct_decl(v__checker__Checker* c, v__ast__StructDecl decl);
v__table__Type v__checker__Checker_struct_init(v__checker__Checker* c, v__ast__StructInit* struct_init);
v__table__Type v__checker__Checker_infix_expr(v__checker__Checker* c, v__ast__InfixExpr* infix_expr);
static void v__checker__Checker_fail_if_immutable(v__checker__Checker* c, v__ast__Expr expr);
static void v__checker__Checker_assign_expr(v__checker__Checker* c, v__ast__AssignExpr* assign_expr);
v__table__Type v__checker__Checker_call_expr(v__checker__Checker* c, v__ast__CallExpr* call_expr);
v__table__Type v__checker__Checker_call_method(v__checker__Checker* c, v__ast__CallExpr* call_expr);
v__table__Type v__checker__Checker_call_fn(v__checker__Checker* c, v__ast__CallExpr* call_expr);
static void v__checker__Checker_type_implements(v__checker__Checker* c, v__table__Type typ, v__table__Type inter_typ, v__token__Position pos);
void v__checker__Checker_check_expr_opt_call(v__checker__Checker* c, v__ast__Expr x, v__table__Type xtype, bool is_return_used);
void v__checker__Checker_check_or_block(v__checker__Checker* c, v__ast__CallExpr* call_expr, v__table__Type ret_type, bool is_ret_used);
static bool v__checker__is_expr_panic_or_exit(v__ast__Expr expr);
bool v__checker__Checker_is_last_or_block_stmt_valid(v__checker__Checker* c, v__ast__Stmt stmt);
v__table__Type v__checker__Checker_selector_expr(v__checker__Checker* c, v__ast__SelectorExpr* selector_expr);
void v__checker__Checker_return_stmt(v__checker__Checker* c, v__ast__Return* return_stmt);
void v__checker__Checker_enum_decl(v__checker__Checker* c, v__ast__EnumDecl decl);
void v__checker__Checker_assign_stmt(v__checker__Checker* c, v__ast__AssignStmt* assign_stmt);
v__table__Type v__checker__Checker_array_init(v__checker__Checker* c, v__ast__ArrayInit* array_init);
static Option_int v__checker__const_int_value(v__ast__ConstField cfield);
static Option_v__ast__IntegerLiteral v__checker__is_const_integer(v__ast__ConstField cfield);
static void v__checker__Checker_stmt(v__checker__Checker* c, v__ast__Stmt node);
static void v__checker__Checker_stmts(v__checker__Checker* c, array_v__ast__Stmt stmts);
v__table__Type v__checker__Checker_expr(v__checker__Checker* c, v__ast__Expr node);
v__table__Type v__checker__Checker_ident(v__checker__Checker* c, v__ast__Ident* ident);
v__table__Type v__checker__Checker_match_expr(v__checker__Checker* c, v__ast__MatchExpr* node);
static void v__checker__Checker_match_exprs(v__checker__Checker* c, v__ast__MatchExpr* node, v__table__TypeSymbol type_sym);
v__table__Type v__checker__Checker_if_expr(v__checker__Checker* c, v__ast__IfExpr* node);
v__table__Type v__checker__Checker_postfix_expr(v__checker__Checker* c, v__ast__PostfixExpr node);
v__table__Type v__checker__Checker_index_expr(v__checker__Checker* c, v__ast__IndexExpr* node);
v__table__Type v__checker__Checker_enum_val(v__checker__Checker* c, v__ast__EnumVal* node);
v__table__Type v__checker__Checker_map_init(v__checker__Checker* c, v__ast__MapInit* node);
void v__checker__Checker_warn(v__checker__Checker* c, string s, v__token__Position pos);
void v__checker__Checker_error(v__checker__Checker* c, string message, v__token__Position pos);
static void v__checker__Checker_warn_or_error(v__checker__Checker* c, string message, v__token__Position pos, bool warn);
static bool v__checker__Checker_fileis(v__checker__Checker* c, string s);
array_string _const_v__gen__c_reserved; // inited later
static void v__gen__foo(v__token__Token t);
array_string _const_v__gen__tabs; // inited later
string v__gen__cgen(array_v__ast__File files, v__table__Table* table, v__pref__Preferences* pref);
string v__gen__Gen_hashes(v__gen__Gen g);
void v__gen__Gen_init(v__gen__Gen* g);
void v__gen__Gen_finish(v__gen__Gen* g);
void v__gen__Gen_write_typeof_functions(v__gen__Gen* g);
static string v__gen__Gen_typ(v__gen__Gen* g, v__table__Type t);
static string v__gen__Gen_base_type(v__gen__Gen* g, v__table__Type t);
static string v__gen__Gen_cc_type(v__gen__Gen* g, v__table__Type t);
void v__gen__Gen_write_typedef_types(v__gen__Gen* g);
void v__gen__Gen_write_multi_return_types(v__gen__Gen* g);
void v__gen__Gen_write_variadic_types(v__gen__Gen* g);
void v__gen__Gen_save(v__gen__Gen g);
void v__gen__Gen_write(v__gen__Gen* g, string s);
void v__gen__Gen_writeln(v__gen__Gen* g, string s);
string v__gen__Gen_new_tmp_var(v__gen__Gen* g);
void v__gen__Gen_reset_tmp_count(v__gen__Gen* g);
static void v__gen__Gen_stmts(v__gen__Gen* g, array_v__ast__Stmt stmts);
static void v__gen__Gen_stmt(v__gen__Gen* g, v__ast__Stmt node);
static void v__gen__Gen_write_defer_stmts(v__gen__Gen* g);
static void v__gen__Gen_for_in(v__gen__Gen* g, v__ast__ForInStmt it);
static void v__gen__Gen_expr_with_cast(v__gen__Gen* g, v__ast__Expr expr, v__table__Type got_type, v__table__Type exp_type);
static void v__gen__Gen_gen_assert_stmt(v__gen__Gen* g, v__ast__AssertStmt a);
static void v__gen__Gen_gen_assign_stmt(v__gen__Gen* g, v__ast__AssignStmt assign_stmt);
static bool v__gen__Gen_gen_clone_assignment(v__gen__Gen* g, v__ast__Expr val, v__table__TypeSymbol right_sym, bool add_eq);
static string v__gen__Gen_autofree_scope_vars(v__gen__Gen* g, int pos);
static string v__gen__Gen_autofree_variable(v__gen__Gen* g, v__ast__Var v);
static string v__gen__Gen_autofree_var_call(v__gen__Gen* g, string free_fn_name, v__ast__Var v);
static void v__gen__Gen_expr(v__gen__Gen* g, v__ast__Expr node);
static void v__gen__Gen_typeof_expr(v__gen__Gen* g, v__ast__TypeOf node);
static void v__gen__Gen_enum_expr(v__gen__Gen* g, v__ast__Expr node);
static void v__gen__Gen_assign_expr(v__gen__Gen* g, v__ast__AssignExpr node);
static void v__gen__Gen_infix_expr(v__gen__Gen* g, v__ast__InfixExpr node);
static void v__gen__Gen_match_expr(v__gen__Gen* g, v__ast__MatchExpr node);
static void v__gen__Gen_ident(v__gen__Gen* g, v__ast__Ident node);
static void v__gen__Gen_if_expr(v__gen__Gen* g, v__ast__IfExpr node);
static void v__gen__Gen_index_expr(v__gen__Gen* g, v__ast__IndexExpr node);
static void v__gen__Gen_return_statement(v__gen__Gen* g, v__ast__Return node);
static void v__gen__Gen_const_decl(v__gen__Gen* g, v__ast__ConstDecl node);
static void v__gen__Gen_const_decl_simple_define(v__gen__Gen* g, string name, string val);
static void v__gen__Gen_const_decl_init_later(v__gen__Gen* g, string name, string val, v__table__Type typ);
static void v__gen__Gen_struct_init(v__gen__Gen* g, v__ast__StructInit struct_init);
static void v__gen__Gen_assoc(v__gen__Gen* g, v__ast__Assoc node);
static void v__gen__Gen_generate_array_equality_fn(v__gen__Gen* g, string ptr_typ, v__table__Type styp, v__table__TypeSymbol* sym);
static void v__gen__verror(string s);
static void v__gen__Gen_write_init_function(v__gen__Gen* g);
array_string _const_v__gen__builtins; // inited later
static void v__gen__Gen_write_builtin_types(v__gen__Gen* g);
static void v__gen__Gen_write_sorted_types(v__gen__Gen* g);
static void v__gen__Gen_write_types(v__gen__Gen* g, array_v__table__TypeSymbol types);
static array_v__table__TypeSymbol v__gen__Gen_sort_structs(v__gen__Gen g, array_v__table__TypeSymbol typesa);
static void v__gen__Gen_string_inter_literal(v__gen__Gen* g, v__ast__StringInterLiteral node);
static void v__gen__Gen_gen_map(v__gen__Gen* g, v__ast__CallExpr node);
static void v__gen__Gen_gen_filter(v__gen__Gen* g, v__ast__CallExpr node);
static void v__gen__Gen_insert_before(v__gen__Gen* g, string s);
static void v__gen__Gen_or_block(v__gen__Gen* g, string var_name, array_v__ast__Stmt stmts, v__table__Type return_type);
static multi_return_string_string v__gen__Gen_type_of_last_statement(v__gen__Gen* g, array_v__ast__Stmt stmts);
static string v__gen__Gen_type_of_call_expr(v__gen__Gen* g, v__ast__Expr node);
static void v__gen__Gen_in_optimization(v__gen__Gen* g, v__ast__Expr left, v__ast__ArrayInit right);
static string v__gen__op_to_fn_name(string name);
static string v__gen__Gen_comp_if_to_ifdef(v__gen__Gen* g, string name, bool is_comptime_optional);
static string v__gen__c_name(string name_);
static string v__gen__Gen_type_default(v__gen__Gen g, v__table__Type typ);
void v__gen__Gen_write_tests_main(v__gen__Gen* g);
static array_string v__gen__Gen_get_all_test_function_names(v__gen__Gen g);
static bool v__gen__Gen_is_importing_os(v__gen__Gen g);
static void v__gen__Gen_comp_if(v__gen__Gen* g, v__ast__CompIf it);
static void v__gen__Gen_go_stmt(v__gen__Gen* g, v__ast__GoStmt node);
static void v__gen__Gen_as_cast(v__gen__Gen* g, v__ast__AsCast node);
static void v__gen__Gen_is_expr(v__gen__Gen* g, v__ast__InfixExpr node);
static string v__gen__styp_to_str_fn_name(string styp);
static string v__gen__Gen_gen_str_for_type(v__gen__Gen* g, v__table__Type typ);
static string v__gen__Gen_gen_str_for_type_with_styp(v__gen__Gen* g, v__table__Type typ, string styp);
static void v__gen__Gen_gen_str_default(v__gen__Gen* g, v__table__TypeSymbol sym, string styp, string str_fn_name);
static void v__gen__Gen_gen_str_for_enum(v__gen__Gen* g, v__table__Enum info, string styp, string str_fn_name);
static void v__gen__Gen_gen_str_for_struct(v__gen__Gen* g, v__table__Struct info, string styp, string str_fn_name);
static void v__gen__Gen_gen_str_for_array(v__gen__Gen* g, v__table__Array info, string styp, string str_fn_name);
static void v__gen__Gen_gen_str_for_array_fixed(v__gen__Gen* g, v__table__ArrayFixed info, string styp, string str_fn_name);
static void v__gen__Gen_gen_str_for_map(v__gen__Gen* g, v__table__Map info, string styp, string str_fn_name);
static void v__gen__Gen_gen_str_for_varg(v__gen__Gen* g, string styp, string str_fn_name);
static string v__gen__Gen_type_to_fmt(v__gen__Gen g, v__table__Type typ);
static string v__gen__Gen_interface_table(v__gen__Gen* g);
static void v__gen__Gen_array_init(v__gen__Gen* g, v__ast__ArrayInit it);
static void v__gen__Gen_interface_call(v__gen__Gen* g, v__table__Type typ, v__table__Type interface_type);
string _const_v__gen__c_commit_hash_default; // a string literal, inited later
string _const_v__gen__c_current_commit_hash_default; // a string literal, inited later
string _const_v__gen__c_common_macros; // a string literal, inited later
string _const_v__gen__c_headers; // inited later
string _const_v__gen__c_builtin_types; // a string literal, inited later
string _const_v__gen__bare_c_headers; // inited later
static void v__gen__Gen_gen_fn_decl(v__gen__Gen* g, v__ast__FnDecl it);
static void v__gen__Gen_write_autofree_stmts_when_needed(v__gen__Gen* g, v__ast__Return r);
static void v__gen__Gen_write_defer_stmts_when_needed(v__gen__Gen* g);
static multi_return_array_string_array_string v__gen__Gen_fn_args(v__gen__Gen* g, array_v__table__Arg args, bool is_variadic);
static void v__gen__Gen_call_expr(v__gen__Gen* g, v__ast__CallExpr node);
static void v__gen__Gen_method_call(v__gen__Gen* g, v__ast__CallExpr node);
static void v__gen__Gen_fn_call(v__gen__Gen* g, v__ast__CallExpr node);
static void v__gen__Gen_call_args(v__gen__Gen* g, array_v__ast__CallArg args, array_v__table__Type expected_types);
static void v__gen__Gen_ref_or_deref_arg(v__gen__Gen* g, v__ast__CallArg arg, v__table__Type expected_type);
static bool v__gen__Gen_is_gui_app(v__gen__Gen* g);
static void v__gen__Gen_gen_json_for_type(v__gen__Gen* g, v__table__Type typ);
static string v__gen__js_enc_name(string typ);
static string v__gen__js_dec_name(string typ);
static bool v__gen__is_js_prim(string typ);
static string v__gen__Gen_decode_array(v__gen__Gen* g, v__table__Type value_type);
static string v__gen__Gen_encode_array(v__gen__Gen* g, v__table__Type value_type);
static void v__gen__Gen_generate_hotcode_reloading_declarations(v__gen__Gen* g);
static void v__gen__Gen_generate_hotcode_reloader_code(v__gen__Gen* g);
string _const_v__gen__posix_hotcode_definitions_1; // a string literal, inited later
string _const_v__gen__windows_hotcode_definitions_1; // a string literal, inited later
static void v__gen__Gen_generate_hotcode_reloading_main_caller(v__gen__Gen* g);
static void v__gen__Gen_profile_fn(v__gen__Gen* g, string fn_name, bool is_main);
void v__gen__Gen_gen_vprint_profile_stats(v__gen__Gen* g);
static void v__gen__Gen_write_str_fn_definitions(v__gen__Gen* g);
array_string _const_v__gen__js__js_reserved; // inited later
array_string _const_v__gen__js__tabs; // inited later
string v__gen__js__gen(array_v__ast__File files, v__table__Table* table, v__pref__Preferences* pref);
void v__gen__js__JsGen_enter_namespace(v__gen__js__JsGen* g, string n);
void v__gen__js__JsGen_escape_namespace(v__gen__js__JsGen* g);
void v__gen__js__JsGen_push_pub_var(v__gen__js__JsGen* g, string s);
void v__gen__js__JsGen_find_class_methods(v__gen__js__JsGen* g, array_v__ast__Stmt stmts);
void v__gen__js__JsGen_init(v__gen__js__JsGen* g);
void v__gen__js__JsGen_finish(v__gen__js__JsGen* g);
string v__gen__js__JsGen_hashes(v__gen__js__JsGen g);
string v__gen__js__JsGen_typ(v__gen__js__JsGen* g, v__table__Type t);
static string v__gen__js__JsGen_to_js_typ(v__gen__js__JsGen* g, string typ);
void v__gen__js__JsGen_save(v__gen__js__JsGen* g);
void v__gen__js__JsGen_gen_indent(v__gen__js__JsGen* g);
void v__gen__js__JsGen_inc_indent(v__gen__js__JsGen* g);
void v__gen__js__JsGen_dec_indent(v__gen__js__JsGen* g);
void v__gen__js__JsGen_write(v__gen__js__JsGen* g, string s);
void v__gen__js__JsGen_writeln(v__gen__js__JsGen* g, string s);
string v__gen__js__JsGen_new_tmp_var(v__gen__js__JsGen* g);
static void v__gen__js__JsGen_stmts(v__gen__js__JsGen* g, array_v__ast__Stmt stmts);
static void v__gen__js__JsGen_stmt(v__gen__js__JsGen* g, v__ast__Stmt node);
static void v__gen__js__JsGen_expr(v__gen__js__JsGen* g, v__ast__Expr node);
static void v__gen__js__JsGen_gen_string_inter_literal(v__gen__js__JsGen* g, v__ast__StringInterLiteral it);
static void v__gen__js__JsGen_gen_array_init_expr(v__gen__js__JsGen* g, v__ast__ArrayInit it);
static void v__gen__js__JsGen_gen_assert_stmt(v__gen__js__JsGen* g, v__ast__AssertStmt a);
static void v__gen__js__JsGen_gen_assign_stmt(v__gen__js__JsGen* g, v__ast__AssignStmt it);
static void v__gen__js__JsGen_gen_attr(v__gen__js__JsGen* g, v__ast__Attr it);
static void v__gen__js__JsGen_gen_block(v__gen__js__JsGen* g, v__ast__Block it);
static void v__gen__js__JsGen_gen_branch_stmt(v__gen__js__JsGen* g, v__ast__BranchStmt it);
static void v__gen__js__JsGen_gen_const_decl(v__gen__js__JsGen* g, v__ast__ConstDecl it);
static void v__gen__js__JsGen_gen_defer_stmts(v__gen__js__JsGen* g);
static void v__gen__js__JsGen_gen_enum_decl(v__gen__js__JsGen* g, v__ast__EnumDecl it);
static void v__gen__js__JsGen_gen_expr_stmt(v__gen__js__JsGen* g, v__ast__ExprStmt it);
static void v__gen__js__JsGen_gen_fn_decl(v__gen__js__JsGen* g, v__ast__FnDecl it);
static void v__gen__js__JsGen_gen_method_decl(v__gen__js__JsGen* g, v__ast__FnDecl it);
static void v__gen__js__JsGen_gen_for_c_stmt(v__gen__js__JsGen* g, v__ast__ForCStmt it);
static void v__gen__js__JsGen_gen_for_in_stmt(v__gen__js__JsGen* g, v__ast__ForInStmt it);
static void v__gen__js__JsGen_gen_for_stmt(v__gen__js__JsGen* g, v__ast__ForStmt it);
static void v__gen__js__JsGen_fn_args(v__gen__js__JsGen* g, array_v__table__Arg args, bool is_variadic);
static void v__gen__js__JsGen_gen_go_stmt(v__gen__js__JsGen* g, v__ast__GoStmt node);
static void v__gen__js__JsGen_gen_map_init_expr(v__gen__js__JsGen* g, v__ast__MapInit it);
static void v__gen__js__JsGen_gen_return_stmt(v__gen__js__JsGen* g, v__ast__Return it);
static void v__gen__js__JsGen_enum_expr(v__gen__js__JsGen* g, v__ast__Expr node);
static void v__gen__js__JsGen_gen_struct_decl(v__gen__js__JsGen* g, v__ast__StructDecl node);
static void v__gen__js__JsGen_gen_struct_init(v__gen__js__JsGen* g, v__ast__StructInit it);
static void v__gen__js__JsGen_gen_ident(v__gen__js__JsGen* g, v__ast__Ident node);
static void v__gen__js__JsGen_gen_selector_expr(v__gen__js__JsGen* g, v__ast__SelectorExpr it);
static void v__gen__js__JsGen_gen_if_expr(v__gen__js__JsGen* g, v__ast__IfExpr node);
static void v__gen__js__verror(string s);
static bool v__gen__js__fn_has_go(v__ast__FnDecl it);
static v__gen__js__JsDoc* v__gen__js__new_jsdoc(v__gen__js__JsGen* gen);
static void v__gen__js__JsDoc_gen_indent(v__gen__js__JsDoc* d);
static void v__gen__js__JsDoc_write(v__gen__js__JsDoc* d, string s);
static void v__gen__js__JsDoc_writeln(v__gen__js__JsDoc* d, string s);
static void v__gen__js__JsDoc_reset(v__gen__js__JsDoc* d);
static string v__gen__js__JsDoc_gen_typ(v__gen__js__JsDoc* d, string typ, string name);
static string v__gen__js__JsDoc_gen_ctor(v__gen__js__JsDoc* d, array_v__ast__StructField fields);
static string v__gen__js__JsDoc_gen_fn(v__gen__js__JsDoc* d, v__ast__FnDecl it);
byte _const_v__gen__x64__mag0; // inited later
#define _const_v__gen__x64__mag1 'E'
#define _const_v__gen__x64__mag2 'L'
#define _const_v__gen__x64__mag3 'F'
#define _const_v__gen__x64__ei_class 4
#define _const_v__gen__x64__elfclass64 2
#define _const_v__gen__x64__elfdata2lsb 1
#define _const_v__gen__x64__ev_current 1
#define _const_v__gen__x64__elf_osabi 0
#define _const_v__gen__x64__et_rel 1
#define _const_v__gen__x64__et_exec 2
#define _const_v__gen__x64__et_dyn 3
#define _const_v__gen__x64__e_machine 0x3e
#define _const_v__gen__x64__shn_xindex 0xffff
#define _const_v__gen__x64__sht_null 0
#define _const_v__gen__x64__segment_start 0x400000
#define _const_v__gen__x64__PLACEHOLDER 0
#define _const_v__gen__x64__SEVENS 0x77777777
void v__gen__x64__Gen_generate_elf_header(v__gen__x64__Gen* g);
void v__gen__x64__Gen_generate_elf_footer(v__gen__x64__Gen* g);
static void v__gen__x64__Gen_section_header(v__gen__x64__Gen* g, v__gen__x64__SectionConfig c);
static void v__gen__x64__genobj();
array_v__gen__x64__Register _const_v__gen__x64__fn_arg_registers; // inited later
void v__gen__x64__gen(array_v__ast__File files, string out_name);
void v__gen__x64__Gen_stmts(v__gen__x64__Gen* g, array_v__ast__Stmt stmts);
i64 v__gen__x64__Gen_pos(v__gen__x64__Gen* g);
static void v__gen__x64__Gen_write8(v__gen__x64__Gen* g, int n);
static void v__gen__x64__Gen_write16(v__gen__x64__Gen* g, int n);
static void v__gen__x64__Gen_write32(v__gen__x64__Gen* g, int n);
static void v__gen__x64__Gen_write64(v__gen__x64__Gen* g, i64 n);
static void v__gen__x64__Gen_write64_at(v__gen__x64__Gen* g, i64 n, i64 at);
static void v__gen__x64__Gen_write32_at(v__gen__x64__Gen* g, i64 at, int n);
static void v__gen__x64__Gen_write_string(v__gen__x64__Gen* g, string s);
static void v__gen__x64__Gen_inc(v__gen__x64__Gen* g, v__gen__x64__Register reg);
string v__gen__x64__Register_str(v__gen__x64__Register it); // auto
static void v__gen__x64__Gen_cmp(v__gen__x64__Gen* g, v__gen__x64__Register reg, v__gen__x64__Size size, i64 val);
static int v__gen__x64__Gen_get_var_offset(v__gen__x64__Gen* g, string var_name);
static void v__gen__x64__Gen_cmp_var(v__gen__x64__Gen* g, string var_name, int val);
static void v__gen__x64__Gen_inc_var(v__gen__x64__Gen* g, string var_name);
static int v__gen__x64__Gen_jne(v__gen__x64__Gen* g);
static int v__gen__x64__Gen_jge(v__gen__x64__Gen* g);
static void v__gen__x64__Gen_jmp(v__gen__x64__Gen* g, int addr);
static i64 v__gen__x64__abs(i64 a);
static void v__gen__x64__Gen_jle(v__gen__x64__Gen* g, i64 addr);
static void v__gen__x64__Gen_println(v__gen__x64__Gen* g, string comment);
static void v__gen__x64__Gen_jl(v__gen__x64__Gen* g, i64 addr);
static int v__gen__x64__Gen_abs_to_rel_addr(v__gen__x64__Gen* g, i64 addr);
static void v__gen__x64__Gen_mov64(v__gen__x64__Gen* g, v__gen__x64__Register reg, i64 val);
static void v__gen__x64__Gen_mov_from_reg(v__gen__x64__Gen* g, int var_offset, v__gen__x64__Register reg);
static void v__gen__x64__Gen_call(v__gen__x64__Gen* g, int addr);
static void v__gen__x64__Gen_syscall(v__gen__x64__Gen* g);
void v__gen__x64__Gen_ret(v__gen__x64__Gen* g);
void v__gen__x64__Gen_push(v__gen__x64__Gen* g, v__gen__x64__Register reg);
void v__gen__x64__Gen_pop(v__gen__x64__Gen* g, v__gen__x64__Register reg);
void v__gen__x64__Gen_sub32(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val);
void v__gen__x64__Gen_add(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val);
static void v__gen__x64__Gen_leave(v__gen__x64__Gen* g);
int v__gen__x64__Gen_gen_loop_start(v__gen__x64__Gen* g, int from);
void v__gen__x64__Gen_gen_loop_end(v__gen__x64__Gen* g, int to, int label);
void v__gen__x64__Gen_save_main_fn_addr(v__gen__x64__Gen* g);
void v__gen__x64__Gen_gen_print_from_expr(v__gen__x64__Gen* g, v__ast__Expr expr, bool newline);
void v__gen__x64__Gen_gen_print(v__gen__x64__Gen* g, string s);
void v__gen__x64__Gen_gen_exit(v__gen__x64__Gen* g);
static void v__gen__x64__Gen_mov(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val);
static void v__gen__x64__Gen_mov_reg(v__gen__x64__Gen* g, v__gen__x64__Register a, v__gen__x64__Register b);
static void v__gen__x64__Gen_mov_rbp_rsp(v__gen__x64__Gen* g);
void v__gen__x64__Gen_register_function_address(v__gen__x64__Gen* g, string name);
void v__gen__x64__Gen_call_fn(v__gen__x64__Gen* g, v__ast__CallExpr node);
static void v__gen__x64__Gen_stmt(v__gen__x64__Gen* g, v__ast__Stmt node);
static void v__gen__x64__Gen_expr(v__gen__x64__Gen* g, v__ast__Expr node);
static void v__gen__x64__Gen_allocate_var(v__gen__x64__Gen* g, string name, int size, int initial_val);
static void v__gen__x64__Gen_assign_stmt(v__gen__x64__Gen* g, v__ast__AssignStmt node);
static void v__gen__x64__Gen_infix_expr(v__gen__x64__Gen* g, v__ast__InfixExpr node);
static void v__gen__x64__Gen_if_expr(v__gen__x64__Gen* g, v__ast__IfExpr node);
static void v__gen__x64__Gen_for_stmt(v__gen__x64__Gen* g, v__ast__ForStmt node);
static void v__gen__x64__Gen_fn_decl(v__gen__x64__Gen* g, v__ast__FnDecl node);
static void v__gen__x64__Gen_postfix_expr(v__gen__x64__Gen* g, v__ast__PostfixExpr node);
static void v__gen__x64__verror(string s);
#define _const_v__scanner__single_quote '\''
#define _const_v__scanner__double_quote '"'
#define _const_v__scanner__num_sep '_'
v__scanner__Scanner* v__scanner__new_scanner_file(string file_path, v__scanner__CommentsMode comments_mode);
v__scanner__Scanner* v__scanner__new_scanner(string text, v__scanner__CommentsMode comments_mode);
void v__scanner__Scanner_add_fn_main_and_rescan(v__scanner__Scanner* s, int pos);
static v__token__Token v__scanner__Scanner_new_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len);
static string v__scanner__Scanner_ident_name(v__scanner__Scanner* s);
static string v__scanner__filter_num_sep(byteptr txt, int start, int end);
static string v__scanner__Scanner_ident_bin_number(v__scanner__Scanner* s);
static string v__scanner__Scanner_ident_hex_number(v__scanner__Scanner* s);
static string v__scanner__Scanner_ident_oct_number(v__scanner__Scanner* s);
static string v__scanner__Scanner_ident_dec_number(v__scanner__Scanner* s);
static string v__scanner__Scanner_ident_number(v__scanner__Scanner* s);
static void v__scanner__Scanner_skip_whitespace(v__scanner__Scanner* s);
static v__token__Token v__scanner__Scanner_end_of_file(v__scanner__Scanner* s);
v__token__Token v__scanner__Scanner_scan(v__scanner__Scanner* s);
static int v__scanner__Scanner_current_column(v__scanner__Scanner* s);
static int v__scanner__Scanner_count_symbol_before(v__scanner__Scanner* s, int p, byte sym);
static string v__scanner__Scanner_ident_string(v__scanner__Scanner* s);
static string v__scanner__trim_slash_line_break(string s);
static string v__scanner__Scanner_ident_char(v__scanner__Scanner* s);
static bool v__scanner__Scanner_expect(v__scanner__Scanner* s, string want, int start_pos);
static void v__scanner__Scanner_debug_tokens(v__scanner__Scanner* s);
static void v__scanner__Scanner_ignore_line(v__scanner__Scanner* s);
static void v__scanner__Scanner_eat_to_end_of_line(v__scanner__Scanner* s);
static void v__scanner__Scanner_inc_line_number(v__scanner__Scanner* s);
void v__scanner__Scanner_error(v__scanner__Scanner* s, string msg);
void v__scanner__verror(string s);
static v__ast__Stmt v__parser__Parser_assign_stmt(v__parser__Parser* p);
v__ast__AssignExpr v__parser__Parser_assign_expr(v__parser__Parser* p, v__ast__Expr left);
static array_v__ast__Ident v__parser__Parser_parse_assign_lhs(v__parser__Parser* p);
static array_v__ast__Expr v__parser__Parser_parse_assign_rhs(v__parser__Parser* p);
array_string _const_v__parser__supported_platforms; // inited later
static v__ast__HashStmt v__parser__Parser_hash(v__parser__Parser* p);
static v__ast__CompIf v__parser__Parser_comp_if(v__parser__Parser* p);
v__pref__OS _const_v__parser__todo_delete_me; // inited later
static v__pref__OS v__parser__os_from_string(string os);
static v__ast__ArrayInit v__parser__Parser_array_init(v__parser__Parser* p);
static v__ast__MapInit v__parser__Parser_map_init(v__parser__Parser* p);
v__ast__CallExpr v__parser__Parser_call_expr(v__parser__Parser* p, bool is_c, bool is_js, string mod);
array_v__ast__CallArg v__parser__Parser_call_args(v__parser__Parser* p);
static v__ast__FnDecl v__parser__Parser_fn_decl(v__parser__Parser* p);
static v__ast__AnonFn v__parser__Parser_anon_fn(v__parser__Parser* p);
static multi_return_array_v__table__Arg_bool v__parser__Parser_fn_args(v__parser__Parser* p);
static bool v__parser__Parser_fileis(v__parser__Parser* p, string s);
static void v__parser__Parser_fn_redefinition_error(v__parser__Parser* p, string name);
static bool v__parser__have_fn_main(array_v__ast__Stmt stmts);
static v__ast__Stmt v__parser__Parser_for_stmt(v__parser__Parser* p);
static v__ast__IfExpr v__parser__Parser_if_expr(v__parser__Parser* p);
static v__ast__MatchExpr v__parser__Parser_match_expr(v__parser__Parser* p);
bool v__parser__Parser_known_import(v__parser__Parser* p, string mod);
static string v__parser__Parser_prepend_mod(v__parser__Parser* p, string name);
v__table__Type v__parser__Parser_parse_array_type(v__parser__Parser* p);
v__table__Type v__parser__Parser_parse_map_type(v__parser__Parser* p);
v__table__Type v__parser__Parser_parse_multi_return_type(v__parser__Parser* p);
v__table__Type v__parser__Parser_parse_fn_type(v__parser__Parser* p, string name);
v__table__Type v__parser__Parser_parse_type_with_mut(v__parser__Parser* p, bool is_mut);
v__table__Type v__parser__Parser_parse_type(v__parser__Parser* p);
v__table__Type v__parser__Parser_parse_any_type(v__parser__Parser* p, bool is_c, bool is_js, bool is_ptr);
v__ast__Stmt v__parser__parse_stmt(string text, v__table__Table* table, v__ast__Scope* scope);
v__ast__File v__parser__parse_file(string path, v__table__Table* b_table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref, v__ast__Scope* global_scope);
array_v__ast__File v__parser__parse_files(array_string paths, v__table__Table* table, v__pref__Preferences* pref, v__ast__Scope* global_scope);
void v__parser__Parser_init_parse_fns(v__parser__Parser* p);
void v__parser__Parser_read_first_token(v__parser__Parser* p);
void v__parser__Parser_open_scope(v__parser__Parser* p);
void v__parser__Parser_close_scope(v__parser__Parser* p);
array_v__ast__Stmt v__parser__Parser_parse_block(v__parser__Parser* p);
array_v__ast__Stmt v__parser__Parser_parse_block_no_scope(v__parser__Parser* p);
static void v__parser__Parser_next(v__parser__Parser* p);
static void v__parser__Parser_check(v__parser__Parser* p, v__token__Kind expected);
static string v__parser__Parser_check_name(v__parser__Parser* p);
v__ast__Stmt v__parser__Parser_top_stmt(v__parser__Parser* p);
v__ast__Comment v__parser__Parser_check_comment(v__parser__Parser* p);
v__ast__Comment v__parser__Parser_comment(v__parser__Parser* p);
v__ast__Stmt v__parser__Parser_stmt(v__parser__Parser* p);
static v__ast__Attr v__parser__Parser_attribute(v__parser__Parser* p);
void v__parser__Parser_error(v__parser__Parser* p, string s);
void v__parser__Parser_warn(v__parser__Parser* p, string s);
void v__parser__Parser_error_with_pos(v__parser__Parser* p, string s, v__token__Position pos);
void v__parser__Parser_warn_with_pos(v__parser__Parser* p, string s, v__token__Position pos);
v__ast__Ident v__parser__Parser_parse_ident(v__parser__Parser* p, bool is_c, bool is_js);
v__ast__Expr v__parser__Parser_name_expr(v__parser__Parser* p);
static v__ast__IndexExpr v__parser__Parser_index_expr(v__parser__Parser* p, v__ast__Expr left);
static void v__parser__Parser_scope_register_it(v__parser__Parser* p);
static v__ast__Expr v__parser__Parser_dot_expr(v__parser__Parser* p, v__ast__Expr left);
static v__ast__EnumVal v__parser__Parser_enum_val(v__parser__Parser* p);
static v__ast__Expr v__parser__Parser_string_expr(v__parser__Parser* p);
static v__ast__Expr v__parser__Parser_parse_number_literal(v__parser__Parser* p);
static v__ast__Module v__parser__Parser_module_decl(v__parser__Parser* p);
static v__ast__Import v__parser__Parser_import_stmt(v__parser__Parser* p);
static v__ast__ConstDecl v__parser__Parser_const_decl(v__parser__Parser* p);
static v__ast__Return v__parser__Parser_return_stmt(v__parser__Parser* p);
static v__ast__GlobalDecl v__parser__Parser_global_decl(v__parser__Parser* p);
static v__ast__EnumDecl v__parser__Parser_enum_decl(v__parser__Parser* p);
static v__ast__TypeDecl v__parser__Parser_type_decl(v__parser__Parser* p);
static v__ast__Assoc v__parser__Parser_assoc(v__parser__Parser* p);
static v__ast__Expr v__parser__Parser_new_true_expr(v__parser__Parser* p);
static void v__parser__verror(string s);
v__ast__Expr v__parser__Parser_expr(v__parser__Parser* p, int precedence);
static v__ast__Expr v__parser__Parser_infix_expr(v__parser__Parser* p, v__ast__Expr left);
static v__ast__PrefixExpr v__parser__Parser_prefix_expr(v__parser__Parser* p);
static v__ast__StructDecl v__parser__Parser_struct_decl(v__parser__Parser* p);
static v__ast__StructInit v__parser__Parser_struct_init(v__parser__Parser* p, bool short_syntax);
static v__ast__InterfaceDecl v__parser__Parser_interface_decl(v__parser__Parser* p);
string v__doc__doc(string mod, v__table__Table* table, v__pref__Preferences* prefs);
static string v__doc__Doc_get_fn_node(v__doc__Doc* d, v__ast__FnDecl f);
static void v__doc__Doc_print_fns(v__doc__Doc* d);
static void v__doc__Doc_print_methods(v__doc__Doc* d);
static void v__doc__Doc_write_fn_signatures(v__doc__Doc* d, array_string fn_signatures);
static array_string v__doc__Doc_get_fn_signatures(v__doc__Doc d, v__doc__FilterFn filter_fn);
static bool v__doc__is_pub_method(v__ast__FnDecl node);
static bool v__doc__is_pub_function(v__ast__FnDecl node);
static void v__doc__Doc_print_enums(v__doc__Doc* d);
static void v__doc__Doc_print_structs(v__doc__Doc* d);
v__builder__Builder v__builder__new_builder(v__pref__Preferences* pref);
void v__builder__Builder_parse_imports(v__builder__Builder* b);
void v__builder__Builder_resolve_deps(v__builder__Builder* b);
v__depgraph__DepGraph* v__builder__Builder_import_graph(v__builder__Builder* b);
array_string v__builder__Builder_v_files_from_dir(v__builder__Builder b, string dir);
void v__builder__Builder_log(v__builder__Builder b, string s);
void v__builder__Builder_info(v__builder__Builder b, string s);
static string v__builder__module_path(string mod);
Option_string v__builder__Builder_find_module_path(v__builder__Builder b, string mod, string fpath);
static void v__builder__Builder_print_warnings_and_errors(v__builder__Builder* b);
string v__errors__Reporter_str(v__errors__Reporter it); // auto
static void v__builder__verror(string s);
string v__builder__Builder_gen_c(v__builder__Builder* b, array_string v_files);
void v__builder__Builder_build_c(v__builder__Builder* b, array_string v_files, string out_file);
void v__builder__Builder_compile_c(v__builder__Builder* b);
static void v__builder__todo();
static bool v__builder__Builder_no_cc_installed(v__builder__Builder* v);
static void v__builder__Builder_cc(v__builder__Builder* v);
static void v__builder__Builder_cc_windows_cross(v__builder__Builder* c);
static void v__builder__Builder_build_thirdparty_obj_files(v__builder__Builder* c);
static void v__builder__Builder_build_thirdparty_obj_file(v__builder__Builder* v, string path, array_v__cflag__CFlag moduleflags);
static string v__builder__missing_compiler_info();
static array_string v__builder__error_context_lines(string text, string keyword, int before, int after);
static array_v__cflag__CFlag v__builder__Builder_get_os_cflags(v__builder__Builder* v);
static array_v__cflag__CFlag v__builder__Builder_get_rest_of_module_cflags(v__builder__Builder* v, v__cflag__CFlag* c);
static string v__builder__get_vtmp_folder();
static string v__builder__get_vtmp_filename(string base_file_name, string postfix);
void v__builder__compile(string command, v__pref__Preferences* pref);
static void v__builder__Builder_myfree(v__builder__Builder* b);
static void v__builder__Builder_run_compiled_executable_and_exit(v__builder__Builder* b);
static void v__builder__Builder_set_module_lookup_paths(v__builder__Builder* v);
array_string v__builder__Builder_get_builtin_files(v__builder__Builder v);
array_string v__builder__Builder_get_user_files(v__builder__Builder v);
string v__builder__Builder_gen_js(v__builder__Builder* b, array_string v_files);
void v__builder__Builder_build_js(v__builder__Builder* b, array_string v_files, string out_file);
void v__builder__Builder_compile_js(v__builder__Builder* b);
v__builder__RegKey _const_v__builder__HKEY_LOCAL_MACHINE; // inited later
int _const_v__builder__KEY_QUERY_VALUE; // inited later
int _const_v__builder__KEY_WOW64_32KEY; // inited later
int _const_v__builder__KEY_ENUMERATE_SUB_KEYS; // inited later
static Option_string v__builder__find_windows_kit_internal(v__builder__RegKey key, array_string versions);
static Option_v__builder__WindowsKit v__builder__find_windows_kit_root(string host_arch);
static Option_v__builder__VsInstallation v__builder__find_vs(string vswhere_dir, string host_arch);
static Option_v__builder__MsvcResult v__builder__find_msvc();
void v__builder__Builder_cc_msvc(v__builder__Builder* v);
static void v__builder__build_thirdparty_obj_file_with_msvc(string path, array_v__cflag__CFlag moduleflags);
static v__builder__MsvcStringFlags array_v__cflag__CFlag_msvc_string_flags(array_v__cflag__CFlag cflags);
void v__builder__Builder_build_x64(v__builder__Builder* b, array_string v_files, string out_file);
void v__builder__Builder_compile_x64(v__builder__Builder* b);
array_string _const_simple_cmd; // inited later
array_string _const_list_of_flags_that_allow_duplicates; // inited later
array_string _const_list_of_flags_with_param; // inited later
static multi_return_v__pref__Preferences_string parse_args(array_string args);
static void invoke_help_and_exit(array_string remaining);
static void create_symlink();
static void parse_define(v__pref__Preferences* prefs, string define);
// variadic structs
struct varg_voidptr {
	int len;
	voidptr args[0];
};

struct varg_string {
	int len;
	string args[4];
};

struct varg_int {
	int len;
	int args[1];
};



// V profile counters:


// V interface table:


// V gowrappers:


// V hotcode definitions:


// V stringliterals:

// >> string literal consts
void vinit_string_literals(){
	_const_math__bits__overflow_error = tos3("Overflow Error");
	_const_math__bits__divide_error = tos3("Divide Error");
	_const_digit_pairs = tos3("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_os__path_separator = tos3("/");
	_const_time__days_string = tos3("MonTueWedThuFriSatSun");
	_const_time__months_string = tos3("JanFebMarAprMayJunJulAugSepOctNovDec");
	_const_help__unknown_topic = tos3("V Error: Unknown help topic provided. Use `v help` for usage information.");
	_const_v__util__v_version = tos3("0.1.27");
	_const_v__checker__no_pub_in_main_warning = tos3("in module main cannot be declared public");
	_const_v__gen__c_commit_hash_default = tos3("\n#ifndef V_COMMIT_HASH\n#define V_COMMIT_HASH \"@@@\"\n#endif\n\n");
	_const_v__gen__c_current_commit_hash_default = tos3("\n#ifndef V_CURRENT_COMMIT_HASH\n#define V_CURRENT_COMMIT_HASH \"@@@\"\n#endif\n\n");
	_const_v__gen__c_common_macros = tos3("\n#define EMPTY_STRUCT_DECLARATION\n#define EMPTY_STRUCT_INITIALIZATION 0\n// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...\n#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])\n#define TCCSKIP(x) x\n\n#ifdef __TINYC__\n#undef EMPTY_STRUCT_DECLARATION\n#undef EMPTY_STRUCT_INITIALIZATION\n#define EMPTY_STRUCT_DECLARATION char _dummy\n#define EMPTY_STRUCT_INITIALIZATION 0\n#undef EMPTY_ARRAY_OF_ELEMS\n#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])\n#undef TCCSKIP\n#define TCCSKIP(x)\n#include <byteswap.h>\n#endif\n\n// for __offset_of\n#ifndef __offsetof\n#define __offsetof(s,memb) \((size_t)((char *)&((s *)0)->memb - (char *)0))\n#endif\n\n#define OPTION_CAST(x) (x)\n\n#ifndef V64_PRINTFORMAT\n#ifdef PRIx64\n#define V64_PRINTFORMAT \"0x%\"PRIx64\n#elif defined(__WIN32__)\n#define V64_PRINTFORMAT \"0x%I64x\"\n#elif defined(__linux__) && defined(__LP64__)\n#define V64_PRINTFORMAT \"0x%lx\"\n#else\n#define V64_PRINTFORMAT \"0x%llx\"\n#endif\n#endif\n\n");
	_const_v__gen__c_builtin_types = tos3("\n\n//================================== builtin types ================================*/\n\ntypedef int64_t i64;\ntypedef int16_t i16;\ntypedef int8_t i8;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef uint16_t u16;\ntypedef uint8_t byte;\ntypedef uint32_t rune;\ntypedef float f32;\ntypedef double f64;\ntypedef unsigned char* byteptr;\ntypedef void* voidptr;\ntypedef char* charptr;\ntypedef struct array array;\ntypedef struct map map;\ntypedef array array_string;\ntypedef array array_int;\ntypedef array array_byte;\ntypedef array array_f32;\ntypedef array array_f64;\ntypedef array array_u16;\ntypedef array array_u32;\ntypedef array array_u64;\ntypedef map map_int;\ntypedef map map_string;\ntypedef byte array_fixed_byte_300 [300];\ntypedef byte array_fixed_byte_400 [400];\n#ifndef bool\n	typedef int bool;\n	#define true 1\n	#define false 0\n#endif\n\n");
	_const_v__gen__posix_hotcode_definitions_1 = tos3("\nvoid v_bind_live_symbols(void* live_lib){\n    @LOAD_FNS@\n}\n");
	_const_v__gen__windows_hotcode_definitions_1 = tos3("\nvoid v_bind_live_symbols(void* live_lib){\n    @LOAD_FNS@\n}\n");
}
// << string literal consts



// V auto str functions:
string time__FormatTime_str(time__FormatTime it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatTime_hhmm12: return tos3("hhmm12");
		case time__FormatTime_hhmm24: return tos3("hhmm24");
		case time__FormatTime_hhmmss12: return tos3("hhmmss12");
		case time__FormatTime_hhmmss24: return tos3("hhmmss24");
		case time__FormatTime_no_time: return tos3("no_time");
		default: return tos3("unknown enum value");
	}
}
string time__FormatDate_str(time__FormatDate it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatDate_ddmmyy: return tos3("ddmmyy");
		case time__FormatDate_ddmmyyyy: return tos3("ddmmyyyy");
		case time__FormatDate_mmddyy: return tos3("mmddyy");
		case time__FormatDate_mmddyyyy: return tos3("mmddyyyy");
		case time__FormatDate_mmmd: return tos3("mmmd");
		case time__FormatDate_mmmdd: return tos3("mmmdd");
		case time__FormatDate_mmmddyyyy: return tos3("mmmddyyyy");
		case time__FormatDate_no_date: return tos3("no_date");
		case time__FormatDate_yyyymmdd: return tos3("yyyymmdd");
		default: return tos3("unknown enum value");
	}
}
string v__gen__x64__Register_str(v__gen__x64__Register it) { /* gen_str_for_enum */
	switch(it) {
		case v__gen__x64__Register_rax: return tos3("rax");
		case v__gen__x64__Register_rcx: return tos3("rcx");
		case v__gen__x64__Register_rdx: return tos3("rdx");
		case v__gen__x64__Register_rbx: return tos3("rbx");
		case v__gen__x64__Register_rsp: return tos3("rsp");
		case v__gen__x64__Register_rbp: return tos3("rbp");
		case v__gen__x64__Register_rsi: return tos3("rsi");
		case v__gen__x64__Register_rdi: return tos3("rdi");
		case v__gen__x64__Register_eax: return tos3("eax");
		case v__gen__x64__Register_edi: return tos3("edi");
		case v__gen__x64__Register_edx: return tos3("edx");
		case v__gen__x64__Register_r8: return tos3("r8");
		case v__gen__x64__Register_r9: return tos3("r9");
		case v__gen__x64__Register_r10: return tos3("r10");
		case v__gen__x64__Register_r11: return tos3("r11");
		case v__gen__x64__Register_r12: return tos3("r12");
		case v__gen__x64__Register_r13: return tos3("r13");
		case v__gen__x64__Register_r14: return tos3("r14");
		case v__gen__x64__Register_r15: return tos3("r15");
		default: return tos3("unknown enum value");
	}
}
string v__errors__Reporter_str(v__errors__Reporter it) { /* gen_str_for_enum */
	switch(it) {
		case v__errors__Reporter_scanner: return tos3("scanner");
		case v__errors__Reporter_parser: return tos3("parser");
		case v__errors__Reporter_checker: return tos3("checker");
		case v__errors__Reporter_gen: return tos3("gen");
		default: return tos3("unknown enum value");
	}
}


// V out

// >> typeof() support for sum types
char * v_typeof_sumtype_89(int sidx) { /* v.table.TypeInfo */ 
	switch(sidx) {
		case 89: return "v.table.TypeInfo";
		case 79: return "v.table.Alias";
		case 80: return "v.table.Array";
		case 81: return "v.table.ArrayFixed";
		case 82: return "v.table.Enum";
		case 83: return "v.table.FnType";
		case 84: return "v.table.Interface";
		case 85: return "v.table.Map";
		case 86: return "v.table.MultiReturn";
		case 87: return "v.table.Struct";
		case 88: return "v.table.SumType";
		default: return "unknown v.table.TypeInfo";
	}
}
char * v_typeof_sumtype_100(int sidx) { /* v.table.FExpr */ 
	switch(sidx) {
		case 100: return "v.table.FExpr";
		case 3: return "byteptr";
		case 2: return "voidptr";
		default: return "unknown v.table.FExpr";
	}
}
char * v_typeof_sumtype_108(int sidx) { /* v.ast.Stmt */ 
	switch(sidx) {
		case 108: return "v.ast.Stmt";
		case 170: return "v.ast.AssertStmt";
		case 132: return "v.ast.AssignStmt";
		case 178: return "v.ast.Attr";
		case 169: return "v.ast.Block";
		case 171: return "v.ast.BranchStmt";
		case 157: return "v.ast.Comment";
		case 141: return "v.ast.CompIf";
		case 188: return "v.ast.ConstDecl";
		case 173: return "v.ast.DeferStmt";
		case 193: return "v.ast.EnumDecl";
		case 177: return "v.ast.ExprStmt";
		case 111: return "v.ast.FnDecl";
		case 152: return "v.ast.ForCStmt";
		case 153: return "v.ast.ForInStmt";
		case 151: return "v.ast.ForStmt";
		case 192: return "v.ast.GlobalDecl";
		case 174: return "v.ast.GoStmt";
		case 176: return "v.ast.GotoLabel";
		case 175: return "v.ast.GotoStmt";
		case 140: return "v.ast.HashStmt";
		case 165: return "v.ast.Import";
		case 217: return "v.ast.InterfaceDecl";
		case 187: return "v.ast.Module";
		case 191: return "v.ast.Return";
		case 211: return "v.ast.StructDecl";
		case 196: return "v.ast.TypeDecl";
		case 172: return "v.ast.UnsafeStmt";
		default: return "unknown v.ast.Stmt";
	}
}
char * v_typeof_sumtype_133(int sidx) { /* v.ast.Expr */ 
	switch(sidx) {
		case 133: return "v.ast.Expr";
		case 149: return "v.ast.AnonFn";
		case 142: return "v.ast.ArrayInit";
		case 207: return "v.ast.AsCast";
		case 134: return "v.ast.AssignExpr";
		case 200: return "v.ast.Assoc";
		case 201: return "v.ast.BoolLiteral";
		case 144: return "v.ast.CallExpr";
		case 179: return "v.ast.CastExpr";
		case 202: return "v.ast.CharLiteral";
		case 219: return "v.ast.ConcatExpr";
		case 180: return "v.ast.EnumVal";
		case 185: return "v.ast.FloatLiteral";
		case 136: return "v.ast.Ident";
		case 154: return "v.ast.IfExpr";
		case 158: return "v.ast.IfGuardExpr";
		case 135: return "v.ast.IndexExpr";
		case 208: return "v.ast.InfixExpr";
		case 186: return "v.ast.IntegerLiteral";
		case 143: return "v.ast.MapInit";
		case 159: return "v.ast.MatchExpr";
		case 204: return "v.ast.None";
		case 145: return "v.ast.OrExpr";
		case 203: return "v.ast.ParExpr";
		case 209: return "v.ast.PostfixExpr";
		case 210: return "v.ast.PrefixExpr";
		case 181: return "v.ast.RangeExpr";
		case 182: return "v.ast.SelectorExpr";
		case 205: return "v.ast.SizeOf";
		case 184: return "v.ast.StringInterLiteral";
		case 183: return "v.ast.StringLiteral";
		case 214: return "v.ast.StructInit";
		case 162: return "v.ast.Type";
		case 206: return "v.ast.TypeOf";
		default: return "unknown v.ast.Expr";
	}
}
char * v_typeof_sumtype_196(int sidx) { /* v.ast.TypeDecl */ 
	switch(sidx) {
		case 196: return "v.ast.TypeDecl";
		case 199: return "v.ast.AliasTypeDecl";
		case 197: return "v.ast.FnTypeDecl";
		case 198: return "v.ast.SumTypeDecl";
		default: return "unknown v.ast.TypeDecl";
	}
}
char * v_typeof_sumtype_220(int sidx) { /* v.ast.ScopeObject */ 
	switch(sidx) {
		case 220: return "v.ast.ScopeObject";
		case 189: return "v.ast.ConstField";
		case 192: return "v.ast.GlobalDecl";
		case 131: return "v.ast.Var";
		default: return "unknown v.ast.ScopeObject";
	}
}
char * v_typeof_sumtype_222(int sidx) { /* v.ast.IdentInfo */ 
	switch(sidx) {
		case 222: return "v.ast.IdentInfo";
		case 221: return "v.ast.IdentFn";
		case 138: return "v.ast.IdentVar";
		default: return "unknown v.ast.IdentInfo";
	}
}
// << typeof() support for sum types


void _STR_PRINT_ARG(const char *fmt, char** refbufp, int *nbytes, int *memsize, int guess, ...) {
	va_list args;
	va_start(args, guess);
	for(;;) {
		if (guess < *memsize - *nbytes) {
			guess = vsnprintf(*refbufp + *nbytes, *memsize - *nbytes, fmt, args);
			if (guess < *memsize - *nbytes) { // result did fit into buffer
				*nbytes += guess;
				return;
			}
		}
		// increase buffer (somewhat exponentially)
		*memsize += (*memsize + *memsize) / 3 + guess;
		*refbufp = realloc(*refbufp, *memsize);
	}
}

string _STR(const char *fmt, int nfmts, ...) {
	va_list argptr;
	int memsize = 128;
	int nbytes = 0;
	char* buf = malloc(memsize);
	va_start(argptr, nfmts);
	for (int i=0; i<nfmts; i++) {
		int k = strlen(fmt);
		bool is_fspec = false;
		for (int j=0; j<k; j++) {
			if (fmt[j] == '%') {
				j++;
				if (fmt[j] != '%') {
					is_fspec = true;
					break;
				}
			}
		}
		if (is_fspec) {
			char f = fmt[k-1];
			char fup = f & 0xdf; // toupper
			bool l = fmt[k-2] == 'l';
			bool ll = l && fmt[k-3] == 'l';
			if (f == 'u' || fup == 'X' || f == 'o' || f == 'd' || f == 'c') { // int...
				if (ll) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+16, va_arg(argptr, long long));
				else if (l) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, long));
				else _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+8, va_arg(argptr, int));
			} else if (fup >= 'E' && fup <= 'G') { // floating point
				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, double));
			} else if (f == 'p') {
				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+14, va_arg(argptr, void*));
			} else if (f == 's') { // v string
				string s = va_arg(argptr, string);
				if (fmt[k-4] == '*') { // %*.*s
					int fwidth = va_arg(argptr, int);
					if (fwidth < 0)
						fwidth -= (s.len - utf8_str_visible_length(s));
					else
						fwidth += (s.len - utf8_str_visible_length(s));
					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+fwidth-4, fwidth, s.len, s.str);
				} else { // %.*s
					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+s.len-4, s.len, s.str);
				}
			} else {
				//v_panic(tos3('Invaid format specifier'));
			}
		} else {
			_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k);
		}
		fmt += k+1;
	}
	va_end(argptr);
	buf[nbytes] = 0;
	buf = realloc(buf, nbytes+1);
#ifdef DEBUG_ALLOC
	//puts('_STR:');
	puts(buf);
#endif
	return tos2(buf);
}

string _STR_TMP(const char *fmt, ...) {
	va_list argptr;
	va_start(argptr, fmt);
	//size_t len = vsnprintf(0, 0, fmt, argptr) + 1;
	va_end(argptr);
	va_start(argptr, fmt);
	vsprintf((char *)g_str_buf, fmt, argptr);
	va_end(argptr);
#ifdef DEBUG_ALLOC
	//puts('_STR_TMP:');
	//puts(g_str_buf);
#endif
	return tos2(g_str_buf);
} // endof _STR_TMP


strings__Builder strings__new_builder(int initial_size) {
	return (strings__Builder){
		.buf = __new_array(0, initial_size, sizeof(byte)),
		.initial_size = initial_size,
		.str_calls = 0,
		.len = 0,
	};
}

void strings__Builder_write_bytes(strings__Builder* b, byteptr bytes, int howmany) {
	array_push_many(&b->buf, bytes, howmany);
	b->len += howmany;
}

void strings__Builder_write_b(strings__Builder* b, byte data) {
	array_push(&b->buf, &(byte[]){ data });
	b->len++;
}

void strings__Builder_write(strings__Builder* b, string s) {
	if (string_eq(s, tos3(""))) {
		return ;
	}
	array_push_many(&b->buf, s.str, s.len);
	b->len += s.len;
}

void strings__Builder_go_back(strings__Builder* b, int n) {
	array_trim(&b->buf, b->buf.len - n);
	b->len -= n;
}

void strings__Builder_go_back_to(strings__Builder* b, int pos) {
	array_trim(&b->buf, pos);
	b->len = pos;
}

void strings__Builder_writeln(strings__Builder* b, string s) {
	array_push_many(&b->buf, s.str, s.len);
	array_push(&b->buf, &(byte[]){ '\n' });
	b->len += s.len + 1;
}

string strings__Builder_last_n(strings__Builder* b, int n) {
	if (n > b->len) {
		return tos3("");
	}
	array_byte buf = array_slice(b->buf, b->len - n, b->buf.len);
	return tos2(array_clone(&buf).data);
}

string strings__Builder_after(strings__Builder* b, int n) {
	if (n >= b->len) {
		return tos3("");
	}
	array_byte buf = array_slice(b->buf, n, b->buf.len);
	array_byte copy = array_clone(&buf);
	array_push(&copy, &(byte[]){ '\0' });
	return tos2(copy.data);
}

string strings__Builder_str(strings__Builder* b) {
	b->str_calls++;
	if (b->str_calls > 1) {
		v_panic(string_add(tos3("builder.str() should be called just once.\n"), tos3("If you want to reuse a builder, call b.free() first.")));
	}
	array_push(&b->buf, &(byte[]){ '\0' });
	string s = tos(b->buf.data, b->len);
	int bis = b->initial_size;
	b->buf = __new_array(0, bis, sizeof(byte));
	b->len = 0;
	return s;
}

void strings__Builder_free(strings__Builder* b) {
		v_free(b->buf.data);
	b->len = 0;
	b->str_calls = 0;
}

int strings__levenshtein_distance(string a, string b) {
	array_int f = array_repeat(new_array_from_c_array(1, 1, sizeof(int), (int[1]){
		0, 
}), b.len + 1);
	for (int tmp1 = 0; tmp1 < f.len; tmp1++) {
		int j = tmp1;
		array_set(&f, j, &(int[]) { j });
	}
	for (int tmp2 = 0; tmp2 < a.len; tmp2++) {
	byte ca = a.str[tmp2];
		int j = 1;
		int fj1 = (*(int*)array_get(f, 0));
		(*(int*)array_get(f, 0))++;
		for (int tmp3 = 0; tmp3 < b.len; tmp3++) {
		byte cb = b.str[tmp3];
			int mn = ((*(int*)array_get(f, j)) + 1 <= (*(int*)array_get(f, j - 1)) + 1 ?  ( (*(int*)array_get(f, j)) + 1 )  :  ( (*(int*)array_get(f, j - 1)) + 1 ) );
			if (cb != ca) {
				mn = (mn <= fj1 + 1 ?  ( mn )  :  ( fj1 + 1 ) );
			} else {
				mn = (mn <= fj1 ?  ( mn )  :  ( fj1 ) );
			}
			fj1 = (*(int*)array_get(f, j));
			array_set(&f, j, &(int[]) { mn });
			j++;
		}
	}
	return (*(int*)array_get(f, f.len - 1));
}

f32 strings__levenshtein_distance_percentage(string a, string b) {
	int d = strings__levenshtein_distance(a, b);
	int l = (a.len >= b.len ?  ( a.len )  :  ( b.len ) );
	return (1.00 - ((f32)(d)) / ((f32)(l))) * 100.00;
}

f32 strings__dice_coefficient(string s1, string s2) {
	if (s1.len == 0 || s2.len == 0) {
		return 0.0;
	}
	if (string_eq(s1, s2)) {
		return 1.0;
	}
	if (s1.len < 2 || s2.len < 2) {
		return 0.0;
	}
	string a = (s1.len > s2.len ?  ( s1 )  :  ( s2 ) );
	string b = (string_eq(a, s1) ?  ( s2 )  :  ( s1 ) );
	map_string_int first_bigrams = new_map_1(sizeof(int));
	for (int tmp6 = 0; tmp6 < a.len - 1; tmp6++) {
		int i = tmp6;
		string bigram = string_substr(a, i, i + 2);
		int q = (_IN_MAP(bigram, first_bigrams) ?  ( (*(int*)map_get3(first_bigrams, bigram, &(int[]){ 0 })) + 1 )  :  ( 1 ) );
		map_set(&first_bigrams, bigram, &(int[]) { q });
	}
	int intersection_size = 0;
	for (int tmp8 = 0; tmp8 < b.len - 1; tmp8++) {
		int i = tmp8;
		string bigram = string_substr(b, i, i + 2);
		int count = (_IN_MAP(bigram, first_bigrams) ?  ( (*(int*)map_get3(first_bigrams, bigram, &(int[]){ 0 })) )  :  ( 0 ) );
		if (count > 0) {
			map_set(&first_bigrams, bigram, &(int[]) { count - 1 });
			intersection_size++;
		}
	}
	return (2.0 * intersection_size) / (((f32)(a.len)) + ((f32)(b.len)) - 2);
}

string strings__repeat(byte c, int n) {
	if (n <= 0) {
		return tos3("");
	}
	byte* bytes = ((byte*)(0));
		bytes = v_malloc(n + 1);
	memset(bytes, c, n);
	bytes[n] = '0';
	return tos(bytes, n);
}

string strings__repeat_string(string s, int n) {
	if (n <= 0 || s.len == 0) {
		return tos3("");
	}
	int slen = s.len;
	int blen = slen * n;
	byte* bytes = ((byte*)(0));
		bytes = v_malloc(blen + 1);
	for (int tmp2 = 0; tmp2 < n; tmp2++) {
		int bi = tmp2;
		int bislen = bi * slen;
		for (int tmp3 = 0; tmp3 < slen; tmp3++) {
			int si = tmp3;
			bytes[bislen + si] = string_at(s, si);
		}
	}
	bytes[blen] = '0';
	return tos(bytes, blen);
}

u64 hash__wyhash__rand_u64(u64* seed) {
	u64* seed0 = seed;
		u64 seed1 = *seed0;
		seed1 += _const_hash__wyhash__wyp0;
		*seed0 = seed1;
		return hash__wyhash__wymum((seed1 ^ _const_hash__wyhash__wyp1), seed1);
	return 0;
}


// Attr: [inline]
inline u64 hash__wyhash__wyhash_c(byteptr key, u64 len, u64 seed) {
	return wyhash(key, len, seed);
}

// Attr: [inline]
inline u64 hash__wyhash__sum64_string(string key, u64 seed) {
	return hash__wyhash__wyhash64(key.str, ((u64)(key.len)), seed);
}

// Attr: [inline]
inline u64 hash__wyhash__sum64(array_byte key, u64 seed) {
	return hash__wyhash__wyhash64(key.data, ((u64)(key.len)), seed);
}

// Attr: [inline]
inline static u64 hash__wyhash__wyhash64(byteptr key, u64 len, u64 seed_) {
	if (len == 0) {
		return 0;
	}
	byte* p = &key[0];
	u64 seed = seed_;
	u64 i = (len & 63);
	if (i < 4) {
		seed = hash__wyhash__wymum(((hash__wyhash__wyr3(p, i) ^ seed) ^ _const_hash__wyhash__wyp0), (seed ^ _const_hash__wyhash__wyp1));
	} else if (i <= 8) {
		seed = hash__wyhash__wymum(((hash__wyhash__wyr4(p) ^ seed) ^ _const_hash__wyhash__wyp0), ((hash__wyhash__wyr4(p + i - 4) ^ seed) ^ _const_hash__wyhash__wyp1));
	} else if (i <= 16) {
		seed = hash__wyhash__wymum(((hash__wyhash__wyr8(p) ^ seed) ^ _const_hash__wyhash__wyp0), ((hash__wyhash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyhash__wyp1));
	} else if (i <= 24) {
		seed = (hash__wyhash__wymum(((hash__wyhash__wyr8(p) ^ seed) ^ _const_hash__wyhash__wyp0), ((hash__wyhash__wyr8(p + 8) ^ seed) ^ _const_hash__wyhash__wyp1)) ^ hash__wyhash__wymum(((hash__wyhash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyhash__wyp2), (seed ^ _const_hash__wyhash__wyp3)));
	} else if (i <= 32) {
		seed = (hash__wyhash__wymum(((hash__wyhash__wyr8(p) ^ seed) ^ _const_hash__wyhash__wyp0), ((hash__wyhash__wyr8(p + 8) ^ seed) ^ _const_hash__wyhash__wyp1)) ^ hash__wyhash__wymum(((hash__wyhash__wyr8(p + 16) ^ seed) ^ _const_hash__wyhash__wyp2), ((hash__wyhash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyhash__wyp3)));
	} else {
		seed = (((hash__wyhash__wymum(((hash__wyhash__wyr8(p) ^ seed) ^ _const_hash__wyhash__wyp0), ((hash__wyhash__wyr8(p + 8) ^ seed) ^ _const_hash__wyhash__wyp1)) ^ hash__wyhash__wymum(((hash__wyhash__wyr8(p + 16) ^ seed) ^ _const_hash__wyhash__wyp2), ((hash__wyhash__wyr8(p + 24) ^ seed) ^ _const_hash__wyhash__wyp3))) ^ hash__wyhash__wymum(((hash__wyhash__wyr8(p + i - 32) ^ seed) ^ _const_hash__wyhash__wyp1), ((hash__wyhash__wyr8(p + i - 24) ^ seed) ^ _const_hash__wyhash__wyp2))) ^ hash__wyhash__wymum(((hash__wyhash__wyr8(p + i - 16) ^ seed) ^ _const_hash__wyhash__wyp3), ((hash__wyhash__wyr8(p + i - 8) ^ seed) ^ _const_hash__wyhash__wyp0)));
	}
	if (i == len) {
		return hash__wyhash__wymum(seed, (len ^ _const_hash__wyhash__wyp4));
	}
	u64 see1 = seed;
	u64 see2 = seed;
	u64 see3 = seed;
	p = p + i;
	for (i = len - i;
	i >= 64; i -= 64) {
		seed = hash__wyhash__wymum(((hash__wyhash__wyr8(p) ^ seed) ^ _const_hash__wyhash__wyp0), ((hash__wyhash__wyr8(p + 8) ^ seed) ^ _const_hash__wyhash__wyp1));
		see1 = hash__wyhash__wymum(((hash__wyhash__wyr8(p + 16) ^ see1) ^ _const_hash__wyhash__wyp2), ((hash__wyhash__wyr8(p + 24) ^ see1) ^ _const_hash__wyhash__wyp3));
		see2 = hash__wyhash__wymum(((hash__wyhash__wyr8(p + 32) ^ see2) ^ _const_hash__wyhash__wyp1), ((hash__wyhash__wyr8(p + 40) ^ see2) ^ _const_hash__wyhash__wyp2));
		see3 = hash__wyhash__wymum(((hash__wyhash__wyr8(p + 48) ^ see3) ^ _const_hash__wyhash__wyp3), ((hash__wyhash__wyr8(p + 56) ^ see3) ^ _const_hash__wyhash__wyp0));
		p = p + 64;
	}
	return hash__wyhash__wymum(((seed ^ see1) ^ see2), ((see3 ^ len) ^ _const_hash__wyhash__wyp4));
}

// Attr: [inline]
inline static u64 hash__wyhash__wyrotr(u64 v, u32 k) {
	return ((v >> k) | (v << (64 - k)));
}

// Attr: [inline]
inline static u64 hash__wyhash__wymum(u64 a, u64 b) {
	u32 mask32 = ((u32)(4294967295));
	u64 x0 = (a & mask32);
	u64 x1 = a >> 32;
	u64 y0 = (b & mask32);
	u64 y1 = b >> 32;
	u64 w0 = x0 * y0;
	u64 t = x1 * y0 + (w0 >> 32);
	u64 w1 = (t & mask32);
	u64 w2 = t >> 32;
	w1 += x0 * y1;
	u64 hi = x1 * y1 + w2 + (w1 >> 32);
	u64 lo = a * b;
	return (hi ^ lo);
}

// Attr: [inline]
inline static u64 hash__wyhash__wyr3(byteptr p, u64 k) {
	return (((((u64)(p[0])) << 16) | (((u64)(p[k >> 1])) << 8)) | ((u64)(p[k - 1])));
}

// Attr: [inline]
inline static u64 hash__wyhash__wyr4(byteptr p) {
	return (((((u32)(p[0])) | (((u32)(p[1])) << ((u32)(8)))) | (((u32)(p[2])) << ((u32)(16)))) | (((u32)(p[3])) << ((u32)(24))));
}

// Attr: [inline]
inline static u64 hash__wyhash__wyr8(byteptr p) {
	return (((((((((u64)(p[0])) | (((u64)(p[1])) << 8)) | (((u64)(p[2])) << 16)) | (((u64)(p[3])) << 24)) | (((u64)(p[4])) << 32)) | (((u64)(p[5])) << 40)) | (((u64)(p[6])) << 48)) | (((u64)(p[7])) << 56));
}

int math__bits__leading_zeros_8(byte x) {
	return 8 - math__bits__len_8(x);
}

int math__bits__leading_zeros_16(u16 x) {
	return 16 - math__bits__len_16(x);
}

int math__bits__leading_zeros_32(u32 x) {
	return 32 - math__bits__len_32(x);
}

int math__bits__leading_zeros_64(u64 x) {
	return 64 - math__bits__len_64(x);
}

int math__bits__trailing_zeros_8(byte x) {
	return ((int)((*(byte*)array_get(_const_math__bits__ntz_8_tab, x))));
}

int math__bits__trailing_zeros_16(u16 x) {
	if (x == 0) {
		return 16;
	}
	return ((int)((*(byte*)array_get(_const_math__bits__de_bruijn32tab, ((u32)((x & -x))) * _const_math__bits__de_bruijn32 >> (32 - 5)))));
}

int math__bits__trailing_zeros_32(u32 x) {
	if (x == 0) {
		return 32;
	}
	return ((int)((*(byte*)array_get(_const_math__bits__de_bruijn32tab, ((x & -x)) * _const_math__bits__de_bruijn32 >> (32 - 5)))));
}

int math__bits__trailing_zeros_64(u64 x) {
	if (x == 0) {
		return 64;
	}
	return ((int)((*(byte*)array_get(_const_math__bits__de_bruijn64tab, ((x & -x)) * _const_math__bits__de_bruijn64 >> (64 - 6)))));
}

int math__bits__ones_count_8(byte x) {
	return ((int)((*(byte*)array_get(_const_math__bits__pop_8_tab, x))));
}

int math__bits__ones_count_16(u16 x) {
	return ((int)((*(byte*)array_get(_const_math__bits__pop_8_tab, x >> 8)) + (*(byte*)array_get(_const_math__bits__pop_8_tab, (x & ((u16)(0xff)))))));
}

int math__bits__ones_count_32(u32 x) {
	return ((int)((*(byte*)array_get(_const_math__bits__pop_8_tab, x >> 24)) + (*(byte*)array_get(_const_math__bits__pop_8_tab, (x >> 16 & 0xff))) + (*(byte*)array_get(_const_math__bits__pop_8_tab, (x >> 8 & 0xff))) + (*(byte*)array_get(_const_math__bits__pop_8_tab, (x & ((u32)(0xff)))))));
}

int math__bits__ones_count_64(u64 x) {
	u64 y = ((x >> ((u64)(1)) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) + ((x & ((_const_math__bits__m0 & _const_math__bits__max_u64))));
	y = ((y >> ((u64)(2)) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) + ((y & ((_const_math__bits__m1 & _const_math__bits__max_u64))));
	y = (((y >> 4) + y) & ((_const_math__bits__m2 & _const_math__bits__max_u64)));
	y += y >> 8;
	y += y >> 16;
	y += y >> 32;
	return (((int)(y)) & ((1 << 7) - 1));
}

// Attr: [inline]
inline byte math__bits__rotate_left_8(byte x, int k) {
	byte n = ((byte)(8));
	byte s = (((byte)(k)) & (n - ((byte)(1))));
	return (((x << s) | (x >> (n - s))));
}

// Attr: [inline]
inline u16 math__bits__rotate_left_16(u16 x, int k) {
	u16 n = ((u16)(16));
	u16 s = (((u16)(k)) & (n - ((u16)(1))));
	return (((x << s) | (x >> (n - s))));
}

// Attr: [inline]
inline u32 math__bits__rotate_left_32(u32 x, int k) {
	u32 n = ((u32)(32));
	u32 s = (((u32)(k)) & (n - ((u32)(1))));
	return (((x << s) | (x >> (n - s))));
}

// Attr: [inline]
inline u64 math__bits__rotate_left_64(u64 x, int k) {
	u64 n = ((u64)(64));
	u64 s = (((u64)(k)) & (n - ((u64)(1))));
	return (((x << s) | (x >> (n - s))));
}

// Attr: [inline]
inline byte math__bits__reverse_8(byte x) {
	return (*(byte*)array_get(_const_math__bits__rev_8_tab, x));
}

// Attr: [inline]
inline u16 math__bits__reverse_16(u16 x) {
	return (((u16)((*(byte*)array_get(_const_math__bits__rev_8_tab, x >> 8)))) | (((u16)((*(byte*)array_get(_const_math__bits__rev_8_tab, (x & ((u16)(0xff))))))) << 8));
}

// Attr: [inline]
inline u32 math__bits__reverse_32(u32 x) {
	u32 y = ((((x >> ((u32)(1)) & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) | (((x & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) << 1)));
	y = ((((y >> ((u32)(2)) & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) | (((y & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) << ((u32)(2)))));
	y = ((((y >> ((u32)(4)) & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) | (((y & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) << ((u32)(4)))));
	return math__bits__reverse_bytes_32(y);
}

// Attr: [inline]
inline u64 math__bits__reverse_64(u64 x) {
	u64 y = ((((x >> ((u64)(1)) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) | (((x & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) << 1)));
	y = ((((y >> ((u64)(2)) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) << 2)));
	y = ((((y >> ((u64)(4)) & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) << 4)));
	return math__bits__reverse_bytes_64(y);
}

// Attr: [inline]
inline u16 math__bits__reverse_bytes_16(u16 x) {
	return ((x >> 8) | (x << 8));
}

// Attr: [inline]
inline u32 math__bits__reverse_bytes_32(u32 x) {
	u32 y = ((((x >> ((u32)(8)) & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) | (((x & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) << ((u32)(8)))));
	return ((y >> 16) | (y << 16));
}

// Attr: [inline]
inline u64 math__bits__reverse_bytes_64(u64 x) {
	u64 y = ((((x >> ((u64)(8)) & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) | (((x & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) << ((u64)(8)))));
	y = ((((y >> ((u64)(16)) & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) << ((u64)(16)))));
	return ((y >> 32) | (y << 32));
}

int math__bits__len_8(byte x) {
	return ((int)((*(byte*)array_get(_const_math__bits__len_8_tab, x))));
}

int math__bits__len_16(u16 x) {
	u16 y = x;
	int n = 0;
	if (y >= 1 << 8) {
		y >>= 8;
		n = 8;
	}
	return n + ((int)((*(byte*)array_get(_const_math__bits__len_8_tab, y))));
}

int math__bits__len_32(u32 x) {
	u32 y = x;
	int n = 0;
	if (y >= (1 << 16)) {
		y >>= 16;
		n = 16;
	}
	if (y >= (1 << 8)) {
		y >>= 8;
		n += 8;
	}
	return n + ((int)((*(byte*)array_get(_const_math__bits__len_8_tab, y))));
}

int math__bits__len_64(u64 x) {
	u64 y = x;
	int n = 0;
	if (y >= ((u64)(1)) << ((u64)(32))) {
		y >>= 32;
		n = 32;
	}
	if (y >= ((u64)(1)) << ((u64)(16))) {
		y >>= 16;
		n += 16;
	}
	if (y >= ((u64)(1)) << ((u64)(8))) {
		y >>= 8;
		n += 8;
	}
	return n + ((int)((*(byte*)array_get(_const_math__bits__len_8_tab, y))));
}

multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry) {
	u64 sum64 = ((u64)(x)) + ((u64)(y)) + ((u64)(carry));
	u32 sum = ((u32)(sum64));
	u32 carry_out = ((u32)(sum64 >> 32));
	return (multi_return_u32_u32){.arg0=sum,.arg1=carry_out};
}

multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry) {
	u64 sum = x + y + carry;
	u64 carry_out = ((((x & y)) | ((((x | y)) & ~sum)))) >> 63;
	return (multi_return_u64_u64){.arg0=sum,.arg1=carry_out};
}

multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow) {
	u32 diff = x - y - borrow;
	u32 borrow_out = ((((~x & y)) | ((~((x ^ y)) & diff)))) >> 31;
	return (multi_return_u32_u32){.arg0=diff,.arg1=borrow_out};
}

multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow) {
	u64 diff = x - y - borrow;
	u64 borrow_out = ((((~x & y)) | ((~((x ^ y)) & diff)))) >> 63;
	return (multi_return_u64_u64){.arg0=diff,.arg1=borrow_out};
}

multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y) {
	u64 tmp = ((u64)(x)) * ((u64)(y));
	u32 hi = ((u32)(tmp >> 32));
	u32 lo = ((u32)(tmp));
	return (multi_return_u32_u32){.arg0=hi,.arg1=lo};
}

multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y) {
	u64 x0 = (x & _const_math__bits__mask32);
	u64 x1 = x >> 32;
	u64 y0 = (y & _const_math__bits__mask32);
	u64 y1 = y >> 32;
	u64 w0 = x0 * y0;
	u64 t = x1 * y0 + (w0 >> 32);
	u64 w1 = (t & _const_math__bits__mask32);
	u64 w2 = t >> 32;
	w1 += x0 * y1;
	u64 hi = x1 * y1 + w2 + (w1 >> 32);
	u64 lo = x * y;
	return (multi_return_u64_u64){.arg0=hi,.arg1=lo};
}

multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y) {
	if (y != 0 && y <= hi) {
		v_panic(_const_math__bits__overflow_error);
	}
	u64 z = ((((u64)(hi)) << 32) | ((u64)(lo)));
	u32 quo = ((u32)(z / ((u64)(y))));
	u32 rem = ((u32)(z % ((u64)(y))));
	return (multi_return_u32_u32){.arg0=quo,.arg1=rem};
}

multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1) {
	u64 y = y1;
	if (y == 0) {
		v_panic(_const_math__bits__overflow_error);
	}
	if (y <= hi) {
		v_panic(_const_math__bits__overflow_error);
	}
	u32 s = ((u32)(math__bits__leading_zeros_64(y)));
	y <<= s;
	u64 yn1 = y >> 32;
	u64 yn0 = (y & _const_math__bits__mask32);
	u64 un32 = ((hi << s) | (lo >> (64 - s)));
	u64 un10 = lo << s;
	u64 un1 = un10 >> 32;
	u64 un0 = (un10 & _const_math__bits__mask32);
	u64 q1 = un32 / yn1;
	u64 rhat = un32 - q1 * yn1;
	while (q1 >= _const_math__bits__two32 || q1 * yn0 > _const_math__bits__two32 * rhat + un1) {
		q1--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	u64 un21 = un32 * _const_math__bits__two32 + un1 - q1 * y;
	u64 q0 = un21 / yn1;
	rhat = un21 - q0 * yn1;
	while (q0 >= _const_math__bits__two32 || q0 * yn0 > _const_math__bits__two32 * rhat + un0) {
		q0--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	return (multi_return_u64_u64){.arg0=q1 * _const_math__bits__two32 + q0,.arg1=(un21 * _const_math__bits__two32 + un0 - q0 * y) >> s};
}

u32 math__bits__rem_32(u32 hi, u32 lo, u32 y) {
	return ((u32)((((((u64)(hi)) << 32) | ((u64)(lo)))) % ((u64)(y))));
}

u64 math__bits__rem_64(u64 hi, u64 lo, u64 y) {
	multi_return_u64_u64 mr_15079 = math__bits__div_64(hi % y, lo, y);
	u64 rem = mr_15079.arg1;
	return rem;
}

static string strconv__ftoa__Dec32_get_string_32(strconv__ftoa__Dec32 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = i_n_digit + 1;
	int pad_digit = i_pad_digit + 1;
	u32 out = d.m;
	int out_len = strconv__ftoa__decimal_len_32(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = pad_digit - out_len;
	}
	array_byte buf = array_repeat(new_array_from_c_array(1, 1, sizeof(byte), (byte[1]){
		((byte)(0)), 
}), out_len + 5 + 1 + 1);
	int i = 0;
	if (neg) {
		array_set(&buf, i, &(byte[]) { '-' });
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (*(u32*)array_get(_const_strconv__ftoa__ten_pow_table_32, out_len - n_digit - 1)) * 5;
		out /= (*(u32*)array_get(_const_strconv__ftoa__ten_pow_table_32, out_len - n_digit));
		out_len = n_digit;
	}
	int y = i + out_len;
	int x = 0;
	while (x < (out_len - disp - 1)) {
		array_set(&buf, y - x, &(byte[]) { '0' + ((byte)(out % 10)) });
		out /= 10;
		i++;
		x++;
	}
	if (out_len >= 1) {
		array_set(&buf, y - x, &(byte[]) { '.' });
		x++;
		i++;
	}
	if (y - x >= 0) {
		array_set(&buf, y - x, &(byte[]) { '0' + ((byte)(out % 10)) });
		i++;
	}
	while (fw_zeros > 0) {
		array_set(&buf, i++, &(byte[]) { '0' });
		fw_zeros--;
	}
	array_set(&buf, i, &(byte[]) { 'e' });
	i++;
	int exp = d.e + out_len_original - 1;
	if (exp < 0) {
		array_set(&buf, i, &(byte[]) { '-' });
		i++;
		exp = -exp;
	} else {
		array_set(&buf, i, &(byte[]) { '+' });
		i++;
	}
	int d1 = exp % 10;
	int d0 = exp / 10;
	array_set(&buf, i, &(byte[]) { '0' + ((byte)(d0)) });
	i++;
	array_set(&buf, i, &(byte[]) { '0' + ((byte)(d1)) });
	i++;
	array_set(&buf, i, &(byte[]) { 0 });
	return tos(((byteptr)(&(*(byte*)array_get(buf, 0)))), i);
}

static multi_return_strconv__ftoa__Dec32_bool strconv__ftoa__f32_to_decimal_exact_int(u32 i_mant, u32 exp) {
	strconv__ftoa__Dec32 d = (strconv__ftoa__Dec32){
		.m = 0,
		.e = 0,
	};
	u32 e = exp - _const_strconv__ftoa__bias32;
	if (e > _const_strconv__ftoa__mantbits32) {
		return (multi_return_strconv__ftoa__Dec32_bool){.arg0=d,.arg1=false};
	}
	u32 shift = _const_strconv__ftoa__mantbits32 - e;
	u32 mant = (i_mant | 0x00800000);
	d.m = mant >> shift;
	if ((d.m << shift) != mant) {
		return (multi_return_strconv__ftoa__Dec32_bool){.arg0=d,.arg1=false};
	}
	while ((d.m % 10) == 0) {
		d.m /= 10;
		d.e++;
	}
	return (multi_return_strconv__ftoa__Dec32_bool){.arg0=d,.arg1=true};
}

strconv__ftoa__Dec32 strconv__ftoa__f32_to_decimal(u32 mant, u32 exp) {
	int e2 = 0;
	u32 m2 = ((u32)(0));
	if (exp == 0) {
		e2 = 1 - _const_strconv__ftoa__bias32 - _const_strconv__ftoa__mantbits32 - 2;
		m2 = mant;
	} else {
		e2 = ((int)(exp)) - _const_strconv__ftoa__bias32 - _const_strconv__ftoa__mantbits32 - 2;
		m2 = ((((u32)(1)) << _const_strconv__ftoa__mantbits32) | mant);
	}
	bool even = ((m2 & 1)) == 0;
	bool accept_bounds = even;
	u32 mv = ((u32)(4 * m2));
	u32 mp = ((u32)(4 * m2 + 2));
	u32 mm_shift = strconv__ftoa__bool_to_u32(mant != 0 || exp <= 1);
	u32 mm = ((u32)(4 * m2 - 1 - mm_shift));
	u32 vr = ((u32)(0));
	u32 vp = ((u32)(0));
	u32 vm = ((u32)(0));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	byte last_removed_digit = ((byte)(0));
	if (e2 >= 0) {
		u32 q = strconv__ftoa__log10_pow2(e2);
		e10 = ((int)(q));
		int k = _const_strconv__ftoa__pow5_inv_num_bits_32 + strconv__ftoa__pow5_bits(((int)(q))) - 1;
		int i = -e2 + ((int)(q)) + k;
		vr = strconv__ftoa__mul_pow5_invdiv_pow2(mv, q, i);
		vp = strconv__ftoa__mul_pow5_invdiv_pow2(mp, q, i);
		vm = strconv__ftoa__mul_pow5_invdiv_pow2(mm, q, i);
		if (q != 0 && (vp - 1) / 10 <= vm / 10) {
			int l = _const_strconv__ftoa__pow5_inv_num_bits_32 + strconv__ftoa__pow5_bits(((int)(q - 1))) - 1;
			last_removed_digit = ((byte)(strconv__ftoa__mul_pow5_invdiv_pow2(mv, q - 1, -e2 + ((int)(q - 1)) + l) % 10));
		}
		if (q <= 9) {
			if (mv % 5 == 0) {
				vr_is_trailing_zeros = strconv__ftoa__multiple_of_power_of_five_32(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__ftoa__multiple_of_power_of_five_32(mm, q);
			} else if (strconv__ftoa__multiple_of_power_of_five_32(mp, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__ftoa__log10_pow5(-e2);
		e10 = ((int)(q)) + e2;
		int i = -e2 - ((int)(q));
		int k = strconv__ftoa__pow5_bits(i) - _const_strconv__ftoa__pow5_num_bits_32;
		int j = ((int)(q)) - k;
		vr = strconv__ftoa__mul_pow5_div_pow2(mv, ((u32)(i)), j);
		vp = strconv__ftoa__mul_pow5_div_pow2(mp, ((u32)(i)), j);
		vm = strconv__ftoa__mul_pow5_div_pow2(mm, ((u32)(i)), j);
		if (q != 0 && ((vp - 1) / 10) <= vm / 10) {
			j = ((int)(q)) - 1 - (strconv__ftoa__pow5_bits(i + 1) - _const_strconv__ftoa__pow5_num_bits_32);
			last_removed_digit = ((byte)(strconv__ftoa__mul_pow5_div_pow2(mv, ((u32)(i + 1)), j) % 10));
		}
		if (q <= 1) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = mm_shift == 1;
			} else {
				vp--;
			}
		} else if (q < 31) {
			vr_is_trailing_zeros = strconv__ftoa__multiple_of_power_of_two_32(mv, q - 1);
		}
	}
	int removed = 0;
	u32 out = ((u32)(0));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		while (vp / 10 > vm / 10) {
			vm_is_trailing_zeros = vm_is_trailing_zeros && (vm % 10) == 0;
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
			last_removed_digit = ((byte)(vr % 10));
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			while (vm % 10 == 0) {
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
				last_removed_digit = ((byte)(vr % 10));
				vr /= 10;
				vp /= 10;
				vm /= 10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2) == 0) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		while (vp / 10 > vm / 10) {
			last_removed_digit = ((byte)(vr % 10));
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		out = vr + strconv__ftoa__bool_to_u32(vr == vm || last_removed_digit >= 5);
	}
	return (strconv__ftoa__Dec32){
		.m = out,
		.e = e10 + removed,
	};
}

string strconv__ftoa__f32_to_str(f32 f, int n_digit) {
	strconv__ftoa__Uf32 u1 = (strconv__ftoa__Uf32){
		.f = 0,
		.u = 0,
	};
	u1.f = f;
	u32 u = u1.u;
	bool neg = (u >> (_const_strconv__ftoa__mantbits32 + _const_strconv__ftoa__expbits32)) != 0;
	u32 mant = (u & ((((u32)(1)) << _const_strconv__ftoa__mantbits32) - ((u32)(1))));
	u32 exp = ((u >> _const_strconv__ftoa__mantbits32) & ((((u32)(1)) << _const_strconv__ftoa__expbits32) - ((u32)(1))));
	if ((exp == _const_strconv__ftoa__maxexp32) || (exp == 0 && mant == 0)) {
		return strconv__ftoa__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__ftoa__Dec32_bool mr_8459 = strconv__ftoa__f32_to_decimal_exact_int(mant, exp);
	strconv__ftoa__Dec32 d = mr_8459.arg0;
	bool ok = mr_8459.arg1;
	if (!ok) {
		d = strconv__ftoa__f32_to_decimal(mant, exp);
	}
	return strconv__ftoa__Dec32_get_string_32(d, neg, n_digit, 0);
}

string strconv__ftoa__f32_to_str_pad(f32 f, int n_digit) {
	strconv__ftoa__Uf32 u1 = (strconv__ftoa__Uf32){
		.f = 0,
		.u = 0,
	};
	u1.f = f;
	u32 u = u1.u;
	bool neg = (u >> (_const_strconv__ftoa__mantbits32 + _const_strconv__ftoa__expbits32)) != 0;
	u32 mant = (u & ((((u32)(1)) << _const_strconv__ftoa__mantbits32) - ((u32)(1))));
	u32 exp = ((u >> _const_strconv__ftoa__mantbits32) & ((((u32)(1)) << _const_strconv__ftoa__expbits32) - ((u32)(1))));
	if ((exp == _const_strconv__ftoa__maxexp32) || (exp == 0 && mant == 0)) {
		return strconv__ftoa__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__ftoa__Dec32_bool mr_9167 = strconv__ftoa__f32_to_decimal_exact_int(mant, exp);
	strconv__ftoa__Dec32 d = mr_9167.arg0;
	bool ok = mr_9167.arg1;
	if (!ok) {
		d = strconv__ftoa__f32_to_decimal(mant, exp);
	}
	return strconv__ftoa__Dec32_get_string_32(d, neg, n_digit, n_digit);
}

static string strconv__ftoa__Dec64_get_string_64(strconv__ftoa__Dec64 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = i_n_digit + 1;
	int pad_digit = i_pad_digit + 1;
	u64 out = d.m;
	int d_exp = d.e;
	int out_len = strconv__ftoa__decimal_len_64(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = pad_digit - out_len;
	}
	array_byte buf = array_repeat(new_array_from_c_array(1, 1, sizeof(byte), (byte[1]){
		((byte)(0)), 
}), out_len + 6 + 1 + 1 + fw_zeros);
	int i = 0;
	if (neg) {
		array_set(&buf, i, &(byte[]) { '-' });
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (*(u64*)array_get(_const_strconv__ftoa__ten_pow_table_64, out_len - n_digit - 1)) * 5;
		out /= (*(u64*)array_get(_const_strconv__ftoa__ten_pow_table_64, out_len - n_digit));
		if (d.m / (*(u64*)array_get(_const_strconv__ftoa__ten_pow_table_64, out_len - n_digit)) < out) {
			d_exp += 1;
			n_digit += 1;
		}
		out_len = n_digit;
	}
	int y = i + out_len;
	int x = 0;
	while (x < (out_len - disp - 1)) {
		array_set(&buf, y - x, &(byte[]) { '0' + ((byte)(out % 10)) });
		out /= 10;
		i++;
		x++;
	}
	if (out_len >= 1) {
		array_set(&buf, y - x, &(byte[]) { '.' });
		x++;
		i++;
	}
	if (y - x >= 0) {
		array_set(&buf, y - x, &(byte[]) { '0' + ((byte)(out % 10)) });
		i++;
	}
	while (fw_zeros > 0) {
		array_set(&buf, i++, &(byte[]) { '0' });
		fw_zeros--;
	}
	array_set(&buf, i, &(byte[]) { 'e' });
	i++;
	int exp = d_exp + out_len_original - 1;
	if (exp < 0) {
		array_set(&buf, i, &(byte[]) { '-' });
		i++;
		exp = -exp;
	} else {
		array_set(&buf, i, &(byte[]) { '+' });
		i++;
	}
	int d2 = exp % 10;
	exp /= 10;
	int d1 = exp % 10;
	int d0 = exp / 10;
	if (d0 > 0) {
		array_set(&buf, i, &(byte[]) { '0' + ((byte)(d0)) });
		i++;
	}
	array_set(&buf, i, &(byte[]) { '0' + ((byte)(d1)) });
	i++;
	array_set(&buf, i, &(byte[]) { '0' + ((byte)(d2)) });
	i++;
	array_set(&buf, i, &(byte[]) { 0 });
	return tos(((byteptr)(&(*(byte*)array_get(buf, 0)))), i);
}

static multi_return_strconv__ftoa__Dec64_bool strconv__ftoa__f64_to_decimal_exact_int(u64 i_mant, u64 exp) {
	strconv__ftoa__Dec64 d = (strconv__ftoa__Dec64){
		.m = 0,
		.e = 0,
	};
	u64 e = exp - _const_strconv__ftoa__bias64;
	if (e > _const_strconv__ftoa__mantbits64) {
		return (multi_return_strconv__ftoa__Dec64_bool){.arg0=d,.arg1=false};
	}
	u32 shift = _const_strconv__ftoa__mantbits64 - e;
	u64 mant = (i_mant | ((u64)(0x0010000000000000)));
	d.m = mant >> shift;
	if ((d.m << shift) != mant) {
		return (multi_return_strconv__ftoa__Dec64_bool){.arg0=d,.arg1=false};
	}
	while ((d.m % 10) == 0) {
		d.m /= 10;
		d.e++;
	}
	return (multi_return_strconv__ftoa__Dec64_bool){.arg0=d,.arg1=true};
}

static strconv__ftoa__Dec64 strconv__ftoa__f64_to_decimal(u64 mant, u64 exp) {
	int e2 = 0;
	u64 m2 = ((u64)(0));
	if (exp == 0) {
		e2 = 1 - _const_strconv__ftoa__bias64 - _const_strconv__ftoa__mantbits64 - 2;
		m2 = mant;
	} else {
		e2 = ((int)(exp)) - _const_strconv__ftoa__bias64 - _const_strconv__ftoa__mantbits64 - 2;
		m2 = ((((u64)(1)) << _const_strconv__ftoa__mantbits64) | mant);
	}
	bool even = ((m2 & 1)) == 0;
	bool accept_bounds = even;
	u64 mv = ((u64)(4 * m2));
	u64 mm_shift = strconv__ftoa__bool_to_u64(mant != 0 || exp <= 1);
	u64 vr = ((u64)(0));
	u64 vp = ((u64)(0));
	u64 vm = ((u64)(0));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	if (e2 >= 0) {
		u32 q = strconv__ftoa__log10_pow2(e2) - strconv__ftoa__bool_to_u32(e2 > 3);
		e10 = ((int)(q));
		int k = _const_strconv__ftoa__pow5_inv_num_bits_64 + strconv__ftoa__pow5_bits(((int)(q))) - 1;
		int i = -e2 + ((int)(q)) + k;
		strconv__ftoa__Uint128 mul = (*(strconv__ftoa__Uint128*)array_get(_const_strconv__ftoa__pow5_inv_split_64, q));
		vr = strconv__ftoa__mul_shift_64(((u64)(4)) * m2, mul, i);
		vp = strconv__ftoa__mul_shift_64(((u64)(4)) * m2 + ((u64)(2)), mul, i);
		vm = strconv__ftoa__mul_shift_64(((u64)(4)) * m2 - ((u64)(1)) - mm_shift, mul, i);
		if (q <= 21) {
			if (mv % 5 == 0) {
				vr_is_trailing_zeros = strconv__ftoa__multiple_of_power_of_five_64(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__ftoa__multiple_of_power_of_five_64(mv - 1 - mm_shift, q);
			} else if (strconv__ftoa__multiple_of_power_of_five_64(mv + 2, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__ftoa__log10_pow5(-e2) - strconv__ftoa__bool_to_u32(-e2 > 1);
		e10 = ((int)(q)) + e2;
		int i = -e2 - ((int)(q));
		int k = strconv__ftoa__pow5_bits(i) - _const_strconv__ftoa__pow5_num_bits_64;
		int j = ((int)(q)) - k;
		strconv__ftoa__Uint128 mul = (*(strconv__ftoa__Uint128*)array_get(_const_strconv__ftoa__pow5_split_64, i));
		vr = strconv__ftoa__mul_shift_64(((u64)(4)) * m2, mul, j);
		vp = strconv__ftoa__mul_shift_64(((u64)(4)) * m2 + ((u64)(2)), mul, j);
		vm = strconv__ftoa__mul_shift_64(((u64)(4)) * m2 - ((u64)(1)) - mm_shift, mul, j);
		if (q <= 1) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = (mm_shift == 1);
			} else {
				vp--;
			}
		} else if (q < 63) {
			vr_is_trailing_zeros = strconv__ftoa__multiple_of_power_of_two_64(mv, q - 1);
		}
	}
	int removed = 0;
	byte last_removed_digit = ((byte)(0));
	u64 out = ((u64)(0));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		while (1) {
			u64 vp_div_10 = vp / 10;
			u64 vm_div_10 = vm / 10;
			if (vp_div_10 <= vm_div_10) {
				break;
			}
			u64 vm_mod_10 = vm % 10;
			u64 vr_div_10 = vr / 10;
			u64 vr_mod_10 = vr % 10;
			vm_is_trailing_zeros = vm_is_trailing_zeros && vm_mod_10 == 0;
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
			last_removed_digit = ((byte)(vr_mod_10));
			vr = vr_div_10;
			vp = vp_div_10;
			vm = vm_div_10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			while (1) {
				u64 vm_div_10 = vm / 10;
				u64 vm_mod_10 = vm % 10;
				if (vm_mod_10 != 0) {
					break;
				}
				u64 vp_div_10 = vp / 10;
				u64 vr_div_10 = vr / 10;
				u64 vr_mod_10 = vr % 10;
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
				last_removed_digit = ((byte)(vr_mod_10));
				vr = vr_div_10;
				vp = vp_div_10;
				vm = vm_div_10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2) == 0) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		bool round_up = false;
		while (vp / 100 > vm / 100) {
			round_up = (vr % 100) >= 50;
			vr /= 100;
			vp /= 100;
			vm /= 100;
			removed += 2;
		}
		while (vp / 10 > vm / 10) {
			round_up = (vr % 10) >= 5;
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		out = vr + strconv__ftoa__bool_to_u64(vr == vm || round_up);
	}
	return (strconv__ftoa__Dec64){
		.m = out,
		.e = e10 + removed,
	};
}

string strconv__ftoa__f64_to_str(f64 f, int n_digit) {
	strconv__ftoa__Uf64 u1 = (strconv__ftoa__Uf64){
		.f = 0,
		.u = 0,
	};
	u1.f = f;
	u64 u = u1.u;
	bool neg = (u >> (_const_strconv__ftoa__mantbits64 + _const_strconv__ftoa__expbits64)) != 0;
	u64 mant = (u & ((((u64)(1)) << _const_strconv__ftoa__mantbits64) - ((u64)(1))));
	u64 exp = ((u >> _const_strconv__ftoa__mantbits64) & ((((u64)(1)) << _const_strconv__ftoa__expbits64) - ((u64)(1))));
	if ((exp == _const_strconv__ftoa__maxexp64) || (exp == 0 && mant == 0)) {
		return strconv__ftoa__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__ftoa__Dec64_bool mr_10245 = strconv__ftoa__f64_to_decimal_exact_int(mant, exp);
	strconv__ftoa__Dec64 d = mr_10245.arg0;
	bool ok = mr_10245.arg1;
	if (!ok) {
		d = strconv__ftoa__f64_to_decimal(mant, exp);
	}
	return strconv__ftoa__Dec64_get_string_64(d, neg, n_digit, 0);
}

string strconv__ftoa__f64_to_str_pad(f64 f, int n_digit) {
	strconv__ftoa__Uf64 u1 = (strconv__ftoa__Uf64){
		.f = 0,
		.u = 0,
	};
	u1.f = f;
	u64 u = u1.u;
	bool neg = (u >> (_const_strconv__ftoa__mantbits64 + _const_strconv__ftoa__expbits64)) != 0;
	u64 mant = (u & ((((u64)(1)) << _const_strconv__ftoa__mantbits64) - ((u64)(1))));
	u64 exp = ((u >> _const_strconv__ftoa__mantbits64) & ((((u64)(1)) << _const_strconv__ftoa__expbits64) - ((u64)(1))));
	if ((exp == _const_strconv__ftoa__maxexp64) || (exp == 0 && mant == 0)) {
		return strconv__ftoa__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__ftoa__Dec64_bool mr_10981 = strconv__ftoa__f64_to_decimal_exact_int(mant, exp);
	strconv__ftoa__Dec64 d = mr_10981.arg0;
	bool ok = mr_10981.arg1;
	if (!ok) {
		d = strconv__ftoa__f64_to_decimal(mant, exp);
	}
	return strconv__ftoa__Dec64_get_string_64(d, neg, n_digit, n_digit);
}

// Attr: [inline]
inline string strconv__ftoa__ftoa_64(f64 f) {
	return strconv__ftoa__f64_to_str(f, 17);
}

// Attr: [inline]
inline string strconv__ftoa__ftoa_long_64(f64 f) {
	return strconv__ftoa__f64_to_str_l(f);
}

// Attr: [inline]
inline string strconv__ftoa__ftoa_32(f32 f) {
	return strconv__ftoa__f32_to_str(f, 8);
}

// Attr: [inline]
inline string strconv__ftoa__ftoa_long_32(f32 f) {
	return strconv__ftoa__f32_to_str_l(f);
}

static void strconv__ftoa__assert1(bool t, string msg) {
	if (!t) {
		v_panic(msg);
	}
}

// Attr: [inline]
inline static int strconv__ftoa__bool_to_int(bool b) {
	if (b) {
		return 1;
	}
	return 0;
}

// Attr: [inline]
inline static u32 strconv__ftoa__bool_to_u32(bool b) {
	if (b) {
		return ((u32)(1));
	}
	return ((u32)(0));
}

// Attr: [inline]
inline static u64 strconv__ftoa__bool_to_u64(bool b) {
	if (b) {
		return ((u64)(1));
	}
	return ((u64)(0));
}

static string strconv__ftoa__get_string_special(bool neg, bool expZero, bool mantZero) {
	if (!mantZero) {
		return tos3("nan");
	}
	if (!expZero) {
		if (neg) {
			return tos3("-inf");
		} else {
			return tos3("+inf");
		}
	}
	if (neg) {
		return tos3("-0e+00");
	}
	return tos3("0e+00");
}

static int strconv__ftoa__decimal_len_32(u32 u) {
	strconv__ftoa__assert1(u < 1000000000, tos3("too big"));
	if (u >= 100000000) {
		return 9;
	} else if (u >= 10000000) {
		return 8;
	} else if (u >= 1000000) {
		return 7;
	} else if (u >= 100000) {
		return 6;
	} else if (u >= 10000) {
		return 5;
	} else if (u >= 1000) {
		return 4;
	} else if (u >= 100) {
		return 3;
	} else if (u >= 10) {
		return 2;
	}
	return 1;
}

static u32 strconv__ftoa__mul_shift_32(u32 m, u64 mul, int ishift) {
	multi_return_u64_u64 mr_2333 = math__bits__mul_64(((u64)(m)), mul);
	u64 hi = mr_2333.arg0;
	u64 lo = mr_2333.arg1;
	u64 shifted_sum = (lo >> ((u64)(ishift))) + (hi << ((u64)(64 - ishift)));
	strconv__ftoa__assert1(shifted_sum <= 2147483647, tos3("shiftedSum <= math.max_u32"));
	return ((u32)(shifted_sum));
}

static u32 strconv__ftoa__mul_pow5_invdiv_pow2(u32 m, u32 q, int j) {
	return strconv__ftoa__mul_shift_32(m, (*(u64*)array_get(_const_strconv__ftoa__pow5_inv_split_32, q)), j);
}

static u32 strconv__ftoa__mul_pow5_div_pow2(u32 m, u32 i, int j) {
	return strconv__ftoa__mul_shift_32(m, (*(u64*)array_get(_const_strconv__ftoa__pow5_split_32, i)), j);
}

static u32 strconv__ftoa__pow5_factor_32(u32 i_v) {
	u32 v = i_v;
	for (u32 n = ((u32)(0));
	; n++) {
		u32 q = v / 5;
		u32 r = v % 5;
		if (r != 0) {
			return n;
		}
		v = q;
	}
	return v;
}

static bool strconv__ftoa__multiple_of_power_of_five_32(u32 v, u32 p) {
	return strconv__ftoa__pow5_factor_32(v) >= p;
}

static bool strconv__ftoa__multiple_of_power_of_two_32(u32 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_32(v))) >= p;
}

static u32 strconv__ftoa__log10_pow2(int e) {
	strconv__ftoa__assert1(e >= 0, tos3("e >= 0"));
	strconv__ftoa__assert1(e <= 1650, tos3("e <= 1650"));
	return (((u32)(e)) * 78913) >> 18;
}

static u32 strconv__ftoa__log10_pow5(int e) {
	strconv__ftoa__assert1(e >= 0, tos3("e >= 0"));
	strconv__ftoa__assert1(e <= 2620, tos3("e <= 2620"));
	return (((u32)(e)) * 732923) >> 20;
}

static int strconv__ftoa__pow5_bits(int e) {
	strconv__ftoa__assert1(e >= 0, tos3("e >= 0"));
	strconv__ftoa__assert1(e <= 3528, tos3("e <= 3528"));
	return ((int)(((((u32)(e)) * 1217359) >> 19) + 1));
}

static int strconv__ftoa__decimal_len_64(u64 u) {
	int log2 = 64 - math__bits__leading_zeros_64(u) - 1;
	int t = (log2 + 1) * 1233 >> 12;
	return t - strconv__ftoa__bool_to_int(u < (*(u64*)array_get(_const_strconv__ftoa__powers_of_10, t))) + 1;
}

static u64 strconv__ftoa__shift_right_128(strconv__ftoa__Uint128 v, int shift) {
	strconv__ftoa__assert1(shift < 64, tos3("shift < 64"));
	return ((v.hi << ((u64)(64 - shift))) | (v.lo >> ((u32)(shift))));
}

static u64 strconv__ftoa__mul_shift_64(u64 m, strconv__ftoa__Uint128 mul, int shift) {
	multi_return_u64_u64 mr_5023 = math__bits__mul_64(m, mul.hi);
	u64 hihi = mr_5023.arg0;
	u64 hilo = mr_5023.arg1;
	multi_return_u64_u64 mr_5061 = math__bits__mul_64(m, mul.lo);
	u64 lohi = mr_5061.arg0;
	strconv__ftoa__Uint128 sum = (strconv__ftoa__Uint128){
		.hi = hihi,
		.lo = lohi + hilo,
	};
	if (sum.lo < lohi) {
		sum.hi++;
	}
	return strconv__ftoa__shift_right_128(sum, shift - 64);
}

static u32 strconv__ftoa__pow5_factor_64(u64 v_i) {
	u64 v = v_i;
	for (u32 n = ((u32)(0));
	; n++) {
		u64 q = v / 5;
		u64 r = v % 5;
		if (r != 0) {
			return n;
		}
		v = q;
	}
	return ((u32)(0));
}

static bool strconv__ftoa__multiple_of_power_of_five_64(u64 v, u32 p) {
	return strconv__ftoa__pow5_factor_64(v) >= p;
}

static bool strconv__ftoa__multiple_of_power_of_two_64(u64 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_64(v))) >= p;
}

string strconv__ftoa__f32_to_str_l(f64 f) {
	return strconv__ftoa__f64_to_str_l(((f32)(f)));
}

string strconv__ftoa__f64_to_str_l(f64 f) {
	string s = strconv__ftoa__f64_to_str(f, 18);
	if (s.len > 2 && (string_at(s, 0) == 'n' || string_at(s, 1) == 'i')) {
		return s;
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	array_fixed_byte_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int tmp2 = 0; tmp2 < s.len; tmp2++) {
	byte c = s.str[tmp2];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[i1++] = c;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = i - 1;
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return tos3("Float conversion error!!");
		}
	}
	b[i1] = 0;
	if (string_at(s, i) == '-') {
		exp_sgn = -1;
		i++;
	} else if (string_at(s, i) == '+') {
		exp_sgn = 1;
		i++;
	}
	for (int tmp6 = 0; tmp6 < string_substr(s, i, s.len).len; tmp6++) {
	byte c = string_substr(s, i, s.len).str[tmp6];
		exp = exp * 10 + ((int)(c - '0'));
	}
	array_byte res = array_repeat(new_array_from_c_array(1, 1, sizeof(byte), (byte[1]){
		'0', 
}), exp + 32);
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			array_set(&res, r_i++, &(byte[]) { '+' });
		}
	} else {
		array_set(&res, r_i++, &(byte[]) { '-' });
	}
	i = 0;
	if (exp_sgn >= 0) {
		while (b[i] != 0) {
			array_set(&res, r_i++, &(byte[]) { b[i] });
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					array_set(&res, r_i++, &(byte[]) { '.' });
				}
				exp--;
			}
		}
		while (exp >= 0) {
			array_set(&res, r_i++, &(byte[]) { '0' });
			exp--;
		}
	} else {
		bool dot_p = true;
		while (exp > 0) {
			array_set(&res, r_i++, &(byte[]) { '0' });
			exp--;
			if (dot_p) {
				array_set(&res, r_i++, &(byte[]) { '.' });
				dot_p = false;
			}
		}
		while (b[i] != 0) {
			array_set(&res, r_i++, &(byte[]) { b[i] });
			i++;
		}
	}
	array_set(&res, r_i, &(byte[]) { 0 });
	return tos(&(*(byte*)array_get(res, 0)), r_i);
}

static multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r2 = ((u32)(0));
	r0 = ((s0 >> 1) | (((s1 & ((u32)(1)))) << 31));
	r1 = ((s1 >> 1) | (((s2 & ((u32)(1)))) << 31));
	r2 = s2 >> 1;
	return (multi_return_u32_u32_u32){.arg0=r2,.arg1=r1,.arg2=r0};
}

static multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r2 = ((u32)(0));
	r2 = ((s2 << 1) | (((s1 & (((u32)(1)) << 31))) >> 31));
	r1 = ((s1 << 1) | (((s0 & (((u32)(1)) << 31))) >> 31));
	r0 = s0 << 1;
	return (multi_return_u32_u32_u32){.arg0=r2,.arg1=r1,.arg2=r0};
}

static multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0));
	u32 r0 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r2 = ((u32)(0));
	w = ((u64)(s0)) + ((u64)(d0));
	r0 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s1)) + ((u64)(d1));
	r1 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s2)) + ((u64)(d2));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2,.arg1=r1,.arg2=r0};
}

static multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0));
	u32 r0 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r2 = ((u32)(0));
	w = ((u64)(s0)) - ((u64)(d0));
	r0 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s1)) - ((u64)(d1));
	r1 = ((u32)(w));
	w >>= 32;
	w += ((u64)(s2)) - ((u64)(d2));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2,.arg1=r1,.arg2=r0};
}

static bool strconv__is_digit(byte x) {
	return (x >= _const_strconv__ZERO && x <= _const_strconv__NINE) == true;
}

static bool strconv__is_space(byte x) {
	return ((x >= 0x89 && x <= 0x13) || x == 0x20) == true;
}

static bool strconv__is_exp(byte x) {
	return (x == 'E' || x == 'e') == true;
}

static multi_return_int_strconv__PrepNumber strconv__parser(string s) {
	int state = _const_strconv__fsm_a;
	int digx = 0;
	byte c = ' ';
	int result = _const_strconv__parser_ok;
	bool expneg = false;
	int expexp = 0;
	int i = 0;
	strconv__PrepNumber pn = (strconv__PrepNumber){
		.negative = 0,
		.exponent = 0,
		.mantissa = 0,
	};
	while (state != _const_strconv__FSM_STOP) {
		if (state == _const_strconv__fsm_a) {
			if (strconv__is_space(c) == true) {
				c = string_at(s, i++);
			} else {
				state = _const_strconv__fsm_b;
			}
		}else if (state == _const_strconv__fsm_b) {
			state = _const_strconv__fsm_c;
			if (c == _const_strconv__PLUS) {
				c = string_at(s, i++);
			} else if (c == _const_strconv__MINUS) {
				pn.negative = true;
				c = string_at(s, i++);
			} else if (strconv__is_digit(c)) {
			} else if (c == _const_strconv__DPOINT) {
			} else {
				state = _const_strconv__FSM_STOP;
			}
		}else if (state == _const_strconv__fsm_c) {
			if (c == _const_strconv__ZERO) {
				c = string_at(s, i++);
			} else if (c == _const_strconv__DPOINT) {
				c = string_at(s, i++);
				state = _const_strconv__fsm_d;
			} else {
				state = _const_strconv__fsm_e;
			}
		}else if (state == _const_strconv__fsm_d) {
			if (c == _const_strconv__ZERO) {
				c = string_at(s, i++);
				if (pn.exponent > -2147483647) {
					pn.exponent--;
				}
			} else {
				state = _const_strconv__fsm_f;
			}
		}else if (state == _const_strconv__fsm_e) {
			if (strconv__is_digit(c)) {
				if (digx < _const_strconv__DIGITS) {
					pn.mantissa *= 10;
					pn.mantissa += ((u64)(c - _const_strconv__ZERO));
					digx++;
				} else if (pn.exponent < 2147483647) {
					pn.exponent++;
				}
				c = string_at(s, i++);
			} else if (c == _const_strconv__DPOINT) {
				c = string_at(s, i++);
				state = _const_strconv__fsm_f;
			} else {
				state = _const_strconv__fsm_f;
			}
		}else if (state == _const_strconv__fsm_f) {
			if (strconv__is_digit(c)) {
				if (digx < _const_strconv__DIGITS) {
					pn.mantissa *= 10;
					pn.mantissa += ((u64)(c - _const_strconv__ZERO));
					pn.exponent--;
					digx++;
				}
				c = string_at(s, i++);
			} else if (strconv__is_exp(c)) {
				c = string_at(s, i++);
				state = _const_strconv__fsm_g;
			} else {
				state = _const_strconv__fsm_g;
			}
		}else if (state == _const_strconv__fsm_g) {
			if (c == _const_strconv__PLUS) {
				c = string_at(s, i++);
			} else if (c == _const_strconv__MINUS) {
				expneg = true;
				c = string_at(s, i++);
			}
			state = _const_strconv__fsm_h;
		}else if (state == _const_strconv__fsm_h) {
			if (c == _const_strconv__ZERO) {
				c = string_at(s, i++);
			} else {
				state = _const_strconv__fsm_i;
			}
		}else if (state == _const_strconv__fsm_i) {
			if (strconv__is_digit(c)) {
				if (expexp < 214748364) {
					expexp *= 10;
					expexp += ((int)(c - _const_strconv__ZERO));
				}
				c = string_at(s, i++);
			} else {
				state = _const_strconv__FSM_STOP;
			}
		}else {
		};
		if (i >= s.len) {
			state = _const_strconv__FSM_STOP;
		}
	}
	if (expneg) {
		expexp = -expexp;
	}
	pn.exponent += expexp;
	if (pn.mantissa == 0) {
		if (pn.negative) {
			result = _const_strconv__parser_mzero;
		} else {
			result = _const_strconv__parser_pzero;
		}
	} else if (pn.exponent > 309) {
		if (pn.negative) {
			result = _const_strconv__parser_minf;
		} else {
			result = _const_strconv__parser_pinf;
		}
	} else if (pn.exponent < -328) {
		if (pn.negative) {
			result = _const_strconv__parser_mzero;
		} else {
			result = _const_strconv__parser_pzero;
		}
	}
	return (multi_return_int_strconv__PrepNumber){.arg0=result,.arg1=pn};
}

static u64 strconv__converter(strconv__PrepNumber* pn) {
	int binexp = 92;
	u32 s2 = ((u32)(0));
	u32 s1 = ((u32)(0));
	u32 s0 = ((u32)(0));
	u32 q2 = ((u32)(0));
	u32 q1 = ((u32)(0));
	u32 q0 = ((u32)(0));
	u32 r2 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r0 = ((u32)(0));
	u32 mask28 = ((u32)(0xF << 28));
	u64 result = ((u64)(0));
	s0 = ((u32)((pn->mantissa & ((u64)(0x00000000FFFFFFFF)))));
	s1 = ((u32)(pn->mantissa >> 32));
	s2 = ((u32)(0));
	while (pn->exponent > 0) {
		multi_return_u32_u32_u32 mr_7893 = strconv__lsl96(s2, s1, s0);
		q2 = mr_7893.arg0;
		q1 = mr_7893.arg1;
		q0 = mr_7893.arg2;
		multi_return_u32_u32_u32 mr_7937 = strconv__lsl96(q2, q1, q0);
		r2 = mr_7937.arg0;
		r1 = mr_7937.arg1;
		r0 = mr_7937.arg2;
		multi_return_u32_u32_u32 mr_7991 = strconv__lsl96(r2, r1, r0);
		s2 = mr_7991.arg0;
		s1 = mr_7991.arg1;
		s0 = mr_7991.arg2;
		multi_return_u32_u32_u32 mr_8045 = strconv__add96(s2, s1, s0, q2, q1, q0);
		s2 = mr_8045.arg0;
		s1 = mr_8045.arg1;
		s0 = mr_8045.arg2;
		pn->exponent--;
		while (((s2 & mask28)) != 0) {
			multi_return_u32_u32_u32 mr_8166 = strconv__lsr96(s2, s1, s0);
			q2 = mr_8166.arg0;
			q1 = mr_8166.arg1;
			q0 = mr_8166.arg2;
			binexp++;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	while (pn->exponent < 0) {
		while (!(((s2 & (((u32)(1)) << 31))) != 0)) {
			multi_return_u32_u32_u32 mr_8309 = strconv__lsl96(s2, s1, s0);
			q2 = mr_8309.arg0;
			q1 = mr_8309.arg1;
			q0 = mr_8309.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
		q2 = s2 / _const_strconv__TEN;
		r1 = s2 % _const_strconv__TEN;
		r2 = ((s1 >> 8) | (r1 << 24));
		q1 = r2 / _const_strconv__TEN;
		r1 = r2 % _const_strconv__TEN;
		r2 = (((((s1 & ((u32)(0xFF)))) << 16) | (s0 >> 16)) | (r1 << 24));
		r0 = r2 / _const_strconv__TEN;
		r1 = r2 % _const_strconv__TEN;
		q1 = ((q1 << 8) | (((r0 & ((u32)(0x00FF0000)))) >> 16));
		q0 = r0 << 16;
		r2 = (((s0 & ((u32)(0xFFFF)))) | (r1 << 16));
		q0 |= r2 / _const_strconv__TEN;
		s2 = q2;
		s1 = q1;
		s0 = q0;
		pn->exponent++;
	}
	if (s2 != 0 || s1 != 0 || s0 != 0) {
		while (((s2 & mask28)) == 0) {
			multi_return_u32_u32_u32 mr_8954 = strconv__lsl96(s2, s1, s0);
			q2 = mr_8954.arg0;
			q1 = mr_8954.arg1;
			q0 = mr_8954.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	int nbit = 7;
	u32 check_round_bit = ((u32)(1)) << ((u32)(nbit));
	u32 check_round_mask = ((u32)(0xFFFFFFFF)) << ((u32)(nbit));
	if (((s1 & check_round_bit)) != 0) {
		if (((s1 & ~check_round_mask)) != 0) {
			multi_return_u32_u32_u32 mr_10027 = strconv__add96(s2, s1, s0, 0, check_round_bit, 0);
			s2 = mr_10027.arg0;
			s1 = mr_10027.arg1;
			s0 = mr_10027.arg2;
		} else {
			if (((s1 & (check_round_bit << ((u32)(1))))) != 0) {
				multi_return_u32_u32_u32 mr_10217 = strconv__add96(s2, s1, s0, 0, check_round_bit, 0);
				s2 = mr_10217.arg0;
				s1 = mr_10217.arg1;
				s0 = mr_10217.arg2;
			}
		}
		s1 = (s1 & check_round_mask);
		s0 = ((u32)(0));
		if ((s2 & (mask28 << ((u32)(1)))) != 0) {
			multi_return_u32_u32_u32 mr_10417 = strconv__lsr96(s2, s1, s0);
			q2 = mr_10417.arg0;
			q1 = mr_10417.arg1;
			q0 = mr_10417.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	binexp += 1023;
	if (binexp > 2046) {
		if (pn->negative) {
			result = _const_strconv__DOUBLE_MINUS_INFINITY;
		} else {
			result = _const_strconv__DOUBLE_PLUS_INFINITY;
		}
	} else if (binexp < 1) {
		if (pn->negative) {
			result = _const_strconv__DOUBLE_MINUS_ZERO;
		} else {
			result = _const_strconv__DOUBLE_PLUS_ZERO;
		}
	} else if (s2 != 0) {
		u64 q = ((u64)(0));
		u64 binexs2 = ((u64)(binexp)) << 52;
		q = (((((u64)((s2 & ~mask28))) << 24) | ((((u64)(s1)) + ((u64)(128))) >> 8)) | binexs2);
		if (pn->negative) {
			q |= (((u64)(1)) << 63);
		}
		result = q;
	}
	return result;
}

f64 strconv__atof64(string s) {
	strconv__PrepNumber pn = (strconv__PrepNumber){
		.negative = 0,
		.exponent = 0,
		.mantissa = 0,
	};
	int res_parsing = 0;
	strconv__Float64u res = (strconv__Float64u){
		.f = 0,
		.u = 0,
	};
	multi_return_int_strconv__PrepNumber mr_11564 = strconv__parser(string_add(s, tos3(" ")));
	res_parsing = mr_11564.arg0;
	pn = mr_11564.arg1;
	if (res_parsing == _const_strconv__parser_ok) {
		res.u = strconv__converter(&/*qq*/pn);
	}else if (res_parsing == _const_strconv__parser_pzero) {
		res.u = _const_strconv__DOUBLE_PLUS_ZERO;
	}else if (res_parsing == _const_strconv__parser_mzero) {
		res.u = _const_strconv__DOUBLE_MINUS_ZERO;
	}else if (res_parsing == _const_strconv__parser_pinf) {
		res.u = _const_strconv__DOUBLE_PLUS_INFINITY;
	}else if (res_parsing == _const_strconv__parser_minf) {
		res.u = _const_strconv__DOUBLE_MINUS_INFINITY;
	}else {
	};
	return res.f;
}

static byte strconv__byte_to_lower(byte c) {
	return (c | ('x' - 'X'));
}

u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	int bit_size = _bit_size;
	int base = _base;
	if (s.len < 1 || !strconv__underscore_ok(s)) {
		return ((u64)(0));
	}
	bool base0 = base == 0;
	int start_index = 0;
	if (2 <= base && base <= 36) {
	} else if (base == 0) {
		base = 10;
		if (string_at(s, 0) == '0') {
			if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'b') {
				base = 2;
				start_index += 2;
			} else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'o') {
				base = 8;
				start_index += 2;
			} else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'x') {
				base = 16;
				start_index += 2;
			} else if (s.len >= 2 && (string_at(s, 1) >= '0' && string_at(s, 1) <= '9')) {
				base = 10;
				start_index++;
			} else {
				base = 8;
				start_index++;
			}
		}
	} else {
		return ((u64)(0));
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	} else if (bit_size < 0 || bit_size > 64) {
		return ((u64)(0));
	}
	u64 cutoff = _const_strconv__max_u64 / ((u64)(base)) + ((u64)(1));
	u64 max_val = (bit_size == 64 ?  ( _const_strconv__max_u64 )  :  ( (((u64)(1)) << ((u64)(bit_size))) - ((u64)(1)) ) );
	bool underscores = false;
	u64 n = ((u64)(0));
	for (int tmp7 = start_index; tmp7 < s.len; tmp7++) {
		int i = tmp7;
		byte c = string_at(s, i);
		byte cl = strconv__byte_to_lower(c);
		byte d = ((byte)(0));
		if (c == '_' && base0) {
			underscores = true;
			continue;
		} else if ('0' <= c && c <= '9') {
			d = c - '0';
		} else if ('a' <= cl && cl <= 'z') {
			d = cl - 'a' + 10;
		} else {
			if (error_on_non_digit) {
				return ((u64)(0));
			} else {
				break;
			}
		}
		if (d >= ((byte)(base))) {
			if (error_on_high_digit) {
				return ((u64)(0));
			} else {
				break;
			}
		}
		if (n >= cutoff) {
			return max_val;
		}
		n *= ((u64)(base));
		u64 n1 = n + ((u64)(d));
		if (n1 < n || n1 > max_val) {
			return max_val;
		}
		n = n1;
	}
	if (underscores && !strconv__underscore_ok(s)) {
		return ((u64)(0));
	}
	return n;
}

u64 strconv__parse_uint(string s, int _base, int _bit_size) {
	return strconv__common_parse_uint(s, _base, _bit_size, true, true);
}

i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	string s = _s;
	int bit_size = _bit_size;
	if (s.len < 1) {
		return ((i64)(0));
	}
	bool neg = false;
	if (string_at(s, 0) == '+') {
		s = string_substr(s, 1, s.len);
	} else if (string_at(s, 0) == '-') {
		neg = true;
		s = string_substr(s, 1, s.len);
	}
	u64 un = strconv__common_parse_uint(s, base, bit_size, error_on_non_digit, error_on_high_digit);
	if (un == 0) {
		return ((i64)(0));
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	}
	u64 cutoff = ((u64)(1)) << ((u64)(bit_size - 1));
	if (!neg && un >= cutoff) {
		return ((i64)(cutoff - ((u64)(1))));
	}
	if (neg && un > cutoff) {
		return -((i64)(cutoff));
	}
	return (neg ?  ( -((i64)(un)) )  :  ( ((i64)(un)) ) );
}

i64 strconv__parse_int(string _s, int base, int _bit_size) {
	return strconv__common_parse_int(_s, base, _bit_size, true, true);
}

int strconv__atoi(string s) {
	if ((_const_strconv__int_size == 32 && (0 < s.len && s.len < 10)) || (_const_strconv__int_size == 64 && (0 < s.len && s.len < 19))) {
		int start_idx = 0;
		if (string_at(s, 0) == '-' || string_at(s, 0) == '+') {
			start_idx++;
			if (s.len - start_idx < 1) {
				return 0;
			}
		}
		int n = 0;
		for (int tmp4 = start_idx; tmp4 < s.len; tmp4++) {
			int i = tmp4;
			byte ch = string_at(s, i) - '0';
			if (ch > 9) {
				return 0;
			}
			n = n * 10 + ((int)(ch));
		}
		return (string_at(s, 0) == '-' ?  ( -n )  :  ( n ) );
	}
	i64 int64 = strconv__parse_int(s, 10, 0);
	return ((int)(int64));
}

static bool strconv__underscore_ok(string s) {
	byte saw = '^';
	int i = 0;
	if (s.len >= 1 && (string_at(s, 0) == '-' || string_at(s, 0) == '+')) {
		i++;
	}
	bool hex = false;
	if (s.len - i >= 2 && string_at(s, i) == '0' && (strconv__byte_to_lower(string_at(s, i + 1)) == 'b' || strconv__byte_to_lower(string_at(s, i + 1)) == 'o' || strconv__byte_to_lower(string_at(s, i + 1)) == 'x')) {
		saw = '0';
		hex = strconv__byte_to_lower(string_at(s, i + 1)) == 'x';
		i += 2;
	}
	for (; i < s.len; i++) {
		if (('0' <= string_at(s, i) && string_at(s, i) <= '9') || (hex && 'a' <= strconv__byte_to_lower(string_at(s, i)) && strconv__byte_to_lower(string_at(s, i)) <= 'f')) {
			saw = '0';
			continue;
		}
		if (string_at(s, i) == '_') {
			if (saw != '0') {
				return false;
			}
			saw = '_';
			continue;
		}
		if (saw == '_') {
			return false;
		}
		saw = '!';
	}
	return saw != '_';
}

string strconv__f64_to_str_lnd(f64 f, int dec_digit) {
	string s = strconv__ftoa__f64_to_str(f + (*(f64*)array_get(_const_strconv__dec_round, dec_digit)), 18);
	if (s.len > 2 && (string_at(s, 0) == 'n' || string_at(s, 1) == 'i')) {
		return s;
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	array_fixed_byte_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	int dot_res_sp = -1;
	for (int tmp2 = 0; tmp2 < s.len; tmp2++) {
	byte c = s.str[tmp2];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[i1++] = c;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = i - 1;
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return tos3("[Float conversion error!!]");
		}
	}
	b[i1] = 0;
	if (string_at(s, i) == '-') {
		exp_sgn = -1;
		i++;
	} else if (string_at(s, i) == '+') {
		exp_sgn = 1;
		i++;
	}
	for (int tmp6 = 0; tmp6 < string_substr(s, i, s.len).len; tmp6++) {
	byte c = string_substr(s, i, s.len).str[tmp6];
		exp = exp * 10 + ((int)(c - '0'));
	}
	array_byte res = array_repeat(new_array_from_c_array(1, 1, sizeof(byte), (byte[1]){
		'0', 
}), exp + 32);
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			array_set(&res, r_i++, &(byte[]) { '+' });
		}
	} else {
		array_set(&res, r_i++, &(byte[]) { '-' });
	}
	i = 0;
	if (exp_sgn >= 0) {
		while (b[i] != 0) {
			array_set(&res, r_i++, &(byte[]) { b[i] });
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					dot_res_sp = r_i;
					array_set(&res, r_i++, &(byte[]) { '.' });
				}
				exp--;
			}
		}
		while (exp >= 0) {
			array_set(&res, r_i++, &(byte[]) { '0' });
			exp--;
		}
	} else {
		bool dot_p = true;
		while (exp > 0) {
			array_set(&res, r_i++, &(byte[]) { '0' });
			exp--;
			if (dot_p) {
				dot_res_sp = r_i;
				array_set(&res, r_i++, &(byte[]) { '.' });
				dot_p = false;
			}
		}
		while (b[i] != 0) {
			array_set(&res, r_i++, &(byte[]) { b[i] });
			i++;
		}
	}
	if (dot_res_sp >= 0) {
		if ((r_i - dot_res_sp) > dec_digit) {
			r_i = dot_res_sp + dec_digit + 1;
		}
		array_set(&res, r_i, &(byte[]) { 0 });
		return tos(&(*(byte*)array_get(res, 0)), r_i);
	} else {
		if (dec_digit > 0) {
			int c = 0;
			array_set(&res, r_i++, &(byte[]) { '.' });
			while (c < dec_digit) {
				array_set(&res, r_i++, &(byte[]) { '0' });
				c++;
			}
			array_set(&res, r_i, &(byte[]) { 0 });
		}
		return tos(&(*(byte*)array_get(res, 0)), r_i);
	}
}

string strconv__format_str(string s, strconv__BF_param p) {
	int dif = p.len0 - s.len;
	if (dif <= 0) {
		return s;
	}
	strings__Builder res = strings__new_builder(s.len + dif);
	if (p.allign == strconv__Align_text_right) {
		for (int i1 = 0;
		i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write(&res, s);
	if (p.allign == strconv__Align_text_left) {
		for (int i1 = 0;
		i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	return strings__Builder_str(&res);
}

string strconv__format_dec(u64 d, strconv__BF_param p) {
	string s = tos3("");
	strings__Builder res = strings__new_builder(20);
	int sign_len_diff = 0;
	if (p.pad_ch == '0') {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_b(&res, '+');
				sign_len_diff = -1;
			}
		} else {
			strings__Builder_write_b(&res, '-');
			sign_len_diff = -1;
		}
		s = u64_str(d);
	} else {
		if (p.positive) {
			if (p.sign_flag) {
				s = string_add(tos3("+"), u64_str(d));
			} else {
				s = u64_str(d);
			}
		} else {
			s = string_add(tos3("-"), u64_str(d));
		}
	}
	int dif = p.len0 - s.len + sign_len_diff;
	if (p.allign == strconv__Align_text_right) {
		for (int i1 = 0;
		i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write(&res, s);
	if (p.allign == strconv__Align_text_left) {
		for (int i1 = 0;
		i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	return strings__Builder_str(&res);
}

string strconv__format_fl(f64 f, strconv__BF_param p) {
	string s = tos3("");
	string fs = strconv__f64_to_str_lnd((f >= 0.0 ?  ( f )  :  ( -f ) ), p.len1);
	if (string_at(fs, 0) == '[') {
		return fs;
	}
	if (p.rm_tail_zero) {
		fs = strconv__remove_tail_zeros(fs);
	}
	strings__Builder res = strings__new_builder((p.len0 > fs.len ?  ( p.len0 )  :  ( fs.len ) ));
	int sign_len_diff = 0;
	if (p.pad_ch == '0') {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_b(&res, '+');
				sign_len_diff = -1;
			}
		} else {
			strings__Builder_write_b(&res, '-');
			sign_len_diff = -1;
		}
		s = fs;
	} else {
		if (p.positive) {
			if (p.sign_flag) {
				s = string_add(tos3("+"), fs);
			} else {
				s = fs;
			}
		} else {
			s = string_add(tos3("-"), fs);
		}
	}
	int dif = p.len0 - s.len + sign_len_diff;
	if (p.allign == strconv__Align_text_right) {
		for (int i1 = 0;
		i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write(&res, s);
	if (p.allign == strconv__Align_text_left) {
		for (int i1 = 0;
		i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	return strings__Builder_str(&res);
}

string strconv__format_es(f64 f, strconv__BF_param p) {
	string s = tos3("");
	string fs = strconv__ftoa__f64_to_str_pad((f > 0 ?  ( f )  :  ( -f ) ), p.len1);
	if (p.rm_tail_zero) {
		fs = strconv__remove_tail_zeros(fs);
	}
	strings__Builder res = strings__new_builder((p.len0 > fs.len ?  ( p.len0 )  :  ( fs.len ) ));
	int sign_len_diff = 0;
	if (p.pad_ch == '0') {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_b(&res, '+');
				sign_len_diff = -1;
			}
		} else {
			strings__Builder_write_b(&res, '-');
			sign_len_diff = -1;
		}
		s = fs;
	} else {
		if (p.positive) {
			if (p.sign_flag) {
				s = string_add(tos3("+"), fs);
			} else {
				s = fs;
			}
		} else {
			s = string_add(tos3("-"), fs);
		}
	}
	int dif = p.len0 - s.len + sign_len_diff;
	if (p.allign == strconv__Align_text_right) {
		for (int i1 = 0;
		i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	strings__Builder_write(&res, s);
	if (p.allign == strconv__Align_text_left) {
		for (int i1 = 0;
		i1 < dif; i1++) {
			strings__Builder_write_b(&res, p.pad_ch);
		}
	}
	return strings__Builder_str(&res);
}

string strconv__remove_tail_zeros(string s) {
	int i = 0;
	int last_zero_start = -1;
	int dot_pos = -1;
	bool in_decimal = false;
	byte prev_ch = ((byte)(0));
	while (i < s.len) {
		byte ch = s.str[i];
		if (ch == '.') {
			in_decimal = true;
			dot_pos = i;
		} else if (in_decimal) {
			if (ch == '0' && prev_ch != '0') {
				last_zero_start = i;
			} else if (ch >= '1' && ch <= '9') {
				last_zero_start = -1;
			} else if (ch == 'e') {
				break;
			}
		}
		prev_ch = ch;
		i++;
	}
	string tmp = tos3("");
	if (last_zero_start > 0) {
		if (last_zero_start == dot_pos + 1) {
			tmp = string_add(string_substr(s, 0, dot_pos), string_substr(s, i, s.len));
		} else {
			tmp = string_add(string_substr(s, 0, last_zero_start), string_substr(s, i, s.len));
		}
	} else {
		tmp = s;
	}
	if (tmp.str[tmp.len - 1] == '.') {
		return string_substr(tmp, 0, tmp.len - 1);
	}
	return tmp;
}

void strconv__v_printf(string str, varg_voidptr pt) {
	print(strconv__v_sprintf(str, pt));
}

string strconv__v_sprintf(string str, varg_voidptr pt) {
	strings__Builder res = strings__new_builder(pt.len * 16);
	int i = 0;
	int p_index = 0;
	bool sign = false;
	strconv__Align_text allign = strconv__Align_text_right;
	int len0 = -1;
	int len1 = -1;
	int def_len1 = 6;
	byte pad_ch = ' ';
	bool th_separator = false;
	byte ch1 = '0';
	byte ch2 = '0';
	strconv__Char_parse_state status = strconv__Char_parse_state_norm_char;
	while (i < str.len) {
		if (status == strconv__Char_parse_state_reset_params) {
			sign = false;
			allign = strconv__Align_text_right;
			len0 = -1;
			len1 = -1;
			pad_ch = ' ';
			th_separator = false;
			status = strconv__Char_parse_state_norm_char;
			ch1 = '0';
			ch2 = '0';
			continue;
		}
		byte ch = string_at(str, i);
		if (ch != '%' && status == strconv__Char_parse_state_norm_char) {
			strings__Builder_write_b(&res, ch);
			i++;
			continue;
		}
		if (ch == '%' && status == strconv__Char_parse_state_norm_char) {
			status = strconv__Char_parse_state_field_char;
			i++;
			continue;
		}
		if (ch == 'c' && status == strconv__Char_parse_state_field_char) {
			byte d1 = *(((byte*)(pt.args[p_index])));
			strings__Builder_write_b(&res, d1);
			status = strconv__Char_parse_state_reset_params;
			p_index++;
			i++;
			continue;
		}
		if (ch == 'p' && status == strconv__Char_parse_state_field_char) {
			strings__Builder_write(&res, string_add(tos3("0x"), ptr_str(pt.args[p_index])));
			status = strconv__Char_parse_state_reset_params;
			p_index++;
			i++;
			continue;
		}
		if (status == strconv__Char_parse_state_field_char) {
			byte fc_ch1 = '0';
			byte fc_ch2 = '0';
			if ((i + 1) < str.len) {
				fc_ch1 = string_at(str, i + 1);
				if ((i + 2) < str.len) {
					fc_ch2 = string_at(str, i + 2);
				}
			}
			if (ch == '+') {
				sign = true;
				i++;
				continue;
			} else if (ch == '-') {
				allign = strconv__Align_text_left;
				i++;
				continue;
			} else if ((ch == '0' || ch == ' ')) {
				if (allign == strconv__Align_text_right) {
					pad_ch = ch;
				}
				i++;
				continue;
			} else if (ch == '\'') {
				th_separator = true;
				i++;
				continue;
			} else if (ch == '.' && fc_ch1 >= '1' && fc_ch1 <= '9') {
				status = strconv__Char_parse_state_check_float;
				i++;
				continue;
			} else if (ch == '.' && fc_ch1 == '*' && fc_ch2 == 's') {
				int len = *(((int*)(pt.args[p_index])));
				p_index++;
				string s = *(((string*)(pt.args[p_index])));
				s = string_substr(s, 0, len);
				p_index++;
				strings__Builder_write(&res, s);
				status = strconv__Char_parse_state_reset_params;
				i += 3;
				continue;
			}
			status = strconv__Char_parse_state_len_set_start;
			continue;
		}
		if (status == strconv__Char_parse_state_len_set_start) {
			if (ch >= '1' && ch <= '9') {
				len0 = ((int)(ch - '0'));
				status = strconv__Char_parse_state_len_set_in;
				i++;
				continue;
			}
			if (ch == '.') {
				status = strconv__Char_parse_state_check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state_check_type;
			continue;
		}
		if (status == strconv__Char_parse_state_len_set_in) {
			if (ch >= '0' && ch <= '9') {
				len0 *= 10;
				len0 += ((int)(ch - '0'));
				i++;
				continue;
			}
			if (ch == '.') {
				status = strconv__Char_parse_state_check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state_check_type;
			continue;
		}
		if (status == strconv__Char_parse_state_check_float) {
			if (ch >= '0' && ch <= '9') {
				len1 = ((int)(ch - '0'));
				status = strconv__Char_parse_state_check_float_in;
				i++;
				continue;
			}
			status = strconv__Char_parse_state_check_type;
			continue;
		}
		if (status == strconv__Char_parse_state_check_float_in) {
			if (ch >= '0' && ch <= '9') {
				len1 *= 10;
				len1 += ((int)(ch - '0'));
				i++;
				continue;
			}
			status = strconv__Char_parse_state_check_type;
			continue;
		}
		if (status == strconv__Char_parse_state_check_type) {
			if (ch == 'l') {
				if (ch1 == '0') {
					ch1 = 'l';
					i++;
					continue;
				} else {
					ch2 = 'l';
					i++;
					continue;
				}
			} else if (ch == 'h') {
				if (ch1 == '0') {
					ch1 = 'h';
					i++;
					continue;
				} else {
					ch2 = 'h';
					i++;
					continue;
				}
			} else if ((ch == 'd' || ch == 'i')) {
				u64 d1 = ((u64)(0));
				bool positive = true;
				if (ch1 == 'h') {
					if (ch2 == 'h') {
						i8 x = *(((i8*)(pt.args[p_index])));
						positive = (x >= 0 ?  ( true )  :  ( false ) );
						d1 = (positive ?  ( ((u64)(x)) )  :  ( ((u64)(-x)) ) );
					} else {
						i16 x = *(((i16*)(pt.args[p_index])));
						positive = (x >= 0 ?  ( true )  :  ( false ) );
						d1 = (positive ?  ( ((u64)(x)) )  :  ( ((u64)(-x)) ) );
					}
				}else if (ch1 == 'l') {
					if (ch2 == 'l') {
						i64 x = *(((i64*)(pt.args[p_index])));
						positive = (x >= 0 ?  ( true )  :  ( false ) );
						d1 = (positive ?  ( ((u64)(x)) )  :  ( ((u64)(-x)) ) );
					} else {
						i64 x = *(((i64*)(pt.args[p_index])));
						positive = (x >= 0 ?  ( true )  :  ( false ) );
						d1 = (positive ?  ( ((u64)(x)) )  :  ( ((u64)(-x)) ) );
					}
				}else {
					int x = *(((int*)(pt.args[p_index])));
					positive = (x >= 0 ?  ( true )  :  ( false ) );
					d1 = (positive ?  ( ((u64)(x)) )  :  ( ((u64)(-x)) ) );
				};
				strings__Builder_write(&res, strconv__format_dec(d1, (strconv__BF_param){
					.positive = positive,
					.pad_ch = pad_ch,
					.len0 = len0,
					.sign_flag = sign,
					.allign = allign,
					.len1 = 6,
					.rm_tail_zero = false,
				}));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				ch1 = '0';
				ch2 = '0';
				continue;
			} else if (ch == 'u') {
				u64 d1 = ((u64)(0));
				bool positive = true;
				if (ch1 == 'h') {
					if (ch2 == 'h') {
						d1 = ((u64)(*(((byte*)(pt.args[p_index])))));
					} else {
						d1 = ((u64)(*(((u16*)(pt.args[p_index])))));
					}
				}else if (ch1 == 'l') {
					if (ch2 == 'l') {
						d1 = ((u64)(*(((u64*)(pt.args[p_index])))));
					} else {
						d1 = ((u64)(*(((u64*)(pt.args[p_index])))));
					}
				}else {
					d1 = ((u64)(*(((u32*)(pt.args[p_index])))));
				};
				strings__Builder_write(&res, strconv__format_dec(d1, (strconv__BF_param){
					.positive = positive,
					.pad_ch = pad_ch,
					.len0 = len0,
					.sign_flag = sign,
					.allign = allign,
					.len1 = 6,
					.rm_tail_zero = false,
				}));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			} else if ((ch == 'x' || ch == 'X')) {
				string s = tos3("");
				if (ch1 == 'h') {
					if (ch2 == 'h') {
						i8 x = *(((i8*)(pt.args[p_index])));
						s = i8_hex(x);
					} else {
						i16 x = *(((i16*)(pt.args[p_index])));
						s = i16_hex(x);
					}
				}else if (ch1 == 'l') {
					if (ch2 == 'l') {
						i64 x = *(((i64*)(pt.args[p_index])));
						s = i64_hex(x);
					} else {
						i64 x = *(((i64*)(pt.args[p_index])));
						s = i64_hex(x);
					}
				}else {
					int x = *(((int*)(pt.args[p_index])));
					s = int_hex(x);
				};
				if (ch == 'X') {
					s = string_to_upper(s);
				}
				strings__Builder_write(&res, strconv__format_str(s, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.allign = allign,
					.len1 = 6,
					.positive = true,
					.sign_flag = false,
					.rm_tail_zero = false,
				}));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			}
			if ((ch == 'f' || ch == 'F')) {
				f64 x = *(((f64*)(pt.args[p_index])));
				bool positive = x >= ((f64)(0.0));
				len1 = (len1 >= 0 ?  ( len1 )  :  ( def_len1 ) );
				string s = strconv__format_fl(((f64)(x)), (strconv__BF_param){
					.positive = positive,
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = len1,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = false,
				});
				strings__Builder_write(&res, (ch == 'F' ?  ( string_to_upper(s) )  :  ( s ) ));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			} else if ((ch == 'e' || ch == 'E')) {
				f64 x = *(((f64*)(pt.args[p_index])));
				bool positive = x >= ((f64)(0.0));
				len1 = (len1 >= 0 ?  ( len1 )  :  ( def_len1 ) );
				string s = strconv__format_es(((f64)(x)), (strconv__BF_param){
					.positive = positive,
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = len1,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = false,
				});
				strings__Builder_write(&res, (ch == 'E' ?  ( string_to_upper(s) )  :  ( s ) ));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			} else if ((ch == 'g' || ch == 'G')) {
				f64 x = *(((f64*)(pt.args[p_index])));
				bool positive = x >= ((f64)(0.0));
				string s = tos3("");
				f64 tx = strconv__fabs(x);
				if (tx < 999999.0 && tx >= 0.00001) {
					len1 = (len1 >= 0 ?  ( len1 + 1 )  :  ( def_len1 ) );
					s = strconv__format_fl(x, (strconv__BF_param){
						.positive = positive,
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.sign_flag = sign,
						.allign = allign,
						.rm_tail_zero = true,
					});
				} else {
					len1 = (len1 >= 0 ?  ( len1 + 1 )  :  ( def_len1 ) );
					s = strconv__format_es(x, (strconv__BF_param){
						.positive = positive,
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.sign_flag = sign,
						.allign = allign,
						.rm_tail_zero = true,
					});
				}
				strings__Builder_write(&res, (ch == 'G' ?  ( string_to_upper(s) )  :  ( s ) ));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 's') {
				string s1 = *(((string*)(pt.args[p_index])));
				pad_ch = ' ';
				strings__Builder_write(&res, strconv__format_str(s1, (strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.allign = allign,
					.len1 = 6,
					.positive = true,
					.sign_flag = false,
					.rm_tail_zero = false,
				}));
				status = strconv__Char_parse_state_reset_params;
				p_index++;
				i++;
				continue;
			}
		}
		status = strconv__Char_parse_state_reset_params;
		p_index++;
		i++;
	}
	return strings__Builder_str(&res);
}

static f64 strconv__fabs(f64 x) {
	if (x < 0.0) {
		return -x;
	}
	return x;
}

static array __new_array(int mylen, int cap, int elm_size) {
	int cap_ = (cap == 0 ?  ( 1 )  :  ( cap ) );
	array arr = (array){
		.len = mylen,
		.cap = cap_,
		.element_size = elm_size,
		.data = vcalloc(cap_ * elm_size),
	};
	return arr;
}

static array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array) {
	int cap_ = (cap == 0 ?  ( 1 )  :  ( cap ) );
	array arr = (array){
		.len = len,
		.cap = cap,
		.element_size = elm_size,
		.data = vcalloc(cap_ * elm_size),
	};
	memcpy(arr.data, c_array, len * elm_size);
	return arr;
}

static array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array) {
	array arr = (array){
		.len = len,
		.cap = cap,
		.element_size = elm_size,
		.data = c_array,
	};
	return arr;
}

// Attr: [inline]
inline static void array_ensure_cap(array* a, int required) {
	if (required <= a->cap) {
		return ;
	}
	int cap = (a->cap == 0 ?  ( 2 )  :  ( a->cap * 2 ) );
	while (required > cap) {
		cap *= 2;
	}
	if (a->cap == 0) {
		a->data = vcalloc(cap * a->element_size);
	} else {
		a->data = realloc(a->data, cap * a->element_size);
	}
	a->cap = cap;
}

array array_repeat(array a, int count) {
	if (count < 0) {
		v_panic(_STR("array.repeat: count is negative: %"PRId32"", 1, count));
	}
	int size = count * a.len * a.element_size;
	if (size == 0) {
		size = a.element_size;
	}
	array arr = (array){
		.len = count * a.len,
		.cap = count * a.len,
		.element_size = a.element_size,
		.data = vcalloc(size),
	};
	for (int tmp3 = 0; tmp3 < count; tmp3++) {
		int i = tmp3;
		memcpy(((byteptr)(arr.data)) + i * a.len * a.element_size, ((byteptr)(a.data)), a.len * a.element_size);
	}
	return arr;
}

void array_sort_with_compare(array* a, voidptr compare) {
	qsort(a->data, a->len, a->element_size, compare);
}

void array_insert(array* a, int i, voidptr val) {
	
// $if !no_bounds_checking {
#ifndef CUSTOM_DEFINE_no_bounds_checking
		if (i < 0 || i > a->len) {
			v_panic(_STR("array.insert: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a->len));
		}
	
// } no_bounds_checking
#endif

	array_ensure_cap(a, a->len + 1);
	int size = a->element_size;
	memmove(((byteptr)(a->data)) + (i + 1) * size, ((byteptr)(a->data)) + i * size, (a->len - i) * size);
	memcpy(((byteptr)(a->data)) + i * size, val, size);
	a->len++;
}

void array_prepend(array* a, voidptr val) {
	array_insert(a, 0, val);
}

void array_delete(array* a, int i) {
	
// $if !no_bounds_checking {
#ifndef CUSTOM_DEFINE_no_bounds_checking
		if (i < 0 || i >= a->len) {
			v_panic(_STR("array.delete: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a->len));
		}
	
// } no_bounds_checking
#endif

	int size = a->element_size;
	memmove(((byteptr)(a->data)) + i * size, ((byteptr)(a->data)) + (i + 1) * size, (a->len - i) * size);
	a->len--;
}

void array_clear(array* a) {
	a->len = 0;
}

void array_trim(array* a, int index) {
	if (index < a->len) {
		a->len = index;
	}
}

static voidptr array_get(array a, int i) {
	
// $if !no_bounds_checking {
#ifndef CUSTOM_DEFINE_no_bounds_checking
		if (i < 0 || i >= a.len) {
			v_panic(_STR("array.get: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a.len));
		}
	
// } no_bounds_checking
#endif

	return ((byteptr)(a.data)) + i * a.element_size;
}

voidptr array_first(array a) {
	
// $if !no_bounds_checking {
#ifndef CUSTOM_DEFINE_no_bounds_checking
		if (a.len == 0) {
			v_panic(tos3("array.first: array is empty"));
		}
	
// } no_bounds_checking
#endif

	return a.data;
}

voidptr array_last(array a) {
	
// $if !no_bounds_checking {
#ifndef CUSTOM_DEFINE_no_bounds_checking
		if (a.len == 0) {
			v_panic(tos3("array.last: array is empty"));
		}
	
// } no_bounds_checking
#endif

	return ((byteptr)(a.data)) + (a.len - 1) * a.element_size;
}

static array array_slice(array a, int start, int _end) {
	int end = _end;
	
// $if !no_bounds_checking {
#ifndef CUSTOM_DEFINE_no_bounds_checking
		if (start > end) {
			v_panic(_STR("array.slice: invalid slice index (%"PRId32"\000 > %"PRId32"\000)", 3, start, end));
		}
		if (end > a.len) {
			v_panic(_STR("array.slice: slice bounds out of range (%"PRId32"\000 >= %"PRId32"\000)", 3, end, a.len));
		}
		if (start < 0) {
			v_panic(_STR("array.slice: slice bounds out of range (%"PRId32"\000 < 0)", 2, start));
		}
	
// } no_bounds_checking
#endif

	int l = end - start;
	array res = (array){
		.element_size = a.element_size,
		.data = ((byteptr)(a.data)) + start * a.element_size,
		.len = l,
		.cap = l,
	};
	return res;
}

static array array_slice2(array a, int start, int _end, bool end_max) {
	int end = (end_max ?  ( a.len )  :  ( _end ) );
	return array_slice(a, start, end);
}

static array array_clone_static(array a) {
	return array_clone(&a);
}

array array_clone(array* a) {
	int size = a->cap * a->element_size;
	if (size == 0) {
		size++;
	}
	array arr = (array){
		.len = a->len,
		.cap = a->cap,
		.element_size = a->element_size,
		.data = vcalloc(size),
	};
	memcpy(((byteptr)(arr.data)), a->data, a->cap * a->element_size);
	return arr;
}

static array array_slice_clone(array* a, int start, int _end) {
	int end = _end;
	
// $if !no_bounds_checking {
#ifndef CUSTOM_DEFINE_no_bounds_checking
		if (start > end) {
			v_panic(_STR("array.slice: invalid slice index (%"PRId32"\000 > %"PRId32"\000)", 3, start, end));
		}
		if (end > a->len) {
			v_panic(_STR("array.slice: slice bounds out of range (%"PRId32"\000 >= %"PRId32"\000)", 3, end, a->len));
		}
		if (start < 0) {
			v_panic(_STR("array.slice: slice bounds out of range (%"PRId32"\000 < 0)", 2, start));
		}
	
// } no_bounds_checking
#endif

	int l = end - start;
	array res = (array){
		.element_size = a->element_size,
		.data = ((byteptr)(a->data)) + start * a->element_size,
		.len = l,
		.cap = l,
	};
	return array_clone(&res);
}

static void array_set(array* a, int i, voidptr val) {
	
// $if !no_bounds_checking {
#ifndef CUSTOM_DEFINE_no_bounds_checking
		if (i < 0 || i >= a->len) {
			v_panic(_STR("array.set: index out of range (i == %"PRId32"\000, a.len == %"PRId32"\000)", 3, i, a->len));
		}
	
// } no_bounds_checking
#endif

	memcpy(((byteptr)(a->data)) + a->element_size * i, val, a->element_size);
}

static void array_push(array* a, voidptr val) {
	array_ensure_cap(a, a->len + 1);
	memcpy(((byteptr)(a->data)) + a->element_size * a->len, val, a->element_size);
	a->len++;
}

void array_push_many(array* a3, voidptr val, int size) {
	if (a3->data == val) {
		array copy = array_clone(a3);
		array_ensure_cap(a3, a3->len + size);
		memcpy(((byteptr)(a3->data)) + a3->element_size * a3->len, copy.data, a3->element_size * size);
	} else {
		array_ensure_cap(a3, a3->len + size);
		memcpy(((byteptr)(a3->data)) + a3->element_size * a3->len, val, a3->element_size * size);
	}
	a3->len += size;
}

array array_reverse(array a) {
	if (a.len < 2) {
		return a;
	}
	array arr = (array){
		.len = a.len,
		.cap = a.cap,
		.element_size = a.element_size,
		.data = vcalloc(a.cap * a.element_size),
	};
	for (int tmp2 = 0; tmp2 < a.len; tmp2++) {
		int i = tmp2;
		memcpy(((byteptr)(arr.data)) + i * arr.element_size, ((byteptr)(a.data)) + (a.len - 1 - i) * arr.element_size, arr.element_size);
	}
	return arr;
}

// Attr: [unsafe_fn]
void array_free(array* a) {
	free(a->data);
}

string array_string_str(array_string a) {
	strings__Builder sb = strings__new_builder(a.len * 3);
	strings__Builder_write(&sb, tos3("["));
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		string val = (*(string*)array_get(a, i));
		strings__Builder_write(&sb, tos3("\'"));
		strings__Builder_write(&sb, val);
		strings__Builder_write(&sb, tos3("\'"));
		if (i < a.len - 1) {
			strings__Builder_write(&sb, tos3(", "));
		}
	}
	strings__Builder_write(&sb, tos3("]"));
	return strings__Builder_str(&sb);
}

string array_byte_hex(array_byte b) {
	byteptr hex = v_malloc(b.len * 2 + 1);
	int dst_i = 0;
	// FOR IN array
	array tmp1 = b;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		byte i = ((byte*)tmp1.data)[tmp2];
		byte n0 = i >> 4;
		hex[dst_i++] = (n0 < 10 ?  ( n0 + '0' )  :  ( n0 + 87 ) );
		byte n1 = (i & 0xF);
		hex[dst_i++] = (n1 < 10 ?  ( n1 + '0' )  :  ( n1 + 87 ) );
	}
	hex[dst_i] = '\0';
	return tos(hex, dst_i);
}

int copy(array_byte dst, array_byte src) {
	if (dst.len > 0 && src.len > 0) {
		int min = 0;
		min = (dst.len < src.len ?  ( dst.len )  :  ( src.len ) );
		memcpy(((byteptr)(dst.data)), array_slice(src, 0, min).data, dst.element_size * min);
		return min;
	}
	return 0;
}

static int compare_ints(int* a, int* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

void array_int_sort(array_int* a) {
	array_sort_with_compare(a, &/*qq*/compare_ints);
}

int array_string_index(array_string a, string v) {
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		if (string_eq((*(string*)array_get(a, i)), v)) {
			return i;
		}
	}
	return -1;
}

int array_int_index(array_int a, int v) {
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		if ((*(int*)array_get(a, i)) == v) {
			return i;
		}
	}
	return -1;
}

int array_byte_index(array_byte a, byte v) {
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		if ((*(byte*)array_get(a, i)) == v) {
			return i;
		}
	}
	return -1;
}

int array_char_index(array_char a, char v) {
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		if ((*(char*)array_get(a, i)) == v) {
			return i;
		}
	}
	return -1;
}

int array_int_reduce(array_int a, int (*iter)(int accum, int curr), int accum_start) {
	int accum_ = accum_start;
	// FOR IN array
	array tmp1 = a;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		int i = ((int*)tmp1.data)[tmp2];
		accum_ = iter(accum_, i);
	}
	return accum_;
}

bool array_string_eq(array_string a1, array_string a2) {
	if (a1.len != a2.len) {
		return false;
	}
	for (int tmp2 = 0; tmp2 < a1.len; tmp2++) {
		int i = tmp2;
		if (string_ne((*(string*)array_get(a1, i)), (*(string*)array_get(a2, i)))) {
			return false;
		}
	}
	return true;
}

int compare_i64(i64* a, i64* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

int compare_f64(f64* a, f64* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

int compare_f32(f32* a, f32* b) {
	if (*a < *b) {
		return -1;
	}
	if (*a > *b) {
		return 1;
	}
	return 0;
}

array_voidptr array_pointers(array a) {
	array_voidptr res = __new_array(0, 0, sizeof(voidptr));
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		array_push(&res, &(voidptr[]){ ((byteptr)(a.data)) + i * a.element_size });
	}
	return res;
}

void v_exit(int code) {
	exit(code);
}

bool isnil(voidptr v) {
	return v == 0;
}

void print_backtrace() {
	print_backtrace_skipping_top_frames(2);
}

static void panic_debug(int line_no, string file, string mod, string fn_name, string s) {
	eprintln(tos3("================ V panic ================"));
	eprintln(_STR("   module: %.*s", 1, mod));
	eprintln(_STR(" function: %.*s\000()", 2, fn_name));
	eprintln(_STR("  message: %.*s", 1, s));
	eprintln(_STR("     file: %.*s", 1, file));
	eprintln(string_add(tos3("     line: "), int_str(line_no)));
	eprintln(tos3("========================================="));
	print_backtrace_skipping_top_frames(1);
	exit(1);
}

void v_panic(string s) {
	eprintln(_STR("V panic: %.*s", 1, s));
	print_backtrace();
	exit(1);
}

void eprintln(string s) {
	if (s.str == 0) {
		eprintln(tos3("eprintln(NIL)"));
	}
	
// $if !windows {
#ifndef _WIN32
		fflush(stdout);
		fflush(stderr);
		fprintf(stderr, "%.*s\n", s.len, s.str);
		fflush(stderr);
		return ;
	
// } windows
#endif

	println(s);
}

void eprint(string s) {
	if (s.str == 0) {
		eprintln(tos3("eprint(NIL)"));
	}
	
// $if !windows {
#ifndef _WIN32
		fflush(stdout);
		fflush(stderr);
		fprintf(stderr, "%.*s", s.len, s.str);
		fflush(stderr);
		return ;
	
// } windows
#endif

	print(s);
}

void print(string s) {
	
// $if  windows {
#ifdef _WIN32
		voidptr output_handle = GetStdHandle(STD_OUTPUT_HANDLE);
		int bytes_written = 0;
		if (is_atty(1) > 0) {
			u16* wide_str = string_to_wide(s);
			int wide_len = wcslen(wide_str);
			WriteConsole(output_handle, wide_str, wide_len, &bytes_written, 0);
		} else {
			WriteFile(output_handle, s.str, s.len, &bytes_written, 0);
		}
	
#else
		printf("%.*s", s.len, s.str);
	
// } windows
#endif

}

static void looo() {
}

// Attr: [unsafe_fn]
byteptr v_malloc(int n) {
	if (n <= 0) {
		v_panic(tos3("malloc(<=0)"));
	}
	
// $if  prealloc {
#ifdef VPREALLOC
		byteptr res = g_m2_ptr;
		g_m2_ptr += n;
		nr_mallocs++;
		return res;
	
#else
		byteptr ptr = malloc(n);
		if (ptr == 0) {
			v_panic(_STR("malloc(%"PRId32"\000) failed", 2, n));
		}
		return ptr;
	
// } prealloc
#endif

}

byteptr v_calloc(int n) {
	return calloc(n, 1);
}

byteptr vcalloc(int n) {
	if (n <= 0) {
		v_panic(tos3("calloc(<=0)"));
	}
	return calloc(n, 1);
}

// Attr: [unsafe_fn]
void v_free(voidptr ptr) {
	free(ptr);
}

voidptr memdup(voidptr src, int sz) {
	if (sz == 0) {
		return vcalloc(1);
	}
	byteptr mem = v_malloc(sz);
	return memcpy(mem, src, sz);
}

static void v_ptr_free(voidptr ptr) {
	free(ptr);
}

int is_atty(int fd) {
	
// $if  windows {
#ifdef _WIN32
		u32 mode = ((u32)(0));
		voidptr osfh = ((voidptr)(_get_osfhandle(fd)));
		GetConsoleMode(osfh, ((voidptr)(&mode)));
		return ((int)(mode));
	
#else
		return isatty(fd);
	
// } windows
#endif

}

static voidptr __as_cast(voidptr obj, int obj_type, int expected_type) {
	if (obj_type != expected_type) {
		v_panic(_STR("as cast: cannot cast %"PRId32"\000 to %"PRId32"", 2, obj_type, expected_type));
	}
	return obj;
}

static void builtin_init() {
}

void println(string s) {
	printf("%.*s\n", s.len, s.str);
}

static bool print_backtrace_skipping_top_frames(int xskipframes) {
	int skipframes = xskipframes + 2;
	
// $if  macos {
#ifdef __APPLE__
		return print_backtrace_skipping_top_frames_mac(skipframes);
	
// } macos
#endif

	
// $if  linux {
#ifdef __linux__
		return print_backtrace_skipping_top_frames_linux(skipframes);
	
// } linux
#endif

	
// $if  freebsd {
#ifdef __FreeBSD__
		return print_backtrace_skipping_top_frames_freebsd(skipframes);
	
// } freebsd
#endif

	
// $if  netbsd {
#ifdef __NetBSD__
		return print_backtrace_skipping_top_frames_freebsd(skipframes);
	
// } netbsd
#endif

	
// $if  openbsd {
#ifdef __OpenBSD__
		return print_backtrace_skipping_top_frames_freebsd(skipframes);
	
// } openbsd
#endif

	println(_STR("print_backtrace_skipping_top_frames is not implemented. skipframes: %"PRId32"", 1, skipframes));
	return false;
}

static bool print_backtrace_skipping_top_frames_mac(int skipframes) {
	
// $if  macos {
#ifdef __APPLE__
		array_fixed_byteptr_100 buffer = {0};
		int nr_ptrs = backtrace(&/*qq*/buffer, 100);
		backtrace_symbols_fd(&buffer[skipframes], nr_ptrs - skipframes, 2);
	
// } macos
#endif

	return true;
}

static bool print_backtrace_skipping_top_frames_freebsd(int skipframes) {
	
// $if  freebsd {
#ifdef __FreeBSD__
		array_fixed_byteptr_100 buffer = {0};
		int nr_ptrs = backtrace(&/*qq*/buffer, 100);
		backtrace_symbols_fd(&buffer[skipframes], nr_ptrs - skipframes, 2);
	
// } freebsd
#endif

	return true;
}

static bool print_backtrace_skipping_top_frames_linux(int skipframes) {
	
// $if  tinyc {
#ifdef __TINYC__
		println(_STR("TODO: print_backtrace_skipping_top_frames_linux %"PRId32"\000 with tcc fails tests with \"stack smashing detected\" .", 2, skipframes));
		return false;
	
// } tinyc
#endif

	
// $if !android {
#ifndef __ANDROID__
		
// $if  glibc {
#ifdef __GLIBC__
			array_fixed_byteptr_100 buffer = {0};
			int nr_ptrs = backtrace(&/*qq*/buffer, 100);
			int nr_actual_frames = nr_ptrs - skipframes;
			array_string sframes = __new_array(0, 0, sizeof(string));
			byteptr* csymbols = backtrace_symbols(&buffer[skipframes], nr_actual_frames);
			for (int tmp1 = 0; tmp1 < nr_actual_frames; tmp1++) {
				int i = tmp1;
				array_push(&sframes, &(string[]){ tos2(((byteptr)(((voidptr)(csymbols[i]))))) });
			}
			// FOR IN array
			array tmp3 = sframes;
			for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
				string sframe = ((string*)tmp3.data)[tmp4];
				string executable = string_all_before(sframe, tos3("("));
				string addr = string_all_before(string_all_after(sframe, tos3("[")), tos3("]"));
				string beforeaddr = string_all_before(sframe, tos3("["));
				string cmd = _STR("addr2line -e %.*s\000 %.*s", 2, executable, addr);
				voidptr f = popen(cmd.str, "r");
				if (isnil(f)) {
					eprintln(sframe);
					continue;
				}
				array_fixed_byte_1000 buf = {0};
				string output = tos3("");
				while (fgets(((charptr)(buf)), 1000, f) != 0) {
					output = string_add(output, tos(&/*qq*/buf, vstrlen(&/*qq*/buf)));
				}
				output = string_add(string_trim_space(output), tos3(":"));
				if (pclose(f) != 0) {
					eprintln(sframe);
					continue;
				}
				if ((string_eq(output, tos3("??:0:")) || string_eq(output, tos3("??:?:")))) {
					output = tos3("");
				}
				output = string_replace(output, tos3(" (discriminator"), tos3(": (d."));
				eprintln(_STR("%*.*s\000 | %*.*s\000 | %.*s", 3, output, -46, addr, 14, beforeaddr));
			}
			return true;
		
#else
			eprintln(tos3("backtrace_symbols_fd is missing, so printing backtraces is not available.\n"));
			eprintln(tos3("Some libc implementations like musl simply do not provide it."));
		
// } glibc
#endif

	
// } android
#endif

	return false;
}













static int backtrace(voidptr a, int b);

static byteptr* backtrace_symbols(voidptr, int);

static void backtrace_symbols_fd(voidptr, int, int);

static int proc_pidpath(int, voidptr, int);



























































































































// Attr: [inline]
inline string f64_str(f64 d) {
	return strconv__ftoa__ftoa_64(d);
}

// Attr: [inline]
inline string f64_strsci(f64 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 17) {
		n_digit = 17;
	}
	return strconv__ftoa__f64_to_str(x, n_digit);
}

// Attr: [inline]
inline string f64_strlong(f64 x) {
	return strconv__ftoa__f64_to_str_l(x);
}

// Attr: [inline]
inline string f32_str(f32 d) {
	return strconv__ftoa__ftoa_32(d);
}

// Attr: [inline]
inline string f32_strsci(f32 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 8) {
		n_digit = 8;
	}
	return strconv__ftoa__f32_to_str(x, n_digit);
}

// Attr: [inline]
inline string f32_strlong(f32 x) {
	return strconv__ftoa__f32_to_str_l(x);
}

// Attr: [inline]
inline static f32 f32_abs(f32 a) {
	return (a < 0 ?  ( -a )  :  ( a ) );
}

// Attr: [inline]
inline static f64 f64_abs(f64 a) {
	return (a < 0 ?  ( -a )  :  ( a ) );
}

// Attr: [inline]
inline bool f64_eq(f64 a, f64 b) {
	return f64_abs(a - b) <= DBL_EPSILON;
}

// Attr: [inline]
inline bool f32_eq(f32 a, f32 b) {
	return f32_abs(a - b) <= FLT_EPSILON;
}

bool f64_eqbit(f64 a, f64 b) {
	return DEFAULT_EQUAL(a, b);
}

bool f32_eqbit(f32 a, f32 b) {
	return DEFAULT_EQUAL(a, b);
}

static bool f64_ne(f64 a, f64 b) {
	return !f64_eq(a, b);
}

static bool f32_ne(f32 a, f32 b) {
	return !f32_eq(a, b);
}

bool f64_nebit(f64 a, f64 b) {
	return DEFAULT_NOT_EQUAL(a, b);
}

bool f32_nebit(f32 a, f32 b) {
	return DEFAULT_NOT_EQUAL(a, b);
}

static bool f64_lt(f64 a, f64 b) {
	return f64_ne(a, b) && f64_ltbit(a, b);
}

static bool f32_lt(f32 a, f32 b) {
	return f32_ne(a, b) && f32_ltbit(a, b);
}

static bool f64_ltbit(f64 a, f64 b) {
	return DEFAULT_LT(a, b);
}

static bool f32_ltbit(f32 a, f32 b) {
	return DEFAULT_LT(a, b);
}

static bool f64_le(f64 a, f64 b) {
	return !f64_gt(a, b);
}

static bool f32_le(f32 a, f32 b) {
	return !f32_gt(a, b);
}

static bool f64_lebit(f64 a, f64 b) {
	return DEFAULT_LE(a, b);
}

static bool f32_lebit(f32 a, f32 b) {
	return DEFAULT_LE(a, b);
}

static bool f64_gt(f64 a, f64 b) {
	return f64_ne(a, b) && f64_gtbit(a, b);
}

static bool f32_gt(f32 a, f32 b) {
	return f32_ne(a, b) && f32_gtbit(a, b);
}

static bool f64_gtbit(f64 a, f64 b) {
	return DEFAULT_GT(a, b);
}

static bool f32_gtbit(f32 a, f32 b) {
	return DEFAULT_GT(a, b);
}

static bool f64_ge(f64 a, f64 b) {
	return !f64_lt(a, b);
}

static bool f32_ge(f32 a, f32 b) {
	return !f32_lt(a, b);
}

static bool f64_gebit(f64 a, f64 b) {
	return DEFAULT_GE(a, b);
}

static bool f32_gebit(f32 a, f32 b) {
	return DEFAULT_GE(a, b);
}

string ptr_str(voidptr ptr) {
	string buf1 = u64_hex(((u64)(ptr)));
	return buf1;
}

// Attr: [inline]
inline string int_str_l(int nn, int max) {
	int n = nn;
	int d = 0;
	if (n == 0) {
		return tos3("0");
	}
	byteptr buf = v_malloc(max + 1);
	bool is_neg = false;
	if (n < 0) {
		n = -n;
		is_neg = true;
	}
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		int n1 = n / 100;
		d = ((n - (n1 * 100)) << 1);
		n = n1;
		buf[index--] = _const_digit_pairs.str[d++];
		buf[index--] = _const_digit_pairs.str[d];
	}
	index++;
	if (d < 20) {
		index++;
	}
	if (is_neg) {
		index--;
		buf[index] = '-';
	}
	memmove(buf, buf + index, (max - index) + 1);
	return tos(buf, (max - index));
}

string i8_str(i8 n) {
	return int_str_l(((int)(n)), 5);
}

string i16_str(i16 n) {
	return int_str_l(((int)(n)), 7);
}

string u16_str(u16 n) {
	return int_str_l(((int)(n)), 7);
}

string int_str(int n) {
	return int_str_l(n, 12);
}

string u32_str(u32 nn) {
	u32 n = nn;
	u32 d = ((u32)(0));
	if (n == 0) {
		return tos3("0");
	}
	int max = 12;
	byteptr buf = v_malloc(max + 1);
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		u32 n1 = n / ((u32)(100));
		d = ((n - (n1 * ((u32)(100)))) << ((u32)(1)));
		n = n1;
		buf[index--] = string_at(_const_digit_pairs, d++);
		buf[index--] = string_at(_const_digit_pairs, d);
	}
	index++;
	if (d < ((u32)(20))) {
		index++;
	}
	memmove(buf, buf + index, (max - index) + 1);
	return tos(buf, (max - index));
}

string i64_str(i64 nn) {
	i64 n = nn;
	i64 d = ((i64)(0));
	if (n == 0) {
		return tos3("0");
	}
	int max = 20;
	byteptr buf = vcalloc(max + 1);
	bool is_neg = false;
	if (n < 0) {
		n = -n;
		is_neg = true;
	}
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		i64 n1 = n / ((i64)(100));
		d = ((n - (n1 * ((i64)(100)))) << ((i64)(1)));
		n = n1;
		buf[index--] = string_at(_const_digit_pairs, d++);
		buf[index--] = string_at(_const_digit_pairs, d);
	}
	index++;
	if (d < ((i64)(20))) {
		index++;
	}
	if (is_neg) {
		index--;
		buf[index] = '-';
	}
	memmove(buf, buf + index, (max - index) + 1);
	return tos(buf, (max - index));
}

string u64_str(u64 nn) {
	u64 n = nn;
	int d = 0;
	if (n == 0) {
		return tos3("0");
	}
	int max = 20;
	byteptr buf = vcalloc(max + 1);
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		u64 n1 = n / 100;
		d = ((n - (n1 * 100)) << 1);
		n = n1;
		buf[index--] = string_at(_const_digit_pairs, d++);
		buf[index--] = string_at(_const_digit_pairs, d);
	}
	index++;
	if (d < 20) {
		index++;
	}
	memmove(buf, buf + index, (max - index) + 1);
	return tos(buf, (max - index));
}

string bool_str(bool b) {
	if (b) {
		return tos3("true");
	}
	return tos3("false");
}

string byte_hex(byte nn) {
	if (nn == 0) {
		return tos3("0");
	}
	byte n = nn;
	int max = 2;
	byteptr buf = v_malloc(max + 1);
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		byte d = (n & 0xF);
		n = n >> 4;
		buf[index--] = (d < 10 ?  ( d + '0' )  :  ( d + 87 ) );
	}
	index++;
	return tos(buf + index, (max - index));
}

string i8_hex(i8 nn) {
	return byte_hex(((byte)(nn)));
}

string u16_hex(u16 nn) {
	if (nn == 0) {
		return tos3("0");
	}
	u16 n = nn;
	int max = 5;
	byteptr buf = v_malloc(max + 1);
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		u16 d = (n & 0xF);
		n = n >> 4;
		buf[index--] = (d < 10 ?  ( d + '0' )  :  ( d + 87 ) );
	}
	index++;
	return tos(buf + index, (max - index));
}

string i16_hex(i16 nn) {
	return u16_hex(((u16)(nn)));
}

string u32_hex(u32 nn) {
	if (nn == 0) {
		return tos3("0");
	}
	u32 n = nn;
	int max = 10;
	byteptr buf = v_malloc(max + 1);
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		u32 d = (n & 0xF);
		n = n >> 4;
		buf[index--] = (d < 10 ?  ( d + '0' )  :  ( d + 87 ) );
	}
	index++;
	return tos(buf + index, (max - index));
}

string int_hex(int nn) {
	return u32_hex(((u32)(nn)));
}

string u64_hex(u64 nn) {
	if (nn == 0) {
		return tos3("0");
	}
	u64 n = nn;
	int max = 18;
	byteptr buf = v_malloc(max + 1);
	int index = max;
	buf[index--] = '\0';
	while (n > 0) {
		u64 d = (n & 0xF);
		n = n >> 4;
		buf[index--] = (d < 10 ?  ( d + '0' )  :  ( d + 87 ) );
	}
	index++;
	memmove(buf, buf + index, (max - index) + 1);
	return tos(buf, (max - index));
}

string i64_hex(i64 nn) {
	return u64_hex(((u64)(nn)));
}

string voidptr_str(voidptr nn) {
	return u64_hex(((u64)(nn)));
}

string byteptr_str(byteptr nn) {
	return u64_hex(((u64)(nn)));
}

bool array_byte_contains(array_byte a, byte val) {
	// FOR IN array
	array tmp1 = a;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		byte aa = ((byte*)tmp1.data)[tmp2];
		if (aa == val) {
			return true;
		}
	}
	return false;
}

string byte_str(byte c) {
	string str = (string){
		.len = 1,
		.str = v_malloc(2),
	};
	str.str[0] = c;
	str.str[1] = '\0';
	return str;
}

bool byte_is_capital(byte c) {
	return c >= 'A' && c <= 'Z';
}

array_byte array_byte_clone(array_byte b) {
	array_byte res = array_repeat(new_array_from_c_array(1, 1, sizeof(byte), (byte[1]){
		((byte)(0)), 
}), b.len);
	for (int tmp1 = 0; tmp1 < b.len; tmp1++) {
		int i = tmp1;
		array_set(&res, i, &(byte[]) { (*(byte*)array_get(b, i)) });
	}
	return res;
}


// Attr: [inline]
inline static bool fast_string_eq(string a, string b) {
	if (a.len != b.len) {
		return false;
	}
	return memcmp(a.str, b.str, b.len) == 0;
}

// Attr: [inline]
// Attr: [unsafe_fn]
static DenseArray new_dense_array(int value_bytes) {
	return (DenseArray){
		.value_bytes = value_bytes,
		.cap = 8,
		.size = 0,
		.deletes = 0,
		.keys = ((string*)(v_malloc(8 * sizeof(string)))),
		.values = v_malloc(8 * value_bytes),
	};
}

// Attr: [inline]
inline static u32 DenseArray_push(DenseArray* d, string key, voidptr value) {
	if (d->cap == d->size) {
		d->cap += d->cap >> 3;
		d->keys = ((string*)(realloc(d->keys, sizeof(string) * d->cap)));
		d->values = realloc(d->values, d->value_bytes * d->cap);
	}
	u32 push_index = d->size;
	d->keys[push_index] = key;
	memcpy(d->values + push_index * d->value_bytes, value, d->value_bytes);
	d->size++;
	return push_index;
}

static voidptr DenseArray_get(DenseArray d, int i) {
	
// $if !no_bounds_checking {
#ifndef CUSTOM_DEFINE_no_bounds_checking
		if (i < 0 || i >= d.size) {
			v_panic(_STR("DenseArray.get: index out of range (i == %"PRId32"\000, d.len == %"PRIu32"\000)", 3, i, d.size));
		}
	
// } no_bounds_checking
#endif

	return ((byteptr)(d.keys)) + i * sizeof(string);
}

static void DenseArray_zeros_to_end(DenseArray* d) {
	byteptr tmp_value = v_malloc(d->value_bytes);
	u32 count = ((u32)(0));
	for (int tmp1 = 0; tmp1 < d->size; tmp1++) {
		int i = tmp1;
		if (d->keys[i].str != 0) {
			string tmp_key = d->keys[count];
			d->keys[count] = d->keys[i];
			d->keys[i] = tmp_key;
			memcpy(tmp_value, d->values + count * d->value_bytes, d->value_bytes);
			memcpy(d->values + count * d->value_bytes, d->values + i * d->value_bytes, d->value_bytes);
			memcpy(d->values + i * d->value_bytes, tmp_value, d->value_bytes);
			count++;
		}
	}
	v_free(tmp_value);
	d->deletes = 0;
	d->size = count;
	d->cap = (count < 8 ?  ( ((u32)(8)) )  :  ( count ) );
	d->keys = ((string*)(realloc(d->keys, sizeof(string) * d->cap)));
	d->values = realloc(d->values, d->value_bytes * d->cap);
}

static map new_map_1(int value_bytes) {
	return (map){
		.value_bytes = value_bytes,
		.cap = _const_init_cap,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array(value_bytes),
		.metas = ((u32*)(vcalloc(sizeof(u32) * (_const_init_capicity + _const_extra_metas_inc)))),
		.extra_metas = _const_extra_metas_inc,
		.size = 0,
	};
}

static map new_map_init(int n, int value_bytes, string* keys, voidptr values) {
	map out = new_map_1(value_bytes);
	for (int tmp1 = 0; tmp1 < n; tmp1++) {
		int i = tmp1;
		map_set(&out, keys[i], ((byteptr)(values)) + i * value_bytes);
	}
	return out;
}

// Attr: [inline]
inline static multi_return_u32_u32 map_key_to_index(map* m, string key) {
	u64 hash = hash__wyhash__wyhash_c(key.str, ((u64)(key.len)), 0);
	u64 index = (hash & m->cap);
	u64 meta = ((((hash >> m->shift) & _const_hash_mask)) | _const_probe_inc);
	return (multi_return_u32_u32){.arg0=((u32)(index)),.arg1=((u32)(meta))};
}

// Attr: [inline]
inline static multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas) {
	u32 index = _index;
	u32 meta = _metas;
	while (meta < m->metas[index]) {
		index += 2;
		meta += _const_probe_inc;
	}
	return (multi_return_u32_u32){.arg0=index,.arg1=meta};
}

// Attr: [inline]
inline static void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi) {
	u32 meta = _metas;
	u32 index = _index;
	u32 kv_index = kvi;
	while (m->metas[index] != 0) {
		if (meta > m->metas[index]) {
			u32 tmp_meta = m->metas[index];
			m->metas[index] = meta;
			meta = tmp_meta;
			u32 tmp_index = m->metas[index + 1];
			m->metas[index + 1] = kv_index;
			kv_index = tmp_index;
		}
		index += 2;
		meta += _const_probe_inc;
	}
	m->metas[index] = meta;
	m->metas[index + 1] = kv_index;
	u32 probe_count = (meta >> _const_hashbits) - 1;
	if ((probe_count << 1) == m->extra_metas) {
		m->extra_metas += _const_extra_metas_inc;
		u32 mem_size = (m->cap + 2 + m->extra_metas);
		m->metas = ((u32*)(realloc(m->metas, sizeof(u32) * mem_size)));
		memset(m->metas + mem_size - _const_extra_metas_inc, 0, sizeof(u32) * _const_extra_metas_inc);
		if (probe_count == 252) {
			v_panic(tos3("Probe overflow"));
		}
	}
}

static void map_set(map* m, string key, voidptr value) {
	f32 load_factor = ((f32)(m->size << 1)) / ((f32)(m->cap));
	if (load_factor > _const_max_load_factor) {
		map_expand(m);
	}
	multi_return_u32_u32 mr_8621 = map_key_to_index(m, key);
	u32 index = mr_8621.arg0;
	u32 meta = mr_8621.arg1;
	multi_return_u32_u32 mr_8655 = map_meta_less(m, index, meta);
	index = mr_8655.arg0;
	meta = mr_8655.arg1;
	while (meta == m->metas[index]) {
		u32 kv_index = m->metas[index + 1];
		if (fast_string_eq(key, m->key_values.keys[kv_index])) {
			memcpy(m->key_values.values + kv_index * m->value_bytes, value, m->value_bytes);
			return ;
		}
		index += 2;
		meta += _const_probe_inc;
	}
	u32 kv_index = DenseArray_push(&m->key_values, key, value);
	map_meta_greater(m, index, meta, kv_index);
	m->size++;
}

static void map_expand(map* m) {
	u32 old_cap = m->cap;
	m->cap = ((m->cap + 2) << 1) - 2;
	if (m->cached_hashbits == 0) {
		m->shift += _const_max_cached_hashbits;
		m->cached_hashbits = _const_max_cached_hashbits;
		map_rehash(m);
	} else {
		map_cached_rehash(m, old_cap);
		m->cached_hashbits--;
	}
}

static void map_rehash(map* m) {
	int meta_bytes = sizeof(u32) * (m->cap + 2 + m->extra_metas);
	m->metas = ((u32*)(realloc(m->metas, meta_bytes)));
	memset(m->metas, 0, meta_bytes);
	for (u32 i = ((u32)(0));
	i < m->key_values.size; i++) {
		if (m->key_values.keys[i].str == 0) {
			continue;
		}
		multi_return_u32_u32 mr_9675 = map_key_to_index(m, m->key_values.keys[i]);
		u32 index = mr_9675.arg0;
		u32 meta = mr_9675.arg1;
		multi_return_u32_u32 mr_9727 = map_meta_less(m, index, meta);
		index = mr_9727.arg0;
		meta = mr_9727.arg1;
		map_meta_greater(m, index, meta, i);
	}
}

static void map_cached_rehash(map* m, u32 old_cap) {
	u32* old_metas = m->metas;
	m->metas = ((u32*)(vcalloc(sizeof(u32) * (m->cap + 2 + m->extra_metas))));
	u32 old_extra_metas = m->extra_metas;
	for (u32 i = ((u32)(0));
	i <= old_cap + old_extra_metas; i += 2) {
		if (old_metas[i] == 0) {
			continue;
		}
		u32 old_meta = old_metas[i];
		u32 old_probe_count = ((old_meta >> _const_hashbits) - 1) << 1;
		u32 old_index = ((i - old_probe_count) & (m->cap >> 1));
		u32 index = (((old_index | (old_meta << m->shift))) & m->cap);
		u32 meta = (((old_meta & _const_hash_mask)) | _const_probe_inc);
		multi_return_u32_u32 mr_10308 = map_meta_less(m, index, meta);
		index = mr_10308.arg0;
		meta = mr_10308.arg1;
		u32 kv_index = old_metas[i + 1];
		map_meta_greater(m, index, meta, kv_index);
	}
		v_free(old_metas);
}

static voidptr map_get3(map m, string key, voidptr zero) {
	multi_return_u32_u32 mr_10515 = map_key_to_index(&m, key);
	u32 index = mr_10515.arg0;
	u32 meta = mr_10515.arg1;
	multi_return_u32_u32 mr_10549 = map_meta_less(&m, index, meta);
	index = mr_10549.arg0;
	meta = mr_10549.arg1;
	while (meta == m.metas[index]) {
		u32 kv_index = m.metas[index + 1];
		if (fast_string_eq(key, m.key_values.keys[kv_index])) {
			return ((voidptr)(m.key_values.values + kv_index * m.value_bytes));
		}
		index += 2;
		meta += _const_probe_inc;
	}
	return zero;
}

static bool map_exists(map m, string key) {
	multi_return_u32_u32 mr_10875 = map_key_to_index(&m, key);
	u32 index = mr_10875.arg0;
	u32 meta = mr_10875.arg1;
	multi_return_u32_u32 mr_10909 = map_meta_less(&m, index, meta);
	index = mr_10909.arg0;
	meta = mr_10909.arg1;
	while (meta == m.metas[index]) {
		u32 kv_index = m.metas[index + 1];
		if (fast_string_eq(key, m.key_values.keys[kv_index])) {
			return true;
		}
		index += 2;
		meta += _const_probe_inc;
	}
	return false;
}

void map_delete(map* m, string key) {
	multi_return_u32_u32 mr_11188 = map_key_to_index(m, key);
	u32 index = mr_11188.arg0;
	u32 meta = mr_11188.arg1;
	multi_return_u32_u32 mr_11222 = map_meta_less(m, index, meta);
	index = mr_11222.arg0;
	meta = mr_11222.arg1;
	while (meta == m->metas[index]) {
		u32 kv_index = m->metas[index + 1];
		if (fast_string_eq(key, m->key_values.keys[kv_index])) {
			while ((m->metas[index + 2] >> _const_hashbits) > 1) {
				m->metas[index] = m->metas[index + 2] - _const_probe_inc;
				m->metas[index + 1] = m->metas[index + 3];
				index += 2;
			}
			m->size--;
			m->metas[index] = 0;
			m->key_values.deletes++;
			memset(&m->key_values.keys[kv_index], 0, sizeof(string));
			if (m->key_values.size <= 32) {
				return ;
			}
			if (m->key_values.deletes >= (m->key_values.size >> 1)) {
				DenseArray_zeros_to_end(&m->key_values);
				map_rehash(m);
				m->key_values.deletes = 0;
			}
			return ;
		}
		index += 2;
		meta += _const_probe_inc;
	}
}

array_string map_keys(map* m) {
	array_string keys = array_repeat(new_array_from_c_array(1, 1, sizeof(string), (string[1]){
		tos3(""), 
}), m->size);
	int j = 0;
	for (u32 i = ((u32)(0));
	i < m->key_values.size; i++) {
		if (m->key_values.keys[i].str == 0) {
			continue;
		}
		array_set(&keys, j, &(string[]) { m->key_values.keys[i] });
		j++;
	}
	return keys;
}

// Attr: [unsafe_fn]
void map_free(map* m) {
	v_free(m->metas);
	for (u32 i = ((u32)(0));
	i < m->key_values.size; i++) {
		if (m->key_values.keys[i].str == 0) {
			continue;
		}
		string_free(&m->key_values.keys[i]);
	}
	v_free(m->key_values.keys);
	v_free(m->key_values.values);
}

string map_string_str(map_string m) {
	if (m.size == 0) {
		return tos3("{}");
	}
	strings__Builder sb = strings__new_builder(50);
	strings__Builder_writeln(&sb, tos3("{"));
	strings__Builder_writeln(&sb, tos3("}"));
	return strings__Builder_str(&sb);
}

string Option_str(Option o) {
	if (o.ok && !o.is_none) {
		return string_add(string_add(tos3("Option{ data: "), array_byte_hex(array_slice(new_array_from_c_array(_ARR_LEN(o.data), _ARR_LEN(o.data), sizeof(o.data[0]), o.data), 0, 32))), tos3(" }"));
	}
	if (o.is_none) {
		return tos3("Option{ none }");
	}
	return _STR("Option{ error: \"%.*s\000\" }", 2, o.v_error);
}

static Option opt_ok(voidptr data, int size) {
	if (size >= 400) {
		v_panic(_STR("option size too big: %"PRId32"\000 (max is 400), this is a temporary limit", 2, size));
	}
	Option res = (Option){
		.ok = true,
		.data = {0},
		.v_error = (string){.str=""},
		.ecode = 0,
		.is_none = 0,
	};
	memcpy(res.data, data, size);
	return res;
}

static Option opt_none() {
	return (Option){
		.is_none = true,
		.data = {0},
		.v_error = (string){.str=""},
		.ecode = 0,
		.ok = 0,
	};
}

Option v_error(string s) {
	return (Option){
		.v_error = s,
		.data = {0},
		.ecode = 0,
		.ok = 0,
		.is_none = 0,
	};
}

Option error_with_code(string s, int code) {
	return (Option){
		.v_error = s,
		.ecode = code,
		.data = {0},
		.ok = 0,
		.is_none = 0,
	};
}

static SortedMap new_sorted_map(int n, int value_bytes) {
	return (SortedMap){
		.value_bytes = value_bytes,
		.root = new_node(),
		.size = 0,
	};
}

static SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values) {
	SortedMap out = new_sorted_map(n, value_bytes);
	for (int tmp1 = 0; tmp1 < n; tmp1++) {
		int i = tmp1;
		SortedMap_set(&out, keys[i], ((byteptr)(values)) + i * value_bytes);
	}
	return out;
}

static mapnode* new_node() {
	return (mapnode*)memdup(&(mapnode){	.children = 0,
		.size = 0,
		.keys = {0},
		.values = {0},
	}, sizeof(mapnode));
}

static void SortedMap_set(SortedMap* m, string key, voidptr value) {
	mapnode* node = m->root;
	int child_index = 0;
	mapnode* parent = ((mapnode*)(0));
	while (1) {
		if (node->size == _const_max_size) {
			if (isnil(parent)) {
				parent = new_node();
				m->root = parent;
			}
			mapnode_split_child(parent, child_index, node);
			if (string_eq(key, parent->keys[child_index])) {
				memcpy(parent->values[child_index], value, m->value_bytes);
				return ;
			}
			node = (string_lt(key, parent->keys[child_index]) ?  ( ((mapnode*)(parent->children[child_index])) )  :  ( ((mapnode*)(parent->children[child_index + 1])) ) );
		}
		int i = 0;
		while (i < node->size && string_gt(key, node->keys[i])) {
			i++;
		}
		if (i != node->size && string_eq(key, node->keys[i])) {
			memcpy(node->values[i], value, m->value_bytes);
			return ;
		}
		if (isnil(node->children)) {
			int j = node->size - 1;
			while (j >= 0 && string_lt(key, node->keys[j])) {
				node->keys[j + 1] = node->keys[j];
				node->values[j + 1] = node->values[j];
				j--;
			}
			node->keys[j + 1] = key;
			node->values[j + 1] = v_malloc(m->value_bytes);
			memcpy(node->values[j + 1], value, m->value_bytes);
			node->size++;
			m->size++;
			return ;
		}
		parent = node;
		child_index = i;
		node = ((mapnode*)(node->children[child_index]));
	}
}

static void mapnode_split_child(mapnode* n, int child_index, mapnode* y) {
	mapnode* z = new_node();
	z->size = _const_mid_index;
	y->size = _const_mid_index;
	for (int j = _const_mid_index - 1;
	j >= 0; j--) {
		z->keys[j] = y->keys[j + _const_degree];
		z->values[j] = y->values[j + _const_degree];
	}
	if (!isnil(y->children)) {
		z->children = ((voidptr*)(v_malloc(_const_children_bytes)));
		for (int jj = _const_degree - 1;
		jj >= 0; jj--) {
			z->children[jj] = y->children[jj + _const_degree];
		}
	}
	if (isnil(n->children)) {
		n->children = ((voidptr*)(v_malloc(_const_children_bytes)));
	}
	n->children[n->size + 1] = n->children[n->size];
	for (int j = n->size;
	j > child_index; j--) {
		n->keys[j] = n->keys[j - 1];
		n->values[j] = n->values[j - 1];
		n->children[j] = n->children[j - 1];
	}
	n->keys[child_index] = y->keys[_const_mid_index];
	n->values[child_index] = y->values[_const_mid_index];
	n->children[child_index] = ((voidptr)(y));
	n->children[child_index + 1] = ((voidptr)(z));
	n->size++;
}

static bool SortedMap_get(SortedMap m, string key, voidptr out) {
	mapnode* node = m.root;
	while (1) {
		int i = node->size - 1;
		while (i >= 0 && string_lt(key, node->keys[i])) {
			i--;
		}
		if (i != -1 && string_eq(key, node->keys[i])) {
			memcpy(out, node->values[i], m.value_bytes);
			return true;
		}
		if (isnil(node->children)) {
			break;
		}
		node = ((mapnode*)(node->children[i + 1]));
	}
	return false;
}

static bool SortedMap_exists(SortedMap m, string key) {
	if (isnil(m.root)) {
		return false;
	}
	mapnode* node = m.root;
	while (1) {
		int i = node->size - 1;
		while (i >= 0 && string_lt(key, node->keys[i])) {
			i--;
		}
		if (i != -1 && string_eq(key, node->keys[i])) {
			return true;
		}
		if (isnil(node->children)) {
			break;
		}
		node = ((mapnode*)(node->children[i + 1]));
	}
	return false;
}

static int mapnode_find_key(mapnode* n, string k) {
	int idx = 0;
	while (idx < n->size && string_lt(n->keys[idx], k)) {
		idx++;
	}
	return idx;
}

static bool mapnode_remove_key(mapnode* n, string k) {
	int idx = mapnode_find_key(n, k);
	if (idx < n->size && string_eq(n->keys[idx], k)) {
		if (isnil(n->children)) {
			mapnode_remove_from_leaf(n, idx);
		} else {
			mapnode_remove_from_non_leaf(n, idx);
		}
		return true;
	} else {
		if (isnil(n->children)) {
			return false;
		}
		bool flag = (idx == n->size ?  ( true )  :  ( false ) );
		if ((((mapnode*)(n->children[idx])))->size < _const_degree) {
			mapnode_fill(n, idx);
		}
		if (flag && idx > n->size) {
			return mapnode_remove_key((((mapnode*)(n->children[idx - 1]))), k);
		} else {
			return mapnode_remove_key((((mapnode*)(n->children[idx]))), k);
		}
	}
}

static void mapnode_remove_from_leaf(mapnode* n, int idx) {
	for (int i = idx + 1;
	i < n->size; i++) {
		n->keys[i - 1] = n->keys[i];
		n->values[i - 1] = n->values[i];
	}
	n->size--;
}

static void mapnode_remove_from_non_leaf(mapnode* n, int idx) {
	string k = n->keys[idx];
	if (((mapnode*)(n->children[idx]))->size >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx]));
		while (!isnil(current->children)) {
			current = ((mapnode*)(current->children[current->size]));
		}
		string predecessor = current->keys[current->size - 1];
		n->keys[idx] = predecessor;
		n->values[idx] = current->values[current->size - 1];
		mapnode_remove_key((((mapnode*)(n->children[idx]))), predecessor);
	} else if (((mapnode*)(n->children[idx + 1]))->size >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx + 1]));
		while (!isnil(current->children)) {
			current = ((mapnode*)(current->children[0]));
		}
		string successor = current->keys[0];
		n->keys[idx] = successor;
		n->values[idx] = current->values[0];
		mapnode_remove_key((((mapnode*)(n->children[idx + 1]))), successor);
	} else {
		mapnode_merge(n, idx);
		mapnode_remove_key((((mapnode*)(n->children[idx]))), k);
	}
}

static void mapnode_fill(mapnode* n, int idx) {
	if (idx != 0 && ((mapnode*)(n->children[idx - 1]))->size >= _const_degree) {
		mapnode_borrow_from_prev(n, idx);
	} else if (idx != n->size && ((mapnode*)(n->children[idx + 1]))->size >= _const_degree) {
		mapnode_borrow_from_next(n, idx);
	} else if (idx != n->size) {
		mapnode_merge(n, idx);
	} else {
		mapnode_merge(n, idx - 1);
	}
}

static void mapnode_borrow_from_prev(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx - 1]));
	for (int i = child->size - 1;
	i >= 0; i--) {
		child->keys[i + 1] = child->keys[i];
		child->values[i + 1] = child->values[i];
	}
	if (!isnil(child->children)) {
		for (int i = child->size;
		i >= 0; i--) {
			child->children[i + 1] = child->children[i];
		}
	}
	child->keys[0] = n->keys[idx - 1];
	child->values[0] = n->values[idx - 1];
	if (!isnil(child->children)) {
		child->children[0] = sibling->children[sibling->size];
	}
	n->keys[idx - 1] = sibling->keys[sibling->size - 1];
	n->values[idx - 1] = sibling->values[sibling->size - 1];
	child->size++;
	sibling->size--;
}

static void mapnode_borrow_from_next(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx + 1]));
	child->keys[child->size] = n->keys[idx];
	child->values[child->size] = n->values[idx];
	if (!isnil(child->children)) {
		child->children[child->size + 1] = sibling->children[0];
	}
	n->keys[idx] = sibling->keys[0];
	n->values[idx] = sibling->values[0];
	for (int i = 1;
	i < sibling->size; i++) {
		sibling->keys[i - 1] = sibling->keys[i];
		sibling->values[i - 1] = sibling->values[i];
	}
	if (!isnil(sibling->children)) {
		for (int i = 1;
		i <= sibling->size; i++) {
			sibling->children[i - 1] = sibling->children[i];
		}
	}
	child->size++;
	sibling->size--;
}

static void mapnode_merge(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx + 1]));
	child->keys[_const_mid_index] = n->keys[idx];
	child->values[_const_mid_index] = n->values[idx];
	for (int tmp1 = 0; tmp1 < sibling->size; tmp1++) {
		int i = tmp1;
		child->keys[i + _const_degree] = sibling->keys[i];
		child->values[i + _const_degree] = sibling->values[i];
	}
	if (!isnil(child->children)) {
		for (int i = 0;
		i <= sibling->size; i++) {
			child->children[i + _const_degree] = sibling->children[i];
		}
	}
	for (int i = idx + 1;
	i < n->size; i++) {
		n->keys[i - 1] = n->keys[i];
		n->values[i - 1] = n->values[i];
	}
	for (int i = idx + 2;
	i <= n->size; i++) {
		n->children[i - 1] = n->children[i];
	}
	child->size += sibling->size + 1;
	n->size--;
}

void SortedMap_delete(SortedMap* m, string key) {
	if (m->root->size == 0) {
		return ;
	}
	bool removed = mapnode_remove_key(m->root, key);
	if (removed) {
		m->size--;
	}
	if (m->root->size == 0) {
		if (isnil(m->root->children)) {
			return ;
		} else {
			m->root = ((mapnode*)(m->root->children[0]));
		}
	}
}

static int mapnode_subkeys(mapnode* n, array_string* keys, int at) {
	int position = at;
	if (!isnil(n->children)) {
		for (int tmp2 = 0; tmp2 < n->size; tmp2++) {
			int i = tmp2;
			mapnode* child = ((mapnode*)(n->children[i]));
			position += mapnode_subkeys(child, keys, position);
			array_set(keys, position, &(string[]) { n->keys[i] });
			position++;
		}
		mapnode* child = ((mapnode*)(n->children[n->size]));
		position += mapnode_subkeys(child, keys, position);
	} else {
		for (int tmp3 = 0; tmp3 < n->size; tmp3++) {
			int i = tmp3;
			array_set(keys, position + i, &(string[]) { n->keys[i] });
		}
		position += n->size;
	}
	return position - at;
}

array_string SortedMap_keys(SortedMap* m) {
	array_string keys = array_repeat(new_array_from_c_array(1, 1, sizeof(string), (string[1]){
		tos3(""), 
}), m->size);
	if (isnil(m->root) || m->root->size == 0) {
		return keys;
	}
	mapnode_subkeys(m->root, &/*111*/(array[]){keys}[0], 0);
	return keys;
}

static void mapnode_free(mapnode* n) {
	println(tos3("TODO"));
}

void SortedMap_free(SortedMap* m) {
	if (isnil(m->root)) {
		return ;
	}
	mapnode_free(m->root);
}

void SortedMap_print(SortedMap m) {
	println(tos3("TODO"));
}

int vstrlen(byteptr s) {
	return strlen(((charptr)(s)));
}

string tos(byteptr s, int len) {
	if (s == 0) {
		v_panic(tos3("tos(): nil string"));
	}
	return (string){
		.str = s,
		.len = len,
	};
}

string tos_clone(byteptr s) {
	if (s == 0) {
		v_panic(tos3("tos: nil string"));
	}
	return string_clone(tos2(s));
}

string tos2(byteptr s) {
	if (s == 0) {
		v_panic(tos3("tos2: nil string"));
	}
	return (string){
		.str = s,
		.len = vstrlen(s),
	};
}

string tos3(charptr s) {
	if (s == 0) {
		v_panic(tos3("tos3: nil string"));
	}
	return (string){
		.str = ((byteptr)(s)),
		.len = strlen(s),
	};
}

static string string_clone_static(string a) {
	return string_clone(a);
}

string string_clone(string a) {
	string b = (string){
		.len = a.len,
		.str = v_malloc(a.len + 1),
	};
	for (int tmp1 = 0; tmp1 < a.len; tmp1++) {
		int i = tmp1;
		b.str[i] = a.str[i];
	}
	b.str[a.len] = '\0';
	return b;
}

string cstring_to_vstring(byteptr cstr) {
	int slen = strlen(cstr);
	byteptr s = ((byteptr)(memdup(cstr, slen + 1)));
	s[slen] = '\0';
	return tos(s, slen);
}

string string_replace_once(string s, string rep, string with) {
	Option_int index = string_index(s, rep);
	if (!index.ok) {
		string err = index.v_error;
		int errcode = index.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return s;
	};
	return string_add(string_add(string_substr(s, 0, /*opt*/(*(int*)index.data)), with), string_substr(s, /*opt*/(*(int*)index.data) + rep.len, s.len));
}

string string_replace(string s, string rep, string with) {
	if (s.len == 0 || rep.len == 0) {
		return s;
	}
	array_int idxs = __new_array(0, 0, sizeof(int));
	int idx = 0;
	while (1) {
		idx = string_index_after(s, rep, idx);
		if (idx == -1) {
			break;
		}
		array_push(&idxs, &(int[]){ idx });
		idx += rep.len;
	}
	if (idxs.len == 0) {
		return s;
	}
	int new_len = s.len + idxs.len * (with.len - rep.len);
	byteptr b = v_malloc(new_len + 1);
	int idx_pos = 0;
	int cur_idx = (*(int*)array_get(idxs, idx_pos));
	int b_i = 0;
	for (int i = 0;
	i < s.len; i++) {
		if (i == cur_idx) {
			for (int tmp6 = 0; tmp6 < with.len; tmp6++) {
				int j = tmp6;
				b[b_i] = string_at(with, j);
				b_i++;
			}
			i += rep.len - 1;
			idx_pos++;
			if (idx_pos < idxs.len) {
				cur_idx = (*(int*)array_get(idxs, idx_pos));
			}
		} else {
			b[b_i] = string_at(s, i);
			b_i++;
		}
	}
	b[new_len] = '\0';
	return tos(b, new_len);
}

static int compare_rep_index(RepIndex* a, RepIndex* b) {
	if (a->idx < b->idx) {
		return -1;
	}
	if (a->idx > b->idx) {
		return 1;
	}
	return 0;
}

static void array_RepIndex_sort(array_RepIndex* a) {
	array_sort_with_compare(a, &/*qq*/compare_rep_index);
}

string string_replace_each(string s, array_string vals) {
	if (s.len == 0 || vals.len == 0) {
		return s;
	}
	if (vals.len % 2 != 0) {
		println(tos3("string.replace_each(): odd number of strings"));
		return s;
	}
	int new_len = s.len;
	array_RepIndex idxs = __new_array(0, 0, sizeof(RepIndex));
	int idx = 0;
	for (int rep_i = 0;
	rep_i < vals.len; rep_i += 2) {
		string rep = (*(string*)array_get(vals, rep_i));
		string with = (*(string*)array_get(vals, rep_i + 1));
		while (1) {
			idx = string_index_after(s, rep, idx);
			if (idx == -1) {
				break;
			}
			array_push(&idxs, &(RepIndex[]){ (RepIndex){
				.idx = idx,
				.val_idx = rep_i,
			} });
			idx++;
			new_len += with.len - rep.len;
		}
	}
	if (idxs.len == 0) {
		return s;
	}
	array_RepIndex_sort(&idxs);
	byteptr b = v_malloc(new_len + 1);
	int idx_pos = 0;
	RepIndex cur_idx = (*(RepIndex*)array_get(idxs, idx_pos));
	int b_i = 0;
	for (int i = 0;
	i < s.len; i++) {
		if (i == cur_idx.idx) {
			string rep = (*(string*)array_get(vals, cur_idx.val_idx));
			string with = (*(string*)array_get(vals, cur_idx.val_idx + 1));
			for (int tmp7 = 0; tmp7 < with.len; tmp7++) {
				int j = tmp7;
				b[b_i] = string_at(with, j);
				b_i++;
			}
			i += rep.len - 1;
			idx_pos++;
			if (idx_pos < idxs.len) {
				cur_idx = (*(RepIndex*)array_get(idxs, idx_pos));
			}
		} else {
			b[b_i] = s.str[i];
			b_i++;
		}
	}
	b[new_len] = '\0';
	return tos(b, new_len);
}

bool string_bool(string s) {
	return string_eq(s, tos3("true")) || string_eq(s, tos3("t"));
}

int string_int(string s) {
	return ((int)(strconv__common_parse_int(s, 0, 32, false, false)));
}

i64 string_i64(string s) {
	return strconv__common_parse_int(s, 0, 64, false, false);
}

i8 string_i8(string s) {
	return ((i8)(strconv__common_parse_int(s, 0, 8, false, false)));
}

i16 string_i16(string s) {
	return ((i16)(strconv__common_parse_int(s, 0, 16, false, false)));
}

f32 string_f32(string s) {
	return ((f32)(strconv__atof64(s)));
}

f64 string_f64(string s) {
	return strconv__atof64(s);
}

u16 string_u16(string s) {
	return ((u16)(strconv__common_parse_uint(s, 0, 16, false, false)));
}

u32 string_u32(string s) {
	return ((u32)(strconv__common_parse_uint(s, 0, 32, false, false)));
}

u64 string_u64(string s) {
	return strconv__common_parse_uint(s, 0, 64, false, false);
}

static bool string_eq(string s, string a) {
	if (s.str == 0) {
		v_panic(tos3("string.eq(): nil string"));
	}
	if (s.len != a.len) {
		return false;
	}
	return memcmp(s.str, a.str, a.len) == 0;
}

static bool string_ne(string s, string a) {
	return !string_eq(s, a);
}

static bool string_lt(string s, string a) {
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
		int i = tmp1;
		if (i >= a.len || string_at(s, i) > string_at(a, i)) {
			return false;
		} else if (string_at(s, i) < string_at(a, i)) {
			return true;
		}
	}
	if (s.len < a.len) {
		return true;
	}
	return false;
}

static bool string_le(string s, string a) {
	return string_lt(s, a) || string_eq(s, a);
}

static bool string_gt(string s, string a) {
	return !string_le(s, a);
}

static bool string_ge(string s, string a) {
	return !string_lt(s, a);
}

static string string_add(string s, string a) {
	int new_len = a.len + s.len;
	string res = (string){
		.len = new_len,
		.str = v_malloc(new_len + 1),
	};
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
		int j = tmp1;
		res.str[j] = s.str[j];
	}
	for (int tmp2 = 0; tmp2 < a.len; tmp2++) {
		int j = tmp2;
		res.str[s.len + j] = a.str[j];
	}
	res.str[new_len] = '\0';
	return res;
}

array_string string_split(string s, string delim) {
	return string_split_nth(s, delim, 0);
}

array_string string_split_nth(string s, string delim, int nth) {
	array_string res = __new_array(0, 0, sizeof(string));
	int i = 0;
	if (delim.len == 0) {
		i = 1;
		for (int tmp2 = 0; tmp2 < s.len; tmp2++) {
		byte ch = s.str[tmp2];
			if (nth > 0 && i >= nth) {
				array_push(&res, &(string[]){ string_substr(s, i, s.len) });
				break;
			}
			array_push(&res, &(string[]){ byte_str(ch) });
			i++;
		}
		return res;
	}
	int start = 0;
	int nth_1 = nth - 1;
	while (i <= s.len) {
		bool is_delim = s.str[i] == delim.str[0];
		int j = 0;
		while (is_delim && j < delim.len) {
			is_delim = is_delim && s.str[i + j] == delim.str[j];
			j++;
		}
		bool last = i == s.len - 1;
		if (is_delim || last) {
			if (!is_delim && last) {
				i++;
			}
			string val = string_substr(s, start, i);
			if (string_starts_with(val, delim)) {
				val = string_right(val, delim.len);
			}
			bool was_last = nth > 0 && res.len == nth_1;
			if (was_last) {
				array_push(&res, &(string[]){ string_right(s, start) });
				break;
			}
			array_push(&res, &(string[]){ val });
			start = i + delim.len;
		}
		i++;
	}
	if (string_ends_with(s, delim) && (nth < 1 || res.len < nth)) {
		array_push(&res, &(string[]){ tos3("") });
	}
	return res;
}

array_string string_split_into_lines(string s) {
	array_string res = __new_array(0, 0, sizeof(string));
	if (s.len == 0) {
		return res;
	}
	int start = 0;
	for (int i = 0;
	i < s.len; i++) {
		bool is_lf = s.str[i] == '\n';
		bool is_crlf = i != s.len - 1 && s.str[i] == '\r' && s.str[i + 1] == '\n';
		bool is_eol = is_lf || is_crlf;
		bool is_last = (is_crlf ?  ( i == s.len - 2 )  :  ( i == s.len - 1 ) );
		if (is_eol || is_last) {
			if (is_last && !is_eol) {
				i++;
			}
			string line = string_substr(s, start, i);
			array_push(&res, &(string[]){ line });
			if (is_crlf) {
				i++;
			}
			start = i + 1;
		}
	}
	return res;
}

static string string_left(string s, int n) {
	if (n >= s.len) {
		return s;
	}
	return string_substr(s, 0, n);
}

static string string_right(string s, int n) {
	if (n >= s.len) {
		return tos3("");
	}
	return string_substr(s, n, s.len);
}

static string string_substr2(string s, int start, int _end, bool end_max) {
	int end = (end_max ?  ( s.len )  :  ( _end ) );
	return string_substr(s, start, end);
}

string string_substr(string s, int start, int end) {
	
// $if !no_bounds_checking {
#ifndef CUSTOM_DEFINE_no_bounds_checking
		if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
			v_panic(_STR("substr(%"PRId32"\000, %"PRId32"\000) out of bounds (len=%"PRId32"\000)", 4, start, end, s.len));
		}
	
// } no_bounds_checking
#endif

	int len = end - start;
	string res = (string){
		.len = len,
		.str = v_malloc(len + 1),
	};
	for (int tmp2 = 0; tmp2 < len; tmp2++) {
		int i = tmp2;
		res.str[i] = s.str[start + i];
	}
	res.str[len] = '\0';
	return res;
}

int string_index_old(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	int i = 0;
	while (i < s.len) {
		int j = 0;
		while (j < p.len && s.str[i + j] == p.str[j]) {
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

Option_int string_index(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return opt_none();}
	int i = 0;
	while (i < s.len) {
		int j = 0;
		while (j < p.len && s.str[i + j] == p.str[j]) {
			j++;
		}
		if (j == p.len) {
			return /*:)int*/opt_ok(&(int[]) { i }, sizeof(int));
		}
		i++;
	}
	return opt_none();}

static int string_index_kmp(string s, string p) {
	if (p.len > s.len) {
		return -1;
	}
	array_int prefix = array_repeat(new_array_from_c_array(1, 1, sizeof(int), (int[1]){
		0, 
}), p.len);
	int j = 0;
	for (int i = 1;
	i < p.len; i++) {
		while (p.str[j] != p.str[i] && j > 0) {
			j = (*(int*)array_get(prefix, j - 1));
		}
		if (p.str[j] == p.str[i]) {
			j++;
		}
		array_set(&prefix, i, &(int[]) { j });
	}
	j = 0;
	for (int tmp3 = 0; tmp3 < s.len; tmp3++) {
		int i = tmp3;
		while (p.str[j] != s.str[i] && j > 0) {
			j = (*(int*)array_get(prefix, j - 1));
		}
		if (p.str[j] == s.str[i]) {
			j++;
		}
		if (j == p.len) {
			return i - p.len + 1;
		}
	}
	return -1;
}

int string_index_any(string s, string chars) {
	for (int tmp1 = 0; tmp1 < chars.len; tmp1++) {
	byte c = chars.str[tmp1];
		Option_int index = string_index(s, byte_str(c));
		if (!index.ok) {
			string err = index.v_error;
			int errcode = index.ecode;
			// last_type: v.ast.BranchStmt
			// last_expr_result_type: 
			continue;
		};
		return /*opt*/(*(int*)index.data);
	}
	return -1;
}

Option_int string_last_index(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return opt_none();}
	int i = s.len - p.len;
	while (i >= 0) {
		int j = 0;
		while (j < p.len && s.str[i + j] == p.str[j]) {
			j++;
		}
		if (j == p.len) {
			return /*:)int*/opt_ok(&(int[]) { i }, sizeof(int));
		}
		i--;
	}
	return opt_none();}

int string_index_after(string s, string p, int start) {
	if (p.len > s.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start >= s.len) {
		return -1;
	}
	int i = strt;
	while (i < s.len) {
		int j = 0;
		int ii = i;
		while (j < p.len && s.str[ii] == p.str[j]) {
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

int string_index_byte(string s, byte c) {
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
		int i = tmp1;
		if (s.str[i] == c) {
			return i;
		}
	}
	return -1;
}

int string_last_index_byte(string s, byte c) {
	for (int i = s.len - 1;
	i >= 0; i--) {
		if (s.str[i] == c) {
			return i;
		}
	}
	return -1;
}

int string_count(string s, string substr) {
	if (s.len == 0 || substr.len == 0) {
		return 0;
	}
	if (substr.len > s.len) {
		return 0;
	}
	int n = 0;
	int i = 0;
	while (1) {
		i = string_index_after(s, substr, i);
		if (i == -1) {
			return n;
		}
		i += substr.len;
		n++;
	}
	return 0;
}

bool string_contains(string s, string p) {
	Option_int tmp1 = string_index(s, p);
	if (!tmp1.ok) {
		string err = tmp1.v_error;
		int errcode = tmp1.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return false;
	};
	return true;
}

bool string_starts_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int tmp2 = 0; tmp2 < p.len; tmp2++) {
		int i = tmp2;
		if (s.str[i] != p.str[i]) {
			return false;
		}
	}
	return true;
}

bool string_ends_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int tmp2 = 0; tmp2 < p.len; tmp2++) {
		int i = tmp2;
		if (string_at(p, i) != string_at(s, s.len - p.len + i)) {
			return false;
		}
	}
	return true;
}

string string_to_lower(string s) {
	byteptr b = v_malloc(s.len + 1);
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
		int i = tmp1;
		b[i] = tolower(s.str[i]);
	}
	return tos(b, s.len);
}

bool string_is_lower(string s) {
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
		int i = tmp1;
		if (string_at(s, i) >= 'A' && string_at(s, i) <= 'Z') {
			return false;
		}
	}
	return true;
}

string string_to_upper(string s) {
	byteptr b = v_malloc(s.len + 1);
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
		int i = tmp1;
		b[i] = toupper(s.str[i]);
	}
	return tos(b, s.len);
}

bool string_is_upper(string s) {
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
		int i = tmp1;
		if (string_at(s, i) >= 'a' && string_at(s, i) <= 'z') {
			return false;
		}
	}
	return true;
}

string string_capitalize(string s) {
	if (s.len == 0) {
		return tos3("");
	}
	string sl = string_to_lower(s);
	string cap = string_add(string_to_upper(byte_str(string_at(sl, 0))), string_right(sl, 1));
	return cap;
}

bool string_is_capital(string s) {
	if (s.len == 0 || !(string_at(s, 0) >= 'A' && string_at(s, 0) <= 'Z')) {
		return false;
	}
	for (int tmp2 = 1; tmp2 < s.len; tmp2++) {
		int i = tmp2;
		if (string_at(s, i) >= 'A' && string_at(s, i) <= 'Z') {
			return false;
		}
	}
	return true;
}

string string_title(string s) {
	array_string words = string_split(s, tos3(" "));
	array_string tit = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp1 = words;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string word = ((string*)tmp1.data)[tmp2];
		array_push(&tit, &(string[]){ string_capitalize(word) });
	}
	string title = array_string_join(tit, tos3(" "));
	return title;
}

bool string_is_title(string s) {
	array_string words = string_split(s, tos3(" "));
	// FOR IN array
	array tmp1 = words;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string word = ((string*)tmp1.data)[tmp2];
		if (!string_is_capital(word)) {
			return false;
		}
	}
	return true;
}

string string_find_between(string s, string start, string end) {
	Option_int start_pos = string_index(s, start);
	if (!start_pos.ok) {
		string err = start_pos.v_error;
		int errcode = start_pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return tos3("");
	};
	string val = string_right(s, /*opt*/(*(int*)start_pos.data) + start.len);
	Option_int end_pos = string_index(val, end);
	if (!end_pos.ok) {
		string err = end_pos.v_error;
		int errcode = end_pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return val;
	};
	return string_left(val, /*opt*/(*(int*)end_pos.data));
}

static bool array_string_contains(array_string ar, string val) {
	// FOR IN array
	array tmp1 = ar;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string s = ((string*)tmp1.data)[tmp2];
		if (string_eq(s, val)) {
			return true;
		}
	}
	return false;
}

static bool array_int_contains(array_int ar, int val) {
	// FOR IN array
	array tmp1 = ar;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		int s = ((int*)tmp1.data)[tmp2];
		if (s == val) {
			return true;
		}
	}
	return false;
}

bool byte_is_space(byte c) {
	return (c == ' ' || c == '\n' || c == '\t' || c == '\v' || c == '\f' || c == '\r' || c == 0x85 || c == 0xa0);
}

string string_trim_space(string s) {
	return string_trim(s, tos3(" \n\t\v\f\r"));
}

string string_trim(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return s;
	}
	array_byte cs_arr = string_bytes(cutset);
	int pos_left = 0;
	int pos_right = s.len - 1;
	bool cs_match = true;
	while (pos_left <= s.len && pos_right >= -1 && cs_match) {
		cs_match = false;
		if (_IN(byte, string_at(s, pos_left), cs_arr)) {
			pos_left++;
			cs_match = true;
		}
		if (_IN(byte, string_at(s, pos_right), cs_arr)) {
			pos_right--;
			cs_match = true;
		}
		if (pos_left > pos_right) {
			return tos3("");
		}
	}
	return string_substr(s, pos_left, pos_right + 1);
}

string string_trim_left(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return s;
	}
	array_byte cs_arr = string_bytes(cutset);
	int pos = 0;
	while (pos < s.len && _IN(byte, string_at(s, pos), cs_arr)) {
		pos++;
	}
	return string_right(s, pos);
}

string string_trim_right(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return s;
	}
	array_byte cs_arr = string_bytes(cutset);
	int pos = s.len - 1;
	while (pos >= 0 && _IN(byte, string_at(s, pos), cs_arr)) {
		pos--;
	}
	return (pos < 0 ?  ( tos3("") )  :  ( string_left(s, pos + 1) ) );
}

static int compare_strings(string* a, string* b) {
	if (string_lt(/*rec*/*a, */*d*/b)) {
		return -1;
	}
	if (string_gt(/*rec*/*a, */*d*/b)) {
		return 1;
	}
	return 0;
}

static int compare_strings_by_len(string* a, string* b) {
	if (a->len < b->len) {
		return -1;
	}
	if (a->len > b->len) {
		return 1;
	}
	return 0;
}

static int compare_lower_strings(string* a, string* b) {
	string aa = string_to_lower(/*rec*/*a);
	string bb = string_to_lower(/*rec*/*b);
	return compare_strings(&/*qq*/aa, &/*qq*/bb);
}

void array_string_sort(array_string* s) {
	array_sort_with_compare(s, &/*qq*/compare_strings);
}

void array_string_sort_ignore_case(array_string* s) {
	array_sort_with_compare(s, &/*qq*/compare_lower_strings);
}

void array_string_sort_by_len(array_string* s) {
	array_sort_with_compare(s, &/*qq*/compare_strings_by_len);
}

string string_str(string s) {
	return s;
}

string ustring_str(ustring s) {
	return s.s;
}

ustring string_ustring(string s) {
	ustring res = (ustring){
		.s = s,
		.runes = __new_array(0, s.len, sizeof(int)),
		.len = 0,
	};
	for (int i = 0;
	i < s.len; i++) {
		int char_len = utf8_char_len(s.str[i]);
		array_push(&res.runes, &(int[]){ i });
		i += char_len - 1;
		res.len++;
	}
	return res;
}

ustring string_ustring_tmp(string s) {
	if (g_ustring_runes.len == 0) {
		g_ustring_runes = __new_array(0, 128, sizeof(int));
	}
	ustring res = (ustring){
		.s = s,
		.runes = __new_array(0, 1, sizeof(int)),
		.len = 0,
	};
	res.runes = g_ustring_runes;
	res.runes.len = s.len;
	int j = 0;
	for (int i = 0;
	i < s.len; i++) {
		int char_len = utf8_char_len(s.str[i]);
		(*(int*)array_get(res.runes, j)) = i;
		j++;
		i += char_len - 1;
		res.len++;
	}
	return res;
}

static bool ustring_eq(ustring u, ustring a) {
	if (u.len != a.len || string_ne(u.s, a.s)) {
		return false;
	}
	return true;
}

static bool ustring_ne(ustring u, ustring a) {
	return !ustring_eq(u, a);
}

static bool ustring_lt(ustring u, ustring a) {
	return string_lt(u.s, a.s);
}

static bool ustring_le(ustring u, ustring a) {
	return ustring_lt(u, a) || ustring_eq(u, a);
}

static bool ustring_gt(ustring u, ustring a) {
	return !ustring_le(u, a);
}

static bool ustring_ge(ustring u, ustring a) {
	return !ustring_lt(u, a);
}

ustring ustring_add(ustring u, ustring a) {
	ustring res = (ustring){
		.s = string_add(u.s, a.s),
		.runes = __new_array(0, u.s.len + a.s.len, sizeof(int)),
		.len = 0,
	};
	int j = 0;
	for (int i = 0;
	i < u.s.len; i++) {
		int char_len = utf8_char_len(u.s.str[i]);
		array_push(&res.runes, &(int[]){ j });
		i += char_len - 1;
		j += char_len;
		res.len++;
	}
	for (int i = 0;
	i < a.s.len; i++) {
		int char_len = utf8_char_len(a.s.str[i]);
		array_push(&res.runes, &(int[]){ j });
		i += char_len - 1;
		j += char_len;
		res.len++;
	}
	return res;
}

int ustring_index_after(ustring u, ustring p, int start) {
	if (p.len > u.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start > u.len) {
		return -1;
	}
	int i = strt;
	while (i < u.len) {
		int j = 0;
		int ii = i;
		while (j < p.len && string_eq(ustring_at(u, ii), ustring_at(p, j))) {
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

int ustring_count(ustring u, ustring substr) {
	if (u.len == 0 || substr.len == 0) {
		return 0;
	}
	if (substr.len > u.len) {
		return 0;
	}
	int n = 0;
	int i = 0;
	while (1) {
		i = ustring_index_after(u, substr, i);
		if (i == -1) {
			return n;
		}
		i += substr.len;
		n++;
	}
	return 0;
}

string ustring_substr(ustring u, int _start, int _end) {
	
// $if !no_bounds_checking {
#ifndef CUSTOM_DEFINE_no_bounds_checking
		if (_start > _end || _start > u.len || _end > u.len || _start < 0 || _end < 0) {
			v_panic(_STR("substr(%"PRId32"\000, %"PRId32"\000) out of bounds (len=%"PRId32"\000)", 4, _start, _end, u.len));
		}
	
// } no_bounds_checking
#endif

	int end = (_end >= u.len ?  ( u.s.len )  :  ( (*(int*)array_get(u.runes, _end)) ) );
	return string_substr(u.s, (*(int*)array_get(u.runes, _start)), end);
}

string ustring_left(ustring u, int pos) {
	if (pos >= u.len) {
		return u.s;
	}
	return ustring_substr(u, 0, pos);
}

string ustring_right(ustring u, int pos) {
	if (pos >= u.len) {
		return tos3("");
	}
	return ustring_substr(u, pos, u.len);
}

static byte string_at(string s, int idx) {
	
// $if !no_bounds_checking {
#ifndef CUSTOM_DEFINE_no_bounds_checking
		if (idx < 0 || idx >= s.len) {
			v_panic(_STR("string index out of range: %"PRId32"\000 / %"PRId32"", 2, idx, s.len));
		}
	
// } no_bounds_checking
#endif

	return s.str[idx];
}

string ustring_at(ustring u, int idx) {
	
// $if !no_bounds_checking {
#ifndef CUSTOM_DEFINE_no_bounds_checking
		if (idx < 0 || idx >= u.len) {
			v_panic(_STR("string index out of range: %"PRId32"\000 / %"PRId32"", 2, idx, u.runes.len));
		}
	
// } no_bounds_checking
#endif

	return ustring_substr(u, idx, idx + 1);
}

static void ustring_free(ustring* u) {
	array_free(&u->runes);
}

bool byte_is_digit(byte c) {
	return c >= '0' && c <= '9';
}

bool byte_is_hex_digit(byte c) {
	return byte_is_digit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}

bool byte_is_oct_digit(byte c) {
	return c >= '0' && c <= '7';
}

bool byte_is_bin_digit(byte c) {
	return c == '0' || c == '1';
}

bool byte_is_letter(byte c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

void string_free(string* s) {
	v_free(s->str);
}

string string_all_before(string s, string dot) {
	Option_int pos = string_index(s, dot);
	if (!pos.ok) {
		string err = pos.v_error;
		int errcode = pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return s;
	};
	return string_left(s, /*opt*/(*(int*)pos.data));
}

string string_all_before_last(string s, string dot) {
	Option_int pos = string_last_index(s, dot);
	if (!pos.ok) {
		string err = pos.v_error;
		int errcode = pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return s;
	};
	return string_left(s, /*opt*/(*(int*)pos.data));
}

string string_all_after(string s, string dot) {
	Option_int pos = string_last_index(s, dot);
	if (!pos.ok) {
		string err = pos.v_error;
		int errcode = pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return s;
	};
	return string_right(s, /*opt*/(*(int*)pos.data) + dot.len);
}

string string_after(string s, string dot) {
	return string_all_after(s, dot);
}

string array_string_join(array_string a, string del) {
	if (a.len == 0) {
		return tos3("");
	}
	int len = 0;
	// FOR IN array
	array tmp2 = a;
	for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
		string val = ((string*)tmp2.data)[tmp3];
		len += val.len + del.len;
	}
	len -= del.len;
	string res = tos3("");
	res.len = len;
	res.str = v_malloc(res.len + 1);
	int idx = 0;
	// FOR IN array
	array tmp4 = a;
	for (int i = 0; i < tmp4.len; i++) {
		string val = ((string*)tmp4.data)[i];
		for (int tmp5 = 0; tmp5 < val.len; tmp5++) {
			int j = tmp5;
			res.str[idx] = val.str[j];
			idx++;
		}
		if (i != a.len - 1) {
			for (int tmp7 = 0; tmp7 < del.len; tmp7++) {
				int k = tmp7;
				res.str[idx] = del.str[k];
				idx++;
			}
		}
	}
	res.str[res.len] = '\0';
	return res;
}

string array_string_join_lines(array_string s) {
	return array_string_join(s, tos3("\n"));
}

string string_reverse(string s) {
	if (s.len == 0 || s.len == 1) {
		return s;
	}
	string res = (string){
		.len = s.len,
		.str = v_malloc(s.len),
	};
	for (int i = s.len - 1;
	i >= 0; i--) {
		res.str[s.len - i - 1] = string_at(s, i);
	}
	return res;
}

string string_limit(string s, int max) {
	ustring u = string_ustring(s);
	if (u.len <= max) {
		return s;
	}
	return ustring_substr(u, 0, max);
}

// Attr: [deprecated]
bool byte_is_white(byte c) {
	v_panic(tos3("Use `string.is_space` instead of `string.is_white"));
}

int string_hash(string s) {
	int h = 0;
	if (h == 0 && s.len > 0) {
		for (int tmp2 = 0; tmp2 < s.len; tmp2++) {
		byte c = s.str[tmp2];
			h = h * 31 + ((int)(c));
		}
	}
	return h;
}

array_byte string_bytes(string s) {
	if (s.len == 0) {
		return __new_array(0, 0, sizeof(byte));
	}
	array_byte buf = array_repeat(new_array_from_c_array(1, 1, sizeof(byte), (byte[1]){
		((byte)(0)), 
}), s.len);
	memcpy(buf.data, s.str, s.len);
	return buf;
}

string string_repeat(string s, int count) {
	if (count < 0) {
		v_panic(_STR("string.repeat: count is negative: %"PRId32"", 1, count));
	} else if (count == 0) {
		return tos3("");
	} else if (count == 1) {
		return s;
	}
	byteptr ret = v_malloc(s.len * count + 1);
	for (int tmp2 = 0; tmp2 < count; tmp2++) {
		int i = tmp2;
		for (int tmp3 = 0; tmp3 < s.len; tmp3++) {
			int j = tmp3;
			ret[i * s.len + j] = string_at(s, j);
		}
	}
	ret[s.len * count] = 0;
	return tos2(ret);
}

string string_strip_margin(string s) {
	return string_strip_margin_custom(s, '|');
}

string string_strip_margin_custom(string s, byte del) {
	byte sep = del;
	if (byte_is_space(sep)) {
		eprintln(tos3("Warning: `strip_margin` cannot use white-space as a delimiter"));
		eprintln(tos3("    Defaulting to `|`"));
		sep = '|';
	}
	byteptr ret = v_malloc(s.len + 1);
	int count = 0;
	for (int i = 0;
	i < s.len; i++) {
		if ((string_at(s, i) == '\n' || string_at(s, i) == '\r')) {
			ret[count] = string_at(s, i);
			count++;
			if (string_at(s, i) == '\r' && i < s.len - 1 && string_at(s, i + 1) == '\n') {
				ret[count] = string_at(s, i + 1);
				count++;
				i++;
			}
			while (string_at(s, i) != sep) {
				i++;
				if (i >= s.len) {
					break;
				}
			}
		} else {
			ret[count] = string_at(s, i);
			count++;
		}
	}
	ret[count] = 0;
	return tos2(ret);
}

int utf8_char_len(byte b) {
	return (((0xe5000000 >> (((b >> 3) & 0x1e))) & 3)) + 1;
}

string utf32_to_str(u32 code) {
	int icode = ((int)(code));
	byteptr buffer = v_malloc(5);
	if (icode <= 127) {
		buffer[0] = icode;
		return tos(buffer, 1);
	}
	if (icode <= 2047) {
		buffer[0] = (192 | (icode >> 6));
		buffer[1] = (128 | ((icode & 63)));
		return tos(buffer, 2);
	}
	if (icode <= 65535) {
		buffer[0] = (224 | (icode >> 12));
		buffer[1] = (128 | (((icode >> 6) & 63)));
		buffer[2] = (128 | ((icode & 63)));
		return tos(buffer, 3);
	}
	if (icode <= 1114111) {
		buffer[0] = (240 | (icode >> 18));
		buffer[1] = (128 | (((icode >> 12) & 63)));
		buffer[2] = (128 | (((icode >> 6) & 63)));
		buffer[3] = (128 | ((icode & 63)));
		return tos(buffer, 4);
	}
	return tos3("");
}

string utf32_to_str_no_malloc(u32 code, voidptr buf) {
	int icode = ((int)(code));
	byteptr buffer = ((byteptr)(buf));
	if (icode <= 127) {
		buffer[0] = icode;
		return tos(buffer, 1);
	}
	if (icode <= 2047) {
		buffer[0] = (192 | (icode >> 6));
		buffer[1] = (128 | ((icode & 63)));
		return tos(buffer, 2);
	}
	if (icode <= 65535) {
		buffer[0] = (224 | (icode >> 12));
		buffer[1] = (128 | (((icode >> 6) & 63)));
		buffer[2] = (128 | ((icode & 63)));
		return tos(buffer, 3);
	}
	if (icode <= 1114111) {
		buffer[0] = (240 | (icode >> 18));
		buffer[1] = (128 | (((icode >> 12) & 63)));
		buffer[2] = (128 | (((icode >> 6) & 63)));
		buffer[3] = (128 | ((icode & 63)));
		return tos(buffer, 4);
	}
	return tos3("");
}

int string_utf32_code(string _rune) {
	if (_rune.len == 0) {
		return 0;
	}
	if (_rune.len == 1) {
		return ((int)(string_at(_rune, 0)));
	}
	byte b = ((byte)(((int)(string_at(_rune, 0)))));
	b = b << _rune.len;
	int res = ((int)(b));
	int shift = 6 - _rune.len;
	for (int i = 1;
	i < _rune.len; i++) {
		int c = ((int)(string_at(_rune, i)));
		res = res << shift;
		res |= (c & 63);
		shift = 6;
	}
	return res;
}

u16* string_to_wide(string _str) {
	
// $if  windows {
#ifdef _WIN32
		int num_chars = (MultiByteToWideChar(_const_CP_UTF8, 0, _str.str, _str.len, 0, 0));
		u16* wstr = ((u16*)(v_malloc((num_chars + 1) * 2)));
		if (wstr != 0) {
			MultiByteToWideChar(_const_CP_UTF8, 0, _str.str, _str.len, wstr, num_chars);
			memset(((byte*)(wstr)) + num_chars * 2, 0, 2);
		}
		return wstr;
	
#else
		return 0;
	
// } windows
#endif

}

string string_from_wide(u16* _wstr) {
	
// $if  windows {
#ifdef _WIN32
		int wstr_len = wcslen(_wstr);
		return string_from_wide2(_wstr, wstr_len);
	
#else
		return tos3("");
	
// } windows
#endif

}

string string_from_wide2(u16* _wstr, int len) {
	
// $if  windows {
#ifdef _WIN32
		int num_chars = WideCharToMultiByte(_const_CP_UTF8, 0, _wstr, len, 0, 0, 0, 0);
		byteptr str_to = v_malloc(num_chars + 1);
		if (str_to != 0) {
			WideCharToMultiByte(_const_CP_UTF8, 0, _wstr, len, str_to, num_chars, 0, 0);
			memset(str_to + num_chars, 0, 1);
		}
		return tos2(str_to);
	
#else
		return tos3("");
	
// } windows
#endif

}

static int utf8_len(byte c) {
	int b = 0;
	byte x = c;
	if (((x & 240)) != 0) {
		x >>= 4;
	} else {
		b += 4;
	}
	if (((x & 12)) != 0) {
		x >>= 2;
	} else {
		b += 2;
	}
	if (((x & 2)) == 0) {
		b++;
	}
	return b;
}

static int utf8_str_len(string s) {
	int l = 0;
	for (int i = 0;
	i < s.len; i++) {
		l++;
		byte c = s.str[i];
		if (((c & (1 << 7))) != 0) {
			for (byte t = ((byte)(1 << 6));
			((c & t)) != 0; t >>= 1) {
				i++;
			}
		}
	}
	return l;
}

static int utf8_str_visible_length(string s) {
	int l = 0;
	int ul = 1;
	for (int i = 0;
	i < s.len; i += ul) {
		ul = 1;
		byte c = s.str[i];
		if (((c & (1 << 7))) != 0) {
			for (byte t = ((byte)(1 << 6));
			((c & t)) != 0; t >>= 1) {
				ul++;
			}
		}
		if (i + ul > s.len) {
			return l;
		}
		l++;
		if (c == 0xcc || c == 0xcd) {
			u16 r = ((((u16)(c)) << 8) | s.str[i + 1]);
			if (r >= 0xcc80 && r < 0xcdb0) {
				l--;
			}
		} else if (c == 0xe1 || c == 0xe2 || c == 0xef) {
			u32 r = (((((u32)(c)) << 16) | (((u32)(s.str[i + 1])) << 8)) | s.str[i + 2]);
			if (r >= 0xe1aab0 && r < 0xe1ac80 || r >= 0xe1b780 && r < 0xe1b880 || r >= 0xe28390 && r < 0xe28480 || r >= 0xefb8a0 && r < 0xefb8b0) {
				l--;
			}
		}
	}
	return l;
}

int utf8_getchar() {
	int c = getchar();
	int len = utf8_len(~c);
	if (c < 0) {
		return 0;
	} else if (len == 0) {
		return c;
	} else if (len == 1) {
		return -1;
	} else {
		int uc = (c & ((1 << (7 - len)) - 1));
		for (int i = 0;
		i + 1 < len; i++) {
			int c2 = getchar();
			if (c2 != -1 && (c2 >> 6) == 2) {
				uc <<= 6;
				uc |= ((c2 & 63));
			} else if (c2 == -1) {
				return 0;
			} else {
				return -1;
			}
		}
		return uc;
	}
}




string os__getenv(string key) {
	
// $if  windows {
#ifdef _WIN32
		voidptr s = _wgetenv(string_to_wide(key));
		if (s == 0) {
			return tos3("");
		}
		return string_from_wide(s);
	
#else
		char* s = getenv(key.str);
		if (s == 0) {
			return tos3("");
		}
		return cstring_to_vstring(((byteptr)(s)));
	
// } windows
#endif

}

int os__setenv(string name, string value, bool overwrite) {
	
// $if  windows {
#ifdef _WIN32
		string format = _STR("%.*s\000=%.*s", 2, name, value);
		if (overwrite) {
			return _putenv(format.str);
		}
		return -1;
	
#else
		return setenv(name.str, value.str, overwrite);
	
// } windows
#endif

}

int os__unsetenv(string name) {
	
// $if  windows {
#ifdef _WIN32
		string format = _STR("%.*s\000=", 2, name);
		return _putenv(format.str);
	
#else
		return unsetenv(name.str);
	
// } windows
#endif

}

map_string_string os__environ() {
	map_string_string res = new_map_1(sizeof(string));
	
// $if  windows {
#ifdef _WIN32
		u16* estrings = GetEnvironmentStringsW();
		string eline = tos3("");
		for (u16* c = estrings;
		*c != 0; c = c + eline.len + 1) {
			eline = string_from_wide(c);
			int eq_index = string_index_byte(eline, '=');
			if (eq_index > 0) {
				map_set(&res, string_substr(eline, 0, eq_index), &(string[]) { string_substr(eline, eq_index + 1, eline.len) });
			}
		}
		FreeEnvironmentStringsW(estrings);
	
#else
		charptr* e = ((charptr*)(environ));
		for (int i = 0;
		!isnil(e[i]); i++) {
			string eline = cstring_to_vstring(e[i]);
			int eq_index = string_index_byte(eline, '=');
			if (eq_index > 0) {
				map_set(&res, string_substr(eline, 0, eq_index), &(string[]) { string_substr(eline, eq_index + 1, eline.len) });
			}
		}
	
// } windows
#endif

	return res;
}

os__FileMode os__inode(string path) {
	struct stat attr = (struct stat){
		.st_size = 0,
		.st_mode = 0,
		.st_mtime = 0,
	};
	stat(path.str, &attr);
	os__FileType typ = os__FileType_regular;
	if ((attr.st_mode & S_IFMT) == S_IFDIR) {
		typ = os__FileType_directory;
	}
	
// $if !windows {
#ifndef _WIN32
		if ((attr.st_mode & S_IFMT) == S_IFCHR) {
			typ = os__FileType_character_device;
		} else if ((attr.st_mode & S_IFMT) == S_IFBLK) {
			typ = os__FileType_block_device;
		} else if ((attr.st_mode & S_IFMT) == S_IFIFO) {
			typ = os__FileType_fifo;
		} else if ((attr.st_mode & S_IFMT) == S_IFLNK) {
			typ = os__FileType_symbolic_link;
		} else if ((attr.st_mode & S_IFMT) == S_IFSOCK) {
			typ = os__FileType_socket;
		}
	
// } windows
#endif

	
// $if  windows {
#ifdef _WIN32
		return (os__FileMode){
			.typ = typ,
			.owner = (os__FilePermission){
			.read = ((bool)((attr.st_mode & S_IREAD))),
			.write = ((bool)((attr.st_mode & S_IWRITE))),
			.execute = ((bool)((attr.st_mode & S_IEXEC))),
		},
			.group = (os__FilePermission){
			.read = ((bool)((attr.st_mode & S_IREAD))),
			.write = ((bool)((attr.st_mode & S_IWRITE))),
			.execute = ((bool)((attr.st_mode & S_IEXEC))),
		},
			.others = (os__FilePermission){
			.read = ((bool)((attr.st_mode & S_IREAD))),
			.write = ((bool)((attr.st_mode & S_IWRITE))),
			.execute = ((bool)((attr.st_mode & S_IEXEC))),
		},
		};
	
#else
		return (os__FileMode){
			.typ = typ,
			.owner = (os__FilePermission){
			.read = ((bool)((attr.st_mode & S_IRUSR))),
			.write = ((bool)((attr.st_mode & S_IWUSR))),
			.execute = ((bool)((attr.st_mode & S_IXUSR))),
		},
			.group = (os__FilePermission){
			.read = ((bool)((attr.st_mode & S_IRGRP))),
			.write = ((bool)((attr.st_mode & S_IWGRP))),
			.execute = ((bool)((attr.st_mode & S_IXGRP))),
		},
			.others = (os__FilePermission){
			.read = ((bool)((attr.st_mode & S_IROTH))),
			.write = ((bool)((attr.st_mode & S_IWOTH))),
			.execute = ((bool)((attr.st_mode & S_IXOTH))),
		},
		};
	
// } windows
#endif

}







bool os__File_is_opened(os__File f) {
	return f.opened;
}

array_byte os__File_read_bytes(os__File* f, int size) {
	return os__File_read_bytes_at(f, size, 0);
}

array_byte os__File_read_bytes_at(os__File* f, int size, int pos) {
	array_byte arr = array_repeat(new_array_from_c_array(1, 1, sizeof(byte), (byte[1]){
		'0', 
}), size);
	fseek(f->cfile, pos, SEEK_SET);
	int nreadbytes = fread(arr.data, 1, size, f->cfile);
	fseek(f->cfile, 0, SEEK_SET);
	return array_slice(arr, 0, nreadbytes);
}

Option_array_byte os__read_bytes(string path) {
	FILE* fp = os__vfopen(path, tos3("rb"));
	if (isnil(fp)) {
		return v_error(_STR("failed to open file \"%.*s\000\"", 2, path));}
	fseek(fp, 0, SEEK_END);
	int fsize = ftell(fp);
	rewind(fp);
	array_byte res = array_repeat(new_array_from_c_array(1, 1, sizeof(byte), (byte[1]){
		'0', 
}), fsize);
	int nr_read_elements = fread(res.data, fsize, 1, fp);
	fclose(fp);
	return /*:)array_byte*/opt_ok(&(array_byte[]) { array_slice(res, 0, nr_read_elements * fsize) }, sizeof(array_byte));
}

Option_string os__read_file(string path) {
	string mode = tos3("rb");
	FILE* fp = os__vfopen(path, mode);
	if (isnil(fp)) {
		return v_error(_STR("failed to open file \"%.*s\000\"", 2, path));}
	fseek(fp, 0, SEEK_END);
	int fsize = ftell(fp);
	rewind(fp);
	byte* str = ((byte*)(0));
		str = v_malloc(fsize + 1);
	fread(str, fsize, 1, fp);
	str[fsize] = 0;
	// defer
		fclose(fp);
	return /*:)string*/opt_ok(&(string[]) { tos(str, fsize) }, sizeof(string));
// defer
	fclose(fp);
}

int os__file_size(string path) {
	struct stat s = (struct stat){
		.st_size = 0,
		.st_mode = 0,
		.st_mtime = 0,
	};
	
// $if  windows {
#ifdef _WIN32
		_wstat(string_to_wide(path), ((voidptr)(&s)));
	
#else
		stat(((charptr)(path.str)), &s);
	
// } windows
#endif

	return s.st_size;
}

void os__mv(string old, string v_new) {
	
// $if  windows {
#ifdef _WIN32
		_wrename(string_to_wide(old), string_to_wide(v_new));
	
#else
		rename(((charptr)(old.str)), ((charptr)(v_new.str)));
	
// } windows
#endif

}


Option_bool os__cp(string old, string v_new) {
	
// $if  windows {
#ifdef _WIN32
		string _old = string_replace(old, tos3("/"), tos3("\\"));
		string _new = string_replace(v_new, tos3("/"), tos3("\\"));
		CopyFile(string_to_wide(_old), string_to_wide(_new), false);
		u32 result = GetLastError();
		if (result == 0) {
			return /*:)bool*/opt_ok(&(bool[]) { true }, sizeof(bool));
		} else {
			return error_with_code(_STR("failed to copy %.*s\000 to %.*s", 2, old, v_new), ((int)(result)));
		}
	
#else
		os__system(_STR("cp \"%.*s\000\" \"%.*s\000\"", 3, old, v_new));
		return /*:)bool*/opt_ok(&(bool[]) { true }, sizeof(bool));
	
// } windows
#endif

}

// Attr: [deprecated]
Option_bool os__cp_r(string osource_path, string odest_path, bool overwrite) {
	v_panic(tos3("Use `os.cp_all` instead of `os.cp_r`"));
}

Option_bool os__cp_all(string osource_path, string odest_path, bool overwrite) {
	string source_path = os__real_path(osource_path);
	string dest_path = os__real_path(odest_path);
	if (!os__exists(source_path)) {
		return v_error(tos3("Source path doesn\'t exist"));}
	if (!os__is_dir(source_path)) {
		string adjusted_path = (os__is_dir(dest_path) ?  ( os__join_path(dest_path, (varg_string){.len=1,.args={os__file_name(source_path)}}) )  :  ( dest_path ) );
		if (os__exists(adjusted_path)) {
			if (overwrite) {
				os__rm(adjusted_path);
			} else {
				return v_error(tos3("Destination file path already exist"));}
		}
		Option_bool tmp6 = os__cp(source_path, adjusted_path);
		if (!tmp6.ok) {
			string err = tmp6.v_error;
			int errcode = tmp6.ecode;
			// last_type: v.ast.Return
			// last_expr_result_type: 
			return v_error(err);};
		return /*:)bool*/opt_ok(&(bool[]) { true }, sizeof(bool));
	}
	if (!os__is_dir(dest_path)) {
		return v_error(tos3("Destination path is not a valid directory"));}
	Option_array_string files = os__ls(source_path);
	if (!files.ok) {
		string err = files.v_error;
		int errcode = files.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return v_error(err);};
	// FOR IN array
	array tmp8 = /*opt*/(*(array_string*)files.data);
	for (int tmp9 = 0; tmp9 < tmp8.len; tmp9++) {
		string file = ((string*)tmp8.data)[tmp9];
		string sp = os__join_path(source_path, (varg_string){.len=1,.args={file}});
		string dp = os__join_path(dest_path, (varg_string){.len=1,.args={file}});
		if (os__is_dir(sp)) {
			Option_bool tmp11 = os__mkdir(dp);
			if (!tmp11.ok) {
				string err = tmp11.v_error;
				int errcode = tmp11.ecode;
				 // typeof it_expr_type: v.ast.CallExpr
				// last_type: v.ast.ExprStmt
				// last_expr_result_type: void
				v_panic(err);
			};
		}
		Option_bool tmp12 = os__cp_all(sp, dp, overwrite);
		if (!tmp12.ok) {
			string err = tmp12.v_error;
			int errcode = tmp12.ecode;
			 // typeof it_expr_type: v.ast.CallExpr
			// last_type: v.ast.ExprStmt
			// last_expr_result_type: void
			os__rmdir(dp);
			v_panic(err);
		};
	}
	return /*:)bool*/opt_ok(&(bool[]) { true }, sizeof(bool));
}

Option_bool os__mv_by_cp(string source, string target) {
	Option_bool tmp1 = os__cp(source, target);
	if (!tmp1.ok) {
		string err = tmp1.v_error;
		int errcode = tmp1.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return v_error(err);};
	os__rm(source);
	return /*:)bool*/opt_ok(&(bool[]) { true }, sizeof(bool));
}

static FILE* os__vfopen(string path, string mode) {
	
// $if  windows {
#ifdef _WIN32
		return _wfopen(string_to_wide(path), string_to_wide(mode));
	
#else
		return fopen(((charptr)(path.str)), ((charptr)(mode.str)));
	
// } windows
#endif

}

Option_array_string os__read_lines(string path) {
	Option_string buf = os__read_file(path);
	if (!buf.ok) {
		string err = buf.v_error;
		int errcode = buf.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return v_error(err);};
	return /*:)array_string*/opt_ok(&(array_string[]) { string_split_into_lines(/*opt*/(*(string*)buf.data)) }, sizeof(array_string));
}

static Option_array_ustring os__read_ulines(string path) {
	Option_array_string lines = os__read_lines(path);
	if (!lines.ok) {
		string err = lines.v_error;
		int errcode = lines.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return v_error(err);};
	array_ustring ulines = __new_array(0, 0, sizeof(ustring));
	// FOR IN array
	array tmp1 = /*opt*/(*(array_string*)lines.data);
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string myline = ((string*)tmp1.data)[tmp2];
		array_push(&ulines, &(ustring[]){ string_ustring(myline) });
	}
	return /*:)array_ustring*/opt_ok(&(array_ustring[]) { ulines }, sizeof(array_ustring));
}

Option_os__File os__open_append(string path) {
	os__File file = (os__File){
		.cfile = 0,
		.fd = 0,
		.opened = 0,
	};
	
// $if  windows {
#ifdef _WIN32
		u16* wpath = string_to_wide(string_replace(path, tos3("/"), tos3("\\")));
		string mode = tos3("ab");
		file = (os__File){
			.cfile = _wfopen(wpath, string_to_wide(mode)),
			.fd = 0,
			.opened = 0,
		};
	
#else
		byteptr cpath = path.str;
		file = (os__File){
			.cfile = fopen(((charptr)(cpath)), "ab"),
			.fd = 0,
			.opened = 0,
		};
	
// } windows
#endif

	if (isnil(file.cfile)) {
		return v_error(_STR("failed to create(append) file \"%.*s\000\"", 2, path));}
	file.opened = true;
	return /*:)os.File*/opt_ok(&(os__File[]) { file }, sizeof(os__File));
}

Option_os__File os__open_file(string path, string mode, varg_int options) {
	int flags = 0;
	for (int tmp1 = 0; tmp1 < mode.len; tmp1++) {
	byte m = mode.str[tmp1];
		if (m == 'r') {
			flags |= _const_os__O_RDONLY;
		}else if (m == 'w') {
			flags |= (_const_os__O_CREATE | _const_os__O_TRUNC);
		}else if (m == 'a') {
			flags |= (_const_os__O_CREATE | _const_os__O_APPEND);
		}else if (m == 's') {
			flags |= _const_os__O_SYNC;
		}else if (m == 'n') {
			flags |= _const_os__O_NONBLOCK;
		}else if (m == 'c') {
			flags |= _const_os__O_NOCTTY;
		}else if (m == '+') {
			flags |= _const_os__O_RDWR;
		}else {
		};
	}
	int permission = 0666;
	if (options.len > 0) {
		permission = options.args[0];
	}
	
// $if  windows {
#ifdef _WIN32
		if (permission < 0600) {
			permission = 0x0100;
		} else {
			permission = (0x0100 | 0x0080);
		}
	
// } windows
#endif

	string p = path;
	
// $if  windows {
#ifdef _WIN32
		p = string_replace(path, tos3("/"), tos3("\\"));
	
// } windows
#endif

	int fd = open(((charptr)(p.str)), flags, permission);
	if (fd == -1) {
		return v_error(os__posix_get_error_msg(errno));}
	voidptr cfile = fdopen(fd, ((charptr)(mode.str)));
	if (isnil(cfile)) {
		return v_error(_STR("Failed to open or create file \"%.*s\000\"", 2, path));}
	return /*:)os.File*/opt_ok(&(os__File[]) { (os__File){
		.cfile = cfile,
		.fd = fd,
		.opened = true,
	} }, sizeof(os__File));
}

void os__File_write_bytes_at(os__File* f, voidptr data, int size, int pos) {
	fseek(f->cfile, pos, SEEK_SET);
	fwrite(data, 1, size, f->cfile);
	fseek(f->cfile, 0, SEEK_END);
}

void os__File_flush(os__File* f) {
	if (!f->opened) {
		return ;
	}
	fflush(f->cfile);
}

static voidptr os__vpopen(string path) {
	
// $if  windows {
#ifdef _WIN32
		string mode = tos3("rb");
		u16* wpath = string_to_wide(path);
		return _wpopen(wpath, string_to_wide(mode));
	
#else
		byteptr cpath = path.str;
		return popen(cpath, "r");
	
// } windows
#endif

}

static multi_return_int_bool os__posix_wait4_to_exit_status(int waitret) {
	
// $if  windows {
#ifdef _WIN32
		return (multi_return_int_bool){.arg0=waitret,.arg1=false};
	
#else
		int ret = 0;
		bool is_signaled = true;
		if (WIFEXITED(waitret)) {
			ret = WEXITSTATUS(waitret);
			is_signaled = false;
		} else if (WIFSIGNALED(waitret)) {
			ret = WTERMSIG(waitret);
			is_signaled = true;
		}
		return (multi_return_int_bool){.arg0=ret,.arg1=is_signaled};
	
// } windows
#endif

}

string os__posix_get_error_msg(int code) {
	charptr ptr_text = strerror(code);
	if (ptr_text == 0) {
		return tos3("");
	}
	return tos3(ptr_text);
}

static int os__vpclose(voidptr f) {
	
// $if  windows {
#ifdef _WIN32
		return _pclose(f);
	
#else
		multi_return_int_bool mr_8159 = os__posix_wait4_to_exit_status(pclose(f));
		int ret = mr_8159.arg0;
		return ret;
	
// } windows
#endif

}

int os__system(string cmd) {
	int ret = 0;
	
// $if  windows {
#ifdef _WIN32
		string wcmd = (cmd.len > 1 && string_at(cmd, 0) == '"' && string_at(cmd, 1) != '"' ?  ( _STR("\"%.*s\000\"", 2, cmd) )  :  ( cmd ) );
		ret = _wsystem(string_to_wide(wcmd));
	
#else
		ret = system(cmd.str);
	
// } windows
#endif

	if (ret == -1) {
		os__print_c_errno();
	}
	
// $if !windows {
#ifndef _WIN32
		multi_return_int_bool mr_8950 = os__posix_wait4_to_exit_status(ret);
		int pret = mr_8950.arg0;
		bool is_signaled = mr_8950.arg1;
		if (is_signaled) {
			println(string_add(string_add(_STR("Terminated by signal %2"PRId32"\000 (", 2, ret), os__sigint_to_signal_name(pret)), tos3(")")));
		}
		ret = pret;
	
// } windows
#endif

	return ret;
}

string os__sigint_to_signal_name(int si) {
	if (si == 1) {
		return tos3("SIGHUP");
	}else if (si == 2) {
		return tos3("SIGINT");
	}else if (si == 3) {
		return tos3("SIGQUIT");
	}else if (si == 4) {
		return tos3("SIGILL");
	}else if (si == 6) {
		return tos3("SIGABRT");
	}else if (si == 8) {
		return tos3("SIGFPE");
	}else if (si == 9) {
		return tos3("SIGKILL");
	}else if (si == 11) {
		return tos3("SIGSEGV");
	}else if (si == 13) {
		return tos3("SIGPIPE");
	}else if (si == 14) {
		return tos3("SIGALRM");
	}else if (si == 15) {
		return tos3("SIGTERM");
	}else {
	};
	
// $if  linux {
#ifdef __linux__
		if (si == 10) {
			return tos3("SIGUSR1");
		}else if (si == 12) {
			return tos3("SIGUSR2");
		}else if (si == 17) {
			return tos3("SIGCHLD");
		}else if (si == 18) {
			return tos3("SIGCONT");
		}else if (si == 19) {
			return tos3("SIGSTOP");
		}else if (si == 20) {
			return tos3("SIGTSTP");
		}else if (si == 21) {
			return tos3("SIGTTIN");
		}else if (si == 22) {
			return tos3("SIGTTOU");
		}else if (si == 5) {
			return tos3("SIGTRAP");
		}else if (si == 7) {
			return tos3("SIGBUS");
		}else {
		};
	
// } linux
#endif

	return tos3("unknown");
}

bool os__exists(string path) {
	
// $if  windows {
#ifdef _WIN32
		string p = string_replace(path, tos3("/"), tos3("\\"));
		return _waccess(string_to_wide(p), _const_os__F_OK) != -1;
	
#else
		return access(path.str, _const_os__F_OK) != -1;
	
// } windows
#endif

}

bool os__is_executable(string path) {
	
// $if  windows {
#ifdef _WIN32
		string p = os__real_path(path);
		return (os__exists(p) && string_ends_with(p, tos3(".exe")));
	
// } windows
#endif

	
// $if  solaris {
#ifdef __sun
		struct stat statbuf = (struct stat){
			.st_size = 0,
			.st_mode = 0,
			.st_mtime = 0,
		};
		if (stat(path.str, &statbuf) != 0) {
			return false;
		}
		return ((((int)(statbuf.st_mode)) & (((_const_os__S_IXUSR | _const_os__S_IXGRP) | _const_os__S_IXOTH)))) != 0;
	
// } solaris
#endif

	return access(path.str, _const_os__X_OK) != -1;
}

Option_bool os__is_writable_folder(string folder) {
	if (!os__exists(folder)) {
		return v_error(_STR("`%.*s\000` does not exist", 2, folder));}
	if (!os__is_dir(folder)) {
		return v_error(tos3("`folder` is not a folder"));}
	string tmp_perm_check = os__join_path(folder, (varg_string){.len=1,.args={tos3("tmp_perm_check")}});
	Option_os__File f = os__open_file(tmp_perm_check, tos3("w+"), (varg_int){.len=1,.args={0700}});
	if (!f.ok) {
		string err = f.v_error;
		int errcode = f.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return v_error(_STR("cannot write to folder `%.*s\000`: %.*s", 2, folder, err));};
	os__File_close(&/*opt*/(*(os__File*)f.data));
	os__rm(tmp_perm_check);
	return /*:)bool*/opt_ok(&(bool[]) { true }, sizeof(bool));
}

bool os__is_writable(string path) {
	
// $if  windows {
#ifdef _WIN32
		string p = string_replace(path, tos3("/"), tos3("\\"));
		return _waccess(string_to_wide(p), _const_os__W_OK) != -1;
	
#else
		return access(path.str, _const_os__W_OK) != -1;
	
// } windows
#endif

}

bool os__is_readable(string path) {
	
// $if  windows {
#ifdef _WIN32
		string p = string_replace(path, tos3("/"), tos3("\\"));
		return _waccess(string_to_wide(p), _const_os__R_OK) != -1;
	
#else
		return access(path.str, _const_os__R_OK) != -1;
	
// } windows
#endif

}

// Attr: [deprecated]
bool os__file_exists(string _path) {
	v_panic(tos3("Use `os.exists` instead of `os.file_exists`"));
}

void os__rm(string path) {
	
// $if  windows {
#ifdef _WIN32
		_wremove(string_to_wide(path));
	
#else
		remove(path.str);
	
// } windows
#endif

}

void os__rmdir(string path) {
	
// $if !windows {
#ifndef _WIN32
		rmdir(path.str);
	
#else
		RemoveDirectory(string_to_wide(path));
	
// } windows
#endif

}

// Attr: [deprecated]
void os__rmdir_recursive(string path) {
	v_panic(tos3("Use `os.rmdir_all` instead of `os.rmdir_recursive`"));
}

void os__rmdir_all(string path) {
	Option_array_string items = os__ls(path);
	if (!items.ok) {
		string err = items.v_error;
		int errcode = items.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return ;
	};
	// FOR IN array
	array tmp1 = /*opt*/(*(array_string*)items.data);
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string item = ((string*)tmp1.data)[tmp2];
		if (os__is_dir(os__join_path(path, (varg_string){.len=1,.args={item}}))) {
			os__rmdir_all(os__join_path(path, (varg_string){.len=1,.args={item}}));
		}
		os__rm(os__join_path(path, (varg_string){.len=1,.args={item}}));
	}
	os__rmdir(path);
}

bool os__is_dir_empty(string path) {
	Option_array_string items = os__ls(path);
	if (!items.ok) {
		string err = items.v_error;
		int errcode = items.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return true;
	};
	return /*opt*/(*(array_string*)items.data).len == 0;
}

static void os__print_c_errno() {
	int e = errno;
	string se = tos_clone(((byteptr)(strerror(errno))));
	println(_STR("errno=%"PRId32"\000 err=%.*s", 2, e, se));
}

string os__file_ext(string path) {
	Option_int pos = string_last_index(path, tos3("."));
	if (!pos.ok) {
		string err = pos.v_error;
		int errcode = pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return tos3("");
	};
	return string_substr(path, /*opt*/(*(int*)pos.data), path.len);
}

string os__dir(string path) {
	Option_int pos = string_last_index(path, _const_os__path_separator);
	if (!pos.ok) {
		string err = pos.v_error;
		int errcode = pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return tos3(".");
	};
	return string_substr(path, 0, /*opt*/(*(int*)pos.data));
}

string os__base_dir(string path) {
	Option_int posx = string_last_index(path, _const_os__path_separator);
	if (!posx.ok) {
		string err = posx.v_error;
		int errcode = posx.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return path;
	};
	return string_substr(path, 0, /*opt*/(*(int*)posx.data));
}

string os__file_name(string path) {
	return string_all_after(path, _const_os__path_separator);
}

string os__input(string prompt) {
	print(prompt);
	os__flush();
	return os__get_line();
}

string os__get_line() {
	string str = os__get_raw_line();
	
// $if  windows {
#ifdef _WIN32
		return string_trim_right(str, tos3("\r\n"));
	
#else
		return string_trim_right(str, tos3("\n"));
	
// } windows
#endif

}

string os__get_raw_line() {
	
// $if  windows {
#ifdef _WIN32
			int max_line_chars = 256;
			byteptr buf = v_malloc(max_line_chars * 2);
			voidptr h_input = GetStdHandle(_const_os__STD_INPUT_HANDLE);
			int bytes_read = 0;
			if (is_atty(0) > 0) {
				ReadConsole(h_input, buf, max_line_chars * 2, &bytes_read, 0);
				return string_from_wide2(((u16*)(buf)), bytes_read);
			}
			int offset = 0;
			while (1) {
				byteptr pos = buf + offset;
				bool res = ReadFile(h_input, pos, 1, &bytes_read, 0);
				if (!res || bytes_read == 0) {
					break;
				}
				if (*pos == '\n' || *pos == '\r') {
					offset++;
					break;
				}
				offset++;
			}
			return tos(buf, offset);
	
#else
		size_t max = ((size_t)(0));
		charptr buf = ((charptr)(0));
		int nr_chars = getline(&buf, &max, stdin);
		if (nr_chars == 0 || nr_chars == -1) {
			return tos3("");
		}
		return tos3(buf);
	
// } windows
#endif

}

array_string os__get_lines() {
	string line = tos3("");
	array_string inputstr = __new_array(0, 0, sizeof(string));
	while (1) {
		line = os__get_line();
		if (line.len <= 0) {
			break;
		}
		line = string_trim_space(line);
		array_push(&inputstr, &(string[]){ line });
	}
	return inputstr;
}

string os__get_lines_joined() {
	string line = tos3("");
	string inputstr = tos3("");
	while (1) {
		line = os__get_line();
		if (line.len <= 0) {
			break;
		}
		line = string_trim_space(line);
		inputstr = string_add(inputstr, line);
	}
	return inputstr;
}

string os__user_os() {
	
// $if  linux {
#ifdef __linux__
		return tos3("linux");
	
// } linux
#endif

	
// $if  macos {
#ifdef __APPLE__
		return tos3("mac");
	
// } macos
#endif

	
// $if  windows {
#ifdef _WIN32
		return tos3("windows");
	
// } windows
#endif

	
// $if  freebsd {
#ifdef __FreeBSD__
		return tos3("freebsd");
	
// } freebsd
#endif

	
// $if  openbsd {
#ifdef __OpenBSD__
		return tos3("openbsd");
	
// } openbsd
#endif

	
// $if  netbsd {
#ifdef __NetBSD__
		return tos3("netbsd");
	
// } netbsd
#endif

	
// $if  dragonfly {
#ifdef __DragonFly__
		return tos3("dragonfly");
	
// } dragonfly
#endif

	
// $if  android {
#ifdef __ANDROID__
		return tos3("android");
	
// } android
#endif

	
// $if  solaris {
#ifdef __sun
		return tos3("solaris");
	
// } solaris
#endif

	
// $if  haiku {
#ifdef __haiku__
		return tos3("haiku");
	
// } haiku
#endif

	return tos3("unknown");
}

string os__home_dir() {
	
// $if  windows {
#ifdef _WIN32
		return string_add(os__getenv(tos3("USERPROFILE")), _const_os__path_separator);
	
#else
		return string_add(os__getenv(tos3("HOME")), _const_os__path_separator);
	
// } windows
#endif

}

void os__write_file(string path, string text) {
	Option_os__File f = os__create(path);
	if (!f.ok) {
		string err = f.v_error;
		int errcode = f.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return ;
	};
	os__File_write(&/*opt*/(*(os__File*)f.data), text);
	os__File_close(&/*opt*/(*(os__File*)f.data));
}

void os__clear() {
	
// $if !windows {
#ifndef _WIN32
		printf("\x1b[2J");
		printf("\x1b[H");
	
// } windows
#endif

}

void os__on_segfault(voidptr f) {
	
// $if  windows {
#ifdef _WIN32
		return ;
	
// } windows
#endif

	
// $if  macos {
#ifdef __APPLE__
		printf("TODO");
	
// } macos
#endif

}




string os__executable() {
	
// $if  linux {
#ifdef __linux__
		byteptr result = vcalloc(_const_os__MAX_PATH);
		int count = readlink("/proc/self/exe", result, _const_os__MAX_PATH);
		if (count < 0) {
			eprintln(tos3("os.executable() failed at reading /proc/self/exe to get exe path"));
			return os__executable_fallback();
		}
		return tos2(result);
	
// } linux
#endif

	
// $if  windows {
#ifdef _WIN32
		int max = 512;
		u16* result = ((u16*)(vcalloc(max * 2)));
		int len = GetModuleFileName(0, result, max);
		return string_from_wide2(result, len);
	
// } windows
#endif

	
// $if  macos {
#ifdef __APPLE__
		byteptr result = vcalloc(_const_os__MAX_PATH);
		int pid = getpid();
		int ret = proc_pidpath(pid, result, _const_os__MAX_PATH);
		if (ret <= 0) {
			eprintln(_STR("os.executable() failed at calling proc_pidpath with pid: %"PRId32"\000 . proc_pidpath returned %"PRId32"\000 ", 3, pid, ret));
			return os__executable_fallback();
		}
		return tos2(result);
	
// } macos
#endif

	
// $if  freebsd {
#ifdef __FreeBSD__
		byteptr result = vcalloc(_const_os__MAX_PATH);
		array_int mib = new_array_from_c_array(4, 4, sizeof(int), (int[4]){
		1, 14, 12, -1, 
});
		int size = _const_os__MAX_PATH;
		sysctl(mib.data, 4, result, &size, 0, 0);
		return tos2(result);
	
// } freebsd
#endif

	
// $if  openbsd {
#ifdef __OpenBSD__
	
// } openbsd
#endif

	
// $if  solaris {
#ifdef __sun
	
// } solaris
#endif

	
// $if  haiku {
#ifdef __haiku__
	
// } haiku
#endif

	
// $if  netbsd {
#ifdef __NetBSD__
		byteptr result = vcalloc(_const_os__MAX_PATH);
		int count = readlink("/proc/curproc/exe", result, _const_os__MAX_PATH);
		if (count < 0) {
			eprintln(tos3("os.executable() failed at reading /proc/curproc/exe to get exe path"));
			return os__executable_fallback();
		}
		return tos(result, count);
	
// } netbsd
#endif

	
// $if  dragonfly {
#ifdef __DragonFly__
		byteptr result = vcalloc(_const_os__MAX_PATH);
		int count = readlink("/proc/curproc/file", result, _const_os__MAX_PATH);
		if (count < 0) {
			eprintln(tos3("os.executable() failed at reading /proc/curproc/file to get exe path"));
			return os__executable_fallback();
		}
		return tos(result, count);
	
// } dragonfly
#endif

	return os__executable_fallback();
}

static string os__executable_fallback() {
	if (_const_os__args.len == 0) {
		return tos3("");
	}
	string exepath = (*(string*)array_get(_const_os__args, 0));
	if (!os__is_abs_path(exepath)) {
		if (string_contains(exepath, _const_os__path_separator)) {
			exepath = os__join_path(_const_os__wd_at_startup, (varg_string){.len=1,.args={exepath}});
		} else {
			Option_string foundpath = os__find_abs_path_of_executable(exepath);
			if (!foundpath.ok) {
				string err = foundpath.v_error;
				int errcode = foundpath.ecode;
				// last_type: v.ast.ExprStmt
				// last_expr_result_type: v.ast.StringLiteral
				*(string*) foundpath.data = tos3("");
			};
			if (/*opt*/(*(string*)foundpath.data).len > 0) {
				exepath = /*opt*/(*(string*)foundpath.data);
			}
		}
	}
	exepath = os__real_path(exepath);
	return exepath;
}

Option_string os__find_abs_path_of_executable(string exepath) {
	if (os__is_abs_path(exepath)) {
		return /*:)string*/opt_ok(&(string[]) { exepath }, sizeof(string));
	}
	string res = tos3("");
	string env_path_delimiter = (string_eq(os__user_os(), tos3("windows")) ?  ( tos3(";") )  :  ( tos3(":") ) );
	array_string paths = string_split(os__getenv(tos3("PATH")), env_path_delimiter);
	// FOR IN array
	array tmp3 = paths;
	for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
		string p = ((string*)tmp3.data)[tmp4];
		string found_abs_path = os__join_path(p, (varg_string){.len=1,.args={exepath}});
		if (os__exists(found_abs_path) && os__is_executable(found_abs_path)) {
			res = found_abs_path;
			break;
		}
	}
	if (res.len > 0) {
		return /*:)string*/opt_ok(&(string[]) { res }, sizeof(string));
	}
	return v_error(tos3("failed to find executable"));}

// Attr: [deprecated]
bool os__dir_exists(string path) {
	v_panic(tos3("Use `os.is_dir` instead of `os.dir_exists`"));
}

bool os__is_dir(string path) {
	
// $if  windows {
#ifdef _WIN32
		string _path = string_replace(path, tos3("/"), tos3("\\"));
		u32 attr = GetFileAttributesW(string_to_wide(_path));
		if (attr == ((u32)(INVALID_FILE_ATTRIBUTES))) {
			return false;
		}
		if ((((int)(attr)) & FILE_ATTRIBUTE_DIRECTORY) != 0) {
			return true;
		}
		return false;
	
#else
		struct stat statbuf = (struct stat){
			.st_size = 0,
			.st_mode = 0,
			.st_mtime = 0,
		};
		if (stat(path.str, &statbuf) != 0) {
			return false;
		}
		int val = (((int)(statbuf.st_mode)) & _const_os__S_IFMT);
		return val == _const_os__S_IFDIR;
	
// } windows
#endif

}

bool os__is_link(string path) {
	
// $if  windows {
#ifdef _WIN32
		return false;
	
#else
		struct stat statbuf = (struct stat){
			.st_size = 0,
			.st_mode = 0,
			.st_mtime = 0,
		};
		if (lstat(path.str, &statbuf) != 0) {
			return false;
		}
		return (((int)(statbuf.st_mode)) & _const_os__S_IFMT) == _const_os__S_IFLNK;
	
// } windows
#endif

}

void os__chdir(string path) {
	
// $if  windows {
#ifdef _WIN32
		_wchdir(string_to_wide(path));
	
#else
		chdir(path.str);
	
// } windows
#endif

}

string os__getwd() {
	
// $if  windows {
#ifdef _WIN32
		int max = 512;
		u16* buf = ((u16*)(vcalloc(max * 2)));
		if (_wgetcwd(buf, max) == 0) {
			return tos3("");
		}
		return string_from_wide(buf);
	
#else
		byteptr buf = vcalloc(512);
		if (getcwd(buf, 512) == 0) {
			return tos3("");
		}
		return tos2(buf);
	
// } windows
#endif

}

string os__real_path(string fpath) {
	byteptr fullpath = vcalloc(_const_os__MAX_PATH);
	charptr ret = ((charptr)(0));
	
// $if  windows {
#ifdef _WIN32
		ret = _fullpath(fullpath, fpath.str, _const_os__MAX_PATH);
		if (ret == 0) {
			return fpath;
		}
	
#else
		ret = realpath(fpath.str, fullpath);
		if (ret == 0) {
			return fpath;
		}
	
// } windows
#endif

	return tos2(fullpath);
}

bool os__is_abs_path(string path) {
	
// $if  windows {
#ifdef _WIN32
		return string_at(path, 0) == '/' || (byte_is_letter(string_at(path, 0)) && string_at(path, 1) == ':');
	
// } windows
#endif

	return string_at(path, 0) == '/';
}

string os__join_path(string base, varg_string dirs) {
	array_string result = __new_array(0, 0, sizeof(string));
	array_push(&result, &(string[]){ string_trim_right(base, tos3("\\/")) });
	// FOR IN cond_type/variadic
	for (int tmp2 = 0; tmp2 < dirs.len; tmp2++) {
	string d = dirs.args[tmp2];
		array_push(&result, &(string[]){ d });
	}
	return array_string_join(result, _const_os__path_separator);
}

array_string os__walk_ext(string path, string ext) {
	if (!os__is_dir(path)) {
		return __new_array(0, 0, sizeof(string));
	}
	Option_array_string files = os__ls(path);
	if (!files.ok) {
		string err = files.v_error;
		int errcode = files.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return __new_array(0, 0, sizeof(string));
	};
	array_string res = __new_array(0, 0, sizeof(string));
	string separator = (string_ends_with(path, _const_os__path_separator) ?  ( tos3("") )  :  ( _const_os__path_separator ) );
	// FOR IN array
	array tmp3 = /*opt*/(*(array_string*)files.data);
	for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
		string file = ((string*)tmp3.data)[tmp4];
		if (string_starts_with(file, tos3("."))) {
			continue;
		}
		string p = string_add(string_add(path, separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			_PUSH_MANY(&res, (os__walk_ext(p, ext)), tmp7, array_string);
		} else if (string_ends_with(file, ext)) {
			array_push(&res, &(string[]){ p });
		}
	}
	return res;
}

void os__walk(string path, void (*f)(string path)) {
	if (!os__is_dir(path)) {
		return ;
	}
	Option_array_string files = os__ls(path);
	if (!files.ok) {
		string err = files.v_error;
		int errcode = files.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return ;
	};
	// FOR IN array
	array tmp2 = /*opt*/(*(array_string*)files.data);
	for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
		string file = ((string*)tmp2.data)[tmp3];
		string p = string_add(string_add(path, _const_os__path_separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			os__walk(p, f);
		} else if (os__exists(p)) {
			f(p);
		}
	}
	return ;
}

void os__signal(int signum, voidptr handler) {
	signal(signum, handler);
}



int os__fork() {
	int pid = -1;
	
// $if !windows {
#ifndef _WIN32
		pid = fork();
	
// } windows
#endif

	
// $if  windows {
#ifdef _WIN32
		v_panic(tos3("os.fork not supported in windows"));
	
// } windows
#endif

	return pid;
}

int os__wait() {
	int pid = -1;
	
// $if !windows {
#ifndef _WIN32
		pid = wait(0);
	
// } windows
#endif

	
// $if  windows {
#ifdef _WIN32
		v_panic(tos3("os.wait not supported in windows"));
	
// } windows
#endif

	return pid;
}

int os__file_last_mod_unix(string path) {
	struct stat attr = (struct stat){
		.st_size = 0,
		.st_mode = 0,
		.st_mtime = 0,
	};
	stat(path.str, &attr);
	return attr.st_mtime;
}

void os__log(string s) {
	println(string_add(tos3("os.log: "), s));
}

// Attr: [deprecated]
void os__flush_stdout() {
	v_panic(tos3("Use `os.flush` instead of `os.flush_stdout`"));
}

void os__flush() {
	fflush(stdout);
}

void os__mkdir_all(string path) {
	string p = (string_starts_with(path, _const_os__path_separator) ?  ( _const_os__path_separator )  :  ( tos3("") ) );
	// FOR IN array
	array tmp2 = string_split(path, _const_os__path_separator);
	for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
		string subdir = ((string*)tmp2.data)[tmp3];
		p = string_add(p, string_add(subdir, _const_os__path_separator));
		if (!os__is_dir(p)) {
			Option_bool tmp5 = os__mkdir(p);
			if (!tmp5.ok) {
				string err = tmp5.v_error;
				int errcode = tmp5.ecode;
				 // typeof it_expr_type: v.ast.CallExpr
				// last_type: v.ast.ExprStmt
				// last_expr_result_type: void
				v_panic(err);
			};
		}
	}
}

string os__cache_dir() {
	
// $if !windows {
#ifndef _WIN32
		string xdg_cache_home = os__getenv(tos3("XDG_CACHE_HOME"));
		if (string_ne(xdg_cache_home, tos3(""))) {
			return xdg_cache_home;
		}
	
// } windows
#endif

	string cdir = string_add(os__home_dir(), tos3(".cache"));
	if (!os__is_dir(cdir) && !os__is_link(cdir)) {
		Option_bool tmp3 = os__mkdir(cdir);
		if (!tmp3.ok) {
			string err = tmp3.v_error;
			int errcode = tmp3.ecode;
			 // typeof it_expr_type: v.ast.CallExpr
			// last_type: v.ast.ExprStmt
			// last_expr_result_type: void
			v_panic(err);
		};
	}
	return cdir;
}

string os__temp_dir() {
	string path = os__getenv(tos3("TMPDIR"));
	
// $if  windows {
#ifdef _WIN32
		if (string_eq(path, tos3(""))) {
			path = os__getenv(tos3("TEMP"));
			if (string_eq(path, tos3(""))) {
				path = os__getenv(tos3("TMP"));
			}
			if (string_eq(path, tos3(""))) {
				path = tos3("C:/tmp");
			}
		}
	
// } windows
#endif

	if (string_eq(path, tos3(""))) {
		path = os__cache_dir();
	}
	if (string_eq(path, tos3(""))) {
		path = tos3("/tmp");
	}
	return path;
}

void os__chmod(string path, int mode) {
	chmod(path.str, mode);
}

string os__resource_abs_path(string path) {
	string base_path = os__real_path(os__dir(os__executable()));
	string vresource = os__getenv(tos3("V_RESOURCE_PATH"));
	if (vresource.len != 0) {
		base_path = vresource;
	}
	return os__real_path(os__join_path(base_path, (varg_string){.len=1,.args={path}}));
}


static array_string os__init_os_args(int argc, byte** argv) {
	array_string args = __new_array(0, 0, sizeof(string));
	for (int tmp1 = 0; tmp1 < argc; tmp1++) {
		int i = tmp1;
		array_push(&args, &(string[]){ tos2(argv[i]) });
	}
	return args;
}

Option_array_string os__ls(string path) {
	array_string res = __new_array(0, 0, sizeof(string));
	voidptr dir = opendir(path.str);
	if (isnil(dir)) {
		return v_error(_STR("ls() couldnt open dir \"%.*s\000\"", 2, path));}
	struct dirent* ent = ((struct dirent*)(0));
	while (1) {
		ent = readdir(dir);
		if (isnil(ent)) {
			break;
		}
		string name = tos_clone(((byteptr)(ent->d_name)));
		if (string_ne(name, tos3(".")) && string_ne(name, tos3("..")) && string_ne(name, tos3(""))) {
			array_push(&res, &(string[]){ name });
		}
	}
	closedir(dir);
	return /*:)array_string*/opt_ok(&(array_string[]) { res }, sizeof(array_string));
}

Option_os__File os__open(string path) {
	os__File file = (os__File){
		.cfile = fopen(((charptr)(path.str)), "rb"),
		.opened = true,
		.fd = 0,
	};
	if (isnil(file.cfile)) {
		return v_error(_STR("failed to open file \"%.*s\000\"", 2, path));}
	return /*:)os.File*/opt_ok(&(os__File[]) { file }, sizeof(os__File));
}

Option_os__File os__create(string path) {
	os__File file = (os__File){
		.cfile = fopen(((charptr)(path.str)), "wb"),
		.opened = true,
		.fd = 0,
	};
	if (isnil(file.cfile)) {
		return v_error(_STR("failed to create file \"%.*s\000\"", 2, path));}
	return /*:)os.File*/opt_ok(&(os__File[]) { file }, sizeof(os__File));
}

void os__File_write(os__File* f, string s) {
	if (!f->opened) {
		return ;
	}
	fputs(s.str, f->cfile);
}

void os__File_writeln(os__File* f, string s) {
	if (!f->opened) {
		return ;
	}
	fputs(s.str, f->cfile);
	fputs("\n", f->cfile);
}

Option_bool os__mkdir(string path) {
	if (string_eq(path, tos3("."))) {
		return /*:)bool*/opt_ok(&(bool[]) { true }, sizeof(bool));
	}
	string apath = os__real_path(path);
	int r = mkdir(apath.str, 511);
	if (r == -1) {
		return v_error(os__posix_get_error_msg(errno));}
	return /*:)bool*/opt_ok(&(bool[]) { true }, sizeof(bool));
}

Option_os__Result os__exec(string cmd) {
	string pcmd = _STR("%.*s\000 2>&1", 2, cmd);
	voidptr f = os__vpopen(pcmd);
	if (isnil(f)) {
		return v_error(_STR("exec(\"%.*s\000\") failed", 2, cmd));}
	array_fixed_byte_4096 buf = {0};
	strings__Builder res = strings__new_builder(1024);
	while (fgets(((charptr)(buf)), 4096, f) != 0) {
		strings__Builder_write_bytes(&res, &/*qq*/buf, vstrlen(&/*qq*/buf));
	}
	string soutput = string_trim_space(strings__Builder_str(&res));
	int exit_code = os__vpclose(f);
	return /*:)os.Result*/opt_ok(&(os__Result[]) { (os__Result){
		.output = soutput,
		.exit_code = exit_code,
	} }, sizeof(os__Result));
}

Option_bool os__symlink(string origin, string target) {
	int res = symlink(origin.str, target.str);
	if (res == 0) {
		return /*:)bool*/opt_ok(&(bool[]) { true }, sizeof(bool));
	}
	return v_error(os__posix_get_error_msg(errno));}

string os__get_error_msg(int code) {
	return os__posix_get_error_msg(code);
}

void os__File_write_bytes(os__File* f, voidptr data, int size) {
	fwrite(data, 1, size, f->cfile);
}

void os__File_close(os__File* f) {
	if (!f->opened) {
		return ;
	}
	f->opened = false;
	fflush(f->cfile);
	fclose(f->cfile);
}

array_string os__cmdline__options(array_string args, string param) {
	array_string flags = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp1 = args;
	for (int i = 0; i < tmp1.len; i++) {
		string v = ((string*)tmp1.data)[i];
		if (string_eq(v, param)) {
			if (i + 1 < args.len) {
				array_push(&flags, &(string[]){ (*(string*)array_get(args, i + 1)) });
			}
		}
	}
	return flags;
}

string os__cmdline__option(array_string args, string param, string def) {
	bool found = false;
	// FOR IN array
	array tmp1 = args;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string arg = ((string*)tmp1.data)[tmp2];
		if (found) {
			return arg;
		} else if (string_eq(param, arg)) {
			found = true;
		}
	}
	return def;
}

array_string os__cmdline__options_before(array_string args, array_string what) {
	array_string args_before = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp1 = args;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string a = ((string*)tmp1.data)[tmp2];
		if (_IN(string, a, what)) {
			break;
		}
		array_push(&args_before, &(string[]){ a });
	}
	return args_before;
}

array_string os__cmdline__options_after(array_string args, array_string what) {
	bool found = false;
	array_string args_after = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp1 = args;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string a = ((string*)tmp1.data)[tmp2];
		if (_IN(string, a, what)) {
			found = true;
			continue;
		}
		if (found) {
			array_push(&args_after, &(string[]){ a });
		}
	}
	return args_after;
}

array_string os__cmdline__only_non_options(array_string args) {

int tmp1_len = args.len;
	array_string tmp1 = __new_array(0, tmp1_len, sizeof(string));
	for (int i = 0; i < tmp1_len; i++) {
	  string it = ((string*) args.data)[i];
	if (!string_starts_with(it, tos3("-"))) array_push(&tmp1, &it); 
 }
		return  tmp1;
}

array_string os__cmdline__only_options(array_string args) {

int tmp1_len = args.len;
	array_string tmp1 = __new_array(0, tmp1_len, sizeof(string));
	for (int i = 0; i < tmp1_len; i++) {
	  string it = ((string*) args.data)[i];
	if (string_starts_with(it, tos3("-"))) array_push(&tmp1, &it); 
 }
		return  tmp1;
}

string v__token__Position_str(v__token__Position pos) {
	return _STR("Position{ line_nr: %"PRId32"\000, pos: %"PRId32"\000, len: %"PRId32"\000 }", 4, pos.line_nr, pos.pos, pos.len);
}

v__token__Position v__token__Position_extend(v__token__Position pos, v__token__Position end) {
	return // assoc
	(v__token__Position){
		.len = end.pos - pos.pos + end.len, 
		.line_nr = pos.line_nr,
		.pos = pos.pos,
	};
}

// Attr: [inline]
inline v__token__Position v__token__Token_position(v__token__Token* tok) {
	return (v__token__Position){
		.line_nr = tok->line_nr - 1,
		.pos = tok->pos,
		.len = tok->len,
	};
}

static map_string_int v__token__build_keys() {
	map_string_int res = new_map_1(sizeof(int));
	for (int tmp1 = ((int)(v__token__Kind_keyword_beg)) + 1; tmp1 < ((int)(v__token__Kind_keyword_end)); tmp1++) {
		int t = tmp1;
		string key = (*(string*)array_get(_const_v__token__token_str, t));
		map_set(&res, key, &(int[]) { t });
	}
	return res;
}

static array_string v__token__build_token_str() {
	array_string s = array_repeat(new_array_from_c_array(1, 1, sizeof(string), (string[1]){
		tos3(""), 
}), _const_v__token__nr_tokens);
	array_set(&s, v__token__Kind_eof, &(string[]) { tos3("eof") });
	array_set(&s, v__token__Kind_name, &(string[]) { tos3("name") });
	array_set(&s, v__token__Kind_number, &(string[]) { tos3("number") });
	array_set(&s, v__token__Kind_string, &(string[]) { tos3("string") });
	array_set(&s, v__token__Kind_chartoken, &(string[]) { tos3("char") });
	array_set(&s, v__token__Kind_plus, &(string[]) { tos3("+") });
	array_set(&s, v__token__Kind_minus, &(string[]) { tos3("-") });
	array_set(&s, v__token__Kind_mul, &(string[]) { tos3("*") });
	array_set(&s, v__token__Kind_div, &(string[]) { tos3("/") });
	array_set(&s, v__token__Kind_mod, &(string[]) { tos3("%") });
	array_set(&s, v__token__Kind_xor, &(string[]) { tos3("^") });
	array_set(&s, v__token__Kind_bit_not, &(string[]) { tos3("~") });
	array_set(&s, v__token__Kind_pipe, &(string[]) { tos3("|") });
	array_set(&s, v__token__Kind_hash, &(string[]) { tos3("#") });
	array_set(&s, v__token__Kind_amp, &(string[]) { tos3("&") });
	array_set(&s, v__token__Kind_inc, &(string[]) { tos3("++") });
	array_set(&s, v__token__Kind_dec, &(string[]) { tos3("--") });
	array_set(&s, v__token__Kind_and, &(string[]) { tos3("&&") });
	array_set(&s, v__token__Kind_logical_or, &(string[]) { tos3("||") });
	array_set(&s, v__token__Kind_not, &(string[]) { tos3("!") });
	array_set(&s, v__token__Kind_dot, &(string[]) { tos3(".") });
	array_set(&s, v__token__Kind_dotdot, &(string[]) { tos3("..") });
	array_set(&s, v__token__Kind_ellipsis, &(string[]) { tos3("...") });
	array_set(&s, v__token__Kind_comma, &(string[]) { tos3(",") });
	array_set(&s, v__token__Kind_not_in, &(string[]) { tos3("!in") });
	array_set(&s, v__token__Kind_semicolon, &(string[]) { tos3(";") });
	array_set(&s, v__token__Kind_colon, &(string[]) { tos3(":") });
	array_set(&s, v__token__Kind_arrow, &(string[]) { tos3("=>") });
	array_set(&s, v__token__Kind_assign, &(string[]) { tos3("=") });
	array_set(&s, v__token__Kind_decl_assign, &(string[]) { tos3(":=") });
	array_set(&s, v__token__Kind_plus_assign, &(string[]) { tos3("+=") });
	array_set(&s, v__token__Kind_minus_assign, &(string[]) { tos3("-=") });
	array_set(&s, v__token__Kind_mult_assign, &(string[]) { tos3("*=") });
	array_set(&s, v__token__Kind_div_assign, &(string[]) { tos3("/=") });
	array_set(&s, v__token__Kind_xor_assign, &(string[]) { tos3("^=") });
	array_set(&s, v__token__Kind_mod_assign, &(string[]) { tos3("%=") });
	array_set(&s, v__token__Kind_or_assign, &(string[]) { tos3("|=") });
	array_set(&s, v__token__Kind_and_assign, &(string[]) { tos3("&=") });
	array_set(&s, v__token__Kind_right_shift_assign, &(string[]) { tos3(">>=") });
	array_set(&s, v__token__Kind_left_shift_assign, &(string[]) { tos3("<<=") });
	array_set(&s, v__token__Kind_lcbr, &(string[]) { tos3("{") });
	array_set(&s, v__token__Kind_rcbr, &(string[]) { tos3("}") });
	array_set(&s, v__token__Kind_lpar, &(string[]) { tos3("(") });
	array_set(&s, v__token__Kind_rpar, &(string[]) { tos3(")") });
	array_set(&s, v__token__Kind_lsbr, &(string[]) { tos3("[") });
	array_set(&s, v__token__Kind_rsbr, &(string[]) { tos3("]") });
	array_set(&s, v__token__Kind_eq, &(string[]) { tos3("==") });
	array_set(&s, v__token__Kind_ne, &(string[]) { tos3("!=") });
	array_set(&s, v__token__Kind_gt, &(string[]) { tos3(">") });
	array_set(&s, v__token__Kind_lt, &(string[]) { tos3("<") });
	array_set(&s, v__token__Kind_ge, &(string[]) { tos3(">=") });
	array_set(&s, v__token__Kind_le, &(string[]) { tos3("<=") });
	array_set(&s, v__token__Kind_question, &(string[]) { tos3("?") });
	array_set(&s, v__token__Kind_left_shift, &(string[]) { tos3("<<") });
	array_set(&s, v__token__Kind_right_shift, &(string[]) { tos3(">>") });
	array_set(&s, v__token__Kind_comment, &(string[]) { tos3("// comment") });
	array_set(&s, v__token__Kind_nl, &(string[]) { tos3("NLL") });
	array_set(&s, v__token__Kind_dollar, &(string[]) { tos3("$") });
	array_set(&s, v__token__Kind_str_dollar, &(string[]) { tos3("$2") });
	array_set(&s, v__token__Kind_key_assert, &(string[]) { tos3("assert") });
	array_set(&s, v__token__Kind_key_struct, &(string[]) { tos3("struct") });
	array_set(&s, v__token__Kind_key_if, &(string[]) { tos3("if") });
	array_set(&s, v__token__Kind_key_else, &(string[]) { tos3("else") });
	array_set(&s, v__token__Kind_key_asm, &(string[]) { tos3("asm") });
	array_set(&s, v__token__Kind_key_return, &(string[]) { tos3("return") });
	array_set(&s, v__token__Kind_key_module, &(string[]) { tos3("module") });
	array_set(&s, v__token__Kind_key_sizeof, &(string[]) { tos3("sizeof") });
	array_set(&s, v__token__Kind_key_go, &(string[]) { tos3("go") });
	array_set(&s, v__token__Kind_key_goto, &(string[]) { tos3("goto") });
	array_set(&s, v__token__Kind_key_const, &(string[]) { tos3("const") });
	array_set(&s, v__token__Kind_key_mut, &(string[]) { tos3("mut") });
	array_set(&s, v__token__Kind_key_type, &(string[]) { tos3("type") });
	array_set(&s, v__token__Kind_key_for, &(string[]) { tos3("for") });
	array_set(&s, v__token__Kind_key_switch, &(string[]) { tos3("switch") });
	array_set(&s, v__token__Kind_key_fn, &(string[]) { tos3("fn") });
	array_set(&s, v__token__Kind_key_true, &(string[]) { tos3("true") });
	array_set(&s, v__token__Kind_key_false, &(string[]) { tos3("false") });
	array_set(&s, v__token__Kind_key_continue, &(string[]) { tos3("continue") });
	array_set(&s, v__token__Kind_key_break, &(string[]) { tos3("break") });
	array_set(&s, v__token__Kind_key_import, &(string[]) { tos3("import") });
	array_set(&s, v__token__Kind_key_embed, &(string[]) { tos3("embed") });
	array_set(&s, v__token__Kind_key_unsafe, &(string[]) { tos3("unsafe") });
	array_set(&s, v__token__Kind_key_typeof, &(string[]) { tos3("typeof") });
	array_set(&s, v__token__Kind_key_enum, &(string[]) { tos3("enum") });
	array_set(&s, v__token__Kind_key_interface, &(string[]) { tos3("interface") });
	array_set(&s, v__token__Kind_key_pub, &(string[]) { tos3("pub") });
	array_set(&s, v__token__Kind_key_in, &(string[]) { tos3("in") });
	array_set(&s, v__token__Kind_key_atomic, &(string[]) { tos3("atomic") });
	array_set(&s, v__token__Kind_key_orelse, &(string[]) { tos3("or") });
	array_set(&s, v__token__Kind_key_global, &(string[]) { tos3("__global") });
	array_set(&s, v__token__Kind_key_union, &(string[]) { tos3("union") });
	array_set(&s, v__token__Kind_key_static, &(string[]) { tos3("static") });
	array_set(&s, v__token__Kind_key_as, &(string[]) { tos3("as") });
	array_set(&s, v__token__Kind_key_defer, &(string[]) { tos3("defer") });
	array_set(&s, v__token__Kind_key_match, &(string[]) { tos3("match") });
	array_set(&s, v__token__Kind_key_select, &(string[]) { tos3("select") });
	array_set(&s, v__token__Kind_key_none, &(string[]) { tos3("none") });
	array_set(&s, v__token__Kind_key_offsetof, &(string[]) { tos3("__offsetof") });
	array_set(&s, v__token__Kind_key_is, &(string[]) { tos3("is") });
	return s;
}

v__token__Kind v__token__key_to_token(string key) {
	v__token__Kind a = ((v__token__Kind)((*(int*)map_get3(_const_v__token__keywords, key, &(int[]){ 0 }))));
	return a;
}

bool v__token__is_key(string key) {
	return ((int)(v__token__key_to_token(key))) > 0;
}

bool v__token__is_decl(v__token__Kind t) {
	return (t == v__token__Kind_key_enum || t == v__token__Kind_key_interface || t == v__token__Kind_key_fn || t == v__token__Kind_key_struct || t == v__token__Kind_key_type || t == v__token__Kind_key_const || t == v__token__Kind_key_pub || t == v__token__Kind_eof);
}

bool v__token__Kind_is_assign(v__token__Kind t) {
	return _IN(v__token__Kind, t, _const_v__token__assign_tokens);
}

static bool array_v__token__Kind_contains(array_v__token__Kind t, v__token__Kind val) {
	// FOR IN array
	array tmp1 = t;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__token__Kind tt = ((v__token__Kind*)tmp1.data)[tmp2];
		if (tt == val) {
			return true;
		}
	}
	return false;
}

string v__token__Kind_str(v__token__Kind t) {
	return (*(string*)array_get(_const_v__token__token_str, ((int)(t))));
}

string v__token__Token_str(v__token__Token t) {
	return _STR("%.*s\000 \"%.*s\000\"", 3, v__token__Kind_str(t.kind), t.lit);
}

array_v__token__Precedence v__token__build_precedences() {
	array_v__token__Precedence p = __new_array(100, 100, sizeof(v__token__Precedence));
	array_set(&p, v__token__Kind_assign, &(v__token__Precedence[]) { v__token__Precedence_assign });
	array_set(&p, v__token__Kind_eq, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_ne, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_lt, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_gt, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_le, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_ge, &(v__token__Precedence[]) { v__token__Precedence_eq });
	array_set(&p, v__token__Kind_plus, &(v__token__Precedence[]) { v__token__Precedence_sum });
	array_set(&p, v__token__Kind_plus_assign, &(v__token__Precedence[]) { v__token__Precedence_sum });
	array_set(&p, v__token__Kind_minus, &(v__token__Precedence[]) { v__token__Precedence_sum });
	array_set(&p, v__token__Kind_minus_assign, &(v__token__Precedence[]) { v__token__Precedence_sum });
	array_set(&p, v__token__Kind_div, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_div_assign, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_mul, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_mult_assign, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_mod, &(v__token__Precedence[]) { v__token__Precedence_product });
	array_set(&p, v__token__Kind_and, &(v__token__Precedence[]) { v__token__Precedence_cond });
	array_set(&p, v__token__Kind_logical_or, &(v__token__Precedence[]) { v__token__Precedence_cond });
	array_set(&p, v__token__Kind_lpar, &(v__token__Precedence[]) { v__token__Precedence_call });
	array_set(&p, v__token__Kind_dot, &(v__token__Precedence[]) { v__token__Precedence_call });
	array_set(&p, v__token__Kind_lsbr, &(v__token__Precedence[]) { v__token__Precedence_index });
	return p;
}

int v__token__Token_precedence(v__token__Token tok) {
	if (tok.kind == v__token__Kind_lsbr) {
		return ((int)(v__token__Precedence_index));
	}else if (tok.kind == v__token__Kind_dot) {
		return ((int)(v__token__Precedence_call));
	}else if (tok.kind == v__token__Kind_inc || tok.kind == v__token__Kind_dec) {
		return ((int)(v__token__Precedence_postfix));
	}else if (tok.kind == v__token__Kind_mul || tok.kind == v__token__Kind_div || tok.kind == v__token__Kind_mod || tok.kind == v__token__Kind_left_shift || tok.kind == v__token__Kind_right_shift || tok.kind == v__token__Kind_amp) {
		return ((int)(v__token__Precedence_product));
	}else if (tok.kind == v__token__Kind_plus || tok.kind == v__token__Kind_minus || tok.kind == v__token__Kind_pipe || tok.kind == v__token__Kind_xor) {
		return ((int)(v__token__Precedence_sum));
	}else if (tok.kind == v__token__Kind_eq || tok.kind == v__token__Kind_ne || tok.kind == v__token__Kind_lt || tok.kind == v__token__Kind_le || tok.kind == v__token__Kind_gt || tok.kind == v__token__Kind_ge) {
		return ((int)(v__token__Precedence_eq));
	}else if (tok.kind == v__token__Kind_assign || tok.kind == v__token__Kind_plus_assign || tok.kind == v__token__Kind_minus_assign || tok.kind == v__token__Kind_div_assign || tok.kind == v__token__Kind_mod_assign || tok.kind == v__token__Kind_or_assign || tok.kind == v__token__Kind_and_assign || tok.kind == v__token__Kind_left_shift_assign || tok.kind == v__token__Kind_right_shift_assign || tok.kind == v__token__Kind_mult_assign || tok.kind == v__token__Kind_xor_assign) {
		return ((int)(v__token__Precedence_assign));
	}else if (tok.kind == v__token__Kind_key_in || tok.kind == v__token__Kind_not_in || tok.kind == v__token__Kind_key_as || tok.kind == v__token__Kind_key_is) {
		return ((int)(v__token__Precedence_in_as));
	}else if (tok.kind == v__token__Kind_logical_or || tok.kind == v__token__Kind_and) {
		return ((int)(v__token__Precedence_cond));
	}else {
		return ((int)(v__token__Precedence_lowest));
	};
}

bool v__token__Token_is_scalar(v__token__Token tok) {
	return (tok.kind == v__token__Kind_number || tok.kind == v__token__Kind_string);
}

bool v__token__Token_is_unary(v__token__Token tok) {
	return (tok.kind == v__token__Kind_plus || tok.kind == v__token__Kind_minus || tok.kind == v__token__Kind_not || tok.kind == v__token__Kind_bit_not || tok.kind == v__token__Kind_mul || tok.kind == v__token__Kind_amp);
}

bool v__token__Kind_is_relational(v__token__Kind tok) {
	return (tok == v__token__Kind_lt || tok == v__token__Kind_le || tok == v__token__Kind_gt || tok == v__token__Kind_ge || tok == v__token__Kind_eq || tok == v__token__Kind_ne);
}

bool v__token__Kind_is_start_of_type(v__token__Kind k) {
	return (k == v__token__Kind_name || k == v__token__Kind_lpar || k == v__token__Kind_amp || k == v__token__Kind_lsbr || k == v__token__Kind_question);
}

bool v__token__Kind_is_infix(v__token__Kind kind) {
	return (kind == v__token__Kind_plus || kind == v__token__Kind_minus || kind == v__token__Kind_mod || kind == v__token__Kind_mul || kind == v__token__Kind_div || kind == v__token__Kind_eq || kind == v__token__Kind_ne || kind == v__token__Kind_gt || kind == v__token__Kind_lt || kind == v__token__Kind_key_in || kind == v__token__Kind_key_as || kind == v__token__Kind_ge || kind == v__token__Kind_le || kind == v__token__Kind_logical_or || kind == v__token__Kind_xor || kind == v__token__Kind_not_in || kind == v__token__Kind_key_is || kind == v__token__Kind_and || kind == v__token__Kind_dot || kind == v__token__Kind_pipe || kind == v__token__Kind_amp || kind == v__token__Kind_left_shift || kind == v__token__Kind_right_shift);
}

string time__Time_format(time__Time t) {
	return time__Time_get_fmt_str(t, time__FormatDelimiter_hyphen, time__FormatTime_hhmm24, time__FormatDate_yyyymmdd);
}

string time__Time_format_ss(time__Time t) {
	return time__Time_get_fmt_str(t, time__FormatDelimiter_hyphen, time__FormatTime_hhmmss24, time__FormatDate_yyyymmdd);
}

string time__Time_hhmm(time__Time t) {
	return time__Time_get_fmt_time_str(t, time__FormatTime_hhmm24);
}

string time__Time_hhmmss(time__Time t) {
	return time__Time_get_fmt_time_str(t, time__FormatTime_hhmmss24);
}

string time__Time_hhmm12(time__Time t) {
	return time__Time_get_fmt_time_str(t, time__FormatTime_hhmm12);
}

string time__Time_ymmdd(time__Time t) {
	return time__Time_get_fmt_date_str(t, time__FormatDelimiter_hyphen, time__FormatDate_yyyymmdd);
}

string time__Time_ddmmy(time__Time t) {
	return time__Time_get_fmt_date_str(t, time__FormatDelimiter_dot, time__FormatDate_ddmmyyyy);
}

string time__Time_md(time__Time t) {
	return time__Time_get_fmt_date_str(t, time__FormatDelimiter_space, time__FormatDate_mmmd);
}

string time__Time_clean(time__Time t) {
	time__Time now = time__now();
	if (t.month == now.month && t.year == now.year && t.day == now.day) {
		return time__Time_get_fmt_time_str(t, time__FormatTime_hhmm24);
	}
	if (t.year == now.year) {
		return time__Time_get_fmt_str(t, time__FormatDelimiter_space, time__FormatTime_hhmm24, time__FormatDate_mmmd);
	}
	return time__Time_format(t);
}

string time__Time_clean12(time__Time t) {
	time__Time now = time__now();
	if (t.month == now.month && t.year == now.year && t.day == now.day) {
		return time__Time_get_fmt_time_str(t, time__FormatTime_hhmm12);
	}
	if (t.year == now.year) {
		return time__Time_get_fmt_str(t, time__FormatDelimiter_space, time__FormatTime_hhmm12, time__FormatDate_mmmd);
	}
	return time__Time_format(t);
}

string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time) {
	if (fmt_time == time__FormatTime_no_time) {
		return tos3("");
	}
	string tp = (t.hour > 11 ?  ( tos3("p.m.") )  :  ( tos3("a.m.") ) );
	int hour = (t.hour > 12 ?  ( t.hour - 12 )  : t.hour == 0 ?  ( 12 )  :  ( t.hour ) );
	return (fmt_time == time__FormatTime_hhmm12) ?  ( _STR("%"PRId32"\000:%02"PRId32"\000 %.*s", 3, hour, t.minute, tp) )  : (fmt_time == time__FormatTime_hhmm24) ?  ( _STR("%02"PRId32"\000:%02"PRId32"", 2, t.hour, t.minute) )  : (fmt_time == time__FormatTime_hhmmss12) ?  ( _STR("%"PRId32"\000:%02"PRId32"\000:%02"PRId32"\000 %.*s", 4, hour, t.minute, t.second, tp) )  : (fmt_time == time__FormatTime_hhmmss24) ?  ( _STR("%02"PRId32"\000:%02"PRId32"\000:%02"PRId32"", 3, t.hour, t.minute, t.second) )  :  ( _STR("unknown enumeration %.*s", 1, time__FormatTime_str(fmt_time)) ) ;
}

string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate_no_date) {
		return tos3("");
	}
	string month = _STR("%.*s", 1, time__Time_smonth(t));
	string year = string_substr(int_str(t.year), 2, int_str(t.year).len);
	string res = (fmt_date == time__FormatDate_ddmmyy) ?  ( _STR("%02"PRId32"\000|%02"PRId32"\000|%.*s", 3, t.day, t.month, year) )  : (fmt_date == time__FormatDate_ddmmyyyy) ?  ( _STR("%02"PRId32"\000|%02"PRId32"\000|%"PRId32"", 3, t.day, t.month, t.year) )  : (fmt_date == time__FormatDate_mmddyy) ?  ( _STR("%02"PRId32"\000|%02"PRId32"\000|%.*s", 3, t.month, t.day, year) )  : (fmt_date == time__FormatDate_mmddyyyy) ?  ( _STR("%02"PRId32"\000|%02"PRId32"\000|%"PRId32"", 3, t.month, t.day, t.year) )  : (fmt_date == time__FormatDate_mmmd) ?  ( _STR("%.*s\000|%"PRId32"", 2, month, t.day) )  : (fmt_date == time__FormatDate_mmmdd) ?  ( _STR("%.*s\000|%02"PRId32"", 2, month, t.day) )  : (fmt_date == time__FormatDate_mmmddyyyy) ?  ( _STR("%.*s\000|%02"PRId32"\000|%"PRId32"", 3, month, t.day, t.year) )  : (fmt_date == time__FormatDate_yyyymmdd) ?  ( _STR("%"PRId32"\000|%02"PRId32"\000|%02"PRId32"", 3, t.year, t.month, t.day) )  :  ( _STR("unknown enumeration %.*s", 1, time__FormatDate_str(fmt_date)) ) ;
	res = string_replace(res, tos3("|"), (fmt_dlmtr == time__FormatDelimiter_dot) ?  ( tos3(".") )  : (fmt_dlmtr == time__FormatDelimiter_hyphen) ?  ( tos3("-") )  : (fmt_dlmtr == time__FormatDelimiter_slash) ?  ( tos3("/") )  :  ( tos3(" ") ) );
	return res;
}

string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate_no_date) {
		if (fmt_time == time__FormatTime_no_time) {
			return tos3("");
		} else {
			return time__Time_get_fmt_time_str(t, fmt_time);
		}
	} else {
		if (fmt_time != time__FormatTime_no_time) {
			return string_add(string_add(time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date), tos3(" ")), time__Time_get_fmt_time_str(t, fmt_time));
		} else {
			return time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date);
		}
	}
}

Option_time__Time time__parse(string s) {
	Option_int pos = string_index(s, tos3(" "));
	if (!pos.ok) {
		string err = pos.v_error;
		int errcode = pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return v_error(_STR("Invalid time format: %.*s", 1, s));};
	string symd = string_substr(s, 0, /*opt*/(*(int*)pos.data));
	array_string ymd = string_split(symd, tos3("-"));
	if (ymd.len != 3) {
		return v_error(_STR("Invalid time format: %.*s", 1, s));}
	string shms = string_substr(s, /*opt*/(*(int*)pos.data), s.len);
	array_string hms = string_split(shms, tos3(":"));
	string hour = string_substr((*(string*)array_get(hms, 0)), 1, (*(string*)array_get(hms, 0)).len);
	string minute = (*(string*)array_get(hms, 1));
	string second = (*(string*)array_get(hms, 2));
	time__Time res = time__new_time((time__Time){
		.year = string_int((*(string*)array_get(ymd, 0))),
		.month = string_int((*(string*)array_get(ymd, 1))),
		.day = string_int((*(string*)array_get(ymd, 2))),
		.hour = string_int(hour),
		.minute = string_int(minute),
		.second = string_int(second),
		.v_unix = 0,
	});
	return /*:)time.Time*/opt_ok(&(time__Time[]) { res }, sizeof(time__Time));
}

Option_time__Time time__parse_rfc2822(string s) {
	array_string fields = string_split(s, tos3(" "));
	if (fields.len < 5) {
		return v_error(_STR("Invalid time format: %.*s", 1, s));}
	Option_int pos = string_index(_const_time__months_string, (*(string*)array_get(fields, 2)));
	if (!pos.ok) {
		string err = pos.v_error;
		int errcode = pos.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return v_error(_STR("Invalid time format: %.*s", 1, s));};
	int mm = /*opt*/(*(int*)pos.data) / 3 + 1;
	byteptr tmstr = ((byteptr)(0));
		tmstr = v_malloc(s.len * 2);
	int count = snprintf(((charptr)(tmstr)), (s.len * 2), "%s-%02d-%s %s", (*(string*)array_get(fields, 3)).str, mm, (*(string*)array_get(fields, 1)).str, (*(string*)array_get(fields, 4)).str);
	return time__parse(tos(tmstr, count));
}

time__StopWatch time__new_stopwatch() {
	return (time__StopWatch){
		.start = time__sys_mono_now(),
		.pause_time = 0,
		.end = 0,
	};
}

void time__StopWatch_start(time__StopWatch* t) {
	if (t->pause_time == 0) {
		t->start = time__sys_mono_now();
	} else {
		t->start += time__sys_mono_now() - t->pause_time;
	}
	t->end = 0;
	t->pause_time = 0;
}

void time__StopWatch_restart(time__StopWatch* t) {
	t->end = 0;
	t->pause_time = 0;
	t->start = time__sys_mono_now();
}

void time__StopWatch_stop(time__StopWatch* t) {
	t->end = time__sys_mono_now();
	t->pause_time = 0;
}

void time__StopWatch_pause(time__StopWatch* t) {
	t->pause_time = time__sys_mono_now();
	t->end = t->pause_time;
}

time__Duration time__StopWatch_elapsed(time__StopWatch t) {
	if (t.end == 0) {
		return ((time__Duration)(time__sys_mono_now() - t.start));
	} else {
		return ((time__Duration)(t.end - t.start));
	}
}

// TypeDecl


time__Time time__now() {
	time__time_t t = time(0);
	struct tm* now = ((struct tm*)(0));
	now = localtime(&t);
	return time__convert_ctime(*/*d*/now);
}

string time__Time_smonth(time__Time t) {
	int i = t.month - 1;
	return string_substr(_const_time__months_string, i * 3, (i + 1) * 3);
}

time__Time time__new_time(time__Time t) {
	return (time__Time){
		.year = t.year,
		.month = t.month,
		.day = t.day,
		.hour = t.hour,
		.minute = t.minute,
		.second = t.second,
		.v_unix = time__Time_unix_time(t),
	};
}

int time__Time_unix_time(time__Time t) {
	if (t.v_unix != 0) {
		return t.v_unix;
	}
	struct tm tt = (struct tm){
		.tm_sec = t.second,
		.tm_min = t.minute,
		.tm_hour = t.hour,
		.tm_mday = t.day,
		.tm_mon = t.month - 1,
		.tm_year = t.year - 1900,
	};
	return time__make_unix_time(tt);
}

time__Time time__Time_add_seconds(time__Time t, int seconds) {
	return time__unix(t.v_unix + seconds);
}

time__Time time__Time_add_days(time__Time t, int days) {
	return time__unix(t.v_unix + days * 3600 * 24);
}

static int time__since(time__Time t) {
	return 0;
}

string time__Time_relative(time__Time t) {
	time__Time now = time__now();
	u64 secs = now.v_unix - t.v_unix;
	if (secs <= 30) {
		return tos3("now");
	}
	if (secs < 60) {
		return tos3("1m");
	}
	if (secs < 3600) {
		return _STR("%"PRIu64"\000m", 2, secs / 60);
	}
	if (secs < 3600 * 24) {
		return _STR("%"PRIu64"\000h", 2, secs / 3600);
	}
	if (secs < 3600 * 24 * 5) {
		return _STR("%"PRIu64"\000d", 2, secs / 3600 / 24);
	}
	if (secs > 3600 * 24 * 10000) {
		return tos3("");
	}
	return time__Time_md(t);
}

int time__day_of_week(int y, int m, int d) {
	array_int t = new_array_from_c_array(12, 12, sizeof(int), (int[12]){
		0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4, 
});
	int sy = y;
	if (m < 3) {
		sy = sy - 1;
	}
	return (sy + sy / 4 - sy / 100 + sy / 400 + (*(int*)array_get(t, m - 1)) + d - 1) % 7 + 1;
}

int time__Time_day_of_week(time__Time t) {
	return time__day_of_week(t.year, t.month, t.day);
}

string time__Time_weekday_str(time__Time t) {
	int i = time__Time_day_of_week(t) - 1;
	return string_substr(_const_time__days_string, i * 3, (i + 1) * 3);
}

i64 time__ticks() {
	
// $if  windows {
#ifdef _WIN32
		return GetTickCount();
	
#else
		struct timeval ts = (struct timeval){
			.tv_sec = 0,
			.tv_usec = 0,
		};
		gettimeofday(&ts, 0);
		return ((i64)(ts.tv_sec * ((u64)(1000)) + (ts.tv_usec / ((u64)(1000)))));
	
// } windows
#endif

}

void time__sleep(int seconds) {
	
// $if  windows {
#ifdef _WIN32
		Sleep(seconds * 1000);
	
#else
		sleep(seconds);
	
// } windows
#endif

}

void time__sleep_ms(int milliseconds) {
	
// $if  windows {
#ifdef _WIN32
		Sleep(milliseconds);
	
#else
		usleep(milliseconds * 1000);
	
// } windows
#endif

}

void time__usleep(int microseconds) {
	
// $if  windows {
#ifdef _WIN32
		int milliseconds = microseconds / 1000;
		Sleep(milliseconds);
	
#else
		usleep(microseconds);
	
// } windows
#endif

}

bool time__is_leap_year(int year) {
	return (year % 4 == 0) && (year % 100 != 0 || year % 400 == 0);
}

Option_int time__days_in_month(int month, int year) {
	if (month > 12 || month < 1) {
		return v_error(_STR("Invalid month: %"PRId32"", 1, month));}
	int extra = (month == 2 && time__is_leap_year(year) ?  ( 1 )  :  ( 0 ) );
	int res = (*(int*)array_get(_const_time__month_days, month - 1)) + extra;
	return /*:)int*/opt_ok(&(int[]) { res }, sizeof(int));
}

string time__Time_str(time__Time t) {
	return time__Time_format_ss(t);
}

static time__Time time__convert_ctime(struct tm t) {
	return (time__Time){
		.year = t.tm_year + 1900,
		.month = t.tm_mon + 1,
		.day = t.tm_mday,
		.hour = t.tm_hour,
		.minute = t.tm_min,
		.second = t.tm_sec,
		.v_unix = time__make_unix_time(t),
	};
}

// TypeDecl
i64 time__Duration_nanoseconds(time__Duration d) {
	return ((i64)(d));
}

i64 time__Duration_microseconds(time__Duration d) {
	return ((i64)(d)) / 1000;
}

i64 time__Duration_milliseconds(time__Duration d) {
	return ((i64)(d)) / 1000000;
}

f64 time__Duration_seconds(time__Duration d) {
	time__Duration sec = d / _const_time__second;
	time__Duration nsec = d % _const_time__second;
	return ((f64)(sec)) + ((f64)(nsec)) / 1e9;
}

f64 time__Duration_minutes(time__Duration d) {
	time__Duration min = d / _const_time__minute;
	time__Duration nsec = d % _const_time__minute;
	return ((f64)(min)) + ((f64)(nsec)) / (60 * 1e9);
}

f64 time__Duration_hours(time__Duration d) {
	time__Duration hr = d / _const_time__hour;
	time__Duration nsec = d % _const_time__hour;
	return ((f64)(hr)) + ((f64)(nsec)) / (60 * 60 * 1e9);
}

static u64 time__sys_mono_now_darwin() {
	return 0;
}


static int time__make_unix_time(struct tm t) {
	return ((int)(timegm(&t)));
}

// TypeDecl

static u64 time__sys_mono_now() {
	
// $if  macos {
#ifdef __APPLE__
		return time__sys_mono_now_darwin();
	
#else
		struct timespec ts = (struct timespec){
			.tv_sec = 0,
			.tv_nsec = 0,
		};
		clock_gettime(CLOCK_MONOTONIC, &ts);
		return ((u64)(ts.tv_sec)) * 1000000000 + ((u64)(ts.tv_nsec));
	
// } macos
#endif

}

// Attr: [inline]
inline static u64 time__vpc_now() {
	struct timespec ts = (struct timespec){
		.tv_sec = 0,
		.tv_nsec = 0,
	};
	clock_gettime(CLOCK_MONOTONIC, &ts);
	return ((u64)(ts.tv_sec)) * 1000000000 + ((u64)(ts.tv_nsec));
}

time__Time time__unix(int abs) {
	int day_offset = abs / _const_time__seconds_per_day;
	if (abs % _const_time__seconds_per_day < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_473 = time__calculate_date_from_offset(day_offset);
	int year = mr_473.arg0;
	int month = mr_473.arg1;
	int day = mr_473.arg2;
	multi_return_int_int_int mr_527 = time__calculate_time_from_offset(abs % _const_time__seconds_per_day);
	int hr = mr_527.arg0;
	int min = mr_527.arg1;
	int sec = mr_527.arg2;
	return (time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hr,
		.minute = min,
		.second = sec,
		.v_unix = abs,
	};
}

// Attr: [inline]
inline static multi_return_int_int_int time__calculate_date_from_offset(int day_offset_) {
	int day_offset = day_offset_;
	int year = 2001;
	day_offset -= 31 * 365 + 8;
	year += (day_offset / _const_time__days_per_400_years) * 400;
	day_offset %= _const_time__days_per_400_years;
	if (day_offset == _const_time__days_per_100_years * 4) {
		year += 300;
		day_offset -= _const_time__days_per_100_years * 3;
	} else {
		year += (day_offset / _const_time__days_per_100_years) * 100;
		day_offset %= _const_time__days_per_100_years;
	}
	if (day_offset == _const_time__days_per_4_years * 25) {
		year += 96;
		day_offset -= _const_time__days_per_4_years * 24;
	} else {
		year += (day_offset / _const_time__days_per_4_years) * 4;
		day_offset %= _const_time__days_per_4_years;
	}
	if (day_offset == 365 * 4) {
		year += 3;
		day_offset -= 365 * 3;
	} else {
		year += (day_offset / 365);
		day_offset %= 365;
	}
	if (day_offset < 0) {
		year--;
		if (time__is_leap_year(year)) {
			day_offset += 366;
		} else {
			day_offset += 365;
		}
	}
	if (time__is_leap_year(year)) {
		if (day_offset > 31 + 29 - 1) {
			day_offset--;
		} else if (day_offset == 31 + 29 - 1) {
			return (multi_return_int_int_int){.arg0=year,.arg1=2,.arg2=29};
		}
	}
	int estimated_month = day_offset / 31;
	while (day_offset >= (*(int*)array_get(_const_time__days_before, estimated_month + 1))) {
		estimated_month++;
	}
	while (day_offset < (*(int*)array_get(_const_time__days_before, estimated_month))) {
		if (estimated_month == 0) {
			break;
		}
		estimated_month--;
	}
	day_offset -= (*(int*)array_get(_const_time__days_before, estimated_month));
	return (multi_return_int_int_int){.arg0=year,.arg1=estimated_month + 1,.arg2=day_offset + 1};
}

// Attr: [inline]
inline static multi_return_int_int_int time__calculate_time_from_offset(int second_offset_) {
	int second_offset = second_offset_;
	if (second_offset < 0) {
		second_offset += _const_time__seconds_per_day;
	}
	int hour = second_offset / _const_time__seconds_per_hour;
	second_offset %= _const_time__seconds_per_hour;
	int min = second_offset / _const_time__seconds_per_minute;
	second_offset %= _const_time__seconds_per_minute;
	return (multi_return_int_int_int){.arg0=hour,.arg1=min,.arg2=second_offset};
}

void v__depgraph__OrderedDepMap_set(v__depgraph__OrderedDepMap* o, string name, array_string deps) {
	if (!_IN_MAP(name, o->data)) {
		array_push(&o->keys, &(string[]){ name });
	}
	map_set(&o->data, name, &(array_string[]) { deps });
}

void v__depgraph__OrderedDepMap_add(v__depgraph__OrderedDepMap* o, string name, array_string deps) {
	array_string d = (*(array_string*)map_get3(o->data, name, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
	// FOR IN array
	array tmp1 = deps;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string dep = ((string*)tmp1.data)[tmp2];
		if (!_IN(string, dep, d)) {
			array_push(&d, &(string[]){ dep });
		} else {
		}
	}
	v__depgraph__OrderedDepMap_set(o, name, d);
}

array_string v__depgraph__OrderedDepMap_get(v__depgraph__OrderedDepMap* o, string name) {
	return (*(array_string*)map_get3(o->data, name, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
}

void v__depgraph__OrderedDepMap_delete(v__depgraph__OrderedDepMap* o, string name) {
	if (!_IN_MAP(name, o->data)) {
		v_panic(_STR("delete: no such key: %.*s", 1, name));
	}
	// FOR IN array
	array tmp2 = o->keys;
	for (int i = 0; i < tmp2.len; i++) {
		if (string_eq((*(string*)array_get(o->keys, i)), name)) {
			array_delete(&o->keys, i);
			break;
		}
	}
	map_delete(&o->data, name);
}

void v__depgraph__OrderedDepMap_apply_diff(v__depgraph__OrderedDepMap* o, string name, array_string deps) {
	array_string diff = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp1 = (*(array_string*)map_get3(o->data, name, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string dep = ((string*)tmp1.data)[tmp2];
		if (!_IN(string, dep, deps)) {
			array_push(&diff, &(string[]){ dep });
		}
	}
	v__depgraph__OrderedDepMap_set(o, name, diff);
}

int v__depgraph__OrderedDepMap_size(v__depgraph__OrderedDepMap* o) {
	return o->data.size;
}

v__depgraph__DepGraph* v__depgraph__new_dep_graph() {
	return (v__depgraph__DepGraph*)memdup(&(v__depgraph__DepGraph){	.acyclic = true,
		.nodes = __new_array(0, 1, sizeof(v__depgraph__DepGraphNode)),
	}, sizeof(v__depgraph__DepGraph));
}

void v__depgraph__DepGraph_add(v__depgraph__DepGraph* graph, string mod, array_string deps) {
	array_push(&graph->nodes, &(v__depgraph__DepGraphNode[]){ (v__depgraph__DepGraphNode){
		.name = mod,
		.deps = array_clone(&deps),
	} });
}

v__depgraph__DepGraph* v__depgraph__DepGraph_resolve(v__depgraph__DepGraph* graph) {
	v__depgraph__OrderedDepMap node_names = (v__depgraph__OrderedDepMap){
		.keys = __new_array(0, 1, sizeof(string)),
		.data = new_map_1(sizeof(array_string)),
	};
	v__depgraph__OrderedDepMap node_deps = (v__depgraph__OrderedDepMap){
		.keys = __new_array(0, 1, sizeof(string)),
		.data = new_map_1(sizeof(array_string)),
	};
	// FOR IN array
	array tmp1 = graph->nodes;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)tmp1.data)[tmp2];
		v__depgraph__OrderedDepMap_add(&node_names, node.name, node.deps);
		v__depgraph__OrderedDepMap_add(&node_deps, node.name, node.deps);
	}
	v__depgraph__DepGraph* resolved = v__depgraph__new_dep_graph();
	while (v__depgraph__OrderedDepMap_size(&node_deps) != 0) {
		array_string ready_set = __new_array(0, 0, sizeof(string));
		// FOR IN array
		array tmp3 = node_deps.keys;
		for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
			string name = ((string*)tmp3.data)[tmp4];
			array_string deps = (*(array_string*)map_get3(node_deps.data, name, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
			if (deps.len == 0) {
				array_push(&ready_set, &(string[]){ name });
			}
		}
		if (ready_set.len == 0) {
			v__depgraph__DepGraph* g = v__depgraph__new_dep_graph();
			g->acyclic = false;
			// FOR IN array
			array tmp8 = node_deps.keys;
			for (int tmp9 = 0; tmp9 < tmp8.len; tmp9++) {
				string name = ((string*)tmp8.data)[tmp9];
				v__depgraph__DepGraph_add(g, name, (*(array_string*)map_get3(node_names.data, name, &(array_string[]){ __new_array(0, 1, sizeof(string)) })));
			}
			return g;
		}
		// FOR IN array
		array tmp10 = ready_set;
		for (int tmp11 = 0; tmp11 < tmp10.len; tmp11++) {
			string name = ((string*)tmp10.data)[tmp11];
			v__depgraph__OrderedDepMap_delete(&node_deps, name);
			v__depgraph__DepGraph_add(resolved, name, (*(array_string*)map_get3(node_names.data, name, &(array_string[]){ __new_array(0, 1, sizeof(string)) })));
		}
		// FOR IN array
		array tmp12 = node_deps.keys;
		for (int tmp13 = 0; tmp13 < tmp12.len; tmp13++) {
			string name = ((string*)tmp12.data)[tmp13];
			v__depgraph__OrderedDepMap_apply_diff(&node_deps, name, ready_set);
		}
	}
	return resolved;
}

v__depgraph__DepGraphNode v__depgraph__DepGraph_last_node(v__depgraph__DepGraph* graph) {
	return (*(v__depgraph__DepGraphNode*)array_get(graph->nodes, graph->nodes.len - 1));
}

string v__depgraph__DepGraph_display(v__depgraph__DepGraph* graph) {
	string out = tos3("\n");
	// FOR IN array
	array tmp1 = graph->nodes;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)tmp1.data)[tmp2];
		// FOR IN array
		array tmp3 = node.deps;
		for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
			string dep = ((string*)tmp3.data)[tmp4];
			out = string_add(out, _STR(" * %.*s\000 -> %.*s\000\n", 3, node.name, dep));
		}
	}
	return out;
}

string v__depgraph__DepGraph_display_cycles(v__depgraph__DepGraph* graph) {
	map_string_v__depgraph__DepGraphNode node_names = new_map_1(sizeof(v__depgraph__DepGraphNode));
	// FOR IN array
	array tmp1 = graph->nodes;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)tmp1.data)[tmp2];
		map_set(&node_names, node.name, &(v__depgraph__DepGraphNode[]) { node });
	}
	string out = tos3("\n");
	// FOR IN array
	array tmp3 = graph->nodes;
	for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)tmp3.data)[tmp4];
		// FOR IN array
		array tmp5 = node.deps;
		for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
			string dep = ((string*)tmp5.data)[tmp6];
			if (!_IN_MAP(dep, node_names)) {
				continue;
			}
			v__depgraph__DepGraphNode dn = (*(v__depgraph__DepGraphNode*)map_get3(node_names, dep, &(v__depgraph__DepGraphNode[]){ {0} }));
			if (_IN(string, node.name, dn.deps)) {
				out = string_add(out, _STR(" * %.*s\000 -> %.*s\000\n", 3, node.name, dep));
			}
		}
	}
	return out;
}

string v__cflag__CFlag_str(v__cflag__CFlag* c) {
	return _STR("CFlag{ name: \"%.*s\000\" value: \"%.*s\000\" mod: \"%.*s\000\" os: \"%.*s\000\" }", 5, c->name, c->value, c->mod, c->os);
}

string v__cflag__CFlag_format(v__cflag__CFlag* cf) {
	string value = cf->value;
	if ((string_eq(cf->name, tos3("-l")) || string_eq(cf->name, tos3("-Wa")) || string_eq(cf->name, tos3("-Wl")) || string_eq(cf->name, tos3("-Wp"))) && value.len > 0) {
		return string_trim_space(_STR("%.*s\000%.*s", 2, cf->name, value));
	}
	if (string_eq(cf->name, tos3("-I")) || string_eq(cf->name, tos3("-L")) || string_ends_with(value, tos3(".o"))) {
		value = string_add(string_add(tos3("\""), os__real_path(value)), tos3("\""));
	}
	return string_trim_space(_STR("%.*s\000 %.*s", 2, cf->name, value));
}

static string array_v__cflag__CFlag_c_options_before_target_msvc(array_v__cflag__CFlag cflags) {
	return tos3("");
}

static string array_v__cflag__CFlag_c_options_after_target_msvc(array_v__cflag__CFlag cflags) {
	return tos3("");
}

static string array_v__cflag__CFlag_c_options_before_target(array_v__cflag__CFlag cflags) {
	array_string args = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp1 = cflags;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)tmp1.data)[tmp2];
		if (string_ne(flag.name, tos3("-l"))) {
			array_push(&args, &(string[]){ v__cflag__CFlag_format(&flag) });
		}
	}
	return array_string_join(args, tos3(" "));
}

static string array_v__cflag__CFlag_c_options_after_target(array_v__cflag__CFlag cflags) {
	array_string args = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp1 = cflags;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)tmp1.data)[tmp2];
		if (string_eq(flag.name, tos3("-l"))) {
			array_push(&args, &(string[]){ v__cflag__CFlag_format(&flag) });
		}
	}
	return array_string_join(args, tos3(" "));
}

static string array_v__cflag__CFlag_c_options_without_object_files(array_v__cflag__CFlag cflags) {
	array_string args = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp1 = cflags;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)tmp1.data)[tmp2];
		if (string_ends_with(flag.value, tos3(".o")) || string_ends_with(flag.value, tos3(".obj"))) {
			continue;
		}
		array_push(&args, &(string[]){ v__cflag__CFlag_format(&flag) });
	}
	return array_string_join(args, tos3(" "));
}

static string array_v__cflag__CFlag_c_options_only_object_files(array_v__cflag__CFlag cflags) {
	array_string args = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp1 = cflags;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)tmp1.data)[tmp2];
		if (string_ends_with(flag.value, tos3(".o")) || string_ends_with(flag.value, tos3(".obj"))) {
			array_push(&args, &(string[]){ v__cflag__CFlag_format(&flag) });
		}
	}
	return array_string_join(args, tos3(" "));
}

string term__format(string msg, string open, string close) {
	return string_add(string_add(string_add(string_add(string_add(string_add(tos3("\x1b["), open), tos3("m")), msg), tos3("\x1b[")), close), tos3("m"));
}

string term__format_rgb(int r, int g, int b, string msg, string open, string close) {
	return string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(string_add(tos3("\x1b["), open), tos3(";2;")), int_str(r)), tos3(";")), int_str(g)), tos3(";")), int_str(b)), tos3("m")), msg), tos3("\x1b[")), close), tos3("m"));
}

string term__rgb(int r, int g, int b, string msg) {
	return term__format_rgb(r, g, b, msg, tos3("38"), tos3("39"));
}

string term__bg_rgb(int r, int g, int b, string msg) {
	return term__format_rgb(r, g, b, msg, tos3("48"), tos3("49"));
}

string term__hex(int hex, string msg) {
	return term__format_rgb(hex >> 16, (hex >> 8 & 0xFF), (hex & 0xFF), msg, tos3("38"), tos3("39"));
}

string term__bg_hex(int hex, string msg) {
	return term__format_rgb(hex >> 16, (hex >> 8 & 0xFF), (hex & 0xFF), msg, tos3("48"), tos3("49"));
}

string term__bg_black(string msg) {
	return term__format(msg, tos3("40"), tos3("49"));
}

string term__bright_bg_black(string msg) {
	return term__format(msg, tos3("100"), tos3("49"));
}

string term__bg_blue(string msg) {
	return term__format(msg, tos3("44"), tos3("49"));
}

string term__bright_bg_blue(string msg) {
	return term__format(msg, tos3("104"), tos3("49"));
}

string term__bg_cyan(string msg) {
	return term__format(msg, tos3("46"), tos3("49"));
}

string term__bright_bg_cyan(string msg) {
	return term__format(msg, tos3("106"), tos3("49"));
}

string term__bg_green(string msg) {
	return term__format(msg, tos3("42"), tos3("49"));
}

string term__bright_bg_green(string msg) {
	return term__format(msg, tos3("102"), tos3("49"));
}

string term__bg_magenta(string msg) {
	return term__format(msg, tos3("45"), tos3("49"));
}

string term__bright_bg_magenta(string msg) {
	return term__format(msg, tos3("105"), tos3("49"));
}

string term__bg_red(string msg) {
	return term__format(msg, tos3("41"), tos3("49"));
}

string term__bright_bg_red(string msg) {
	return term__format(msg, tos3("101"), tos3("49"));
}

string term__bg_white(string msg) {
	return term__format(msg, tos3("47"), tos3("49"));
}

string term__bright_bg_white(string msg) {
	return term__format(msg, tos3("107"), tos3("49"));
}

string term__bg_yellow(string msg) {
	return term__format(msg, tos3("43"), tos3("49"));
}

string term__bright_bg_yellow(string msg) {
	return term__format(msg, tos3("103"), tos3("49"));
}

string term__black(string msg) {
	return term__format(msg, tos3("30"), tos3("39"));
}

string term__bright_black(string msg) {
	return term__format(msg, tos3("90"), tos3("39"));
}

string term__blue(string msg) {
	return term__format(msg, tos3("34"), tos3("39"));
}

string term__bright_blue(string msg) {
	return term__format(msg, tos3("94"), tos3("39"));
}

string term__bold(string msg) {
	return term__format(msg, tos3("1"), tos3("22"));
}

string term__cyan(string msg) {
	return term__format(msg, tos3("36"), tos3("39"));
}

string term__bright_cyan(string msg) {
	return term__format(msg, tos3("96"), tos3("39"));
}

string term__dim(string msg) {
	return term__format(msg, tos3("2"), tos3("22"));
}

string term__green(string msg) {
	return term__format(msg, tos3("32"), tos3("39"));
}

string term__bright_green(string msg) {
	return term__format(msg, tos3("92"), tos3("39"));
}

string term__gray(string msg) {
	return term__bright_black(msg);
}

string term__hidden(string msg) {
	return term__format(msg, tos3("8"), tos3("28"));
}

string term__italic(string msg) {
	return term__format(msg, tos3("3"), tos3("23"));
}

string term__inverse(string msg) {
	return term__format(msg, tos3("7"), tos3("27"));
}

string term__magenta(string msg) {
	return term__format(msg, tos3("35"), tos3("39"));
}

string term__bright_magenta(string msg) {
	return term__format(msg, tos3("95"), tos3("39"));
}

string term__reset(string msg) {
	return term__format(msg, tos3("0"), tos3("0"));
}

string term__red(string msg) {
	return term__format(msg, tos3("31"), tos3("39"));
}

string term__bright_red(string msg) {
	return term__format(msg, tos3("91"), tos3("39"));
}

string term__strikethrough(string msg) {
	return term__format(msg, tos3("9"), tos3("29"));
}

string term__underline(string msg) {
	return term__format(msg, tos3("4"), tos3("24"));
}

string term__white(string msg) {
	return term__format(msg, tos3("37"), tos3("39"));
}

string term__bright_white(string msg) {
	return term__format(msg, tos3("97"), tos3("39"));
}

string term__yellow(string msg) {
	return term__format(msg, tos3("33"), tos3("39"));
}

string term__bright_yellow(string msg) {
	return term__format(msg, tos3("93"), tos3("39"));
}

void term__set_cursor_position(int x, int y) {
	print(string_add(_STR("\x1b[%"PRId32"\000;%"PRId32"", 2, y, x), tos3("H")));
}

void term__move(int n, string direction) {
	print(_STR("\x1b[%"PRId32"\000%.*s", 2, n, direction));
}

void term__cursor_up(int n) {
	term__move(n, tos3("A"));
}

void term__cursor_down(int n) {
	term__move(n, tos3("B"));
}

void term__cursor_forward(int n) {
	term__move(n, tos3("C"));
}

void term__cursor_back(int n) {
	term__move(n, tos3("D"));
}

void term__erase_display(string t) {
	print(string_add(string_add(tos3("\x1b["), t), tos3("J")));
}

void term__erase_toend() {
	term__erase_display(tos3("0"));
}

void term__erase_tobeg() {
	term__erase_display(tos3("1"));
}

void term__erase_clear() {
	term__erase_display(tos3("2"));
}

void term__erase_del_clear() {
	term__erase_display(tos3("3"));
}

void term__erase_line(string t) {
	print(string_add(string_add(tos3("\x1b["), t), tos3("K")));
}

void term__erase_line_toend() {
	term__erase_line(tos3("0"));
}

void term__erase_line_tobeg() {
	term__erase_line(tos3("1"));
}

void term__erase_line_clear() {
	term__erase_line(tos3("2"));
}

void term__show_cursor() {
	print(tos3("\x1b[?25h"));
}

void term__hide_cursor() {
	print(tos3("\x1b[?25l"));
}

bool term__can_show_color_on_stdout() {
	return term__supports_escape_sequences(1);
}

bool term__can_show_color_on_stderr() {
	return term__supports_escape_sequences(2);
}

string term__ok_message(string s) {
	return (term__can_show_color_on_stdout() ?  ( term__green(s) )  :  ( s ) );
}

string term__fail_message(string s) {
	return (term__can_show_color_on_stdout() ?  ( term__bold(term__bg_red(term__white(s))) )  :  ( s ) );
}

string term__warn_message(string s) {
	return (term__can_show_color_on_stdout() ?  ( term__bright_yellow(s) )  :  ( s ) );
}

string term__h_divider(string divider) {
	multi_return_int_int mr_1366 = term__get_terminal_size();
	int cols = mr_1366.arg0;
	string result = (divider.len > 0 ?  ( string_repeat(divider, 1 + (cols / divider.len)) )  :  ( string_repeat(tos3(" "), 1 + cols) ) );
	return string_substr(result, 0, cols);
}

string term__header(string text, string divider) {
	if (text.len == 0) {
		return term__h_divider(divider);
	}
	multi_return_int_int mr_1778 = term__get_terminal_size();
	int cols = mr_1778.arg0;
	int tlimit = (cols > text.len + 2 + 2 * divider.len ?  ( text.len )  :  ( cols - 3 - 2 * divider.len ) );
	int tlimit_alligned = ((tlimit % 2) != (cols % 2) ?  ( tlimit + 1 )  :  ( tlimit ) );
	int tstart = (cols - tlimit_alligned) / 2;
	string ln = (divider.len > 0 ?  ( string_substr(string_repeat(divider, 1 + cols / divider.len), 0, cols) )  :  ( string_repeat(tos3(" "), 1 + cols) ) );
	return string_add(string_add(string_add(string_add(string_substr(ln, 0, tstart), tos3(" ")), string_substr(text, 0, tlimit)), tos3(" ")), string_substr(ln, tstart + tlimit + 2, cols));
}

static bool term__supports_escape_sequences(int fd) {
	
// $if  windows {
#ifdef _WIN32
		return ((is_atty(fd) & 0x0004)) > 0 && string_ne(os__getenv(tos3("TERM")), tos3("dumb"));
	
#else
		return is_atty(fd) > 0 && string_ne(os__getenv(tos3("TERM")), tos3("dumb"));
	
// } windows
#endif

}


multi_return_int_int term__get_terminal_size() {
	if (is_atty(1) <= 0 || string_eq(os__getenv(tos3("TERM")), tos3("dumb"))) {
		return (multi_return_int_int){.arg0=_const_term__default_columns_size,.arg1=_const_term__default_rows_size};
	}
	struct winsize w = (struct winsize){
		.ws_row = 0,
		.ws_col = 0,
		.ws_xpixel = 0,
		.ws_ypixel = 0,
	};
	ioctl(1, TIOCGWINSZ, &w);
	return (multi_return_int_int){.arg0=((int)(w.ws_col)),.arg1=((int)(w.ws_row))};
}

v__vmod__ModFileCacher* v__vmod__new_mod_file_cacher() {
	return (v__vmod__ModFileCacher*)memdup(&(v__vmod__ModFileCacher){	.cache = new_map_1(sizeof(v__vmod__ModFileAndFolder)),
		.folder_files = new_map_1(sizeof(array_string)),
	}, sizeof(v__vmod__ModFileCacher));
}

void v__vmod__ModFileCacher_dump(v__vmod__ModFileCacher* mcache) {
	
// $if  debug {
#ifdef _VDEBUG
		eprintln(tos3("ModFileCacher DUMP:"));
		eprintln(tos3("	 ModFileCacher.cache:"));
		// FOR IN map
		array_string keys_tmp1 = map_keys(&mcache->cache);
		for (int tmp2 = 0; tmp2 < keys_tmp1.len; tmp2++) {
			string k = ((string*)keys_tmp1.data)[tmp2];
			v__vmod__ModFileAndFolder v = (*(v__vmod__ModFileAndFolder*)map_get3(mcache->cache, k, &(v__vmod__ModFileAndFolder[]){ {0} }));
			eprintln(_STR("	 K: %*.*s\000 | V: \"%*.*s\000\" | \"%*.*s\000\" ", 4, k, -32, v.vmod_file, 32, v.vmod_folder, 32));
		}
		eprintln(tos3("	 ModFileCacher.folder_files:"));
		// FOR IN map
		array_string keys_tmp3 = map_keys(&mcache->folder_files);
		for (int tmp4 = 0; tmp4 < keys_tmp3.len; tmp4++) {
			string k = ((string*)keys_tmp3.data)[tmp4];
			array_string v = (*(array_string*)map_get3(mcache->folder_files, k, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
			eprintln(_STR("	 K: %*.*s\000 | V: %.*s", 2, k, -32, array_string_str(v)));
		}
	
// } debug
#endif

}

v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get(v__vmod__ModFileCacher* mcache, string mfolder) {
	if (_IN_MAP(mfolder, mcache->cache)) {
		return (*(v__vmod__ModFileAndFolder*)map_get3(mcache->cache, mfolder, &(v__vmod__ModFileAndFolder[]){ {0} }));
	}
	multi_return_array_string_v__vmod__ModFileAndFolder mr_1957 = v__vmod__ModFileCacher_traverse(mcache, mfolder);
	array_string traversed_folders = mr_1957.arg0;
	v__vmod__ModFileAndFolder res = mr_1957.arg1;
	// FOR IN array
	array tmp2 = traversed_folders;
	for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
		string tfolder = ((string*)tmp2.data)[tmp3];
		v__vmod__ModFileCacher_add(mcache, tfolder, res);
	}
	return res;
}

static void v__vmod__ModFileCacher_add(v__vmod__ModFileCacher* cacher, string path, v__vmod__ModFileAndFolder result) {
	map_set(&cacher->cache, path, &(v__vmod__ModFileAndFolder[]) { result });
}

static multi_return_array_string_v__vmod__ModFileAndFolder v__vmod__ModFileCacher_traverse(v__vmod__ModFileCacher* mcache, string mfolder) {
	string cfolder = mfolder;
	array_string folders_so_far = new_array_from_c_array(1, 1, sizeof(string), (string[1]){
		cfolder, 
});
	int levels = 0;
	while (1) {
		if (levels > 255) {
			break;
		}
		if (string_eq(cfolder, tos3("/")) || string_eq(cfolder, tos3(""))) {
			break;
		}
		if (_IN_MAP(cfolder, mcache->cache)) {
			v__vmod__ModFileAndFolder res = (*(v__vmod__ModFileAndFolder*)map_get3(mcache->cache, cfolder, &(v__vmod__ModFileAndFolder[]){ {0} }));
			if (res.vmod_file.len == 0) {
				v__vmod__ModFileCacher_mark_folders_as_vmod_free(mcache, folders_so_far);
			} else {
				v__vmod__ModFileCacher_mark_folders_with_vmod(mcache, folders_so_far, res);
			}
			return (multi_return_array_string_v__vmod__ModFileAndFolder){.arg0=__new_array(0, 0, sizeof(string)),.arg1=res};
		}
		array_string files = v__vmod__ModFileCacher_get_files(mcache, cfolder);
		if (_IN(string, tos3("v.mod"), files)) {
			v__vmod__ModFileAndFolder res = (v__vmod__ModFileAndFolder){
				.vmod_file = os__join_path(cfolder, (varg_string){.len=1,.args={tos3("v.mod")}}),
				.vmod_folder = cfolder,
			};
			return (multi_return_array_string_v__vmod__ModFileAndFolder){.arg0=folders_so_far,.arg1=res};
		}
		if (v__vmod__ModFileCacher_check_for_stop(mcache, cfolder, files)) {
			break;
		}
		cfolder = os__base_dir(cfolder);
		array_push(&folders_so_far, &(string[]){ cfolder });
		levels++;
	}
	v__vmod__ModFileCacher_mark_folders_as_vmod_free(mcache, folders_so_far);
	return (multi_return_array_string_v__vmod__ModFileAndFolder){.arg0=new_array_from_c_array(1, 1, sizeof(string), (string[1]){
		mfolder, 
}),.arg1=(v__vmod__ModFileAndFolder){
		.vmod_file = tos3(""),
		.vmod_folder = mfolder,
	}};
}

static void v__vmod__ModFileCacher_mark_folders_with_vmod(v__vmod__ModFileCacher* mcache, array_string folders_so_far, v__vmod__ModFileAndFolder vmod) {
	// FOR IN array
	array tmp1 = folders_so_far;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string f = ((string*)tmp1.data)[tmp2];
		v__vmod__ModFileCacher_add(mcache, f, vmod);
	}
}

static void v__vmod__ModFileCacher_mark_folders_as_vmod_free(v__vmod__ModFileCacher* mcache, array_string folders_so_far) {
	// FOR IN array
	array tmp1 = folders_so_far;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string f = ((string*)tmp1.data)[tmp2];
		v__vmod__ModFileCacher_add(mcache, f, (v__vmod__ModFileAndFolder){
			.vmod_file = tos3(""),
			.vmod_folder = f,
		});
	}
}

static bool v__vmod__ModFileCacher_check_for_stop(v__vmod__ModFileCacher* mcache, string cfolder, array_string files) {
	// FOR IN array
	array tmp1 = _const_v__vmod__MOD_FILE_STOP_PATHS;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string i = ((string*)tmp1.data)[tmp2];
		if (_IN(string, i, files)) {
			return true;
		}
	}
	return false;
}

static array_string v__vmod__ModFileCacher_get_files(v__vmod__ModFileCacher* mcache, string cfolder) {
	if (_IN_MAP(cfolder, mcache->folder_files)) {
		return (*(array_string*)map_get3(mcache->folder_files, cfolder, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
	}
	array_string files = __new_array(0, 0, sizeof(string));
	if (os__exists(cfolder) && os__is_dir(cfolder)) {
		bool tmp3;
		{ /* if guard */ Option_array_string listing = os__ls(cfolder);
		if ((tmp3 = listing.ok)) {
			files = /*opt*/(*(array_string*)listing.data);
		}}
	}
	map_set(&mcache->folder_files, cfolder, &(array_string[]) { files });
	return files;
}

// TypeDecl
// TypeDecl
bool array_v__table__Type_contains(array_v__table__Type types, v__table__Type typ) {
	// FOR IN array
	array tmp1 = types;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__Type t = ((v__table__Type*)tmp1.data)[tmp2];
		if (((int)(typ)) == ((int)(t))) {
			return true;
		}
	}
	return false;
}

// Attr: [inline]
inline int v__table__Type_idx(v__table__Type t) {
	return (((u16)(t)) & 0xffff);
}

// Attr: [inline]
inline int v__table__Type_nr_muls(v__table__Type t) {
	return ((((int)(t)) >> 16) & 0xff);
}

// Attr: [inline]
inline bool v__table__Type_is_ptr(v__table__Type t) {
	return ((((int)(t)) >> 16) & 0xff) > 0;
}

// Attr: [inline]
inline v__table__Type v__table__Type_set_nr_muls(v__table__Type t, int nr_muls) {
	if (nr_muls < 0 || nr_muls > 255) {
		v_panic(tos3("set_nr_muls: nr_muls must be between 0 & 255"));
	}
	return ((((((((int)(t)) >> 24) & 0xff)) << 24) | (nr_muls << 16)) | ((((u16)(t)) & 0xffff)));
}

// Attr: [inline]
inline v__table__Type v__table__Type_to_ptr(v__table__Type t) {
	int nr_muls = ((((int)(t)) >> 16) & 0xff);
	if (nr_muls == 255) {
		v_panic(tos3("to_ptr: nr_muls is already at max of 255"));
	}
	return ((((((((int)(t)) >> 24) & 0xff)) << 24) | ((nr_muls + 1) << 16)) | ((((u16)(t)) & 0xffff)));
}

// Attr: [inline]
inline v__table__Type v__table__Type_deref(v__table__Type t) {
	int nr_muls = ((((int)(t)) >> 16) & 0xff);
	if (nr_muls == 0) {
		v_panic(_STR("deref: type `%"PRId32"\000` is not a pointer", 2, t));
	}
	return ((((((((int)(t)) >> 24) & 0xff)) << 24) | ((nr_muls - 1) << 16)) | ((((u16)(t)) & 0xffff)));
}

// Attr: [inline]
inline v__table__TypeFlag v__table__Type_flag(v__table__Type t) {
	return ((((int)(t)) >> 24) & 0xff);
}

// Attr: [inline]
inline v__table__Type v__table__Type_set_flag(v__table__Type t, v__table__TypeFlag flag) {
	return (((((int)(flag)) << 24) | ((((((int)(t)) >> 16) & 0xff)) << 16)) | ((((u16)(t)) & 0xffff)));
}

// Attr: [inline]
inline bool v__table__Type_flag_is(v__table__Type t, v__table__TypeFlag flag) {
	return ((((int)(t)) >> 24) & 0xff) == flag;
}

// Attr: [inline]
inline v__table__Type v__table__new_type(int idx) {
	if (idx < 1 || idx > 65536) {
		v_panic(tos3("new_type_id: idx must be between 1 & 65536"));
	}
	return idx;
}

// Attr: [inline]
inline v__table__Type v__table__new_type_ptr(int idx, int nr_muls) {
	if (idx < 1 || idx > 65536) {
		v_panic(tos3("new_type_ptr: idx must be between 1 & 65536"));
	}
	if (nr_muls < 0 || nr_muls > 255) {
		v_panic(tos3("new_type_ptr: nr_muls must be between 0 & 255"));
	}
	return ((nr_muls << 16) | ((u16)(idx)));
}

// Attr: [inline]
inline bool v__table__Type_is_pointer(v__table__Type typ) {
	return _IN(int, v__table__Type_idx(typ), _const_v__table__pointer_type_idxs);
}

// Attr: [inline]
inline bool v__table__Type_is_float(v__table__Type typ) {
	return _IN(int, v__table__Type_idx(typ), _const_v__table__float_type_idxs);
}

// Attr: [inline]
inline bool v__table__Type_is_int(v__table__Type typ) {
	return _IN(int, v__table__Type_idx(typ), _const_v__table__integer_type_idxs);
}

// Attr: [inline]
inline bool v__table__Type_is_signed(v__table__Type typ) {
	return _IN(int, v__table__Type_idx(typ), _const_v__table__signed_integer_type_idxs);
}

// Attr: [inline]
inline bool v__table__Type_is_unsigned(v__table__Type typ) {
	return _IN(int, v__table__Type_idx(typ), _const_v__table__unsigned_integer_type_idxs);
}

// Attr: [inline]
inline bool v__table__Type_is_number(v__table__Type typ) {
	return _IN(int, v__table__Type_idx(typ), _const_v__table__number_type_idxs);
}

string v__table__TypeSymbol_str(v__table__TypeSymbol* t) {
	return string_replace(t->name, tos3("array_"), tos3("[]"));
}

// Attr: [inline]
inline v__table__Enum v__table__TypeSymbol_enum_info(v__table__TypeSymbol* t) {
	if (t->info.typ == 82 /* v.table.Enum */) {
		v__table__Enum* it = (v__table__Enum*)t->info.obj; // ST it
		return *it;
	}else {
		v_panic(_STR("TypeSymbol.enum_info(): no enum info for type: %.*s", 1, t->name));
	};
}

// Attr: [inline]
inline v__table__MultiReturn v__table__TypeSymbol_mr_info(v__table__TypeSymbol* t) {
	if (t->info.typ == 86 /* v.table.MultiReturn */) {
		v__table__MultiReturn* it = (v__table__MultiReturn*)t->info.obj; // ST it
		return *it;
	}else {
		v_panic(_STR("TypeSymbol.mr_info(): no multi return info for type: %.*s", 1, t->name));
	};
}

// Attr: [inline]
inline v__table__Array v__table__TypeSymbol_array_info(v__table__TypeSymbol* t) {
	if (t->info.typ == 80 /* v.table.Array */) {
		v__table__Array* it = (v__table__Array*)t->info.obj; // ST it
		return *it;
	}else {
		v_panic(_STR("TypeSymbol.array_info(): no array info for type: %.*s", 1, t->name));
	};
}

// Attr: [inline]
inline v__table__ArrayFixed v__table__TypeSymbol_array_fixed_info(v__table__TypeSymbol* t) {
	if (t->info.typ == 81 /* v.table.ArrayFixed */) {
		v__table__ArrayFixed* it = (v__table__ArrayFixed*)t->info.obj; // ST it
		return *it;
	}else {
		v_panic(_STR("TypeSymbol.array_fixed(): no array fixed info for type: %.*s", 1, t->name));
	};
}

// Attr: [inline]
inline v__table__Map v__table__TypeSymbol_map_info(v__table__TypeSymbol* t) {
	if (t->info.typ == 85 /* v.table.Map */) {
		v__table__Map* it = (v__table__Map*)t->info.obj; // ST it
		return *it;
	}else {
		v_panic(_STR("TypeSymbol.map_info(): no map info for type: %.*s", 1, t->name));
	};
}

// Attr: [inline]
inline v__table__Struct v__table__TypeSymbol_struct_info(v__table__TypeSymbol* t) {
	if (t->info.typ == 87 /* v.table.Struct */) {
		v__table__Struct* it = (v__table__Struct*)t->info.obj; // ST it
		return *it;
	}else {
		v_panic(_STR("TypeSymbol.struct_info(): no struct info for type: %.*s", 1, t->name));
	};
}

void v__table__Table_register_builtin_type_symbols(v__table__Table* t) {
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_placeholder,
		.name = tos3("reserved_0"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_void,
		.name = tos3("void"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_voidptr,
		.name = tos3("voidptr"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_byteptr,
		.name = tos3("byteptr"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_charptr,
		.name = tos3("charptr"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_i8,
		.name = tos3("i8"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_i16,
		.name = tos3("i16"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_int,
		.name = tos3("int"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_i64,
		.name = tos3("i64"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_byte,
		.name = tos3("byte"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_u16,
		.name = tos3("u16"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_u32,
		.name = tos3("u32"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_u64,
		.name = tos3("u64"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_f32,
		.name = tos3("f32"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_f64,
		.name = tos3("f64"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_char,
		.name = tos3("char"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_bool,
		.name = tos3("bool"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_none_,
		.name = tos3("none"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_string,
		.name = tos3("string"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_ustring,
		.name = tos3("ustring"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_array,
		.name = tos3("array"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_map,
		.name = tos3("map"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_any,
		.name = tos3("any"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_size_t,
		.name = tos3("size_t"),
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	int map_string_string_idx = v__table__Table_find_or_register_map(t, _const_v__table__string_type, _const_v__table__string_type);
	int map_string_int_idx = v__table__Table_find_or_register_map(t, _const_v__table__string_type, _const_v__table__int_type);
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_alias,
		.name = tos3("map_string"),
		.parent_idx = map_string_string_idx,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_alias,
		.name = tos3("map_int"),
		.parent_idx = map_string_int_idx,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
}

// Attr: [inline]
inline bool v__table__TypeSymbol_is_pointer(v__table__TypeSymbol* t) {
	return (t->kind == v__table__Kind_byteptr || t->kind == v__table__Kind_charptr || t->kind == v__table__Kind_voidptr);
}

// Attr: [inline]
inline bool v__table__TypeSymbol_is_int(v__table__TypeSymbol* t) {
	return (t->kind == v__table__Kind_i8 || t->kind == v__table__Kind_i16 || t->kind == v__table__Kind_int || t->kind == v__table__Kind_i64 || t->kind == v__table__Kind_byte || t->kind == v__table__Kind_u16 || t->kind == v__table__Kind_u32 || t->kind == v__table__Kind_u64);
}

// Attr: [inline]
inline bool v__table__TypeSymbol_is_float(v__table__TypeSymbol* t) {
	return (t->kind == v__table__Kind_f32 || t->kind == v__table__Kind_f64);
}

// Attr: [inline]
inline bool v__table__TypeSymbol_is_number(v__table__TypeSymbol* t) {
	return v__table__TypeSymbol_is_int(t) || v__table__TypeSymbol_is_float(t);
}

string v__table__Kind_str(v__table__Kind k) {
	string k_str = (k == v__table__Kind_placeholder) ?  ( tos3("placeholder") )  : (k == v__table__Kind_void) ?  ( tos3("void") )  : (k == v__table__Kind_voidptr) ?  ( tos3("voidptr") )  : (k == v__table__Kind_charptr) ?  ( tos3("charptr") )  : (k == v__table__Kind_byteptr) ?  ( tos3("byteptr") )  : (k == v__table__Kind_struct_) ?  ( tos3("struct") )  : (k == v__table__Kind_int) ?  ( tos3("int") )  : (k == v__table__Kind_i8) ?  ( tos3("i8") )  : (k == v__table__Kind_i16) ?  ( tos3("i16") )  : (k == v__table__Kind_i64) ?  ( tos3("i64") )  : (k == v__table__Kind_byte) ?  ( tos3("byte") )  : (k == v__table__Kind_u16) ?  ( tos3("u16") )  : (k == v__table__Kind_u32) ?  ( tos3("u32") )  : (k == v__table__Kind_u64) ?  ( tos3("u64") )  : (k == v__table__Kind_f32) ?  ( tos3("f32") )  : (k == v__table__Kind_f64) ?  ( tos3("f64") )  : (k == v__table__Kind_string) ?  ( tos3("string") )  : (k == v__table__Kind_char) ?  ( tos3("char") )  : (k == v__table__Kind_bool) ?  ( tos3("bool") )  : (k == v__table__Kind_size_t) ?  ( tos3("size_t") )  : (k == v__table__Kind_none_) ?  ( tos3("none") )  : (k == v__table__Kind_array) ?  ( tos3("array") )  : (k == v__table__Kind_array_fixed) ?  ( tos3("array_fixed") )  : (k == v__table__Kind_map) ?  ( tos3("map") )  : (k == v__table__Kind_multi_return) ?  ( tos3("multi_return") )  : (k == v__table__Kind_sum_type) ?  ( tos3("sum_type") )  : (k == v__table__Kind_alias) ?  ( tos3("alias") )  : (k == v__table__Kind_enum_) ?  ( tos3("enum") )  : (k == v__table__Kind_any) ?  ( tos3("any") )  :  ( tos3("unknown") ) ;
	return k_str;
}

string array_v__table__Kind_str(array_v__table__Kind kinds) {
	string kinds_str = tos3("");
	// FOR IN array
	array tmp1 = kinds;
	for (int i = 0; i < tmp1.len; i++) {
		v__table__Kind k = ((v__table__Kind*)tmp1.data)[i];
		kinds_str = string_add(kinds_str, v__table__Kind_str(k));
		if (i < kinds.len - 1) {
			kinds_str = string_add(kinds_str, tos3("_"));
		}
	}
	return kinds_str;
}

// TypeDecl
string v__table__Table_type_to_str(v__table__Table* table, v__table__Type t) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(table, t);
	if (sym->kind == v__table__Kind_multi_return) {
		string res = tos3("(");
		v__table__MultiReturn* mr_info = /* as */ (v__table__MultiReturn*)__as_cast(sym->info.obj, sym->info.typ, /*expected:*/86);
		// FOR IN array
		array tmp2 = mr_info->types;
		for (int i = 0; i < tmp2.len; i++) {
			v__table__Type typ = ((v__table__Type*)tmp2.data)[i];
			res = string_add(res, v__table__Table_type_to_str(table, typ));
			if (i < mr_info->types.len - 1) {
				res = string_add(res, tos3(", "));
			}
		}
		res = string_add(res, tos3(")"));
		return res;
	}
	string res = sym->name;
	if (sym->kind == v__table__Kind_array) {
		res = string_replace(res, tos3("array_"), tos3("[]"));
	} else if (sym->kind == v__table__Kind_map) {
		res = string_replace(res, tos3("map_string_"), tos3("map[string]"));
	}
	if (string_contains(res, tos3("."))) {
		array_string vals = string_split(res, tos3("."));
		if (vals.len > 2) {
			res = string_add(string_add((*(string*)array_get(vals, vals.len - 2)), tos3(".")), (*(string*)array_get(vals, vals.len - 1)));
		}
		if (sym->kind == v__table__Kind_array && !string_starts_with(res, tos3("[]"))) {
			res = string_add(tos3("[]"), res);
		}
	}
	int nr_muls = v__table__Type_nr_muls(t);
	if (nr_muls > 0) {
		res = string_add(strings__repeat('&', nr_muls), res);
	}
	if (v__table__Type_flag_is(t, v__table__TypeFlag_optional)) {
		res = string_add(tos3("?"), res);
	}
	return res;
}

string v__table__Table_fn_to_str(v__table__Table* t, v__table__Fn* func) {
	strings__Builder sb = strings__new_builder(20);
	strings__Builder_write(&sb, _STR("%.*s\000(", 2, func->name));
	for (int tmp1 = 1; tmp1 < func->args.len; tmp1++) {
		int i = tmp1;
		v__table__Arg arg = (*(v__table__Arg*)array_get(func->args, i));
		strings__Builder_write(&sb, _STR("%.*s", 1, arg.name));
		if (i == func->args.len - 1 || (*(v__table__Arg*)array_get(func->args, i + 1)).typ != arg.typ) {
			strings__Builder_write(&sb, _STR(" %.*s", 1, v__table__Table_type_to_str(t, arg.typ)));
		}
		if (i != func->args.len - 1) {
			strings__Builder_write(&sb, tos3(", "));
		}
	}
	strings__Builder_write(&sb, tos3(")"));
	if (func->return_type != _const_v__table__void_type) {
		strings__Builder_write(&sb, _STR(" %.*s", 1, v__table__Table_type_to_str(t, func->return_type)));
	}
	return strings__Builder_str(&sb);
}

bool v__table__TypeSymbol_has_method(v__table__TypeSymbol* t, string name) {
	Option_v__table__Fn tmp1 = v__table__TypeSymbol_find_method(t, name);
	if (!tmp1.ok) {
		string err = tmp1.v_error;
		int errcode = tmp1.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return false;
	};
	return true;
}

Option_v__table__Fn v__table__TypeSymbol_find_method(v__table__TypeSymbol* t, string name) {
	// FOR IN array
	array tmp1 = t->methods;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__Fn method = ((v__table__Fn*)tmp1.data)[tmp2];
		if (string_eq(method.name, name)) {
			return /*:)v.table.Fn*/opt_ok(&(v__table__Fn[]) { method }, sizeof(v__table__Fn));
		}
	}
	return opt_none();}

Option_v__table__Field v__table__Struct_find_field(v__table__Struct s, string name) {
	// FOR IN array
	array tmp1 = s.fields;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__Field field = ((v__table__Field*)tmp1.data)[tmp2];
		if (string_eq(field.name, name)) {
			return /*:)v.table.Field*/opt_ok(&(v__table__Field[]) { field }, sizeof(v__table__Field));
		}
	}
	return opt_none();}

v__table__Field v__table__Struct_get_field(v__table__Struct s, string name) {
	bool tmp1;
	{ /* if guard */ Option_v__table__Field field = v__table__Struct_find_field(s, name);
	if ((tmp1 = field.ok)) {
		return /*opt*/(*(v__table__Field*)field.data);
	}}
	v_panic(_STR("unknown field `%.*s\000`", 2, name));
}

static bool v__table__Table_has_cflag(v__table__Table* table, v__cflag__CFlag flag) {
	// FOR IN array
	array tmp1 = table->cflags;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__cflag__CFlag cf = ((v__cflag__CFlag*)tmp1.data)[tmp2];
		if (string_eq(cf.os, flag.os) && string_eq(cf.name, flag.name) && string_eq(cf.value, flag.value)) {
			return true;
		}
	}
	return false;
}

Option_bool v__table__Table_parse_cflag(v__table__Table* table, string cflg, string mod, array_string ctimedefines) {
	array_string allowed_flags = new_array_from_c_array(8, 8, sizeof(string), (string[8]){
		tos3("framework"), tos3("library"), tos3("Wa"), tos3("Wl"), tos3("Wp"), tos3("I"), tos3("l"), tos3("L"), 
});
	string flag_orig = string_trim_space(cflg);
	string flag = flag_orig;
	if (string_eq(flag, tos3(""))) {
		return opt_none();}
	string fos = tos3("");
	array_string allowed_os_overrides = new_array_from_c_array(6, 6, sizeof(string), (string[6]){
		tos3("linux"), tos3("darwin"), tos3("freebsd"), tos3("windows"), tos3("mingw"), tos3("solaris"), 
});
	_PUSH_MANY(&allowed_os_overrides, (ctimedefines), tmp2, array_string);
	// FOR IN array
	array tmp3 = allowed_os_overrides;
	for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
		string os_override = ((string*)tmp3.data)[tmp4];
		if (!string_starts_with(flag, os_override)) {
			continue;
		}
		Option_int pos = string_index(flag, tos3(" "));
		if (!pos.ok) {
			string err = pos.v_error;
			int errcode = pos.ecode;
			// last_type: v.ast.Return
			// last_expr_result_type: 
			return opt_none();};
		fos = string_trim_space(string_substr(flag, 0, /*opt*/(*(int*)pos.data)));
		flag = string_trim_space(string_substr(flag, /*opt*/(*(int*)pos.data), flag.len));
	}
	while (1) {
		string name = tos3("");
		string value = tos3("");
		if (string_at(flag, 0) == '-') {
			// FOR IN array
			array tmp7 = allowed_flags;
			for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
				string f = ((string*)tmp7.data)[tmp8];
				int i = 1 + f.len;
				if (i <= flag.len && string_eq(f, string_substr(flag, 1, i))) {
					name = string_trim_space(string_substr(flag, 0, i));
					flag = string_trim_space(string_substr(flag, i, flag.len));
					break;
				}
			}
		}
		Option_int index = string_index(flag, tos3(" -"));
		if (!index.ok) {
			string err = index.v_error;
			int errcode = index.ecode;
			// last_type: v.ast.ExprStmt
			// last_expr_result_type: v.ast.PrefixExpr
			*(int*) index.data = -1;
		};
		while (/*opt*/(*(int*)index.data) > -1) {
			bool has_next = false;
			// FOR IN array
			array tmp10 = allowed_flags;
			for (int tmp11 = 0; tmp11 < tmp10.len; tmp11++) {
				string f = ((string*)tmp10.data)[tmp11];
				int i = /*opt*/(*(int*)index.data) + 2 + f.len;
				if (i <= flag.len && string_eq(f, string_substr(flag, /*opt*/(*(int*)index.data) + 2, i))) {
					value = string_trim_space(string_substr(flag, 0, /*opt*/(*(int*)index.data) + 1));
					flag = string_trim_space(string_substr(flag, /*opt*/(*(int*)index.data) + 1, flag.len));
					has_next = true;
					break;
				}
			}
			if (has_next) {
				break;
			}
			/*opt*/(*(int*)index.data) = string_index_after(flag, tos3(" -"), /*opt*/(*(int*)index.data) + 1);
		}
		if (/*opt*/(*(int*)index.data) == -1) {
			value = string_trim_space(flag);
		}
		if (((string_eq(name, tos3("-I")) || string_eq(name, tos3("-l")) || string_eq(name, tos3("-L")))) && string_eq(value, tos3(""))) {
			string hint = (string_eq(name, tos3("-l")) ?  ( tos3("library name") )  :  ( tos3("path") ) );
			return v_error(_STR("bad #flag `%.*s\000`: missing %.*s\000 after `%.*s\000`", 4, flag_orig, hint, name));}
		v__cflag__CFlag cf = (v__cflag__CFlag){
			.mod = mod,
			.os = fos,
			.name = name,
			.value = value,
		};
		if (!v__table__Table_has_cflag(table, cf)) {
			array_push(&table->cflags, &(v__cflag__CFlag[]){ cf });
		}
		if (/*opt*/(*(int*)index.data) == -1) {
			break;
		}
	}
	return /*:)bool*/opt_ok(&(bool[]) { true }, sizeof(bool));
}

v__table__Table* v__table__new_table() {
	v__table__Table* t = (v__table__Table*)memdup(&(v__table__Table){	.types = __new_array(0, 1, sizeof(v__table__TypeSymbol)),
		.type_idxs = new_map_1(sizeof(int)),
		.fns = new_map_1(sizeof(v__table__Fn)),
		.imports = __new_array(0, 1, sizeof(string)),
		.modules = __new_array(0, 1, sizeof(string)),
		.cflags = __new_array(0, 1, sizeof(v__cflag__CFlag)),
	}, sizeof(v__table__Table));
	v__table__Table_register_builtin_type_symbols(t);
	return t;
}

string v__table__Fn_signature(v__table__Fn* f) {
	string sig = tos3("");
	// FOR IN array
	array tmp1 = f->args;
	for (int i = 0; i < tmp1.len; i++) {
		v__table__Arg arg = ((v__table__Arg*)tmp1.data)[i];
		v__table__Type typ = v__table__Type_set_nr_muls(arg.typ, 0);
		sig = string_add(sig, _STR("%"PRId32"", 1, typ));
		if (i < f->args.len - 1) {
			sig = string_add(sig, tos3("_"));
		}
	}
	sig = string_add(sig, _STR("_%"PRId32"", 1, f->return_type));
	return sig;
}

bool v__table__Fn_is_same_method_as(v__table__Fn* f, v__table__Fn* func) {
	if (f->return_type != func->return_type) {
		return false;
	}
	if (f->args.len != func->args.len) {
		return false;
	}
	for (int tmp3 = 1; tmp3 < f->args.len; tmp3++) {
		int i = tmp3;
		if ((*(v__table__Arg*)array_get(f->args, i)).typ != (*(v__table__Arg*)array_get(func->args, i)).typ) {
			return false;
		}
	}
	return true;
}

Option_v__table__Fn v__table__Table_find_fn(v__table__Table* t, string name) {
	v__table__Fn f = (*(v__table__Fn*)map_get3(t->fns, name, &(v__table__Fn[]){ {0} }));
	if (f.name.str != 0) {
		return /*:)v.table.Fn*/opt_ok(&(v__table__Fn[]) { f }, sizeof(v__table__Fn));
	}
	return opt_none();}

bool v__table__Table_known_fn(v__table__Table* t, string name) {
	Option_v__table__Fn tmp1 = v__table__Table_find_fn(t, name);
	if (!tmp1.ok) {
		string err = tmp1.v_error;
		int errcode = tmp1.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return false;
	};
	return true;
}

void v__table__Table_register_fn(v__table__Table* t, v__table__Fn new_fn) {
	map_set(&t->fns, new_fn.name, &(v__table__Fn[]) { new_fn });
}

void v__table__TypeSymbol_register_method(v__table__TypeSymbol* t, v__table__Fn new_fn) {
	array_push(&t->methods, &(v__table__Fn[]){ new_fn });
}

bool v__table__Table_type_has_method(v__table__Table* t, v__table__TypeSymbol* s, string name) {
	bool tmp1;
	{ /* if guard */ Option_v__table__Fn _ = v__table__Table_type_find_method(t, s, name);
	if ((tmp1 = _.ok)) {
		return true;
	}}
	return false;
}

Option_v__table__Fn v__table__Table_type_find_method(v__table__Table* t, v__table__TypeSymbol* s, string name) {
	v__table__TypeSymbol* ts = s;
	while (1) {
		bool tmp1;
		{ /* if guard */ Option_v__table__Fn method = v__table__TypeSymbol_find_method(ts, name);
		if ((tmp1 = method.ok)) {
			return /*:)v.table.Fn*/opt_ok(&(v__table__Fn[]) { /*opt*/(*(v__table__Fn*)method.data) }, sizeof(v__table__Fn));
		}}
		if (ts->parent_idx == 0) {
			break;
		}
		ts = &(*(v__table__TypeSymbol*)array_get(t->types, ts->parent_idx));
	}
	return opt_none();}

bool v__table__Table_struct_has_field(v__table__Table* t, v__table__TypeSymbol* s, string name) {
	bool tmp1;
	{ /* if guard */ Option_v__table__Field _ = v__table__Table_struct_find_field(t, s, name);
	if ((tmp1 = _.ok)) {
		return true;
	}}
	return false;
}

Option_v__table__Field v__table__Table_struct_find_field(v__table__Table* t, v__table__TypeSymbol* s, string name) {
	v__table__TypeSymbol* ts = s;
	while (1) {
		if (ts->info.typ == 87 /* v.table.Struct */) {
			v__table__Struct* struct_info = /* as */ (v__table__Struct*)__as_cast(ts->info.obj, ts->info.typ, /*expected:*/87);
			bool tmp2;
			{ /* if guard */ Option_v__table__Field field = v__table__Struct_find_field(/*rec*/*struct_info, name);
			if ((tmp2 = field.ok)) {
				return /*:)v.table.Field*/opt_ok(&(v__table__Field[]) { /*opt*/(*(v__table__Field*)field.data) }, sizeof(v__table__Field));
			}}
		}
		if (ts->parent_idx == 0) {
			break;
		}
		ts = &(*(v__table__TypeSymbol*)array_get(t->types, ts->parent_idx));
	}
	return opt_none();}

// Attr: [inline]
inline int v__table__Table_find_type_idx(v__table__Table* t, string name) {
	return (*(int*)map_get3(t->type_idxs, name, &(int[]){ 0 }));
}

// Attr: [inline]
inline Option_v__table__TypeSymbol v__table__Table_find_type(v__table__Table* t, string name) {
	int idx = (*(int*)map_get3(t->type_idxs, name, &(int[]){ 0 }));
	if (idx > 0) {
		return /*:)v.table.TypeSymbol*/opt_ok(&(v__table__TypeSymbol[]) { (*(v__table__TypeSymbol*)array_get(t->types, idx)) }, sizeof(v__table__TypeSymbol));
	}
	return opt_none();}

// Attr: [inline]
inline v__table__TypeSymbol* v__table__Table_get_type_symbol(v__table__Table* t, v__table__Type typ) {
	int idx = v__table__Type_idx(typ);
	if (idx > 0) {
		return &(*(v__table__TypeSymbol*)array_get(t->types, idx));
	}
	v_panic(_STR("get_type_symbol: invalid type (typ=%"PRId32"\000 idx=%"PRId32"\000). Compiler bug. This should never happen", 3, typ, idx));
}

// Attr: [inline]
inline string v__table__Table_get_type_name(v__table__Table* t, v__table__Type typ) {
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(t, typ);
	return typ_sym->name;
}

// Attr: [inline]
inline int v__table__Table_register_builtin_type_symbol(v__table__Table* t, v__table__TypeSymbol typ) {
	int existing_idx = (*(int*)map_get3(t->type_idxs, typ.name, &(int[]){ 0 }));
	if (existing_idx > 0) {
		if (existing_idx >= _const_v__table__string_type_idx) {
			if (existing_idx == _const_v__table__string_type_idx) {
				v__table__TypeSymbol existing_type = (*(v__table__TypeSymbol*)array_get(t->types, existing_idx));
				(*(v__table__TypeSymbol*)array_get(t->types, existing_idx)) = // assoc
				(v__table__TypeSymbol){
					.kind = existing_type.kind, 
					.parent_idx = typ.parent_idx,
					.info = typ.info,
					.name = typ.name,
					.methods = typ.methods,
					.mod = typ.mod,
					.is_public = typ.is_public,
				};
			} else {
				(*(v__table__TypeSymbol*)array_get(t->types, existing_idx)) = typ;
			}
		}
		return existing_idx;
	}
	return v__table__Table_register_type_symbol(t, typ);
}

// Attr: [inline]
inline int v__table__Table_register_type_symbol(v__table__Table* t, v__table__TypeSymbol typ) {
	int existing_idx = (*(int*)map_get3(t->type_idxs, typ.name, &(int[]){ 0 }));
	if (existing_idx > 0) {
		v__table__TypeSymbol ex_type = (*(v__table__TypeSymbol*)array_get(t->types, existing_idx));
		if (ex_type.kind == v__table__Kind_placeholder) {
			(*(v__table__TypeSymbol*)array_get(t->types, existing_idx)) = // assoc
			(v__table__TypeSymbol){
				.methods = ex_type.methods, 
				.parent_idx = typ.parent_idx,
				.info = typ.info,
				.kind = typ.kind,
				.name = typ.name,
				.mod = typ.mod,
				.is_public = typ.is_public,
			};
			return existing_idx;
		}else {
			if (ex_type.kind == typ.kind) {
				return existing_idx;
			}
			return -1;
		};
	}
	int typ_idx = t->types.len;
	array_push(&t->types, &(v__table__TypeSymbol[]){ typ });
	map_set(&t->type_idxs, typ.name, &(int[]) { typ_idx });
	return typ_idx;
}

bool v__table__Table_known_type(v__table__Table* t, string name) {
	Option_v__table__TypeSymbol tmp1 =v__table__Table_find_type(t, name);
	if (!tmp1.ok) {
		string err = tmp1.v_error;
		int errcode = tmp1.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return false;
	};
	return true;
}

// Attr: [inline]
inline string v__table__Table_array_name(v__table__Table* t, v__table__Type elem_type, int nr_dims) {
	v__table__TypeSymbol* elem_type_sym = v__table__Table_get_type_symbol(t, elem_type);
	return string_add(string_add(_STR("array_%.*s", 1, elem_type_sym->name), (v__table__Type_is_ptr(elem_type) ?  ( tos3("_ptr") )  :  ( tos3("") ) )), (nr_dims > 1 ?  ( _STR("_%"PRId32"\000d", 2, nr_dims) )  :  ( tos3("") ) ));
}

// Attr: [inline]
inline string v__table__Table_array_fixed_name(v__table__Table* t, v__table__Type elem_type, int size, int nr_dims) {
	v__table__TypeSymbol* elem_type_sym = v__table__Table_get_type_symbol(t, elem_type);
	return string_add(string_add(_STR("array_fixed_%.*s\000_%"PRId32"", 2, elem_type_sym->name, size), (v__table__Type_is_ptr(elem_type) ?  ( tos3("_ptr") )  :  ( tos3("") ) )), (nr_dims > 1 ?  ( _STR("_%"PRId32"\000d", 2, nr_dims) )  :  ( tos3("") ) ));
}

// Attr: [inline]
inline string v__table__Table_map_name(v__table__Table* t, v__table__Type key_type, v__table__Type value_type) {
	v__table__TypeSymbol* key_type_sym = v__table__Table_get_type_symbol(t, key_type);
	v__table__TypeSymbol* value_type_sym = v__table__Table_get_type_symbol(t, value_type);
	string suffix = (v__table__Type_is_ptr(value_type) ?  ( tos3("_ptr") )  :  ( tos3("") ) );
	return string_add(_STR("map_%.*s\000_%.*s", 2, key_type_sym->name, value_type_sym->name), suffix);
}

int v__table__Table_find_or_register_map(v__table__Table* t, v__table__Type key_type, v__table__Type value_type) {
	string name = v__table__Table_map_name(t, key_type, value_type);
	int existing_idx = (*(int*)map_get3(t->type_idxs, name, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__table__TypeSymbol map_typ = (v__table__TypeSymbol){
		.parent_idx = _const_v__table__map_type_idx,
		.kind = v__table__Kind_map,
		.name = name,
		.info = /* sum type cast */ (v__table__TypeInfo) {.obj = memdup(&(v__table__Map[]) {(v__table__Map){
		.key_type = key_type,
		.value_type = value_type,
	}}, sizeof(v__table__Map)), .typ = 85 /* v.table.Map */},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	};
	return v__table__Table_register_type_symbol(t, map_typ);
}

int v__table__Table_find_or_register_array(v__table__Table* t, v__table__Type elem_type, int nr_dims) {
	string name = v__table__Table_array_name(t, elem_type, nr_dims);
	int existing_idx = (*(int*)map_get3(t->type_idxs, name, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__table__TypeSymbol array_type = (v__table__TypeSymbol){
		.parent_idx = _const_v__table__array_type_idx,
		.kind = v__table__Kind_array,
		.name = name,
		.info = /* sum type cast */ (v__table__TypeInfo) {.obj = memdup(&(v__table__Array[]) {(v__table__Array){
		.elem_type = elem_type,
		.nr_dims = nr_dims,
	}}, sizeof(v__table__Array)), .typ = 80 /* v.table.Array */},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	};
	return v__table__Table_register_type_symbol(t, array_type);
}

int v__table__Table_find_or_register_array_fixed(v__table__Table* t, v__table__Type elem_type, int size, int nr_dims) {
	string name = v__table__Table_array_fixed_name(t, elem_type, size, nr_dims);
	int existing_idx = (*(int*)map_get3(t->type_idxs, name, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__table__TypeSymbol array_fixed_type = (v__table__TypeSymbol){
		.kind = v__table__Kind_array_fixed,
		.name = name,
		.info = /* sum type cast */ (v__table__TypeInfo) {.obj = memdup(&(v__table__ArrayFixed[]) {(v__table__ArrayFixed){
		.elem_type = elem_type,
		.size = size,
		.nr_dims = nr_dims,
	}}, sizeof(v__table__ArrayFixed)), .typ = 81 /* v.table.ArrayFixed */},
		.parent_idx = 0,
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	};
	return v__table__Table_register_type_symbol(t, array_fixed_type);
}

int v__table__Table_find_or_register_multi_return(v__table__Table* t, array_v__table__Type mr_typs) {
	string name = tos3("multi_return");
	// FOR IN array
	array tmp1 = mr_typs;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__Type mr_typ = ((v__table__Type*)tmp1.data)[tmp2];
		v__table__TypeSymbol* mr_type_sym = v__table__Table_get_type_symbol(t, mr_typ);
		name = string_add(name, _STR("_%.*s", 1, mr_type_sym->name));
	}
	int existing_idx = (*(int*)map_get3(t->type_idxs, name, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__table__TypeSymbol mr_type = (v__table__TypeSymbol){
		.kind = v__table__Kind_multi_return,
		.name = name,
		.info = /* sum type cast */ (v__table__TypeInfo) {.obj = memdup(&(v__table__MultiReturn[]) {(v__table__MultiReturn){
		.types = mr_typs,
		.name = (string){.str=""},
	}}, sizeof(v__table__MultiReturn)), .typ = 86 /* v.table.MultiReturn */},
		.parent_idx = 0,
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	};
	return v__table__Table_register_type_symbol(t, mr_type);
}

int v__table__Table_find_or_register_fn_type(v__table__Table* t, v__table__Fn f, bool is_anon, bool has_decl) {
	string name = (f.name.len == 0 ?  ( _STR("anon_fn_%.*s", 1, v__table__Fn_signature(&f)) )  :  ( f.name ) );
	bool anon = f.name.len == 0 || is_anon;
	return v__table__Table_register_type_symbol(t, (v__table__TypeSymbol){
		.kind = v__table__Kind_function,
		.name = name,
		.info = /* sum type cast */ (v__table__TypeInfo) {.obj = memdup(&(v__table__FnType[]) {(v__table__FnType){
		.is_anon = anon,
		.has_decl = has_decl,
		.func = f,
	}}, sizeof(v__table__FnType)), .typ = 83 /* v.table.FnType */},
		.parent_idx = 0,
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
}

int v__table__Table_add_placeholder_type(v__table__Table* t, string name) {
	v__table__TypeSymbol ph_type = (v__table__TypeSymbol){
		.kind = v__table__Kind_placeholder,
		.name = name,
		.parent_idx = 0,
		.info = {0},
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	};
	return v__table__Table_register_type_symbol(t, ph_type);
}

// Attr: [inline]
inline v__table__Type v__table__Table_value_type(v__table__Table* t, v__table__Type typ) {
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(t, typ);
	if (v__table__Type_flag_is(typ, v__table__TypeFlag_variadic)) {
		return v__table__Type_set_flag(typ, v__table__TypeFlag_unset);
	}
	if (typ_sym->kind == v__table__Kind_array) {
		v__table__Array* info = /* as */ (v__table__Array*)__as_cast(typ_sym->info.obj, typ_sym->info.typ, /*expected:*/80);
		return info->elem_type;
	}
	if (typ_sym->kind == v__table__Kind_array_fixed) {
		v__table__ArrayFixed* info = /* as */ (v__table__ArrayFixed*)__as_cast(typ_sym->info.obj, typ_sym->info.typ, /*expected:*/81);
		return info->elem_type;
	}
	if (typ_sym->kind == v__table__Kind_map) {
		v__table__Map* info = /* as */ (v__table__Map*)__as_cast(typ_sym->info.obj, typ_sym->info.typ, /*expected:*/85);
		return info->value_type;
	}
	if (typ_sym->kind == v__table__Kind_string && v__table__Type_is_ptr(typ)) {
		return _const_v__table__string_type;
	}
	if ((typ_sym->kind == v__table__Kind_byteptr || typ_sym->kind == v__table__Kind_string)) {
		return _const_v__table__byte_type;
	}
	if (v__table__Type_is_ptr(typ)) {
		return v__table__Type_deref(typ);
	}
	if (string_eq(typ_sym->name, tos3("map_string"))) {
		return _const_v__table__string_type;
	}
	return _const_v__table__void_type;
}

bool v__table__Table_check(v__table__Table* t, v__table__Type got, v__table__Type expected) {
	int got_idx = v__table__Type_idx(got);
	int exp_idx = v__table__Type_idx(expected);
	bool exp_is_ptr = v__table__Type_is_ptr(expected);
	if (got_idx == exp_idx) {
		return true;
	}
	if (got_idx == _const_v__table__none_type_idx && v__table__Type_flag_is(expected, v__table__TypeFlag_optional)) {
		return true;
	}
	if (exp_is_ptr && got_idx == _const_v__table__int_type_idx) {
		return true;
	}
	if (exp_idx == _const_v__table__voidptr_type_idx || got_idx == _const_v__table__voidptr_type_idx) {
		return true;
	}
	if (exp_idx == _const_v__table__any_type_idx || got_idx == _const_v__table__any_type_idx) {
		return true;
	}
	if ((_IN(int, exp_idx, _const_v__table__pointer_type_idxs) || _IN(int, exp_idx, _const_v__table__number_type_idxs)) && (_IN(int, got_idx, _const_v__table__pointer_type_idxs) || _IN(int, got_idx, _const_v__table__number_type_idxs))) {
		return true;
	}
	if ((got_idx == _const_v__table__byte_type_idx && exp_idx == _const_v__table__byteptr_type_idx) || (exp_idx == _const_v__table__byte_type_idx && got_idx == _const_v__table__byteptr_type_idx)) {
		return true;
	}
	if ((got_idx == _const_v__table__char_type_idx && exp_idx == _const_v__table__charptr_type_idx) || (exp_idx == _const_v__table__char_type_idx && got_idx == _const_v__table__charptr_type_idx)) {
		return true;
	}
	v__table__TypeSymbol* got_type_sym = v__table__Table_get_type_symbol(t, got);
	v__table__TypeSymbol* exp_type_sym = v__table__Table_get_type_symbol(t, expected);
	if (exp_type_sym->kind == v__table__Kind_function && got_type_sym->kind == v__table__Kind_int) {
		return true;
	}
	if ((v__table__TypeSymbol_is_int(got_type_sym) && exp_type_sym->kind == v__table__Kind_enum_) || (v__table__TypeSymbol_is_int(exp_type_sym) && got_type_sym->kind == v__table__Kind_enum_)) {
		return true;
	}
	if (got_type_sym->kind == v__table__Kind_array_fixed && exp_type_sym->kind == v__table__Kind_byteptr) {
		v__table__ArrayFixed* info = /* as */ (v__table__ArrayFixed*)__as_cast(got_type_sym->info.obj, got_type_sym->info.typ, /*expected:*/81);
		if (v__table__Type_idx(info->elem_type) == _const_v__table__byte_type_idx) {
			return true;
		}
	}
	if (string_eq(exp_type_sym->name, tos3("array")) || string_eq(got_type_sym->name, tos3("array"))) {
		return true;
	}
	if (got_type_sym->kind == v__table__Kind_array && string_eq(got_type_sym->name, tos3("array_void")) && exp_type_sym->kind == v__table__Kind_array) {
		return true;
	}
	if ((got_type_sym->kind == v__table__Kind_alias && got_type_sym->parent_idx == exp_idx) || (exp_type_sym->kind == v__table__Kind_alias && exp_type_sym->parent_idx == got_idx)) {
		return true;
	}
	if (got_type_sym->kind == v__table__Kind_sum_type) {
		v__table__SumType* sum_info = /* as */ (v__table__SumType*)__as_cast(got_type_sym->info.obj, got_type_sym->info.typ, /*expected:*/88);
		if (_IN(v__table__Type, expected, sum_info->variants)) {
			return true;
		}
	}
	if (exp_type_sym->kind == v__table__Kind_sum_type) {
		v__table__SumType* sum_info = /* as */ (v__table__SumType*)__as_cast(exp_type_sym->info.obj, exp_type_sym->info.typ, /*expected:*/88);
		if (_IN(v__table__Type, got, sum_info->variants)) {
			return true;
		}
	}
	if (got_type_sym->kind == v__table__Kind_function && exp_type_sym->kind == v__table__Kind_function) {
		v__table__FnType* got_info = /* as */ (v__table__FnType*)__as_cast(got_type_sym->info.obj, got_type_sym->info.typ, /*expected:*/83);
		v__table__FnType* exp_info = /* as */ (v__table__FnType*)__as_cast(exp_type_sym->info.obj, exp_type_sym->info.typ, /*expected:*/83);
		if (got_info->func.args.len == exp_info->func.args.len) {
			// FOR IN array
			array tmp22 = got_info->func.args;
			for (int i = 0; i < tmp22.len; i++) {
				v__table__Arg got_arg = ((v__table__Arg*)tmp22.data)[i];
				v__table__Arg exp_arg = (*(v__table__Arg*)array_get(exp_info->func.args, i));
				if (!v__table__Table_check(t, got_arg.typ, exp_arg.typ)) {
					return false;
				}
			}
			return true;
		}
	}
	return false;
}

string v__table__Table_qualify_module(v__table__Table* table, string mod, string file_path) {
	// FOR IN array
	array tmp1 = table->imports;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string m = ((string*)tmp1.data)[tmp2];
		if (string_contains(m, tos3(".")) && string_contains(m, mod)) {
			array_string m_parts = string_split(m, tos3("."));
			string m_path = array_string_join(m_parts, _const_os__path_separator);
			if (string_eq(mod, (*(string*)array_get(m_parts, m_parts.len - 1))) && string_contains(file_path, m_path)) {
				return m;
			}
		}
	}
	return mod;
}

static string v__pref__mpath() {
	return string_add(os__home_dir(), tos3(".vmodules"));
}

v__pref__Preferences v__pref__new_preferences() {
	v__pref__Preferences p = (v__pref__Preferences){
		.os = {0},
		.backend = {0},
		.build_mode = {0},
		.is_verbose = 0,
		.is_test = 0,
		.is_script = 0,
		.is_livemain = 0,
		.is_liveshared = 0,
		.is_shared = 0,
		.is_prof = 0,
		.profile_file = (string){.str=""},
		.translated = 0,
		.is_prod = 0,
		.obfuscate = 0,
		.is_repl = 0,
		.is_run = 0,
		.sanitize = 0,
		.is_debug = 0,
		.is_vlines = 0,
		.keep_c = 0,
		.show_cc = 0,
		.use_cache = 0,
		.is_stats = 0,
		.no_auto_free = 0,
		.cflags = (string){.str=""},
		.ccompiler = (string){.str=""},
		.third_party_option = (string){.str=""},
		.building_v = 0,
		.autofree = 0,
		.compress = 0,
		.fast = 0,
		.enable_globals = 0,
		.is_fmt = 0,
		.is_bare = 0,
		.lookup_path = __new_array(0, 1, sizeof(string)),
		.output_cross_c = 0,
		.prealloc = 0,
		.vroot = (string){.str=""},
		.out_name = (string){.str=""},
		.path = (string){.str=""},
		.compile_defines = __new_array(0, 1, sizeof(string)),
		.compile_defines_all = __new_array(0, 1, sizeof(string)),
		.mod = (string){.str=""},
		.run_args = __new_array(0, 1, sizeof(string)),
		.printfn_list = __new_array(0, 1, sizeof(string)),
		.print_v_files = 0,
	};
	v__pref__Preferences_fill_with_defaults(&p);
	return p;
}

void v__pref__Preferences_fill_with_defaults(v__pref__Preferences* p) {
	if (string_eq(p->vroot, tos3(""))) {
		p->vroot = os__dir(v__pref__vexe_path());
	}
	string vlib_path = os__join_path(p->vroot, (varg_string){.len=1,.args={tos3("vlib")}});
	if (p->lookup_path.len == 0) {
		p->lookup_path = new_array_from_c_array(2, 2, sizeof(string), (string[2]){
		tos3("@vlib"), tos3("@vmodules"), 
});
	}
	// FOR IN array
	array tmp3 = p->lookup_path;
	for (int i = 0; i < tmp3.len; i++) {
		string path = ((string*)tmp3.data)[i];
		(*(string*)array_get(p->lookup_path, i)) = string_replace(string_replace(path, tos3("@vlib"), vlib_path), tos3("@vmodules"), _const_v__pref__default_module_path);
	}
	string rpath = os__real_path(p->path);
	if (string_eq(p->out_name, tos3(""))) {
		string filename = string_trim_space(os__file_name(rpath));
		string base = string_all_before_last(filename, tos3("."));
		if (string_eq(base, tos3(""))) {
			base = filename;
		}
		string target_dir = (os__is_dir(rpath) ?  ( rpath )  :  ( os__dir(rpath) ) );
		p->out_name = os__join_path(target_dir, (varg_string){.len=1,.args={base}});
		if (string_eq(rpath, _STR("%.*s\000/cmd/v", 2, p->vroot)) && os__is_dir(tos3("vlib/compiler"))) {
			println(tos3("Saving the resulting V executable in `./v2`"));
			println(string_add(tos3("Use `v -o v cmd/v` if you want to replace current "), tos3("V executable.")));
			p->out_name = tos3("v2");
		}
	}
	string rpath_name = os__file_name(rpath);
	p->building_v = !p->is_repl && (string_eq(rpath_name, tos3("v")) || string_eq(rpath_name, tos3("vfmt.v")));
	if (p->os == v__pref__OS__auto) {
		p->os = v__pref__get_host_os();
	}
	if (string_eq(p->ccompiler, tos3(""))) {
		p->ccompiler = v__pref__default_c_compiler();
	}
	p->is_test = string_ends_with(p->path, tos3("_test.v")) || string_ends_with(p->path, tos3(".vv"));
	p->is_script = string_ends_with(p->path, tos3(".v")) || string_ends_with(p->path, tos3(".vsh"));
	if (string_eq(p->third_party_option, tos3(""))) {
		p->third_party_option = p->cflags;
		
// $if !windows {
#ifndef _WIN32
			if (!string_contains(p->third_party_option, tos3("-fPIC"))) {
				p->third_party_option = string_add(p->third_party_option, tos3(" -fPIC"));
			}
		
// } windows
#endif

	}
	p->enable_globals = true;
}

static string v__pref__default_c_compiler() {
	
// $if  windows {
#ifdef _WIN32
		return tos3("gcc");
	
// } windows
#endif

	return tos3("cc");
}

string v__pref__vexe_path() {
	string vexe = os__getenv(tos3("VEXE"));
	if (string_ne(vexe, tos3(""))) {
		return vexe;
	}
	string real_vexe_path = os__real_path(os__executable());
	os__setenv(tos3("VEXE"), real_vexe_path, true);
	return real_vexe_path;
}

Option_v__pref__OS v__pref__os_from_string(string os_str) {
	if (string_eq(os_str, tos3("linux"))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS_linux }, sizeof(v__pref__OS));
	}else if (string_eq(os_str, tos3("windows"))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS_windows }, sizeof(v__pref__OS));
	}else if (string_eq(os_str, tos3("mac"))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS_mac }, sizeof(v__pref__OS));
	}else if (string_eq(os_str, tos3("macos"))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS_mac }, sizeof(v__pref__OS));
	}else if (string_eq(os_str, tos3("freebsd"))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS_freebsd }, sizeof(v__pref__OS));
	}else if (string_eq(os_str, tos3("openbsd"))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS_openbsd }, sizeof(v__pref__OS));
	}else if (string_eq(os_str, tos3("netbsd"))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS_netbsd }, sizeof(v__pref__OS));
	}else if (string_eq(os_str, tos3("dragonfly"))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS_dragonfly }, sizeof(v__pref__OS));
	}else if (string_eq(os_str, tos3("js"))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS_js }, sizeof(v__pref__OS));
	}else if (string_eq(os_str, tos3("solaris"))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS_solaris }, sizeof(v__pref__OS));
	}else if (string_eq(os_str, tos3("android"))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS_android }, sizeof(v__pref__OS));
	}else if (string_eq(os_str, tos3("haiku"))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS_haiku }, sizeof(v__pref__OS));
	}else if (string_eq(os_str, tos3("linux_or_macos"))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS_linux }, sizeof(v__pref__OS));
	}else if (string_eq(os_str, tos3(""))) {
		return /*:)v.pref.OS*/opt_ok(&(v__pref__OS[]) { v__pref__OS__auto }, sizeof(v__pref__OS));
	}else {
		return v_error(_STR("bad OS %.*s", 1, os_str));};
}

string v__pref__OS_str(v__pref__OS o) {
	if (o == v__pref__OS__auto) {
		return tos3("RESERVED: AUTO");
	}else if (o == v__pref__OS_mac) {
		return tos3("MacOS");
	}else if (o == v__pref__OS_linux) {
		return tos3("Linux");
	}else if (o == v__pref__OS_windows) {
		return tos3("Windows");
	}else if (o == v__pref__OS_freebsd) {
		return tos3("FreeBSD");
	}else if (o == v__pref__OS_openbsd) {
		return tos3("OpenBSD");
	}else if (o == v__pref__OS_netbsd) {
		return tos3("NetBSD");
	}else if (o == v__pref__OS_dragonfly) {
		return tos3("Dragonfly");
	}else if (o == v__pref__OS_js) {
		return tos3("JavaScript");
	}else if (o == v__pref__OS_android) {
		return tos3("Android");
	}else if (o == v__pref__OS_solaris) {
		return tos3("Solaris");
	}else if (o == v__pref__OS_haiku) {
		return tos3("Haiku");
	};
}

v__pref__OS v__pref__get_host_os() {
	
// $if  linux {
#ifdef __linux__
		return v__pref__OS_linux;
	
// } linux
#endif

	
// $if  macos {
#ifdef __APPLE__
		return v__pref__OS_mac;
	
// } macos
#endif

	
// $if  windows {
#ifdef _WIN32
		return v__pref__OS_windows;
	
// } windows
#endif

	
// $if  freebsd {
#ifdef __FreeBSD__
		return v__pref__OS_freebsd;
	
// } freebsd
#endif

	
// $if  openbsd {
#ifdef __OpenBSD__
		return v__pref__OS_openbsd;
	
// } openbsd
#endif

	
// $if  netbsd {
#ifdef __NetBSD__
		return v__pref__OS_netbsd;
	
// } netbsd
#endif

	
// $if  dragonfly {
#ifdef __DragonFly__
		return v__pref__OS_dragonfly;
	
// } dragonfly
#endif

	
// $if  solaris {
#ifdef __sun
		return v__pref__OS_solaris;
	
// } solaris
#endif

	
// $if  haiku {
#ifdef __haiku__
		return v__pref__OS_haiku;
	
// } haiku
#endif

	v_panic(tos3("unknown host OS"));
}

Option_v__pref__Backend v__pref__backend_from_string(string s) {
	if (string_eq(s, tos3("c"))) {
		return /*:)v.pref.Backend*/opt_ok(&(v__pref__Backend[]) { v__pref__Backend_c }, sizeof(v__pref__Backend));
	}else if (string_eq(s, tos3("js"))) {
		return /*:)v.pref.Backend*/opt_ok(&(v__pref__Backend[]) { v__pref__Backend_js }, sizeof(v__pref__Backend));
	}else if (string_eq(s, tos3("x64"))) {
		return /*:)v.pref.Backend*/opt_ok(&(v__pref__Backend[]) { v__pref__Backend_x64 }, sizeof(v__pref__Backend));
	}else {
		return v_error(_STR("Unknown backend type %.*s", 1, s));};
}

array_string v__pref__Preferences_should_compile_filtered_files(v__pref__Preferences* prefs, string dir, array_string files) {
	array_string res = __new_array(0, 0, sizeof(string));
	array_string_sort(&files);
	// FOR IN array
	array tmp1 = files;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string file = ((string*)tmp1.data)[tmp2];
		if (!string_ends_with(file, tos3(".v")) && !string_ends_with(file, tos3(".vh"))) {
			continue;
		}
		if (string_ends_with(file, tos3("_test.v"))) {
			continue;
		}
		if (prefs->backend == v__pref__Backend_c && !v__pref__Preferences_should_compile_c(prefs, file)) {
			continue;
		}
		if (prefs->backend == v__pref__Backend_js && !v__pref__Preferences_should_compile_js(prefs, file)) {
			continue;
		}
		if (prefs->compile_defines_all.len > 0 && string_contains(file, tos3("_d_"))) {
			bool allowed = false;
			// FOR IN array
			array tmp8 = prefs->compile_defines;
			for (int tmp9 = 0; tmp9 < tmp8.len; tmp9++) {
				string cdefine = ((string*)tmp8.data)[tmp9];
				string file_postfix = _STR("_d_%.*s\000.v", 2, cdefine);
				if (string_ends_with(file, file_postfix)) {
					allowed = true;
					break;
				}
			}
			if (!allowed) {
				continue;
			}
		}
		array_push(&res, &(string[]){ os__join_path(dir, (varg_string){.len=1,.args={file}}) });
	}
	return res;
}

bool v__pref__Preferences_should_compile_c(v__pref__Preferences* prefs, string file) {
	if (!string_ends_with(file, tos3(".c.v")) && string_split(file, tos3(".")).len > 2) {
		return false;
	}
	if (string_ends_with(file, tos3("_windows.c.v")) && prefs->os != v__pref__OS_windows) {
		return false;
	}
	if (string_ends_with(file, tos3("_linux.c.v")) && prefs->os != v__pref__OS_linux) {
		return false;
	}
	if (string_ends_with(file, tos3("_darwin.c.v")) && prefs->os != v__pref__OS_mac) {
		return false;
	}
	if (string_ends_with(file, tos3("_nix.c.v")) && prefs->os == v__pref__OS_windows) {
		return false;
	}
	if (string_ends_with(file, tos3("_android.c.v")) && prefs->os != v__pref__OS_android) {
		return false;
	}
	if (string_ends_with(file, tos3("_freebsd.c.v")) && prefs->os != v__pref__OS_freebsd) {
		return false;
	}
	if (string_ends_with(file, tos3("_solaris.c.v")) && prefs->os != v__pref__OS_solaris) {
		return false;
	}
	return true;
}

bool v__pref__Preferences_should_compile_js(v__pref__Preferences* prefs, string file) {
	if (!string_ends_with(file, tos3(".js.v")) && string_split(file, tos3(".")).len > 2) {
		return false;
	}
	return true;
}

void help__print_and_exit(string topic) {
	string vexe = v__pref__vexe_path();
	string vroot = os__dir(vexe);
	for (int tmp1 = 0; tmp1 < topic.len; tmp1++) {
	byte b = topic.str[tmp1];
		if ((b >= 'a' && b <= 'z') || b == '-' || (b >= '0' && b <= '9')) {
			continue;
		}
		println(_const_help__unknown_topic);
		v_exit(1);
	}
	string target_topic = os__join_path(vroot, (varg_string){.len=4,.args={tos3("cmd"), tos3("v"), tos3("help"), _STR("%.*s\000.txt", 2, topic)}});
	Option_string content = os__read_file(target_topic);
	if (!content.ok) {
		string err = content.v_error;
		int errcode = content.ecode;
		 // typeof it_expr_type: v.ast.CallExpr
		// last_type: v.ast.ExprStmt
		// last_expr_result_type: void
		println(_const_help__unknown_topic);
		v_exit(1);
	};
	println(/*opt*/(*(string*)content.data));
	v_exit(0);
}

void v__util__EManager_set_support_color(v__util__EManager* e, bool b) {
	e->support_color = b;
}

v__util__EManager* v__util__new_error_manager() {
	return (v__util__EManager*)memdup(&(v__util__EManager){	.support_color = term__can_show_color_on_stderr(),
	}, sizeof(v__util__EManager));
}

string v__util__formatted_error(string kind, string emsg, string filepath, v__token__Position pos) {
	string path = filepath;
	string verror_paths_override = os__getenv(tos3("VERROR_PATHS"));
	if (string_eq(verror_paths_override, tos3("absolute"))) {
		path = os__real_path(path);
	} else {
		string workdir = string_add(os__getwd(), _const_os__path_separator);
		if (string_starts_with(path, workdir)) {
			path = string_replace(path, workdir, tos3(""));
		}
	}
	Option_string source = v__util__read_file(filepath);
	if (!source.ok) {
		string err = source.v_error;
		int errcode = source.ecode;
		// last_type: v.ast.ExprStmt
		// last_expr_result_type: v.ast.StringLiteral
		*(string*) source.data = tos3("");
	};
	int p = v__util__imax(0, v__util__imin(/*opt*/(*(string*)source.data).len - 1, pos.pos));
	if (/*opt*/(*(string*)source.data).len > 0) {
		for (; p >= 0; p--) {
			if (string_at(/*opt*/(*(string*)source.data), p) == '\r' || string_at(/*opt*/(*(string*)source.data), p) == '\n') {
				break;
			}
		}
	}
	int column = v__util__imax(0, pos.pos - p - 1);
	string position = _STR("%.*s\000:%"PRId32"\000:%"PRId32"\000:", 4, path, pos.line_nr + 1, v__util__imax(1, column + 1));
	string scontext = array_string_join(v__util__source_context(kind, /*opt*/(*(string*)source.data), column, pos), tos3("\n"));
	string final_position = (_const_v__util__emanager->support_color ?  ( term__bold(position) )  :  ( position ) );
	string final_kind = kind;
	if (_const_v__util__emanager->support_color) {
		final_kind = (string_contains(kind, tos3("error")) ?  ( term__bold(term__red(kind)) )  :  ( term__bold(term__magenta(kind)) ) );
	}
	string final_msg = emsg;
	string final_context = (scontext.len > 0 ?  ( _STR("\n%.*s", 1, scontext) )  :  ( tos3("") ) );
	return string_trim_space(_STR("%.*s\000 %.*s\000 %.*s\000 %.*s", 4, final_position, final_kind, final_msg, final_context));
}

array_string v__util__source_context(string kind, string source, int column, v__token__Position pos) {
	array_string clines = __new_array(0, 0, sizeof(string));
	if (source.len == 0) {
		return clines;
	}
	array_string source_lines = string_split_into_lines(source);
	int bline = v__util__imax(0, pos.line_nr - _const_v__util__error_context_before);
	int aline = v__util__imax(0, v__util__imin(source_lines.len - 1, pos.line_nr + _const_v__util__error_context_after));
	string tab_spaces = tos3("    ");
	for (int iline = bline;
	iline <= aline; iline++) {
		string sline = (*(string*)array_get(source_lines, iline));
		string cline = string_replace(sline, tos3("\t"), tab_spaces);
		if (iline == pos.line_nr && _const_v__util__emanager->support_color) {
			cline = (string_contains(kind, tos3("error")) ?  ( term__red(cline) )  :  ( term__magenta(cline) ) );
		}
		array_push(&clines, &(string[]){ string_add(_STR("%5"PRId32"\000 | ", 2, iline + 1), cline) });
		if (iline == pos.line_nr) {
			array_string pointerline = __new_array(0, 0, sizeof(string));
			for (int i = 0; i < sline.len; i++) {
			byte bchar = sline.str[i];
				if (i < column) {
					byte x = bchar;
					if (x == '\t') {
						array_push(&pointerline, &(string[]){ tab_spaces });
					} else {
						x = (byte_is_space(x) ?  ( bchar )  :  ( ' ' ) );
						array_push(&pointerline, &(string[]){ byte_str(x) });
					}
					continue;
				}
				if (pos.len > 1) {
					int max_len = sline.len - pointerline.len;
					int len = (pos.len > max_len ?  ( max_len )  :  ( pos.len ) );
					string underline = string_repeat(tos3("~"), len);
					array_push(&pointerline, &(string[]){ (_const_v__util__emanager->support_color ?  ( term__bold(term__blue(underline)) )  :  ( underline ) ) });
				} else {
					array_push(&pointerline, &(string[]){ (_const_v__util__emanager->support_color ?  ( term__bold(term__blue(tos3("^"))) )  :  ( tos3("^") ) ) });
				}
				break;
			}
			array_push(&clines, &(string[]){ string_add(tos3("      | "), array_string_join(pointerline, tos3(""))) });
		}
	}
	return clines;
}

void v__util__verror(string kind, string s) {
	if (_const_v__util__emanager->support_color) {
		eprintln(string_add(term__bold(term__red(kind)), _STR(": %.*s", 1, s)));
	} else {
		eprintln(_STR("%.*s\000: %.*s", 2, kind, s));
	}
	v_exit(1);
}

Option_string v__util__find_working_diff_command() {
	// FOR IN array
	array tmp1 = new_array_from_c_array(4, 4, sizeof(string), (string[4]){
		tos3("colordiff"), tos3("diff"), tos3("colordiff.exe"), tos3("diff.exe"), 
});
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string diffcmd = ((string*)tmp1.data)[tmp2];
		Option_os__Result p = os__exec(_STR("%.*s\000 --version", 2, diffcmd));
		if (!p.ok) {
			string err = p.v_error;
			int errcode = p.ecode;
			// last_type: v.ast.BranchStmt
			// last_expr_result_type: 
			continue;
		};
		if (/*opt*/(*(os__Result*)p.data).exit_code == 0) {
			return /*:)string*/opt_ok(&(string[]) { diffcmd }, sizeof(string));
		}
	}
	return v_error(tos3("no working diff command found"));}

string v__util__color_compare_files(string diff_cmd, string file1, string file2) {
	if (string_ne(diff_cmd, tos3(""))) {
		string full_cmd = string_add(_STR("%.*s\000 --minimal --text --unified=2 ", 2, diff_cmd), _STR(" --show-function-line=\"fn \" \"%.*s\000\" \"%.*s\000\" ", 3, file1, file2));
		Option_os__Result x = os__exec(full_cmd);
		if (!x.ok) {
			string err = x.v_error;
			int errcode = x.ecode;
			// last_type: v.ast.Return
			// last_expr_result_type: 
			return _STR("comparison command: `%.*s\000` failed", 2, full_cmd);
		};
		return /*opt*/(*(os__Result*)x.data).output;
	}
	return tos3("");
}

static string v__util__color_compare_strings(string diff_cmd, string expected, string found) {
	string cdir = os__cache_dir();
	u64 ctime = time__sys_mono_now();
	string e_file = os__join_path(cdir, (varg_string){.len=1,.args={_STR("%"PRIu64"\000.expected.txt", 2, ctime)}});
	string f_file = os__join_path(cdir, (varg_string){.len=1,.args={_STR("%"PRIu64"\000.found.txt", 2, ctime)}});
	os__write_file(e_file, expected);
	os__write_file(f_file, found);
	string res = v__util__color_compare_files(diff_cmd, e_file, f_file);
	os__rm(e_file);
	os__rm(f_file);
	return res;
}

// Attr: [inline]
inline static bool v__util__is_name_char(byte c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
}

// Attr: [inline]
inline static bool v__util__is_nl(byte c) {
	return c == '\r' || c == '\n';
}

static bool v__util__contains_capital(string s) {
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
	byte c = s.str[tmp1];
		if (c >= 'A' && c <= 'Z') {
			return true;
		}
	}
	return false;
}

static bool v__util__good_type_name(string s) {
	if (s.len < 4) {
		return true;
	}
	for (int tmp2 = 2; tmp2 < s.len; tmp2++) {
		int i = tmp2;
		if (byte_is_capital(string_at(s, i)) && byte_is_capital(string_at(s, i - 1)) && byte_is_capital(string_at(s, i - 2))) {
			return false;
		}
	}
	return true;
}

string v__util__cescaped_path(string s) {
	return string_replace(s, tos3("\\"), tos3("\\\\"));
}

bool v__util__is_fmt() {
	return string_contains(os__executable(), tos3("vfmt"));
}

string v__util__vhash() {
	array_fixed_byte_50 buf = {0};
	buf[0] = 0;
	snprintf(((charptr)(buf)), 50, "%s", V_COMMIT_HASH);
	return tos_clone(&/*qq*/buf);
}

string v__util__full_hash() {
	string build_hash = v__util__vhash();
	string current_hash = v__util__githash(false);
	if (string_eq(build_hash, current_hash)) {
		return build_hash;
	}
	return _STR("%.*s\000.%.*s", 2, build_hash, current_hash);
}

string v__util__full_v_version() {
	return _STR("V %.*s\000 %.*s", 2, _const_v__util__v_version, v__util__full_hash());
}

string v__util__githash(bool should_get_from_filesystem) {
	while (1) {
		if (should_get_from_filesystem) {
			string vexe = os__getenv(tos3("VEXE"));
			string vroot = os__dir(vexe);
			string git_head_file = os__join_path(vroot, (varg_string){.len=2,.args={tos3(".git"), tos3("HEAD")}});
			if (!os__exists(git_head_file)) {
				break;
			}
			Option_string head_content = os__read_file(git_head_file);
			if (!head_content.ok) {
				string err = head_content.v_error;
				int errcode = head_content.ecode;
				// last_type: v.ast.BranchStmt
				// last_expr_result_type: 
				break;
			};
			string gcbranch_rel_path = string_trim_space(string_replace(/*opt*/(*(string*)head_content.data), tos3("ref: "), tos3("")));
			string gcbranch_file = os__join_path(vroot, (varg_string){.len=2,.args={tos3(".git"), gcbranch_rel_path}});
			if (!os__exists(gcbranch_file)) {
				break;
			}
			Option_string current_branch_hash = os__read_file(gcbranch_file);
			if (!current_branch_hash.ok) {
				string err = current_branch_hash.v_error;
				int errcode = current_branch_hash.ecode;
				// last_type: v.ast.BranchStmt
				// last_expr_result_type: 
				break;
			};
			int desired_hash_length = 7;
			if (/*opt*/(*(string*)current_branch_hash.data).len > desired_hash_length) {
				return string_substr(/*opt*/(*(string*)current_branch_hash.data), 0, desired_hash_length);
			}
		}
		break;
	}
	array_fixed_byte_50 buf = {0};
	buf[0] = 0;
	snprintf(((charptr)(buf)), 50, "%s", V_CURRENT_COMMIT_HASH);
	return tos_clone(&/*qq*/buf);
}

static void v__util__set_vroot_folder(string vroot_path) {
	string vname = (string_eq(os__user_os(), tos3("windows")) ?  ( tos3("v.exe") )  :  ( tos3("v") ) );
	os__setenv(tos3("VEXE"), os__real_path(os__join_path(vroot_path, (varg_string){.len=1,.args={vname}})), true);
}

void v__util__launch_tool(bool is_verbose, string tool_name) {
	string vexe = v__pref__vexe_path();
	string vroot = os__dir(vexe);
	v__util__set_vroot_folder(vroot);
	string tool_args = array_string_join(array_slice(_const_os__args, 1, _const_os__args.len), tos3(" "));
	string tool_exe = v__util__path_of_executable(os__real_path(_STR("%.*s\000/cmd/tools/%.*s", 2, vroot, tool_name)));
	string tool_source = os__real_path(_STR("%.*s\000/cmd/tools/%.*s\000.v", 3, vroot, tool_name));
	string tool_command = _STR("\"%.*s\000\" %.*s", 2, tool_exe, tool_args);
	if (is_verbose) {
		println(_STR("launch_tool vexe        : %.*s", 1, vroot));
		println(_STR("launch_tool vroot       : %.*s", 1, vroot));
		println(_STR("launch_tool tool_args   : %.*s", 1, tool_args));
		println(_STR("launch_tool tool_command: %.*s", 1, tool_command));
	}
	bool should_compile = false;
	if (!os__exists(tool_exe)) {
		should_compile = true;
	} else {
		if (os__file_last_mod_unix(tool_exe) <= os__file_last_mod_unix(vexe)) {
			should_compile = true;
			if (string_eq(tool_name, tos3("vself")) || string_eq(tool_name, tos3("vup"))) {
				should_compile = false;
			}
		}
		if (os__file_last_mod_unix(tool_exe) <= os__file_last_mod_unix(tool_source)) {
			should_compile = true;
		}
	}
	if (is_verbose) {
		println(_STR("launch_tool should_compile: %.*s", 1, should_compile ? _SLIT("true") : _SLIT("false")));
	}
	if (should_compile) {
		string compilation_command = _STR("\"%.*s\000\" ", 2, vexe);
		compilation_command = string_add(compilation_command, _STR("\"%.*s\000\"", 2, tool_source));
		if (is_verbose) {
			println(_STR("Compiling %.*s\000 with: \"%.*s\000\"", 3, tool_name, compilation_command));
		}
		Option_os__Result tool_compilation = os__exec(compilation_command);
		if (!tool_compilation.ok) {
			string err = tool_compilation.v_error;
			int errcode = tool_compilation.ecode;
			 // typeof it_expr_type: v.ast.CallExpr
			// last_type: v.ast.ExprStmt
			// last_expr_result_type: void
			v_panic(err);
		};
		if (/*opt*/(*(os__Result*)tool_compilation.data).exit_code != 0) {
			string err = tos3("Permission denied");
			if (!string_contains(/*opt*/(*(os__Result*)tool_compilation.data).output, tos3("Permission denied"))) {
				err = _STR("\n%.*s", 1, /*opt*/(*(os__Result*)tool_compilation.data).output);
			}
			eprintln(_STR("cannot compile `%.*s\000`: %.*s", 2, tool_source, err));
			v_exit(1);
		}
	}
	if (is_verbose) {
		println(_STR("launch_tool running tool command: %.*s\000 ...", 2, tool_command));
	}
	v_exit(os__system(tool_command));
}

string v__util__path_of_executable(string path) {
	
// $if  windows {
#ifdef _WIN32
		return string_add(path, tos3(".exe"));
	
// } windows
#endif

	return path;
}

Option_string v__util__read_file(string file_path) {
	Option_string raw_text = os__read_file(file_path);
	if (!raw_text.ok) {
		string err = raw_text.v_error;
		int errcode = raw_text.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return v_error(_STR("failed to open %.*s", 1, file_path));};
	if (/*opt*/(*(string*)raw_text.data).len >= 3) {
		byteptr c_text = /*opt*/(*(string*)raw_text.data).str;
		if (c_text[0] == 0xEF && c_text[1] == 0xBB && c_text[2] == 0xBF) {
			int offset_from_begin = 3;
			/*opt*/(*(string*)raw_text.data) = tos(&/*qq*/c_text[offset_from_begin], vstrlen(c_text) - offset_from_begin);
		}
	}
	return /*:)string*/opt_ok(&(string[]) { /*opt*/(*(string*)raw_text.data) }, sizeof(string));
}

// Attr: [inline]
inline static int v__util__imin(int a, int b) {
	return (a < b ?  ( a )  :  ( b ) );
}

// Attr: [inline]
inline static int v__util__imax(int a, int b) {
	return (a > b ?  ( a )  :  ( b ) );
}

static string v__util__replace_op(string s) {
	byte last_char = string_at(s, s.len - 1);
	string suffix = (last_char == '+') ?  ( tos3("_plus") )  : (last_char == '-') ?  ( tos3("_minus") )  : (last_char == '*') ?  ( tos3("_mult") )  : (last_char == '/') ?  ( tos3("_div") )  : (last_char == '%') ?  ( tos3("_mod") )  :  ( tos3("") ) ;
	return string_add(string_substr(s, 0, s.len - 1), suffix);
}

array_string v__util__join_env_vflags_and_os_args() {
	string vosargs = os__getenv(tos3("VOSARGS"));
	if (string_ne(vosargs, tos3(""))) {
		return v__util__non_empty(string_split(vosargs, tos3(" ")));
	}
	array_string args = __new_array(0, 0, sizeof(string));
	string vflags = os__getenv(tos3("VFLAGS"));
	if (string_ne(vflags, tos3(""))) {
		array_push(&args, &(string[]){ (*(string*)array_get(_const_os__args, 0)) });
		_PUSH_MANY(&args, (string_split(vflags, tos3(" "))), tmp4, array_string);
		if (_const_os__args.len > 1) {
			_PUSH_MANY(&args, (array_slice(_const_os__args, 1, _const_os__args.len)), tmp6, array_string);
		}
		return v__util__non_empty(args);
	}
	return v__util__non_empty(_const_os__args);
}

static array_string v__util__non_empty(array_string arg) {

int tmp1_len = arg.len;
	array_string tmp1 = __new_array(0, tmp1_len, sizeof(string));
	for (int i = 0; i < tmp1_len; i++) {
	  string it = ((string*) arg.data)[i];
	if (string_ne(it, tos3(""))) array_push(&tmp1, &it); 
 }
		return  tmp1;
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
v__ast__IdentVar v__ast__Ident_var_info(v__ast__Ident* i) {
	if (i->info.typ == 138 /* v.ast.IdentVar */) {
		v__ast__IdentVar* it = (v__ast__IdentVar*)i->info.obj; // ST it
		return *it;
	}else {
		v_panic(tos3("Ident.var_info(): info is not IdentVar variant"));
	};
}

// Attr: [inline]
inline bool v__ast__expr_is_blank_ident(v__ast__Expr expr) {
	if (expr.typ == 136 /* v.ast.Ident */) {
		v__ast__Ident* it = (v__ast__Ident*)expr.obj; // ST it
		return it->kind == v__ast__IdentKind_blank_ident;
	}else {
		return false;
	};
}

// Attr: [inline]
inline bool v__ast__expr_is_call(v__ast__Expr expr) {
	return (expr.typ == 144 /* v.ast.CallExpr */) ?  ( true )  :  ( false ) ;
}

static v__token__Position v__ast__Expr_position(v__ast__Expr expr) {
	if (expr.typ == 142 /* v.ast.ArrayInit */) {
		v__ast__ArrayInit* it = (v__ast__ArrayInit*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 207 /* v.ast.AsCast */) {
		v__ast__AsCast* it = (v__ast__AsCast*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 134 /* v.ast.AssignExpr */) {
		v__ast__AssignExpr* it = (v__ast__AssignExpr*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 179 /* v.ast.CastExpr */) {
		v__ast__CastExpr* it = (v__ast__CastExpr*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 200 /* v.ast.Assoc */) {
		v__ast__Assoc* it = (v__ast__Assoc*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 201 /* v.ast.BoolLiteral */) {
		v__ast__BoolLiteral* it = (v__ast__BoolLiteral*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* it = (v__ast__CallExpr*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 202 /* v.ast.CharLiteral */) {
		v__ast__CharLiteral* it = (v__ast__CharLiteral*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 180 /* v.ast.EnumVal */) {
		v__ast__EnumVal* it = (v__ast__EnumVal*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 185 /* v.ast.FloatLiteral */) {
		v__ast__FloatLiteral* it = (v__ast__FloatLiteral*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 136 /* v.ast.Ident */) {
		v__ast__Ident* it = (v__ast__Ident*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 154 /* v.ast.IfExpr */) {
		v__ast__IfExpr* it = (v__ast__IfExpr*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 135 /* v.ast.IndexExpr */) {
		v__ast__IndexExpr* it = (v__ast__IndexExpr*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 208 /* v.ast.InfixExpr */) {
		v__ast__InfixExpr* it = (v__ast__InfixExpr*)expr.obj; // ST it
		v__token__Position left_pos = v__ast__Expr_position(it->left);
		v__token__Position right_pos = v__ast__Expr_position(it->right);
		if (left_pos.pos == 0 || right_pos.pos == 0) {
			return it->pos;
		}
		return (v__token__Position){
			.line_nr = it->pos.line_nr,
			.pos = left_pos.pos,
			.len = right_pos.pos - left_pos.pos + right_pos.len,
		};
	}else if (expr.typ == 186 /* v.ast.IntegerLiteral */) {
		v__ast__IntegerLiteral* it = (v__ast__IntegerLiteral*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 143 /* v.ast.MapInit */) {
		v__ast__MapInit* it = (v__ast__MapInit*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 159 /* v.ast.MatchExpr */) {
		v__ast__MatchExpr* it = (v__ast__MatchExpr*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 209 /* v.ast.PostfixExpr */) {
		v__ast__PostfixExpr* it = (v__ast__PostfixExpr*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 210 /* v.ast.PrefixExpr */) {
		v__ast__PrefixExpr* it = (v__ast__PrefixExpr*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 182 /* v.ast.SelectorExpr */) {
		v__ast__SelectorExpr* it = (v__ast__SelectorExpr*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 183 /* v.ast.StringLiteral */) {
		v__ast__StringLiteral* it = (v__ast__StringLiteral*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 184 /* v.ast.StringInterLiteral */) {
		v__ast__StringInterLiteral* it = (v__ast__StringInterLiteral*)expr.obj; // ST it
		return it->pos;
	}else if (expr.typ == 214 /* v.ast.StructInit */) {
		v__ast__StructInit* it = (v__ast__StructInit*)expr.obj; // ST it
		return it->pos;
	}else {
		return (v__token__Position){
			.line_nr = 0,
			.pos = 0,
			.len = 0,
		};
	};
}

static v__token__Position v__ast__Stmt_position(v__ast__Stmt stmt) {
	if (stmt.typ == 170 /* v.ast.AssertStmt */) {
		v__ast__AssertStmt* it = (v__ast__AssertStmt*)stmt.obj; // ST it
		return it->pos;
	}else if (stmt.typ == 132 /* v.ast.AssignStmt */) {
		v__ast__AssignStmt* it = (v__ast__AssignStmt*)stmt.obj; // ST it
		return it->pos;
	}else if (stmt.typ == 157 /* v.ast.Comment */) {
		v__ast__Comment* it = (v__ast__Comment*)stmt.obj; // ST it
		return it->pos;
	}else if (stmt.typ == 141 /* v.ast.CompIf */) {
		v__ast__CompIf* it = (v__ast__CompIf*)stmt.obj; // ST it
		return it->pos;
	}else if (stmt.typ == 188 /* v.ast.ConstDecl */) {
		v__ast__ConstDecl* it = (v__ast__ConstDecl*)stmt.obj; // ST it
		return it->pos;
	}else if (stmt.typ == 193 /* v.ast.EnumDecl */) {
		v__ast__EnumDecl* it = (v__ast__EnumDecl*)stmt.obj; // ST it
		return it->pos;
	}else if (stmt.typ == 177 /* v.ast.ExprStmt */) {
		v__ast__ExprStmt* it = (v__ast__ExprStmt*)stmt.obj; // ST it
		return it->pos;
	}else if (stmt.typ == 111 /* v.ast.FnDecl */) {
		v__ast__FnDecl* it = (v__ast__FnDecl*)stmt.obj; // ST it
		return it->pos;
	}else if (stmt.typ == 152 /* v.ast.ForCStmt */) {
		v__ast__ForCStmt* it = (v__ast__ForCStmt*)stmt.obj; // ST it
		return it->pos;
	}else if (stmt.typ == 153 /* v.ast.ForInStmt */) {
		v__ast__ForInStmt* it = (v__ast__ForInStmt*)stmt.obj; // ST it
		return it->pos;
	}else if (stmt.typ == 151 /* v.ast.ForStmt */) {
		v__ast__ForStmt* it = (v__ast__ForStmt*)stmt.obj; // ST it
		return it->pos;
	}else if (stmt.typ == 165 /* v.ast.Import */) {
		v__ast__Import* it = (v__ast__Import*)stmt.obj; // ST it
		return it->pos;
	}else if (stmt.typ == 191 /* v.ast.Return */) {
		v__ast__Return* it = (v__ast__Return*)stmt.obj; // ST it
		return it->pos;
	}else if (stmt.typ == 211 /* v.ast.StructDecl */) {
		v__ast__StructDecl* it = (v__ast__StructDecl*)stmt.obj; // ST it
		return it->pos;
	}else {
		return (v__token__Position){
			.line_nr = 0,
			.pos = 0,
			.len = 0,
		};
	};
}

v__ast__Expr v__ast__fe2ex(v__table__FExpr x) {
	v__ast__Expr res = (v__ast__Expr){
	0};
	memcpy(&res, &x, sizeof(v__ast__Expr));
	return res;
}

v__table__FExpr v__ast__ex2fe(v__ast__Expr x) {
	v__table__FExpr res = (v__table__FExpr){
	0};
	memcpy(&res, &x, sizeof(v__table__FExpr));
	return res;
}

v__ast__Scope* v__ast__new_scope(v__ast__Scope* parent, int start_pos) {
	return (v__ast__Scope*)memdup(&(v__ast__Scope){	.parent = parent,
		.start_pos = start_pos,
		.children = __new_array(0, 1, sizeof(v__ast__Scope)),
		.end_pos = 0,
		.objects = new_map_1(sizeof(v__ast__ScopeObject)),
	}, sizeof(v__ast__Scope));
}

Option_multi_return_v__ast__ScopeObject_v__ast__Scope v__ast__Scope_find_with_scope(v__ast__Scope* s, string name) {
	v__ast__Scope* sc = s;
	while (1) {
		if (_IN_MAP(name, sc->objects)) {
			return opt_ok(&(multi_return_v__ast__ScopeObject_v__ast__Scope/*X*/[]) { (multi_return_v__ast__ScopeObject_v__ast__Scope){.arg0=(*(v__ast__ScopeObject*)map_get3(sc->objects, name, &(v__ast__ScopeObject[]){ {0} })),.arg1=sc} }, sizeof(multi_return_v__ast__ScopeObject_v__ast__Scope));
		}
		if (isnil(sc->parent)) {
			break;
		}
		sc = sc->parent;
	}
	return opt_none();}

Option_v__ast__ScopeObject v__ast__Scope_find(v__ast__Scope* s, string name) {
	for (v__ast__Scope* sc = s;
	; sc = sc->parent) {
		if (_IN_MAP(name, sc->objects)) {
			return /*:)v.ast.ScopeObject*/opt_ok(&(v__ast__ScopeObject[]) { (*(v__ast__ScopeObject*)map_get3(sc->objects, name, &(v__ast__ScopeObject[]){ {0} })) }, sizeof(v__ast__ScopeObject));
		}
		if (isnil(sc->parent)) {
			break;
		}
	}
	return opt_none();}

bool v__ast__Scope_is_known(v__ast__Scope* s, string name) {
	bool tmp1;
	{ /* if guard */ Option_v__ast__ScopeObject _ = v__ast__Scope_find(s, name);
	if ((tmp1 = _.ok)) {
		return true;
	} if (!tmp1) { /* else */
	}}
	return false;
}

Option_v__ast__Var_ptr v__ast__Scope_find_var(v__ast__Scope* s, string name) {
	bool tmp1;
	{ /* if guard */ Option_v__ast__ScopeObject obj = v__ast__Scope_find(s, name);
	if ((tmp1 = obj.ok)) {
		v__ast__ScopeObject v = /*opt*/(*(v__ast__ScopeObject*)obj.data);
		if (v.typ == 131 /* v.ast.Var */) {
			v__ast__Var* it = (v__ast__Var*)v.obj; // ST it
			return /*:)v.ast.Var*/opt_ok(&(v__ast__Var*[]) { it }, sizeof(v__ast__Var*));
		}else {
		};
	}}
	return opt_none();}

Option_v__ast__ConstField_ptr v__ast__Scope_find_const(v__ast__Scope* s, string name) {
	bool tmp1;
	{ /* if guard */ Option_v__ast__ScopeObject obj = v__ast__Scope_find(s, name);
	if ((tmp1 = obj.ok)) {
		v__ast__ScopeObject cf = /*opt*/(*(v__ast__ScopeObject*)obj.data);
		if (cf.typ == 189 /* v.ast.ConstField */) {
			v__ast__ConstField* it = (v__ast__ConstField*)cf.obj; // ST it
			return /*:)v.ast.ConstField*/opt_ok(&(v__ast__ConstField*[]) { it }, sizeof(v__ast__ConstField*));
		}else {
		};
	}}
	return opt_none();}

bool v__ast__Scope_known_var(v__ast__Scope* s, string name) {
	bool tmp1;
	{ /* if guard */ Option_v__ast__Var_ptr _ = v__ast__Scope_find_var(s, name);
	if ((tmp1 = _.ok)) {
		return true;
	}}
	return false;
}

void v__ast__Scope_update_var_type(v__ast__Scope* s, string name, v__table__Type typ) {
	if ((*(v__ast__ScopeObject*)map_get3(s->objects, name, &(v__ast__ScopeObject[]){ {0} })).typ == 131 /* v.ast.Var */) {
		v__ast__Var* it = (v__ast__Var*)(*(v__ast__ScopeObject*)map_get3(s->objects, name, &(v__ast__ScopeObject[]){ {0} })).obj; // ST it
		if (it->typ == typ) {
			return ;
		}
		it->typ = typ;
	}else {
	};
}

void v__ast__Scope_register(v__ast__Scope* s, string name, v__ast__ScopeObject obj) {
	if (string_eq(name, tos3("_"))) {
		return ;
	}
	if (_IN_MAP(name, s->objects)) {
		return ;
	}
	map_set(&s->objects, name, &(v__ast__ScopeObject[]) { obj });
}

v__ast__Scope* v__ast__Scope_outermost(v__ast__Scope* s) {
	v__ast__Scope* sc = s;
	while (!isnil(sc->parent)) {
		sc = sc->parent;
	}
	return sc;
}

v__ast__Scope* v__ast__Scope_innermost(v__ast__Scope* s, int pos) {
	if (v__ast__Scope_contains(s, pos)) {
		int first = 0;
		int last = s->children.len - 1;
		int middle = last / 2;
		while (first <= last) {
			v__ast__Scope* s1 = (*(v__ast__Scope**)array_get(s->children, middle));
			if (s1->end_pos < pos) {
				first = middle + 1;
			} else if (v__ast__Scope_contains(s1, pos)) {
				return v__ast__Scope_innermost(s1, pos);
			} else {
				last = middle - 1;
			}
			middle = (first + last) / 2;
			if (first > last) {
				break;
			}
		}
		return s;
	}
	return s;
}

// Attr: [inline]
inline static bool v__ast__Scope_contains(v__ast__Scope* s, int pos) {
	return pos >= s->start_pos && pos <= s->end_pos;
}

string v__ast__Scope_show(v__ast__Scope* sc, int depth, int max_depth) {
	string out = tos3("");
	string indent = tos3("");
	for (int tmp1 = 0; tmp1 < depth * 4; tmp1++) {
		indent = string_add(indent, tos3(" "));
	}
	out = string_add(out, _STR("%.*s\000# %"PRId32"\000 - %"PRId32"\000\n", 4, indent, sc->start_pos, sc->end_pos));
	// FOR IN map
	array_string keys_tmp2 = map_keys(&sc->objects);
	for (int tmp3 = 0; tmp3 < keys_tmp2.len; tmp3++) {
		string tmp4 = ((string*)keys_tmp2.data)[tmp3];
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)map_get3(sc->objects, tmp4, &(v__ast__ScopeObject[]){ {0} }));
		if (obj.typ == 189 /* v.ast.ConstField */) {
			v__ast__ConstField* it = (v__ast__ConstField*)obj.obj; // ST it
			out = string_add(out, _STR("%.*s\000  * const: %.*s\000 - %"PRId32"\000\n", 4, indent, it->name, it->typ));
		}else if (obj.typ == 131 /* v.ast.Var */) {
			v__ast__Var* it = (v__ast__Var*)obj.obj; // ST it
			out = string_add(out, _STR("%.*s\000  * var: %.*s\000 - %"PRId32"\000\n", 4, indent, it->name, it->typ));
		}else {
		};
	}
	if (max_depth == 0 || depth < max_depth - 1) {
		// FOR IN array
		array tmp7 = sc->children;
		for (int i = 0; i < tmp7.len; i++) {
			out = string_add(out, v__ast__Scope_show((*(v__ast__Scope**)array_get(sc->children, i)), depth + 1, max_depth));
		}
	}
	return out;
}

string v__ast__Scope_str(v__ast__Scope* sc) {
	return v__ast__Scope_show(sc, 0, 0);
}

string v__ast__FnDecl_str(v__ast__FnDecl* node, v__table__Table* t) {
	strings__Builder f = strings__new_builder(30);
	if (node->is_pub) {
		strings__Builder_write(&f, tos3("pub "));
	}
	string receiver = tos3("");
	if (node->is_method) {
		string styp = v__table__Table_type_to_str(t, node->receiver.typ);
		string m = (node->rec_mut ?  ( tos3("mut ") )  :  ( tos3("") ) );
		if (node->rec_mut) {
			styp = string_substr(styp, 1, styp.len);
		}
		receiver = _STR("(%.*s\000%.*s\000 %.*s\000) ", 4, m, node->receiver.name, styp);
	}
	string name = (node->is_anon ?  ( tos3("") )  :  ( string_after(node->name, tos3(".")) ) );
	if (node->is_c) {
		name = _STR("C.%.*s", 1, name);
	}
	if (node->is_js) {
		name = _STR("JS.%.*s", 1, name);
	}
	strings__Builder_write(&f, _STR("fn %.*s\000%.*s\000(", 3, receiver, name));
	// FOR IN array
	array tmp8 = node->args;
	for (int i = 0; i < tmp8.len; i++) {
		v__table__Arg arg = ((v__table__Arg*)tmp8.data)[i];
		if (node->is_method && i == 0) {
			continue;
		}
		if (arg.is_hidden) {
			continue;
		}
		bool is_last_arg = i == node->args.len - 1;
		bool should_add_type = is_last_arg || (*(v__table__Arg*)array_get(node->args, i + 1)).typ != arg.typ || (node->is_variadic && i == node->args.len - 2);
		if (arg.is_mut) {
			strings__Builder_write(&f, tos3("mut "));
		}
		strings__Builder_write(&f, arg.name);
		string s = v__table__Table_type_to_str(t, arg.typ);
		if (arg.is_mut) {
			if (string_starts_with(s, tos3("&"))) {
				s = string_substr(s, 1, s.len);
			}
		}
		if (should_add_type) {
			if (node->is_variadic && is_last_arg) {
				strings__Builder_write(&f, string_add(tos3(" ..."), s));
			} else {
				strings__Builder_write(&f, string_add(tos3(" "), s));
			}
		}
		if (!is_last_arg) {
			strings__Builder_write(&f, tos3(", "));
		}
	}
	strings__Builder_write(&f, tos3(")"));
	if (node->return_type != _const_v__table__void_type) {
		strings__Builder_write(&f, string_add(tos3(" "), v__table__Table_type_to_str(t, node->return_type)));
	}
	return strings__Builder_str(&f);
}

string v__ast__Expr_str(v__ast__Expr x) {
	if (x.typ == 201 /* v.ast.BoolLiteral */) {
		v__ast__BoolLiteral* it = (v__ast__BoolLiteral*)x.obj; // ST it
		return bool_str(it->val);
	}else if (x.typ == 179 /* v.ast.CastExpr */) {
		v__ast__CastExpr* it = (v__ast__CastExpr*)x.obj; // ST it
		return _STR("%.*s\000(%.*s\000)", 3, it->typname, v__ast__Expr_str(it->expr));
	}else if (x.typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* it = (v__ast__CallExpr*)x.obj; // ST it
		string sargs = v__ast__args2str(it->args);
		if (it->is_method) {
			return _STR("%.*s\000.%.*s\000(%.*s\000)", 4, v__ast__Expr_str(it->left), it->name, sargs);
		}
		return _STR("%.*s\000.%.*s\000(%.*s\000)", 4, it->mod, it->name, sargs);
	}else if (x.typ == 202 /* v.ast.CharLiteral */) {
		v__ast__CharLiteral* it = (v__ast__CharLiteral*)x.obj; // ST it
		return _STR("`%.*s\000`", 2, it->val);
	}else if (x.typ == 180 /* v.ast.EnumVal */) {
		v__ast__EnumVal* it = (v__ast__EnumVal*)x.obj; // ST it
		return _STR(".%.*s", 1, it->val);
	}else if (x.typ == 185 /* v.ast.FloatLiteral */) {
		v__ast__FloatLiteral* it = (v__ast__FloatLiteral*)x.obj; // ST it
		return it->val;
	}else if (x.typ == 136 /* v.ast.Ident */) {
		v__ast__Ident* it = (v__ast__Ident*)x.obj; // ST it
		return it->name;
	}else if (x.typ == 135 /* v.ast.IndexExpr */) {
		v__ast__IndexExpr* it = (v__ast__IndexExpr*)x.obj; // ST it
		return _STR("%.*s\000[%.*s\000]", 3, v__ast__Expr_str(it->left), v__ast__Expr_str(it->index));
	}else if (x.typ == 186 /* v.ast.IntegerLiteral */) {
		v__ast__IntegerLiteral* it = (v__ast__IntegerLiteral*)x.obj; // ST it
		return it->val;
	}else if (x.typ == 208 /* v.ast.InfixExpr */) {
		v__ast__InfixExpr* it = (v__ast__InfixExpr*)x.obj; // ST it
		return _STR("%.*s\000 %.*s\000 %.*s", 3, v__ast__Expr_str(it->left), v__token__Kind_str(it->op), v__ast__Expr_str(it->right));
	}else if (x.typ == 203 /* v.ast.ParExpr */) {
		v__ast__ParExpr* it = (v__ast__ParExpr*)x.obj; // ST it
		return v__ast__Expr_str(it->expr);
	}else if (x.typ == 210 /* v.ast.PrefixExpr */) {
		v__ast__PrefixExpr* it = (v__ast__PrefixExpr*)x.obj; // ST it
		return string_add(v__token__Kind_str(it->op), v__ast__Expr_str(it->right));
	}else if (x.typ == 182 /* v.ast.SelectorExpr */) {
		v__ast__SelectorExpr* it = (v__ast__SelectorExpr*)x.obj; // ST it
		return _STR("%.*s\000.%.*s", 2, v__ast__Expr_str(it->expr), it->field);
	}else if (x.typ == 184 /* v.ast.StringInterLiteral */) {
		v__ast__StringInterLiteral* it = (v__ast__StringInterLiteral*)x.obj; // ST it
		array_string res = __new_array(0, 0, sizeof(string));
		array_push(&res, &(string[]){ tos3("'") });
		// FOR IN array
		array tmp4 = it->vals;
		for (int i = 0; i < tmp4.len; i++) {
			string val = ((string*)tmp4.data)[i];
			array_push(&res, &(string[]){ val });
			if (i >= it->exprs.len) {
				continue;
			}
			array_push(&res, &(string[]){ tos3("$") });
			if ((*(string*)array_get(it->expr_fmts, i)).len > 0) {
				array_push(&res, &(string[]){ tos3("{") });
				array_push(&res, &(string[]){ v__ast__Expr_str((*(v__ast__Expr*)array_get(it->exprs, i))) });
				array_push(&res, &(string[]){ (*(string*)array_get(it->expr_fmts, i)) });
				array_push(&res, &(string[]){ tos3("}") });
			} else {
				array_push(&res, &(string[]){ v__ast__Expr_str((*(v__ast__Expr*)array_get(it->exprs, i))) });
			}
		}
		array_push(&res, &(string[]){ tos3("'") });
		return array_string_join(res, tos3(""));
	}else if (x.typ == 183 /* v.ast.StringLiteral */) {
		v__ast__StringLiteral* it = (v__ast__StringLiteral*)x.obj; // ST it
		return _STR("\"%.*s\000\"", 2, it->val);
	}else if (x.typ == 206 /* v.ast.TypeOf */) {
		v__ast__TypeOf* it = (v__ast__TypeOf*)x.obj; // ST it
		return _STR("typeof(%.*s\000)", 2, v__ast__Expr_str(it->expr));
	}else {
		return _STR("[unhandled expr type %.*s\000]", 2, tos3( /* v.ast.Expr */ v_typeof_sumtype_133( (x).typ )));
	};
}

string v__ast__CallArg_str(v__ast__CallArg a) {
	if (a.is_mut) {
		return _STR("mut %.*s", 1, v__ast__Expr_str(a.expr));
	}
	return _STR("%.*s", 1, v__ast__Expr_str(a.expr));
}

string v__ast__args2str(array_v__ast__CallArg args) {
	array_string res = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp1 = args;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__CallArg a = ((v__ast__CallArg*)tmp1.data)[tmp2];
		array_push(&res, &(string[]){ v__ast__CallArg_str(a) });
	}
	return array_string_join(res, tos3(", "));
}

string v__ast__Stmt_str(v__ast__Stmt node) {
	if (node.typ == 132 /* v.ast.AssignStmt */) {
		v__ast__AssignStmt* it = (v__ast__AssignStmt*)node.obj; // ST it
		string out = tos3("");
		// FOR IN array
		array tmp2 = it->left;
		for (int i = 0; i < tmp2.len; i++) {
			v__ast__Ident ident = ((v__ast__Ident*)tmp2.data)[i];
			v__ast__IdentVar var_info = v__ast__Ident_var_info(&ident);
			if (var_info.is_mut) {
				out = string_add(out, tos3("mut "));
			}
			out = string_add(out, ident.name);
			if (i < it->left.len - 1) {
				out = string_add(out, tos3(","));
			}
		}
		out = string_add(out, _STR(" %.*s\000 ", 2, v__token__Kind_str(it->op)));
		// FOR IN array
		array tmp5 = it->right;
		for (int i = 0; i < tmp5.len; i++) {
			v__ast__Expr val = ((v__ast__Expr*)tmp5.data)[i];
			out = string_add(out, v__ast__Expr_str(val));
			if (i < it->right.len - 1) {
				out = string_add(out, tos3(","));
			}
		}
		return out;
	}else if (node.typ == 177 /* v.ast.ExprStmt */) {
		v__ast__ExprStmt* it = (v__ast__ExprStmt*)node.obj; // ST it
		return v__ast__Expr_str(it->expr);
	}else if (node.typ == 111 /* v.ast.FnDecl */) {
		v__ast__FnDecl* it = (v__ast__FnDecl*)node.obj; // ST it
		return _STR("fn %.*s\000() { %"PRId32"\000 stmts }", 3, it->name, it->stmts.len);
	}else {
		return _STR("[unhandled stmt str type: %.*s\000 ]", 2, tos3( /* v.ast.Stmt */ v_typeof_sumtype_108( (node).typ )));
	};
}

v__checker__Checker v__checker__new_checker(v__table__Table* table, v__pref__Preferences* pref) {
	return (v__checker__Checker){
		.table = table,
		.pref = pref,
		.file = {0},
		.nr_errors = 0,
		.nr_warnings = 0,
		.errors = __new_array(0, 1, sizeof(v__errors__Error)),
		.warnings = __new_array(0, 1, sizeof(v__errors__Warning)),
		.error_lines = __new_array(0, 1, sizeof(int)),
		.expected_type = {0},
		.fn_return_type = {0},
		.const_decl = (string){.str=""},
		.const_deps = __new_array(0, 1, sizeof(string)),
		.const_names = __new_array(0, 1, sizeof(string)),
		.in_for_count = 0,
		.var_decl_name = (string){.str=""},
		.returns = 0,
		.scope_returns = 0,
		.mod = (string){.str=""},
		.is_builtin_mod = 0,
	};
}

void v__checker__Checker_check(v__checker__Checker* c, v__ast__File ast_file) {
	c->file = ast_file;
	// FOR IN array
	array tmp1 = ast_file.imports;
	for (int i = 0; i < tmp1.len; i++) {
		v__ast__Import ast_import = ((v__ast__Import*)tmp1.data)[i];
		for (int tmp2 = 0; tmp2 < i; tmp2++) {
			int j = tmp2;
			if (string_eq(ast_import.mod, (*(v__ast__Import*)array_get(ast_file.imports, j)).mod)) {
				v__checker__Checker_error(c, _STR("module name `%.*s\000` duplicate", 2, ast_import.mod), ast_import.pos);
			}
		}
	}
	// FOR IN array
	array tmp4 = ast_file.stmts;
	for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)tmp4.data)[tmp5];
		v__checker__Checker_stmt(c, stmt);
	}
}

array_v__errors__Error v__checker__Checker_check2(v__checker__Checker* c, v__ast__File ast_file) {
	c->file = ast_file;
	// FOR IN array
	array tmp1 = ast_file.stmts;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)tmp1.data)[tmp2];
		v__checker__Checker_stmt(c, stmt);
	}
	return c->errors;
}

void v__checker__Checker_check_files(v__checker__Checker* c, array_v__ast__File ast_files) {
	bool has_main_mod_file = false;
	bool has_main_fn = false;
	// FOR IN array
	array tmp1 = ast_files;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__File file = ((v__ast__File*)tmp1.data)[tmp2];
		v__checker__Checker_check(c, file);
		if (string_eq(file.mod.name, tos3("main"))) {
			has_main_mod_file = true;
			if (v__checker__Checker_check_file_in_main(c, file)) {
				has_main_fn = true;
			}
		}
	}
	if (c->pref->build_mode == v__pref__BuildMode_build_module || c->pref->is_test) {
		return ;
	}
	if (c->pref->is_shared) {
		return ;
	}
	if (!has_main_mod_file) {
		v__checker__Checker_error(c, tos3("project must include a `main` module or be a shared library (compile with `v -shared`)"), (v__token__Position){
			.line_nr = 0,
			.pos = 0,
			.len = 0,
		});
	} else if (!has_main_fn) {
		v__checker__Checker_error(c, tos3("function `main` must be declared in the main module"), (v__token__Position){
			.line_nr = 0,
			.pos = 0,
			.len = 0,
		});
	}
}

static bool v__checker__Checker_check_file_in_main(v__checker__Checker* c, v__ast__File file) {
	bool has_main_fn = false;
	// FOR IN array
	array tmp1 = file.stmts;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)tmp1.data)[tmp2];
		if (stmt.typ == 188 /* v.ast.ConstDecl */) {
			v__ast__ConstDecl* it = (v__ast__ConstDecl*)stmt.obj; // ST it
			if (it->is_pub) {
				v__checker__Checker_warn(c, _STR("const %.*s", 1, _const_v__checker__no_pub_in_main_warning), it->pos);
			}
		}else if (stmt.typ == 189 /* v.ast.ConstField */) {
			v__ast__ConstField* it = (v__ast__ConstField*)stmt.obj; // ST it
			if (it->is_pub) {
				v__checker__Checker_warn(c, _STR("const field `%.*s\000` %.*s", 2, it->name, _const_v__checker__no_pub_in_main_warning), it->pos);
			}
		}else if (stmt.typ == 193 /* v.ast.EnumDecl */) {
			v__ast__EnumDecl* it = (v__ast__EnumDecl*)stmt.obj; // ST it
			if (it->is_pub) {
				v__checker__Checker_warn(c, _STR("enum `%.*s\000` %.*s", 2, it->name, _const_v__checker__no_pub_in_main_warning), it->pos);
			}
		}else if (stmt.typ == 111 /* v.ast.FnDecl */) {
			v__ast__FnDecl* it = (v__ast__FnDecl*)stmt.obj; // ST it
			if (string_eq(it->name, tos3("main"))) {
				has_main_fn = true;
				if (it->is_pub) {
					v__checker__Checker_error(c, tos3("function `main` cannot be declared public"), it->pos);
				}
				if (it->args.len > 0) {
					v__checker__Checker_error(c, tos3("function `main` cannot have arguments"), it->pos);
				}
				if (it->return_type != _const_v__table__void_type) {
					v__checker__Checker_error(c, tos3("function `main` cannot return values"), it->pos);
				}
			} else {
				if (it->is_pub) {
					v__checker__Checker_warn(c, _STR("function `%.*s\000` %.*s", 2, it->name, _const_v__checker__no_pub_in_main_warning), it->pos);
				}
			}
			if (it->ctdefine.len > 0) {
				if (it->return_type != _const_v__table__void_type) {
					v__checker__Checker_error(c, _STR("only functions that do NOT return values can have `[if %.*s\000]` tags", 2, it->ctdefine), it->pos);
				}
			}
		}else if (stmt.typ == 211 /* v.ast.StructDecl */) {
			v__ast__StructDecl* it = (v__ast__StructDecl*)stmt.obj; // ST it
			if (it->is_pub) {
				v__checker__Checker_warn(c, _STR("struct `%.*s\000` %.*s", 2, it->name, _const_v__checker__no_pub_in_main_warning), it->pos);
			}
		}else if (stmt.typ == 196 /* v.ast.TypeDecl */) {
			v__ast__TypeDecl* it = (v__ast__TypeDecl*)stmt.obj; // ST it
			v__ast__TypeDecl* type_decl = /* as */ (v__ast__TypeDecl*)__as_cast(stmt.obj, stmt.typ, /*expected:*/196);
			if (type_decl->typ == 199 /* v.ast.AliasTypeDecl */) {
				v__ast__AliasTypeDecl* alias_decl = /* as */ (v__ast__AliasTypeDecl*)__as_cast(type_decl->obj, type_decl->typ, /*expected:*/199);
				if (alias_decl->is_pub) {
					v__checker__Checker_warn(c, _STR("type alias `%.*s\000` %.*s", 2, alias_decl->name, _const_v__checker__no_pub_in_main_warning), alias_decl->pos);
				}
			} else if (type_decl->typ == 198 /* v.ast.SumTypeDecl */) {
				v__ast__SumTypeDecl* sum_decl = /* as */ (v__ast__SumTypeDecl*)__as_cast(type_decl->obj, type_decl->typ, /*expected:*/198);
				if (sum_decl->is_pub) {
					v__checker__Checker_warn(c, _STR("sum type `%.*s\000` %.*s", 2, sum_decl->name, _const_v__checker__no_pub_in_main_warning), sum_decl->pos);
				}
			} else if (type_decl->typ == 197 /* v.ast.FnTypeDecl */) {
				v__ast__FnTypeDecl* fn_decl = /* as */ (v__ast__FnTypeDecl*)__as_cast(type_decl->obj, type_decl->typ, /*expected:*/197);
				if (fn_decl->is_pub) {
					v__checker__Checker_warn(c, _STR("type alias `%.*s\000` %.*s", 2, fn_decl->name, _const_v__checker__no_pub_in_main_warning), fn_decl->pos);
				}
			}
		}else {
		};
	}
	return has_main_fn;
}

void v__checker__Checker_type_decl(v__checker__Checker* c, v__ast__TypeDecl node) {
	if (node.typ == 199 /* v.ast.AliasTypeDecl */) {
		v__ast__AliasTypeDecl* it = (v__ast__AliasTypeDecl*)node.obj; // ST it
		v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, it->parent_type);
		if (typ_sym->kind == v__table__Kind_placeholder) {
			v__checker__Checker_error(c, _STR("type `%.*s\000` doesn't exist", 2, typ_sym->name), it->pos);
		}
	}else if (node.typ == 197 /* v.ast.FnTypeDecl */) {
		v__ast__FnTypeDecl* it = (v__ast__FnTypeDecl*)node.obj; // ST it
		v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, it->typ);
		v__table__FnType* fn_typ_info = /* as */ (v__table__FnType*)__as_cast(typ_sym->info.obj, typ_sym->info.typ, /*expected:*/83);
		v__table__Fn fn_info = fn_typ_info->func;
		v__table__TypeSymbol* ret_sym = v__table__Table_get_type_symbol(c->table, fn_info.return_type);
		if (ret_sym->kind == v__table__Kind_placeholder) {
			v__checker__Checker_error(c, _STR("type `%.*s\000` doesn't exist", 2, ret_sym->name), it->pos);
		}
		// FOR IN array
		array tmp4 = fn_info.args;
		for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
			v__table__Arg arg = ((v__table__Arg*)tmp4.data)[tmp5];
			v__table__TypeSymbol* arg_sym = v__table__Table_get_type_symbol(c->table, arg.typ);
			if (arg_sym->kind == v__table__Kind_placeholder) {
				v__checker__Checker_error(c, _STR("type `%.*s\000` doesn't exist", 2, arg_sym->name), it->pos);
			}
		}
	}else if (node.typ == 198 /* v.ast.SumTypeDecl */) {
		v__ast__SumTypeDecl* it = (v__ast__SumTypeDecl*)node.obj; // ST it
		// FOR IN array
		array tmp7 = it->sub_types;
		for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
			v__table__Type typ = ((v__table__Type*)tmp7.data)[tmp8];
			v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
			if (typ_sym->kind == v__table__Kind_placeholder) {
				v__checker__Checker_error(c, _STR("type `%.*s\000` doesn't exist", 2, typ_sym->name), it->pos);
			}
		}
	};
}

void v__checker__Checker_struct_decl(v__checker__Checker* c, v__ast__StructDecl decl) {
	array_string splitted_full_name = string_split(decl.name, tos3("."));
	bool is_builtin = string_eq((*(string*)array_get(splitted_full_name, 0)), tos3("builtin"));
	string name = *(string*)array_last(splitted_full_name);
	if (!byte_is_capital(string_at(name, 0)) && !decl.is_c && !is_builtin && !_IN(string, name, _const_v__table__builtin_type_names)) {
		v__token__Position pos = (v__token__Position){
			.line_nr = decl.pos.line_nr,
			.pos = decl.pos.pos + 7,
			.len = name.len,
		};
		v__checker__Checker_error(c, tos3("struct name must begin with capital letter"), pos);
	}
	// FOR IN array
	array tmp2 = decl.fields;
	for (int i = 0; i < tmp2.len; i++) {
		v__ast__StructField field = ((v__ast__StructField*)tmp2.data)[i];
		for (int tmp3 = 0; tmp3 < i; tmp3++) {
			int j = tmp3;
			if (string_eq(field.name, (*(v__ast__StructField*)array_get(decl.fields, j)).name)) {
				v__checker__Checker_error(c, _STR("field name `%.*s\000` duplicate", 2, field.name), field.pos);
			}
		}
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, field.typ);
		if (sym->kind == v__table__Kind_placeholder && !decl.is_c && !string_starts_with(sym->name, tos3("C."))) {
			v__checker__Checker_error(c, _STR("unknown type `%.*s\000`", 2, sym->name), field.pos);
		}
		if (field.has_default_expr) {
			c->expected_type = field.typ;
			v__table__Type field_expr_type = v__checker__Checker_expr(c, field.default_expr);
			if (!v__table__Table_check(c->table, field_expr_type, field.typ)) {
				v__table__TypeSymbol* field_expr_type_sym = v__table__Table_get_type_symbol(c->table, field_expr_type);
				v__table__TypeSymbol* field_type_sym = v__table__Table_get_type_symbol(c->table, field.typ);
				string field_name = field.name;
				string fet_name = field_expr_type_sym->name;
				string ft_name = field_type_sym->name;
				v__checker__Checker_error(c, string_add(_STR("default expression for field `%.*s\000` ", 2, field_name), _STR("has type `%.*s\000`, but should be `%.*s\000`", 3, fet_name, ft_name)), v__ast__Expr_position(field.default_expr));
			}
		}
	}
}

v__table__Type v__checker__Checker_struct_init(v__checker__Checker* c, v__ast__StructInit* struct_init) {
	if (struct_init->typ == _const_v__table__void_type) {
		if (c->expected_type == _const_v__table__void_type) {
			v__checker__Checker_error(c, tos3("unexpected short struct syntax"), struct_init->pos);
			return _const_v__table__void_type;
		}
		struct_init->typ = c->expected_type;
	}
	v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(c->table, struct_init->typ);
	if (!type_sym->is_public && string_ne(type_sym->mod, c->mod)) {
		v__checker__Checker_warn(c, _STR("type `%.*s\000` is private", 2, type_sym->name), struct_init->pos);
	}
	if (type_sym->kind == v__table__Kind_placeholder) {
		v__checker__Checker_error(c, _STR("unknown struct: %.*s", 1, type_sym->name), struct_init->pos);
	}else if (type_sym->kind == v__table__Kind_struct_ || type_sym->kind == v__table__Kind_string || type_sym->kind == v__table__Kind_array) {
		v__table__Struct* info = /* as */ (v__table__Struct*)__as_cast(type_sym->info.obj, type_sym->info.typ, /*expected:*/87);
		if (struct_init->is_short && struct_init->fields.len > info->fields.len) {
			v__checker__Checker_error(c, tos3("too many fields"), struct_init->pos);
		}
		array_string inited_fields = __new_array(0, 0, sizeof(string));
		// FOR IN array
		array tmp6 = struct_init->fields;
		for (int i = 0; i < tmp6.len; i++) {
			v__ast__StructInitField field = ((v__ast__StructInitField*)tmp6.data)[i];
			v__table__Field info_field = (v__table__Field){
				.name = (string){.str=""},
				.typ = {0},
				.default_expr = {0},
				.has_default_expr = 0,
				.default_val = (string){.str=""},
				.attr = (string){.str=""},
				.is_pub = 0,
				.is_mut = 0,
				.is_global = 0,
			};
			string field_name = tos3("");
			if (struct_init->is_short) {
				if (i >= info->fields.len) {
					break;
				}
				info_field = (*(v__table__Field*)array_get(info->fields, i));
				field_name = info_field.name;
				(*(v__ast__StructInitField*)array_get(struct_init->fields, i)).name = field_name;
			} else {
				field_name = field.name;
				bool exists = false;
				// FOR IN array
				array tmp9 = info->fields;
				for (int tmp10 = 0; tmp10 < tmp9.len; tmp10++) {
					v__table__Field f = ((v__table__Field*)tmp9.data)[tmp10];
					if (string_eq(f.name, field_name)) {
						info_field = f;
						exists = true;
						break;
					}
				}
				if (!exists) {
					v__checker__Checker_error(c, _STR("unknown field `%.*s\000` in struct literal of type `%.*s\000`", 3, field.name, type_sym->name), field.pos);
					continue;
				}
				if (_IN(string, field_name, inited_fields)) {
					v__checker__Checker_error(c, _STR("duplicate field name in struct literal: `%.*s\000`", 2, field_name), field.pos);
					continue;
				}
			}
			array_push(&inited_fields, &(string[]){ field_name });
			c->expected_type = info_field.typ;
			v__table__Type expr_type = v__checker__Checker_expr(c, field.expr);
			v__table__TypeSymbol* expr_type_sym = v__table__Table_get_type_symbol(c->table, expr_type);
			v__table__TypeSymbol* field_type_sym = v__table__Table_get_type_symbol(c->table, info_field.typ);
			if (!v__table__Table_check(c->table, expr_type, info_field.typ)) {
				v__checker__Checker_error(c, _STR("cannot assign `%.*s\000` as `%.*s\000` for field `%.*s\000`", 4, expr_type_sym->name, field_type_sym->name, info_field.name), field.pos);
			}
			(*(v__ast__StructInitField*)array_get(struct_init->fields, i)).typ = expr_type;
			(*(v__ast__StructInitField*)array_get(struct_init->fields, i)).expected_type = info_field.typ;
		}
		// FOR IN array
		array tmp16 = info->fields;
		for (int tmp17 = 0; tmp17 < tmp16.len; tmp17++) {
			v__table__Field field = ((v__table__Field*)tmp16.data)[tmp17];
			if (_IN(string, field.name, inited_fields)) {
				continue;
			}
			if (v__table__Type_is_ptr(field.typ)) {
				v__checker__Checker_warn(c, _STR("reference field `%.*s\000.%.*s\000` must be initialized", 3, type_sym->name, field.name), struct_init->pos);
			}
		}
	}else {
	};
	return struct_init->typ;
}

v__table__Type v__checker__Checker_infix_expr(v__checker__Checker* c, v__ast__InfixExpr* infix_expr) {
	c->expected_type = _const_v__table__void_type;
	v__table__Type left_type = v__checker__Checker_expr(c, infix_expr->left);
	infix_expr->left_type = left_type;
	c->expected_type = left_type;
	v__table__Type right_type = v__checker__Checker_expr(c, infix_expr->right);
	infix_expr->right_type = right_type;
	v__table__TypeSymbol* right = v__table__Table_get_type_symbol(c->table, right_type);
	v__table__TypeSymbol* left = v__table__Table_get_type_symbol(c->table, left_type);
	if (infix_expr->op == v__token__Kind_eq || infix_expr->op == v__token__Kind_ne || infix_expr->op == v__token__Kind_gt || infix_expr->op == v__token__Kind_lt || infix_expr->op == v__token__Kind_ge || infix_expr->op == v__token__Kind_le || infix_expr->op == v__token__Kind_and || infix_expr->op == v__token__Kind_logical_or || infix_expr->op == v__token__Kind_dot || infix_expr->op == v__token__Kind_key_as || infix_expr->op == v__token__Kind_right_shift) {
	}else if (infix_expr->op == v__token__Kind_key_in || infix_expr->op == v__token__Kind_not_in) {
		if (right->kind == v__table__Kind_array) {
			v__table__TypeSymbol* right_sym = v__table__Table_get_type_symbol(c->table, v__table__TypeSymbol_array_info(right).elem_type);
			if (left->kind != right_sym->kind) {
				v__checker__Checker_error(c, tos3("the data type on the left of `in` does not match the array item type"), infix_expr->pos);
			}
		}else if (right->kind == v__table__Kind_map) {
			v__table__TypeSymbol* key_sym = v__table__Table_get_type_symbol(c->table, v__table__TypeSymbol_map_info(right).key_type);
			if (left->kind != key_sym->kind) {
				v__checker__Checker_error(c, tos3("the data type on the left of `in` does not match the map key type"), infix_expr->pos);
			}
		}else if (right->kind == v__table__Kind_string) {
			if (left->kind != v__table__Kind_string) {
				v__checker__Checker_error(c, tos3("the data type on the left of `in` must be a string"), infix_expr->pos);
			}
		}else {
			v__checker__Checker_error(c, tos3("`in` can only be used with an array/map/string"), infix_expr->pos);
		};
		return _const_v__table__bool_type;
	}else if (infix_expr->op == v__token__Kind_plus || infix_expr->op == v__token__Kind_minus || infix_expr->op == v__token__Kind_mul || infix_expr->op == v__token__Kind_div) {
		if (infix_expr->op == v__token__Kind_div && (infix_expr->right.typ == 186 /* v.ast.IntegerLiteral */ && string_eq(v__ast__Expr_str(infix_expr->right), tos3("0")) || infix_expr->right.typ == 185 /* v.ast.FloatLiteral */ && f64_eq(string_f64(v__ast__Expr_str(infix_expr->right)),0.0))) {
			v__checker__Checker_error(c, tos3("division by zero"), v__ast__Expr_position(infix_expr->right));
		}
		if ((left->kind == v__table__Kind_array || left->kind == v__table__Kind_array_fixed || left->kind == v__table__Kind_map || left->kind == v__table__Kind_struct_) && !v__table__TypeSymbol_has_method(left, v__token__Kind_str(infix_expr->op))) {
			v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left->name, right->name), v__ast__Expr_position(infix_expr->left));
		} else if ((right->kind == v__table__Kind_array || right->kind == v__table__Kind_array_fixed || right->kind == v__table__Kind_map || right->kind == v__table__Kind_struct_) && !v__table__TypeSymbol_has_method(right, v__token__Kind_str(infix_expr->op))) {
			v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left->name, right->name), v__ast__Expr_position(infix_expr->right));
		}
	}else if (infix_expr->op == v__token__Kind_left_shift) {
		if (left->kind == v__table__Kind_array) {
			v__checker__Checker_fail_if_immutable(c, infix_expr->left);
			v__table__Type left_value_type = v__table__Table_value_type(c->table, left_type);
			v__table__TypeSymbol* left_value_sym = v__table__Table_get_type_symbol(c->table, left_value_type);
			if (left_value_sym->kind == v__table__Kind_interface_) {
				if (right->kind != v__table__Kind_array) {
					v__checker__Checker_type_implements(c, right_type, left_value_type, v__ast__Expr_position(infix_expr->right));
				} else {
					v__checker__Checker_type_implements(c, v__table__Table_value_type(c->table, right_type), left_value_type, v__ast__Expr_position(infix_expr->right));
				}
				return _const_v__table__void_type;
			}
			if (v__table__Table_check(c->table, right_type, left_value_type)) {
				return _const_v__table__void_type;
			}
			if (right->kind == v__table__Kind_array && v__table__Table_check(c->table, left_value_type, v__table__Table_value_type(c->table, right_type))) {
				return _const_v__table__void_type;
			}
			string s = string_replace(left->name, tos3("array_"), tos3("[]"));
			v__checker__Checker_error(c, _STR("cannot append `%.*s\000` to `%.*s\000`", 3, right->name, s), v__ast__Expr_position(infix_expr->right));
			return _const_v__table__void_type;
		} else if (!v__table__TypeSymbol_is_int(left)) {
			v__checker__Checker_error(c, _STR("cannot shift type %.*s\000 into non-integer type %.*s", 2, right->name, left->name), v__ast__Expr_position(infix_expr->left));
			return _const_v__table__void_type;
		} else if (!v__table__TypeSymbol_is_int(right)) {
			v__checker__Checker_error(c, _STR("cannot shift non-integer type %.*s\000 into type %.*s", 2, right->name, left->name), v__ast__Expr_position(infix_expr->right));
			return _const_v__table__void_type;
		}
	}else if (infix_expr->op == v__token__Kind_key_is) {
		v__ast__Type* type_expr = /* as */ (v__ast__Type*)__as_cast(infix_expr->right.obj, infix_expr->right.typ, /*expected:*/162);
		v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, type_expr->typ);
		if (typ_sym->kind == v__table__Kind_placeholder) {
			v__checker__Checker_error(c, _STR("is: type `%.*s\000` does not exist", 2, typ_sym->name), type_expr->pos);
		}
		return _const_v__table__bool_type;
	}else if (infix_expr->op == v__token__Kind_amp || infix_expr->op == v__token__Kind_pipe || infix_expr->op == v__token__Kind_xor) {
		if (!v__table__TypeSymbol_is_int(left)) {
			v__checker__Checker_error(c, _STR("left type of `%.*s\000` cannot be non-integer type %.*s", 2, v__token__Kind_str(infix_expr->op), left->name), v__ast__Expr_position(infix_expr->left));
		} else if (!v__table__TypeSymbol_is_int(right)) {
			v__checker__Checker_error(c, _STR("right type of `%.*s\000` cannot be non-integer type %.*s", 2, v__token__Kind_str(infix_expr->op), right->name), v__ast__Expr_position(infix_expr->right));
		}
	}else if (infix_expr->op == v__token__Kind_mod) {
		if (v__table__TypeSymbol_is_int(left) && !v__table__TypeSymbol_is_int(right)) {
			v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left->name, right->name), v__ast__Expr_position(infix_expr->right));
		} else if (!v__table__TypeSymbol_is_int(left) && v__table__TypeSymbol_is_int(right)) {
			v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left->name, right->name), v__ast__Expr_position(infix_expr->left));
		} else if ((left->kind == v__table__Kind_f32 || left->kind == v__table__Kind_f64 || left->kind == v__table__Kind_string || left->kind == v__table__Kind_array || left->kind == v__table__Kind_array_fixed || left->kind == v__table__Kind_map || left->kind == v__table__Kind_struct_) && !v__table__TypeSymbol_has_method(left, v__token__Kind_str(infix_expr->op))) {
			v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left->name, right->name), v__ast__Expr_position(infix_expr->left));
		} else if ((right->kind == v__table__Kind_f32 || right->kind == v__table__Kind_f64 || right->kind == v__table__Kind_string || right->kind == v__table__Kind_array || right->kind == v__table__Kind_array_fixed || right->kind == v__table__Kind_map || right->kind == v__table__Kind_struct_) && !v__table__TypeSymbol_has_method(right, v__token__Kind_str(infix_expr->op))) {
			v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, left->name, right->name), v__ast__Expr_position(infix_expr->right));
		}
	}else {
	};
	if (left_type == _const_v__table__bool_type && !(infix_expr->op == v__token__Kind_eq || infix_expr->op == v__token__Kind_ne || infix_expr->op == v__token__Kind_logical_or || infix_expr->op == v__token__Kind_and)) {
		v__checker__Checker_error(c, tos3("bool types only have the following operators defined: `==`, `!=`, `||`, and `&&`"), infix_expr->pos);
	} else if (left_type == _const_v__table__string_type && !(infix_expr->op == v__token__Kind_plus || infix_expr->op == v__token__Kind_eq || infix_expr->op == v__token__Kind_ne || infix_expr->op == v__token__Kind_lt || infix_expr->op == v__token__Kind_gt || infix_expr->op == v__token__Kind_le || infix_expr->op == v__token__Kind_ge)) {
		v__checker__Checker_error(c, tos3("string types only have the following operators defined: `==`, `!=`, `<`, `>`, `<=`, `>=`, and `&&`"), infix_expr->pos);
	}
	if (!v__table__Table_check(c->table, right_type, left_type)) {
		if (left_type == _const_v__table__void_type || right_type == _const_v__table__void_type) {
			return _const_v__table__void_type;
		}
		v__checker__Checker_error(c, _STR("infix expr: cannot use `%.*s\000` (right expression) as `%.*s\000`", 3, right->name, left->name), infix_expr->pos);
	}
	return (v__token__Kind_is_relational(infix_expr->op) ?  ( _const_v__table__bool_type )  :  ( left_type ) );
}

static void v__checker__Checker_fail_if_immutable(v__checker__Checker* c, v__ast__Expr expr) {
	if (expr.typ == 136 /* v.ast.Ident */) {
		v__ast__Ident* it = (v__ast__Ident*)expr.obj; // ST it
		v__ast__Scope* scope = v__ast__Scope_innermost(c->file.scope, it->pos.pos);
		bool tmp2;
		{ /* if guard */ Option_v__ast__Var_ptr v = v__ast__Scope_find_var(scope, it->name);
		if ((tmp2 = v.ok)) {
			if (!/*opt*/(*(v__ast__Var**)v.data)->is_mut && !v__table__Type_is_ptr(/*opt*/(*(v__ast__Var**)v.data)->typ)) {
				v__checker__Checker_error(c, _STR("`%.*s\000` is immutable, declare it with `mut` to make it mutable", 2, it->name), it->pos);
			}
		}}
	}else if (expr.typ == 135 /* v.ast.IndexExpr */) {
		v__ast__IndexExpr* it = (v__ast__IndexExpr*)expr.obj; // ST it
		v__checker__Checker_fail_if_immutable(c, it->left);
	}else if (expr.typ == 203 /* v.ast.ParExpr */) {
		v__ast__ParExpr* it = (v__ast__ParExpr*)expr.obj; // ST it
		v__checker__Checker_fail_if_immutable(c, it->expr);
	}else if (expr.typ == 210 /* v.ast.PrefixExpr */) {
		v__ast__PrefixExpr* it = (v__ast__PrefixExpr*)expr.obj; // ST it
		v__checker__Checker_fail_if_immutable(c, it->right);
	}else if (expr.typ == 182 /* v.ast.SelectorExpr */) {
		v__ast__SelectorExpr* it = (v__ast__SelectorExpr*)expr.obj; // ST it
		if (it->expr_type == 0) {
			v__checker__Checker_error(c, tos3("0 type in SelectorExpr"), it->pos);
			return ;
		}
		v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, it->expr_type);
		if (typ_sym->kind == v__table__Kind_struct_) {
			v__table__Struct* struct_info = /* as */ (v__table__Struct*)__as_cast(typ_sym->info.obj, typ_sym->info.typ, /*expected:*/87);
			v__table__Field field_info = v__table__Struct_get_field(/*rec*/*struct_info, it->field);
			if (!field_info.is_mut) {
				string type_str = v__table__Table_type_to_str(c->table, it->expr_type);
				v__checker__Checker_error(c, _STR("field `%.*s\000` of struct `%.*s\000` is immutable", 3, it->field, type_str), it->pos);
			}
			v__checker__Checker_fail_if_immutable(c, it->expr);
		}else if (typ_sym->kind == v__table__Kind_array || typ_sym->kind == v__table__Kind_string) {
			if (!(string_eq(c->file.mod.name, tos3("builtin")) || string_eq(c->file.mod.name, tos3("crypto.rand")))) {
				v__checker__Checker_error(c, _STR("`%.*s\000` can not be modified", 2, v__table__Kind_str(typ_sym->kind)), it->pos);
			}
		}else {
			v__checker__Checker_error(c, _STR("unexpected symbol `%.*s\000`", 2, v__table__Kind_str(typ_sym->kind)), it->pos);
		};
	}else {
		v__checker__Checker_error(c, _STR("unexpected expression `%.*s\000`", 2, tos3( /* v.ast.Expr */ v_typeof_sumtype_133( (expr).typ ))), v__ast__Expr_position(expr));
	};
}

static void v__checker__Checker_assign_expr(v__checker__Checker* c, v__ast__AssignExpr* assign_expr) {
	c->expected_type = _const_v__table__void_type;
	v__table__Type left_type = v__checker__Checker_expr(c, assign_expr->left);
	c->expected_type = left_type;
	assign_expr->left_type = left_type;
	v__table__Type right_type = v__checker__Checker_expr(c, assign_expr->val);
	assign_expr->right_type = right_type;
	v__table__TypeSymbol* right = v__table__Table_get_type_symbol(c->table, right_type);
	v__table__TypeSymbol* left = v__table__Table_get_type_symbol(c->table, left_type);
	if (v__ast__expr_is_blank_ident(assign_expr->left)) {
		return ;
	}
	v__checker__Checker_fail_if_immutable(c, assign_expr->left);
	if (assign_expr->op == v__token__Kind_assign) {
	}else if (assign_expr->op == v__token__Kind_plus_assign) {
		if (!v__table__TypeSymbol_is_number(left) && left_type != _const_v__table__string_type && !v__table__TypeSymbol_is_pointer(left)) {
			v__checker__Checker_error(c, _STR("operator += not defined on left operand type `%.*s\000`", 2, left->name), v__ast__Expr_position(assign_expr->left));
		} else if (!v__table__TypeSymbol_is_number(right) && right_type != _const_v__table__string_type && !v__table__TypeSymbol_is_pointer(right)) {
			v__checker__Checker_error(c, _STR("operator += not defined on right operand type `%.*s\000`", 2, right->name), v__ast__Expr_position(assign_expr->val));
		}
	}else if (assign_expr->op == v__token__Kind_minus_assign) {
		if (!v__table__TypeSymbol_is_number(left) && !v__table__TypeSymbol_is_pointer(left)) {
			v__checker__Checker_error(c, _STR("operator -= not defined on left operand type `%.*s\000`", 2, left->name), v__ast__Expr_position(assign_expr->left));
		} else if (!v__table__TypeSymbol_is_number(right) && !v__table__TypeSymbol_is_pointer(right)) {
			v__checker__Checker_error(c, _STR("operator -= not defined on right operand type `%.*s\000`", 2, right->name), v__ast__Expr_position(assign_expr->val));
		}
	}else if (assign_expr->op == v__token__Kind_mult_assign || assign_expr->op == v__token__Kind_div_assign) {
		if (!v__table__TypeSymbol_is_number(left)) {
			v__checker__Checker_error(c, _STR("operator %.*s\000 not defined on left operand type `%.*s\000`", 3, v__token__Kind_str(assign_expr->op), left->name), v__ast__Expr_position(assign_expr->left));
		} else if (!v__table__TypeSymbol_is_number(right)) {
			v__checker__Checker_error(c, _STR("operator %.*s\000 not defined on right operand type `%.*s\000`", 3, v__token__Kind_str(assign_expr->op), right->name), v__ast__Expr_position(assign_expr->val));
		}
	}else if (assign_expr->op == v__token__Kind_and_assign || assign_expr->op == v__token__Kind_or_assign || assign_expr->op == v__token__Kind_xor_assign || assign_expr->op == v__token__Kind_mod_assign || assign_expr->op == v__token__Kind_left_shift_assign || assign_expr->op == v__token__Kind_right_shift_assign) {
		if (!v__table__TypeSymbol_is_int(left)) {
			v__checker__Checker_error(c, _STR("operator %.*s\000 not defined on left operand type `%.*s\000`", 3, v__token__Kind_str(assign_expr->op), left->name), v__ast__Expr_position(assign_expr->left));
		} else if (!v__table__TypeSymbol_is_int(right)) {
			v__checker__Checker_error(c, _STR("operator %.*s\000 not defined on right operand type `%.*s\000`", 3, v__token__Kind_str(assign_expr->op), right->name), v__ast__Expr_position(assign_expr->val));
		}
	}else {
	};
	if (!v__table__Table_check(c->table, right_type, left_type)) {
		v__table__TypeSymbol* left_type_sym = v__table__Table_get_type_symbol(c->table, left_type);
		v__table__TypeSymbol* right_type_sym = v__table__Table_get_type_symbol(c->table, right_type);
		v__checker__Checker_error(c, _STR("cannot assign `%.*s\000` to variable `%.*s\000` of type `%.*s\000`", 4, right_type_sym->name, v__ast__Expr_str(assign_expr->left), left_type_sym->name), v__ast__Expr_position(assign_expr->val));
	}
	v__checker__Checker_check_expr_opt_call(c, assign_expr->val, right_type, true);
}

v__table__Type v__checker__Checker_call_expr(v__checker__Checker* c, v__ast__CallExpr* call_expr) {
	v__checker__Checker_stmts(c, call_expr->or_block.stmts);
	if (call_expr->is_method) {
		return v__checker__Checker_call_method(c, call_expr);
	}
	return v__checker__Checker_call_fn(c, call_expr);
}

v__table__Type v__checker__Checker_call_method(v__checker__Checker* c, v__ast__CallExpr* call_expr) {
	v__table__Type left_type = v__checker__Checker_expr(c, call_expr->left);
	call_expr->left_type = left_type;
	v__table__TypeSymbol* left_type_sym = v__table__Table_get_type_symbol(c->table, left_type);
	string method_name = call_expr->name;
	if (left_type_sym->kind == v__table__Kind_array && (string_eq(method_name, tos3("filter")) || string_eq(method_name, tos3("clone")) || string_eq(method_name, tos3("repeat")) || string_eq(method_name, tos3("reverse")) || string_eq(method_name, tos3("map")) || string_eq(method_name, tos3("slice")))) {
		if ((string_eq(method_name, tos3("filter")) || string_eq(method_name, tos3("map")))) {
			v__table__Array* array_info = /* as */ (v__table__Array*)__as_cast(left_type_sym->info.obj, left_type_sym->info.typ, /*expected:*/80);
			v__ast__Scope* scope = v__ast__Scope_innermost(c->file.scope, call_expr->pos.pos);
			v__ast__Scope_update_var_type(scope, tos3("it"), array_info->elem_type);
		}
		v__table__Type arg_type = left_type;
		// FOR IN array
		array tmp3 = call_expr->args;
		for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
			v__ast__CallArg arg = ((v__ast__CallArg*)tmp3.data)[tmp4];
			arg_type = v__checker__Checker_expr(c, arg.expr);
		}
		call_expr->return_type = left_type;
		call_expr->receiver_type = left_type;
		if (string_eq(method_name, tos3("map"))) {
			call_expr->return_type = v__table__Table_find_or_register_array(c->table, arg_type, 1);
		} else if (string_eq(method_name, tos3("clone"))) {
			call_expr->receiver_type = v__table__Type_to_ptr(left_type);
		}
		return call_expr->return_type;
	} else if (left_type_sym->kind == v__table__Kind_array && (string_eq(method_name, tos3("first")) || string_eq(method_name, tos3("last")))) {
		v__table__Array* info = /* as */ (v__table__Array*)__as_cast(left_type_sym->info.obj, left_type_sym->info.typ, /*expected:*/80);
		call_expr->return_type = info->elem_type;
		call_expr->receiver_type = left_type;
		return call_expr->return_type;
	}
	bool tmp6;
	{ /* if guard */ Option_v__table__Fn method = v__table__Table_type_find_method(c->table, left_type_sym, method_name);
	if ((tmp6 = method.ok)) {
		if (!/*opt*/(*(v__table__Fn*)method.data).is_pub && !c->is_builtin_mod && !c->pref->is_test && string_ne(left_type_sym->mod, c->mod) && string_ne(left_type_sym->mod, tos3(""))) {
			v__checker__Checker_error(c, _STR("method `%.*s\000.%.*s\000` is private", 3, left_type_sym->name, method_name), call_expr->pos);
		}
		if (/*opt*/(*(v__table__Fn*)method.data).return_type == _const_v__table__void_type && /*opt*/(*(v__table__Fn*)method.data).ctdefine.len > 0 && !_IN(string, /*opt*/(*(v__table__Fn*)method.data).ctdefine, c->pref->compile_defines)) {
			call_expr->should_be_skipped = true;
		}
		int nr_args = (/*opt*/(*(v__table__Fn*)method.data).args.len == 0 ?  ( 0 )  :  ( /*opt*/(*(v__table__Fn*)method.data).args.len - 1 ) );
		int min_required_args = /*opt*/(*(v__table__Fn*)method.data).args.len - (/*opt*/(*(v__table__Fn*)method.data).is_variadic && /*opt*/(*(v__table__Fn*)method.data).args.len > 1 ?  ( 2 )  :  ( 1 ) );
		if (call_expr->args.len < min_required_args) {
			v__checker__Checker_error(c, _STR("too few arguments in call to `%.*s\000.%.*s\000` (%"PRId32"\000 instead of %"PRId32"\000)", 5, left_type_sym->name, method_name, call_expr->args.len, min_required_args), call_expr->pos);
		} else if (!/*opt*/(*(v__table__Fn*)method.data).is_variadic && call_expr->args.len > nr_args) {
			v__checker__Checker_error(c, _STR("!too many arguments in call to `%.*s\000.%.*s\000` (%"PRId32"\000 instead of %"PRId32"\000)", 5, left_type_sym->name, method_name, call_expr->args.len, nr_args), call_expr->pos);
			return /*opt*/(*(v__table__Fn*)method.data).return_type;
		}
		// FOR IN array
		array tmp12 = call_expr->args;
		for (int i = 0; i < tmp12.len; i++) {
			v__ast__CallArg arg = ((v__ast__CallArg*)tmp12.data)[i];
			v__table__Type exp_arg_typ = (/*opt*/(*(v__table__Fn*)method.data).is_variadic && i >= /*opt*/(*(v__table__Fn*)method.data).args.len - 1 ?  ( (*(v__table__Arg*)array_get(/*opt*/(*(v__table__Fn*)method.data).args, /*opt*/(*(v__table__Fn*)method.data).args.len - 1)).typ )  :  ( (*(v__table__Arg*)array_get(/*opt*/(*(v__table__Fn*)method.data).args, i + 1)).typ ) );
			v__table__TypeSymbol* exp_arg_sym = v__table__Table_get_type_symbol(c->table, exp_arg_typ);
			c->expected_type = exp_arg_typ;
			v__table__Type got_arg_typ = v__checker__Checker_expr(c, arg.expr);
			(*(v__ast__CallArg*)array_get(call_expr->args, i)).typ = got_arg_typ;
			if (/*opt*/(*(v__table__Fn*)method.data).is_variadic && v__table__Type_flag_is(got_arg_typ, v__table__TypeFlag_variadic) && call_expr->args.len - 1 > i) {
				v__checker__Checker_error(c, tos3("when forwarding a varg variable, it must be the final argument"), call_expr->pos);
			}
			if (exp_arg_sym->kind == v__table__Kind_interface_) {
				v__checker__Checker_type_implements(c, got_arg_typ, exp_arg_typ, v__ast__Expr_position(arg.expr));
				continue;
			}
			if (!v__table__Table_check(c->table, got_arg_typ, exp_arg_typ)) {
				v__table__TypeSymbol* got_arg_sym = v__table__Table_get_type_symbol(c->table, got_arg_typ);
				if (exp_arg_sym->kind == v__table__Kind_string && v__table__TypeSymbol_has_method(got_arg_sym, tos3("str"))) {
					continue;
				}
				v__checker__Checker_error(c, _STR("cannot use type `%.*s\000` as type `%.*s\000` in argument %"PRId32"\000 to `%.*s\000.%.*s\000`", 6, v__table__TypeSymbol_str(got_arg_sym), v__table__TypeSymbol_str(exp_arg_sym), i + 1, left_type_sym->name, method_name), call_expr->pos);
			}
		}
		if (call_expr->expected_arg_types.len == 0) {
			for (int tmp19 = 1; tmp19 < /*opt*/(*(v__table__Fn*)method.data).args.len; tmp19++) {
				int i = tmp19;
				array_push(&call_expr->expected_arg_types, &(v__table__Type[]){ (*(v__table__Arg*)array_get(/*opt*/(*(v__table__Fn*)method.data).args, i)).typ });
			}
		}
		call_expr->receiver_type = (*(v__table__Arg*)array_get(/*opt*/(*(v__table__Fn*)method.data).args, 0)).typ;
		call_expr->return_type = /*opt*/(*(v__table__Fn*)method.data).return_type;
		return /*opt*/(*(v__table__Fn*)method.data).return_type;
	}}
	if (string_eq(method_name, tos3("str"))) {
		call_expr->receiver_type = left_type;
		call_expr->return_type = _const_v__table__string_type;
		return _const_v__table__string_type;
	}
	bool tmp22;
	{ /* if guard */ Option_v__table__Field field = v__table__Table_struct_find_field(c->table, left_type_sym, method_name);
	if ((tmp22 = field.ok)) {
		v__table__TypeSymbol* field_type_sym = v__table__Table_get_type_symbol(c->table, /*opt*/(*(v__table__Field*)field.data).typ);
		if (field_type_sym->kind == v__table__Kind_function) {
			call_expr->is_method = false;
			v__table__FnType* info = /* as */ (v__table__FnType*)__as_cast(field_type_sym->info.obj, field_type_sym->info.typ, /*expected:*/83);
			call_expr->return_type = info->func.return_type;
			// FOR IN array
			array tmp24 = call_expr->args;
			for (int tmp25 = 0; tmp25 < tmp24.len; tmp25++) {
				v__ast__CallArg arg = ((v__ast__CallArg*)tmp24.data)[tmp25];
				v__checker__Checker_expr(c, arg.expr);
			}
			return info->func.return_type;
		}
	}}
	v__checker__Checker_error(c, _STR("unknown method: `%.*s\000.%.*s\000`", 3, left_type_sym->name, method_name), call_expr->pos);
	return _const_v__table__void_type;
}

v__table__Type v__checker__Checker_call_fn(v__checker__Checker* c, v__ast__CallExpr* call_expr) {
	if (string_eq(call_expr->name, tos3("panic"))) {
		c->returns = true;
	}
	string fn_name = call_expr->name;
	if (string_eq(fn_name, tos3("main"))) {
		v__checker__Checker_error(c, tos3("the `main` function cannot be called in the program"), call_expr->pos);
	}
	if (string_eq(fn_name, tos3("typeof"))) {
		return _const_v__table__string_type;
	}
	if (string_eq(fn_name, tos3("json.encode"))) {
	} else if (string_eq(fn_name, tos3("json.decode"))) {
		v__ast__Expr expr = (*(v__ast__CallArg*)array_get(call_expr->args, 0)).expr;
		if (!(expr.typ == 162 /* v.ast.Type */)) {
			string typ = tos3( /* v.ast.Expr */ v_typeof_sumtype_133( (expr).typ ));
			v__checker__Checker_error(c, _STR("json.decode: first argument needs to be a type, got `%.*s\000`", 2, typ), call_expr->pos);
			return _const_v__table__void_type;
		}
		c->expected_type = _const_v__table__string_type;
		(*(v__ast__CallArg*)array_get(call_expr->args, 1)).typ = v__checker__Checker_expr(c, (*(v__ast__CallArg*)array_get(call_expr->args, 1)).expr);
		v__ast__Type* typ = /* as */ (v__ast__Type*)__as_cast(expr.obj, expr.typ, /*expected:*/162);
		return v__table__Type_set_flag(typ->typ, v__table__TypeFlag_optional);
	}
	v__table__Fn f = (v__table__Fn){
		.args = __new_array(0, 1, sizeof(v__table__Arg)),
		.return_type = {0},
		.is_variadic = 0,
		.is_c = 0,
		.is_js = 0,
		.is_generic = 0,
		.is_pub = 0,
		.mod = (string){.str=""},
		.ctdefine = (string){.str=""},
		.name = (string){.str=""},
	};
	bool found = false;
	bool found_in_args = false;
	if (!string_contains(fn_name, tos3(".")) && !(string_eq(call_expr->mod, tos3("builtin")) || string_eq(call_expr->mod, tos3("main")))) {
		string name_prefixed = _STR("%.*s\000.%.*s", 2, call_expr->mod, fn_name);
		bool tmp7;
		{ /* if guard */ Option_v__table__Fn f1 = v__table__Table_find_fn(c->table, name_prefixed);
		if ((tmp7 = f1.ok)) {
			call_expr->name = name_prefixed;
			found = true;
			f = /*opt*/(*(v__table__Fn*)f1.data);
		}}
	}
	if (!found) {
		bool tmp9;
		{ /* if guard */ Option_v__table__Fn f1 = v__table__Table_find_fn(c->table, fn_name);
		if ((tmp9 = f1.ok)) {
			found = true;
			f = /*opt*/(*(v__table__Fn*)f1.data);
		}}
	}
	if (!found) {
		v__ast__Scope* scope = v__ast__Scope_innermost(c->file.scope, call_expr->pos.pos);
		bool tmp11;
		{ /* if guard */ Option_v__ast__Var_ptr v = v__ast__Scope_find_var(scope, fn_name);
		if ((tmp11 = v.ok)) {
			if (/*opt*/(*(v__ast__Var**)v.data)->typ != 0) {
				v__table__TypeSymbol* vts = v__table__Table_get_type_symbol(c->table, /*opt*/(*(v__ast__Var**)v.data)->typ);
				if (vts->kind == v__table__Kind_function) {
					v__table__FnType* info = /* as */ (v__table__FnType*)__as_cast(vts->info.obj, vts->info.typ, /*expected:*/83);
					f = info->func;
					found = true;
					found_in_args = true;
				}
			}
		}}
	}
	if (!found) {
		v__checker__Checker_error(c, _STR("unknown function: %.*s", 1, fn_name), call_expr->pos);
		return _const_v__table__void_type;
	}
	if (!found_in_args && (string_eq(call_expr->mod, tos3("builtin")) || string_eq(call_expr->mod, tos3("main")))) {
		v__ast__Scope* scope = v__ast__Scope_innermost(c->file.scope, call_expr->pos.pos);
		bool tmp16;
		{ /* if guard */ Option_v__ast__Var_ptr _ = v__ast__Scope_find_var(scope, fn_name);
		if ((tmp16 = _.ok)) {
			v__checker__Checker_error(c, _STR("ambiguous call to: `%.*s\000`, may refer to fn `%.*s\000` or variable `%.*s\000`", 4, fn_name, fn_name, fn_name), call_expr->pos);
		}}
	}
	call_expr->return_type = f.return_type;
	if (f.return_type == _const_v__table__void_type && f.ctdefine.len > 0 && !_IN(string, f.ctdefine, c->pref->compile_defines)) {
		call_expr->should_be_skipped = true;
	}
	if (f.is_c || call_expr->is_c || f.is_js || call_expr->is_js) {
		// FOR IN array
		array tmp19 = call_expr->args;
		for (int tmp20 = 0; tmp20 < tmp19.len; tmp20++) {
			v__ast__CallArg arg = ((v__ast__CallArg*)tmp19.data)[tmp20];
			v__checker__Checker_expr(c, arg.expr);
		}
		return f.return_type;
	}
	int min_required_args = (f.is_variadic ?  ( f.args.len - 1 )  :  ( f.args.len ) );
	if (call_expr->args.len < min_required_args) {
		v__checker__Checker_error(c, _STR("too few arguments in call to `%.*s\000` (%"PRId32"\000 instead of %"PRId32"\000)", 4, fn_name, call_expr->args.len, min_required_args), call_expr->pos);
	} else if (!f.is_variadic && call_expr->args.len > f.args.len) {
		v__checker__Checker_error(c, _STR("too many arguments in call to `%.*s\000` (%"PRId32"\000 instead of %"PRId32"\000)", 4, fn_name, call_expr->args.len, f.args.len), call_expr->pos);
		return f.return_type;
	}
	if (string_eq(fn_name, tos3("println")) || string_eq(fn_name, tos3("print"))) {
		c->expected_type = _const_v__table__string_type;
		(*(v__ast__CallArg*)array_get(call_expr->args, 0)).typ = v__checker__Checker_expr(c, (*(v__ast__CallArg*)array_get(call_expr->args, 0)).expr);
		return f.return_type;
	}
	if (call_expr->expected_arg_types.len == 0) {
		// FOR IN array
		array tmp25 = f.args;
		for (int tmp26 = 0; tmp26 < tmp25.len; tmp26++) {
			v__table__Arg arg = ((v__table__Arg*)tmp25.data)[tmp26];
			array_push(&call_expr->expected_arg_types, &(v__table__Type[]){ arg.typ });
		}
	}
	// FOR IN array
	array tmp28 = call_expr->args;
	for (int i = 0; i < tmp28.len; i++) {
		v__ast__CallArg call_arg = ((v__ast__CallArg*)tmp28.data)[i];
		v__table__Arg arg = (f.is_variadic && i >= f.args.len - 1 ?  ( (*(v__table__Arg*)array_get(f.args, f.args.len - 1)) )  :  ( (*(v__table__Arg*)array_get(f.args, i)) ) );
		c->expected_type = arg.typ;
		v__table__Type typ = v__checker__Checker_expr(c, call_arg.expr);
		(*(v__ast__CallArg*)array_get(call_expr->args, i)).typ = typ;
		v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
		v__table__TypeSymbol* arg_typ_sym = v__table__Table_get_type_symbol(c->table, arg.typ);
		if (f.is_variadic && v__table__Type_flag_is(typ, v__table__TypeFlag_variadic) && call_expr->args.len - 1 > i) {
			v__checker__Checker_error(c, tos3("when forwarding a varg variable, it must be the final argument"), call_expr->pos);
		}
		if (arg_typ_sym->kind == v__table__Kind_interface_) {
			v__checker__Checker_type_implements(c, typ, arg.typ, v__ast__Expr_position(call_arg.expr));
			continue;
		}
		if (!v__table__Table_check(c->table, typ, arg.typ)) {
			if (arg_typ_sym->kind == v__table__Kind_string && v__table__TypeSymbol_has_method(typ_sym, tos3("str"))) {
				continue;
			}
			if (typ_sym->kind == v__table__Kind_void && arg_typ_sym->kind == v__table__Kind_string) {
				continue;
			}
			if (f.is_generic) {
				continue;
			}
			if (typ_sym->kind == v__table__Kind_array_fixed) {
			}
			v__checker__Checker_error(c, _STR("cannot use type `%.*s\000` as type `%.*s\000` in argument %"PRId32"\000 to `%.*s\000`", 5, v__table__TypeSymbol_str(typ_sym), v__table__TypeSymbol_str(arg_typ_sym), i + 1, fn_name), call_expr->pos);
		}
	}
	return f.return_type;
}

static void v__checker__Checker_type_implements(v__checker__Checker* c, v__table__Type typ, v__table__Type inter_typ, v__token__Position pos) {
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
	v__table__TypeSymbol* inter_sym = v__table__Table_get_type_symbol(c->table, inter_typ);
	string styp = v__table__Table_type_to_str(c->table, typ);
	// FOR IN array
	array tmp1 = inter_sym->methods;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__Fn imethod = ((v__table__Fn*)tmp1.data)[tmp2];
		bool tmp3;
		{ /* if guard */ Option_v__table__Fn method = v__table__TypeSymbol_find_method(typ_sym, imethod.name);
		if ((tmp3 = method.ok)) {
			if (!v__table__Fn_is_same_method_as(&imethod, &/*qq*//*opt*/(*(v__table__Fn*)method.data))) {
				v__checker__Checker_error(c, _STR("`%.*s\000` incorrectly implements method `%.*s\000` of interface `%.*s\000`, expected `%.*s\000`", 5, styp, imethod.name, inter_sym->name, v__table__Table_fn_to_str(c->table, &/*qq*/imethod)), pos);
			}
			continue;
		}}
		v__checker__Checker_error(c, _STR("`%.*s\000` doesn't implement method `%.*s\000`", 3, styp, imethod.name), pos);
	}
	v__table__Interface* inter_info = /* as */ (v__table__Interface*)__as_cast(inter_sym->info.obj, inter_sym->info.typ, /*expected:*/84);
	if (!_IN(v__table__Type, typ, inter_info->types) && typ_sym->kind != v__table__Kind_interface_) {
		array_push(&inter_info->types, &(v__table__Type[]){ typ });
	}
}

void v__checker__Checker_check_expr_opt_call(v__checker__Checker* c, v__ast__Expr x, v__table__Type xtype, bool is_return_used) {
	if (x.typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* it = (v__ast__CallExpr*)x.obj; // ST it
		if (v__table__Type_flag_is(it->return_type, v__table__TypeFlag_optional)) {
			v__checker__Checker_check_or_block(c, it, xtype, is_return_used);
		}
	}else {
	};
}

void v__checker__Checker_check_or_block(v__checker__Checker* c, v__ast__CallExpr* call_expr, v__table__Type ret_type, bool is_ret_used) {
	if (!call_expr->or_block.is_used) {
		v__checker__Checker_error(c, _STR("%.*s\000() returns an option, but you missed to add an `or {}` block to it", 2, call_expr->name), call_expr->pos);
		return ;
	}
	int stmts_len = call_expr->or_block.stmts.len;
	if (stmts_len == 0) {
		if (is_ret_used) {
			v__checker__Checker_error(c, tos3("assignment requires a non empty `or {}` block"), call_expr->pos);
			return ;
		}
		return ;
	}
	v__ast__Stmt last_stmt = (*(v__ast__Stmt*)array_get(call_expr->or_block.stmts, stmts_len - 1));
	if (is_ret_used) {
		if (!v__checker__Checker_is_last_or_block_stmt_valid(c, last_stmt)) {
			string expected_type_name = v__table__Table_get_type_symbol(c->table, ret_type)->name;
			v__checker__Checker_error(c, _STR("last statement in the `or {}` block should return `%.*s\000`", 2, expected_type_name), call_expr->pos);
			return ;
		}
		if (last_stmt.typ == 177 /* v.ast.ExprStmt */) {
			v__ast__ExprStmt* it = (v__ast__ExprStmt*)last_stmt.obj; // ST it
			bool type_fits = v__table__Table_check(c->table, v__checker__Checker_expr(c, it->expr), ret_type);
			bool is_panic_or_exit = v__checker__is_expr_panic_or_exit(it->expr);
			if (type_fits || is_panic_or_exit) {
				return ;
			}
			string type_name = v__table__Table_get_type_symbol(c->table, v__checker__Checker_expr(c, it->expr))->name;
			string expected_type_name = v__table__Table_get_type_symbol(c->table, ret_type)->name;
			v__checker__Checker_error(c, _STR("wrong return type `%.*s\000` in the `or {}` block, expected `%.*s\000`", 3, type_name, expected_type_name), it->pos);
			return ;
		}else if (last_stmt.typ == 171 /* v.ast.BranchStmt */) {
			v__ast__BranchStmt* it = (v__ast__BranchStmt*)last_stmt.obj; // ST it
			if (!(it->tok.kind == v__token__Kind_key_continue || it->tok.kind == v__token__Kind_key_break)) {
				v__checker__Checker_error(c, tos3("only break/continue is allowed as a branch statement in the end of an `or {}` block"), v__token__Token_position(&it->tok));
				return ;
			}
		}else {
		};
		return ;
	}
}

static bool v__checker__is_expr_panic_or_exit(v__ast__Expr expr) {
	if (expr.typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* it = (v__ast__CallExpr*)expr.obj; // ST it
		return (string_eq(it->name, tos3("panic")) || string_eq(it->name, tos3("exit")));
	}else {
		return false;
	};
}

bool v__checker__Checker_is_last_or_block_stmt_valid(v__checker__Checker* c, v__ast__Stmt stmt) {
	return (stmt.typ == 191 /* v.ast.Return */) ?  ( true )  : (stmt.typ == 171 /* v.ast.BranchStmt */) ?  ( true )  : (stmt.typ == 177 /* v.ast.ExprStmt */) ?  ( true )  :  ( false ) ;
}

v__table__Type v__checker__Checker_selector_expr(v__checker__Checker* c, v__ast__SelectorExpr* selector_expr) {
	v__table__Type typ = v__checker__Checker_expr(c, selector_expr->expr);
	if (typ == _const_v__table__void_type_idx) {
		v__checker__Checker_error(c, tos3("unknown selector expression"), selector_expr->pos);
		return _const_v__table__void_type;
	}
	selector_expr->expr_type = typ;
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
	string field_name = selector_expr->field;
	if (v__table__Type_flag_is(typ, v__table__TypeFlag_variadic)) {
		if (string_eq(field_name, tos3("len"))) {
			return _const_v__table__int_type;
		}
	}
	bool tmp4;
	{ /* if guard */ Option_v__table__Field field = v__table__Table_struct_find_field(c->table, typ_sym, field_name);
	if ((tmp4 = field.ok)) {
		return /*opt*/(*(v__table__Field*)field.data).typ;
	}}
	if (typ_sym->kind != v__table__Kind_struct_) {
		v__checker__Checker_error(c, _STR("`%.*s\000` is not a struct", 2, typ_sym->name), selector_expr->pos);
	} else {
		v__checker__Checker_error(c, _STR("unknown field `%.*s\000.%.*s\000`", 3, typ_sym->name, field_name), selector_expr->pos);
	}
	return _const_v__table__void_type;
}

void v__checker__Checker_return_stmt(v__checker__Checker* c, v__ast__Return* return_stmt) {
	c->expected_type = c->fn_return_type;
	if (return_stmt->exprs.len > 0 && c->fn_return_type == _const_v__table__void_type) {
		v__checker__Checker_error(c, tos3("too many arguments to return, current function does not return anything"), return_stmt->pos);
		return ;
	} else if (return_stmt->exprs.len == 0 && c->fn_return_type != _const_v__table__void_type) {
		v__checker__Checker_error(c, tos3("too few arguments to return"), return_stmt->pos);
		return ;
	}
	if (return_stmt->exprs.len == 0) {
		return ;
	}
	v__table__Type expected_type = c->fn_return_type;
	v__table__TypeSymbol* expected_type_sym = v__table__Table_get_type_symbol(c->table, expected_type);
	bool exp_is_optional = v__table__Type_flag_is(expected_type, v__table__TypeFlag_optional);
	array_v__table__Type expected_types = new_array_from_c_array(1, 1, sizeof(v__table__Type), (v__table__Type[1]){
		expected_type, 
});
	if (expected_type_sym->kind == v__table__Kind_multi_return) {
		v__table__MultiReturn* mr_info = /* as */ (v__table__MultiReturn*)__as_cast(expected_type_sym->info.obj, expected_type_sym->info.typ, /*expected:*/86);
		expected_types = mr_info->types;
	}
	array_v__table__Type got_types = __new_array(0, 0, sizeof(v__table__Type));
	// FOR IN array
	array tmp4 = return_stmt->exprs;
	for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
		v__ast__Expr expr = ((v__ast__Expr*)tmp4.data)[tmp5];
		v__table__Type typ = v__checker__Checker_expr(c, expr);
		array_push(&got_types, &(v__table__Type[]){ typ });
	}
	return_stmt->types = got_types;
	if (exp_is_optional && (v__table__Type_idx((*(v__table__Type*)array_get(got_types, 0))) == _const_v__table__none_type_idx || v__table__Type_idx((*(v__table__Type*)array_get(got_types, 0))) == (*(int*)map_get3(c->table->type_idxs, tos3("Option"), &(int[]){ 0 })))) {
		return ;
	}
	if (expected_types.len > 0 && expected_types.len != got_types.len) {
		v__checker__Checker_error(c, tos3("wrong number of return arguments"), return_stmt->pos);
	}
	// FOR IN array
	array tmp9 = expected_types;
	for (int i = 0; i < tmp9.len; i++) {
		v__table__Type exp_typ = ((v__table__Type*)tmp9.data)[i];
		v__table__Type got_typ = (*(v__table__Type*)array_get(got_types, i));
		if (!v__table__Table_check(c->table, got_typ, exp_typ)) {
			v__table__TypeSymbol* got_typ_sym = v__table__Table_get_type_symbol(c->table, got_typ);
			v__table__TypeSymbol* exp_typ_sym = v__table__Table_get_type_symbol(c->table, exp_typ);
			v__token__Position pos = v__ast__Expr_position((*(v__ast__Expr*)array_get(return_stmt->exprs, i)));
			v__checker__Checker_error(c, _STR("cannot use `%.*s\000` as type `%.*s\000` in return argument", 3, got_typ_sym->name, exp_typ_sym->name), pos);
		}
	}
}

void v__checker__Checker_enum_decl(v__checker__Checker* c, v__ast__EnumDecl decl) {
	// FOR IN array
	array tmp1 = decl.fields;
	for (int i = 0; i < tmp1.len; i++) {
		v__ast__EnumField field = ((v__ast__EnumField*)tmp1.data)[i];
		for (int tmp2 = 0; tmp2 < i; tmp2++) {
			int j = tmp2;
			if (string_eq(field.name, (*(v__ast__EnumField*)array_get(decl.fields, j)).name)) {
				v__checker__Checker_error(c, _STR("field name `%.*s\000` duplicate", 2, field.name), field.pos);
			}
		}
		if (field.has_expr) {
			if (field.expr.typ == 186 /* v.ast.IntegerLiteral */) {
				v__ast__IntegerLiteral* it = (v__ast__IntegerLiteral*)field.expr.obj; // ST it
			}else if (field.expr.typ == 210 /* v.ast.PrefixExpr */) {
				v__ast__PrefixExpr* it = (v__ast__PrefixExpr*)field.expr.obj; // ST it
			}else {
				if (field.expr.typ == 136 /* v.ast.Ident */) {
					v__ast__Ident* expr = /* as */ (v__ast__Ident*)__as_cast(field.expr.obj, field.expr.typ, /*expected:*/136);
					if (expr->is_c) {
						continue;
					}
				}
				v__token__Position pos = v__ast__Expr_position(field.expr);
				if (pos.pos == 0) {
					pos = field.pos;
				}
				v__checker__Checker_error(c, tos3("default value for enum has to be an integer"), pos);
			};
		}
	}
}

void v__checker__Checker_assign_stmt(v__checker__Checker* c, v__ast__AssignStmt* assign_stmt) {
	c->expected_type = _const_v__table__none_type;
	if ((*(v__ast__Expr*)array_get(assign_stmt->right, 0)).typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* call_expr = /* as */ (v__ast__CallExpr*)__as_cast((*(v__ast__Expr*)array_get(assign_stmt->right, 0)).obj, (*(v__ast__Expr*)array_get(assign_stmt->right, 0)).typ, /*expected:*/144);
		v__table__Type right_type0 = v__checker__Checker_expr(c, (*(v__ast__Expr*)array_get(assign_stmt->right, 0)));
		assign_stmt->right_types = new_array_from_c_array(1, 1, sizeof(v__table__Type), (v__table__Type[1]){
		right_type0, 
});
		v__table__TypeSymbol* right_type_sym0 = v__table__Table_get_type_symbol(c->table, right_type0);
		int right_len = (right_type0 == _const_v__table__void_type ?  ( 0 )  :  ( assign_stmt->right.len ) );
		if (right_type_sym0->kind == v__table__Kind_multi_return) {
			assign_stmt->right_types = v__table__TypeSymbol_mr_info(right_type_sym0).types;
			right_len = assign_stmt->right_types.len;
		}
		if (assign_stmt->left.len != right_len) {
			v__checker__Checker_error(c, _STR("assignment mismatch: %"PRId32"\000 variable(s) but `%.*s\000()` returns %"PRId32"\000 value(s)", 4, assign_stmt->left.len, call_expr->name, right_len), assign_stmt->pos);
			return ;
		}
	} else {
		if (assign_stmt->left.len != assign_stmt->right.len) {
			v__checker__Checker_error(c, _STR("assignment mismatch: %"PRId32"\000 variable(s) %"PRId32"\000 value(s)", 3, assign_stmt->left.len, assign_stmt->right.len), assign_stmt->pos);
			return ;
		}
	}
	v__ast__Scope* scope = v__ast__Scope_innermost(c->file.scope, assign_stmt->pos.pos);
	// FOR IN array
	array tmp6 = assign_stmt->left;
	for (int i = 0; i < tmp6.len; i++) {
		v__ast__Ident ident = (*(v__ast__Ident*)array_get(assign_stmt->left, i));
		if (assign_stmt->right_types.len < assign_stmt->right.len) {
			array_push(&assign_stmt->right_types, &(v__table__Type[]){ v__checker__Checker_expr(c, (*(v__ast__Expr*)array_get(assign_stmt->right, i))) });
		}
		v__table__Type val_type = (*(v__table__Type*)array_get(assign_stmt->right_types, i));
		bool is_decl = assign_stmt->op == v__token__Kind_decl_assign;
		if (is_decl && v__util__contains_capital(ident.name)) {
			v__checker__Checker_error(c, tos3("variable names cannot contain uppercase letters, use snake_case instead"), ident.pos);
		} else if (is_decl && ident.kind != v__ast__IdentKind_blank_ident) {
			if (string_starts_with(ident.name, tos3("__"))) {
				v__checker__Checker_error(c, tos3("variable names cannot start with `__`"), ident.pos);
			}
		}
		if (assign_stmt->op == v__token__Kind_decl_assign) {
			c->var_decl_name = ident.name;
		}
		v__ast__IdentVar ident_var_info = v__ast__Ident_var_info(&ident);
		if (assign_stmt->op == v__token__Kind_assign) {
			v__table__Type var_type = v__checker__Checker_expr(c, /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__Ident[]) {ident}, sizeof(v__ast__Ident)), .typ = 136 /* v.ast.Ident */});
			array_push(&assign_stmt->left_types, &(v__table__Type[]){ var_type });
			if (!v__table__Table_check(c->table, val_type, var_type)) {
				v__table__TypeSymbol* val_type_sym = v__table__Table_get_type_symbol(c->table, val_type);
				v__table__TypeSymbol* var_type_sym = v__table__Table_get_type_symbol(c->table, var_type);
				v__checker__Checker_error(c, _STR("assign stmt: cannot use `%.*s\000` as `%.*s\000`", 3, val_type_sym->name, var_type_sym->name), assign_stmt->pos);
			}
		}
		ident_var_info.typ = val_type;
		ident.info = /* sum type cast */ (v__ast__IdentInfo) {.obj = memdup(&(v__ast__IdentVar[]) {ident_var_info}, sizeof(v__ast__IdentVar)), .typ = 138 /* v.ast.IdentVar */};
		(*(v__ast__Ident*)array_get(assign_stmt->left, i)) = ident;
		v__ast__Scope_update_var_type(scope, ident.name, val_type);
		if (i < assign_stmt->right.len) {
			v__checker__Checker_check_expr_opt_call(c, (*(v__ast__Expr*)array_get(assign_stmt->right, i)), (*(v__table__Type*)array_get(assign_stmt->right_types, i)), true);
		}
	}
	c->var_decl_name = tos3("");
	c->expected_type = _const_v__table__void_type;
}

v__table__Type v__checker__Checker_array_init(v__checker__Checker* c, v__ast__ArrayInit* array_init) {
	v__table__Type elem_type = _const_v__table__void_type;
	if (array_init->typ != _const_v__table__void_type) {
		if (array_init->exprs.len == 0) {
			if (array_init->has_cap) {
				if (v__checker__Checker_expr(c, array_init->cap_expr) != _const_v__table__int_type) {
					v__checker__Checker_error(c, tos3("array cap needs to be an int"), array_init->pos);
				}
			}
			if (array_init->has_len) {
				if (v__checker__Checker_expr(c, array_init->len_expr) != _const_v__table__int_type) {
					v__checker__Checker_error(c, tos3("array len needs to be an int"), array_init->pos);
				}
			}
		}
		return array_init->typ;
	}
	if (array_init->exprs.len == 0) {
		if (array_init->has_cap) {
			if (v__checker__Checker_expr(c, array_init->cap_expr) != _const_v__table__int_type) {
				v__checker__Checker_error(c, tos3("array cap needs to be an int"), array_init->pos);
			}
		}
		if (array_init->has_len) {
			if (v__checker__Checker_expr(c, array_init->len_expr) != _const_v__table__int_type) {
				v__checker__Checker_error(c, tos3("array len needs to be an int"), array_init->pos);
			}
		}
		v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(c->table, c->expected_type);
		if (type_sym->kind != v__table__Kind_array) {
			v__checker__Checker_error(c, tos3("array_init: no type specified (maybe: `[]Type{}` instead of `[]`)"), array_init->pos);
			return _const_v__table__void_type;
		}
		v__table__Array array_info = v__table__TypeSymbol_array_info(type_sym);
		array_init->elem_type = array_info.elem_type;
		return c->expected_type;
	}
	if (array_init->exprs.len > 0 && array_init->elem_type == _const_v__table__void_type) {
		v__table__Type expected_value_type = _const_v__table__void_type;
		bool expecting_interface_array = false;
		int cap = array_init->exprs.len;
		array_v__table__Type interface_types = __new_array(0, cap, sizeof(v__table__Type));
		if (c->expected_type != 0) {
			expected_value_type = v__table__Table_value_type(c->table, c->expected_type);
			if (v__table__Table_get_type_symbol(c->table, expected_value_type)->kind == v__table__Kind_interface_) {
				expecting_interface_array = true;
				array_init->interface_type = expected_value_type;
				array_init->is_interface = true;
			}
		}
		// FOR IN array
		array tmp16 = array_init->exprs;
		for (int i = 0; i < tmp16.len; i++) {
			v__ast__Expr expr = ((v__ast__Expr*)tmp16.data)[i];
			v__table__Type typ = v__checker__Checker_expr(c, expr);
			if (expecting_interface_array) {
				if (i == 0) {
					elem_type = expected_value_type;
					c->expected_type = elem_type;
				}
				array_push(&interface_types, &(v__table__Type[]){ typ });
				continue;
			}
			if (i == 0) {
				elem_type = typ;
				c->expected_type = typ;
				continue;
			}
			if (!v__table__Table_check(c->table, elem_type, typ)) {
				v__table__TypeSymbol* elem_type_sym = v__table__Table_get_type_symbol(c->table, elem_type);
				v__checker__Checker_error(c, _STR("expected array element with type `%.*s\000`", 2, elem_type_sym->name), array_init->pos);
			}
		}
		if (expecting_interface_array) {
			array_init->interface_types = interface_types;
		}
		if (array_init->is_fixed) {
			int idx = v__table__Table_find_or_register_array_fixed(c->table, elem_type, array_init->exprs.len, 1);
			array_init->typ = v__table__new_type(idx);
		} else {
			int idx = v__table__Table_find_or_register_array(c->table, elem_type, 1);
			array_init->typ = v__table__new_type(idx);
		}
		array_init->elem_type = elem_type;
	} else if (array_init->is_fixed && array_init->exprs.len == 1 && array_init->elem_type != _const_v__table__void_type) {
		int fixed_size = 1;
		if ((*(v__ast__Expr*)array_get(array_init->exprs, 0)).typ == 186 /* v.ast.IntegerLiteral */) {
			v__ast__IntegerLiteral* it = (v__ast__IntegerLiteral*)(*(v__ast__Expr*)array_get(array_init->exprs, 0)).obj; // ST it
			fixed_size = string_int(it->val);
		}else if ((*(v__ast__Expr*)array_get(array_init->exprs, 0)).typ == 136 /* v.ast.Ident */) {
			v__ast__Ident* it = (v__ast__Ident*)(*(v__ast__Expr*)array_get(array_init->exprs, 0)).obj; // ST it
			string full_const_name = (string_eq(it->mod, tos3("main")) ?  ( it->name )  :  ( string_add(string_add(it->mod, tos3(".")), it->name) ) );
			bool tmp26;
			{ /* if guard */ Option_v__ast__ConstField_ptr obj = v__ast__Scope_find_const(c->file.global_scope, full_const_name);
			if ((tmp26 = obj.ok)) {
				bool tmp27;
				{ /* if guard */ Option_int cint = v__checker__const_int_value(*/*d*//*opt*/(*(v__ast__ConstField**)obj.data));
				if ((tmp27 = cint.ok)) {
					fixed_size = /*opt*/(*(int*)cint.data);
				}}
			} if (!tmp26) { /* else */
				v__checker__Checker_error(c, _STR("non existant integer const %.*s\000 while initializing the size of a static array", 2, full_const_name), array_init->pos);
			}}
		}else {
			v__checker__Checker_error(c, tos3("expecting `int` for fixed size"), array_init->pos);
		};
		int idx = v__table__Table_find_or_register_array_fixed(c->table, array_init->elem_type, fixed_size, 1);
		v__table__Type array_type = v__table__new_type(idx);
		array_init->typ = array_type;
	}
	return array_init->typ;
}

static Option_int v__checker__const_int_value(v__ast__ConstField cfield) {
	bool tmp1;
	{ /* if guard */ Option_v__ast__IntegerLiteral cint = v__checker__is_const_integer(cfield);
	if ((tmp1 = cint.ok)) {
		return /*:)int*/opt_ok(&(int[]) { string_int(/*opt*/(*(v__ast__IntegerLiteral*)cint.data).val) }, sizeof(int));
	}}
	return opt_none();}

static Option_v__ast__IntegerLiteral v__checker__is_const_integer(v__ast__ConstField cfield) {
	if (cfield.expr.typ == 186 /* v.ast.IntegerLiteral */) {
		v__ast__IntegerLiteral* it = (v__ast__IntegerLiteral*)cfield.expr.obj; // ST it
		return /*:)v.ast.IntegerLiteral*/opt_ok(&(v__ast__IntegerLiteral[]) { *it }, sizeof(v__ast__IntegerLiteral));
	}else {
	};
	return opt_none();}

static void v__checker__Checker_stmt(v__checker__Checker* c, v__ast__Stmt node) {
	if (node.typ == 170 /* v.ast.AssertStmt */) {
		v__ast__AssertStmt* it = (v__ast__AssertStmt*)node.obj; // ST it
		v__table__Type assert_type = v__checker__Checker_expr(c, it->expr);
		if (assert_type != _const_v__table__bool_type_idx) {
			string atype_name = v__table__Table_get_type_symbol(c->table, assert_type)->name;
			v__checker__Checker_error(c, _STR("assert can be used only with `bool` expressions, but found `%.*s\000` instead", 2, atype_name), it->pos);
		}
	}else if (node.typ == 132 /* v.ast.AssignStmt */) {
		v__ast__AssignStmt* it = (v__ast__AssignStmt*)node.obj; // ST it
		v__checker__Checker_assign_stmt(c, it);
	}else if (node.typ == 169 /* v.ast.Block */) {
		v__ast__Block* it = (v__ast__Block*)node.obj; // ST it
		v__checker__Checker_stmts(c, it->stmts);
	}else if (node.typ == 171 /* v.ast.BranchStmt */) {
		v__ast__BranchStmt* it = (v__ast__BranchStmt*)node.obj; // ST it
		if (c->in_for_count == 0) {
			v__checker__Checker_error(c, _STR("%.*s\000 statement not within a loop", 2, it->tok.lit), v__token__Token_position(&it->tok));
		}
	}else if (node.typ == 141 /* v.ast.CompIf */) {
		v__ast__CompIf* it = (v__ast__CompIf*)node.obj; // ST it
		v__checker__Checker_stmts(c, it->stmts);
		if (it->has_else) {
			v__checker__Checker_stmts(c, it->else_stmts);
		}
	}else if (node.typ == 188 /* v.ast.ConstDecl */) {
		v__ast__ConstDecl* it = (v__ast__ConstDecl*)node.obj; // ST it
		array_string field_names = __new_array(0, 0, sizeof(string));
		array_int field_order = __new_array(0, 0, sizeof(int));
		// FOR IN array
		array tmp5 = it->fields;
		for (int i = 0; i < tmp5.len; i++) {
			v__ast__ConstField field = ((v__ast__ConstField*)tmp5.data)[i];
			if (_IN(string, field.name, c->const_names)) {
				v__checker__Checker_error(c, _STR("field name `%.*s\000` duplicate", 2, field.name), field.pos);
			}
			array_push(&c->const_names, &(string[]){ field.name });
			array_push(&field_names, &(string[]){ field.name });
			array_push(&field_order, &(int[]){ i });
		}
		bool needs_order = false;
		array_int done_fields = __new_array(0, 0, sizeof(int));
		// FOR IN array
		array tmp10 = it->fields;
		for (int i = 0; i < tmp10.len; i++) {
			v__ast__ConstField field = ((v__ast__ConstField*)tmp10.data)[i];
			c->const_decl = field.name;
			array_push(&c->const_deps, &(string[]){ field.name });
			v__table__Type typ = v__checker__Checker_expr(c, field.expr);
			(*(v__ast__ConstField*)array_get(it->fields, i)).typ = typ;
			// FOR IN array
			array tmp12 = c->const_deps;
			for (int tmp13 = 0; tmp13 < tmp12.len; tmp13++) {
				string cd = ((string*)tmp12.data)[tmp13];
				// FOR IN array
				array tmp14 = it->fields;
				for (int j = 0; j < tmp14.len; j++) {
					v__ast__ConstField f = ((v__ast__ConstField*)tmp14.data)[j];
					if (j != i && _IN(string, cd, field_names) && string_eq(cd, f.name) && !_IN(int, j, done_fields)) {
						needs_order = true;
						int x = (*(int*)array_get(field_order, j));
						array_set(&field_order, j, &(int[]) { (*(int*)array_get(field_order, i)) });
						array_set(&field_order, i, &(int[]) { x });
						break;
					}
				}
			}
			array_push(&done_fields, &(int[]){ i });
			c->const_deps = __new_array(0, 0, sizeof(string));
		}
		if (needs_order) {
			array_v__ast__ConstField ordered_fields = __new_array(0, 0, sizeof(v__ast__ConstField));
			// FOR IN array
			array tmp18 = field_order;
			for (int tmp19 = 0; tmp19 < tmp18.len; tmp19++) {
				int order = ((int*)tmp18.data)[tmp19];
				array_push(&ordered_fields, &(v__ast__ConstField[]){ (*(v__ast__ConstField*)array_get(it->fields, order)) });
			}
			it->fields = ordered_fields;
		}
	}else if (node.typ == 173 /* v.ast.DeferStmt */) {
		v__ast__DeferStmt* it = (v__ast__DeferStmt*)node.obj; // ST it
		v__checker__Checker_stmts(c, it->stmts);
	}else if (node.typ == 193 /* v.ast.EnumDecl */) {
		v__ast__EnumDecl* it = (v__ast__EnumDecl*)node.obj; // ST it
		v__checker__Checker_enum_decl(c, */*d*/it);
	}else if (node.typ == 177 /* v.ast.ExprStmt */) {
		v__ast__ExprStmt* it = (v__ast__ExprStmt*)node.obj; // ST it
		v__table__Type etype = v__checker__Checker_expr(c, it->expr);
		c->expected_type = _const_v__table__void_type;
		v__checker__Checker_check_expr_opt_call(c, it->expr, etype, false);
	}else if (node.typ == 111 /* v.ast.FnDecl */) {
		v__ast__FnDecl* it = (v__ast__FnDecl*)node.obj; // ST it
		if (it->is_method) {
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, it->receiver.typ);
			if (sym->kind == v__table__Kind_interface_) {
				v__checker__Checker_error(c, tos3("interaces cannot be used as method receiver"), it->receiver_pos);
			}
		}
		if (!it->is_c) {
			// FOR IN array
			array tmp24 = it->args;
			for (int tmp25 = 0; tmp25 < tmp24.len; tmp25++) {
				v__table__Arg arg = ((v__table__Arg*)tmp24.data)[tmp25];
				v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, arg.typ);
				if (sym->kind == v__table__Kind_placeholder) {
					v__checker__Checker_error(c, _STR("unknown type `%.*s\000`", 2, sym->name), it->pos);
				}
			}
		}
		c->expected_type = _const_v__table__void_type;
		c->fn_return_type = it->return_type;
		v__checker__Checker_stmts(c, it->stmts);
		if (!it->is_c && !it->is_js && !it->no_body && it->return_type != _const_v__table__void_type && !c->returns && !(string_eq(it->name, tos3("panic")) || string_eq(it->name, tos3("exit")))) {
			v__checker__Checker_error(c, _STR("missing return at end of function `%.*s\000`", 2, it->name), it->pos);
		}
		c->returns = false;
	}else if (node.typ == 152 /* v.ast.ForCStmt */) {
		v__ast__ForCStmt* it = (v__ast__ForCStmt*)node.obj; // ST it
		c->in_for_count++;
		v__checker__Checker_stmt(c, it->init);
		v__checker__Checker_expr(c, it->cond);
		v__checker__Checker_expr(c, it->inc);
		v__checker__Checker_stmts(c, it->stmts);
		c->in_for_count--;
	}else if (node.typ == 153 /* v.ast.ForInStmt */) {
		v__ast__ForInStmt* it = (v__ast__ForInStmt*)node.obj; // ST it
		c->in_for_count++;
		v__table__Type typ = v__checker__Checker_expr(c, it->cond);
		int typ_idx = v__table__Type_idx(typ);
		if (it->is_range) {
			int high_type_idx = v__table__Type_idx(v__checker__Checker_expr(c, it->high));
			if (_IN(int, typ_idx, _const_v__table__integer_type_idxs) && !_IN(int, high_type_idx, _const_v__table__integer_type_idxs)) {
				v__checker__Checker_error(c, tos3("range types do not match"), v__ast__Expr_position(it->cond));
			} else if (_IN(int, typ_idx, _const_v__table__float_type_idxs) || _IN(int, high_type_idx, _const_v__table__float_type_idxs)) {
				v__checker__Checker_error(c, tos3("range type can not be float"), v__ast__Expr_position(it->cond));
			} else if (typ_idx == _const_v__table__bool_type_idx || high_type_idx == _const_v__table__bool_type_idx) {
				v__checker__Checker_error(c, tos3("range type can not be bool"), v__ast__Expr_position(it->cond));
			} else if (typ_idx == _const_v__table__string_type_idx || high_type_idx == _const_v__table__string_type_idx) {
				v__checker__Checker_error(c, tos3("range type can not be string"), v__ast__Expr_position(it->cond));
			}
			v__checker__Checker_expr(c, it->high);
		} else {
			v__ast__Scope* scope = v__ast__Scope_innermost(c->file.scope, it->pos.pos);
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, typ);
			if (it->key_var.len > 0) {
				v__table__Type key_type = (sym->kind == v__table__Kind_map) ?  ( v__table__TypeSymbol_map_info(sym).key_type )  :  ( _const_v__table__int_type ) ;
				it->key_type = key_type;
				v__ast__Scope_update_var_type(scope, it->key_var, key_type);
			}
			v__table__Type value_type = v__table__Table_value_type(c->table, typ);
			if (value_type == _const_v__table__void_type) {
				v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
				v__checker__Checker_error(c, _STR("for in: cannot index `%.*s\000`", 2, typ_sym->name), v__ast__Expr_position(it->cond));
			}
			it->cond_type = typ;
			it->kind = sym->kind;
			it->val_type = value_type;
			v__ast__Scope_update_var_type(scope, it->val_var, value_type);
		}
		v__checker__Checker_stmts(c, it->stmts);
		c->in_for_count--;
	}else if (node.typ == 151 /* v.ast.ForStmt */) {
		v__ast__ForStmt* it = (v__ast__ForStmt*)node.obj; // ST it
		c->in_for_count++;
		v__table__Type typ = v__checker__Checker_expr(c, it->cond);
		if (!it->is_inf && v__table__Type_idx(typ) != _const_v__table__bool_type_idx) {
			v__checker__Checker_error(c, tos3("non-bool used as for condition"), it->pos);
		}
		v__checker__Checker_stmts(c, it->stmts);
		c->in_for_count--;
	}else if (node.typ == 174 /* v.ast.GoStmt */) {
		v__ast__GoStmt* it = (v__ast__GoStmt*)node.obj; // ST it
		if (!(it->call_expr.typ == 144 /* v.ast.CallExpr */)) {
			v__checker__Checker_error(c, tos3("expression in `go` must be a function call"), v__ast__Expr_position(it->call_expr));
		}
		v__checker__Checker_expr(c, it->call_expr);
	}else if (node.typ == 165 /* v.ast.Import */) {
		v__ast__Import* it = (v__ast__Import*)node.obj; // ST it
	}else if (node.typ == 217 /* v.ast.InterfaceDecl */) {
		v__ast__InterfaceDecl* it = (v__ast__InterfaceDecl*)node.obj; // ST it
		string name = string_after(it->name, tos3("."));
		if (!byte_is_capital(string_at(name, 0))) {
			v__token__Position pos = (v__token__Position){
				.line_nr = it->pos.line_nr,
				.pos = it->pos.pos + tos3("interface").len,
				.len = name.len,
			};
			v__checker__Checker_error(c, tos3("interface name must begin with capital letter"), pos);
		}
	}else if (node.typ == 187 /* v.ast.Module */) {
		v__ast__Module* it = (v__ast__Module*)node.obj; // ST it
		c->mod = it->name;
		c->is_builtin_mod = string_eq(it->name, tos3("builtin"));
	}else if (node.typ == 191 /* v.ast.Return */) {
		v__ast__Return* it = (v__ast__Return*)node.obj; // ST it
		c->returns = true;
		v__checker__Checker_return_stmt(c, it);
		c->scope_returns = true;
	}else if (node.typ == 211 /* v.ast.StructDecl */) {
		v__ast__StructDecl* it = (v__ast__StructDecl*)node.obj; // ST it
		v__checker__Checker_struct_decl(c, */*d*/it);
	}else if (node.typ == 196 /* v.ast.TypeDecl */) {
		v__ast__TypeDecl* it = (v__ast__TypeDecl*)node.obj; // ST it
		v__checker__Checker_type_decl(c, */*d*/it);
	}else if (node.typ == 172 /* v.ast.UnsafeStmt */) {
		v__ast__UnsafeStmt* it = (v__ast__UnsafeStmt*)node.obj; // ST it
		v__checker__Checker_stmts(c, it->stmts);
	}else {
	};
}

static void v__checker__Checker_stmts(v__checker__Checker* c, array_v__ast__Stmt stmts) {
	v__token__Position unreachable = (v__token__Position){
		.line_nr = -1,
		.pos = 0,
		.len = 0,
	};
	c->expected_type = _const_v__table__void_type;
	// FOR IN array
	array tmp1 = stmts;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)tmp1.data)[tmp2];
		if (c->scope_returns) {
			if (unreachable.line_nr == -1) {
				unreachable = v__ast__Stmt_position(stmt);
			}
		}
		v__checker__Checker_stmt(c, stmt);
	}
	if (unreachable.line_nr >= 0) {
		v__checker__Checker_warn(c, tos3("unreachable code"), unreachable);
	}
	c->scope_returns = false;
	c->expected_type = _const_v__table__void_type;
}

v__table__Type v__checker__Checker_expr(v__checker__Checker* c, v__ast__Expr node) {
	if (node.typ == 142 /* v.ast.ArrayInit */) {
		v__ast__ArrayInit* it = (v__ast__ArrayInit*)node.obj; // ST it
		return v__checker__Checker_array_init(c, it);
	}else if (node.typ == 207 /* v.ast.AsCast */) {
		v__ast__AsCast* it = (v__ast__AsCast*)node.obj; // ST it
		it->expr_type = v__checker__Checker_expr(c, it->expr);
		v__table__TypeSymbol* expr_type_sym = v__table__Table_get_type_symbol(c->table, it->expr_type);
		v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(c->table, it->typ);
		if (expr_type_sym->kind == v__table__Kind_sum_type) {
			v__table__SumType* info = /* as */ (v__table__SumType*)__as_cast(expr_type_sym->info.obj, expr_type_sym->info.typ, /*expected:*/88);
			if (!_IN(v__table__Type, it->typ, info->variants)) {
				v__checker__Checker_error(c, _STR("cannot cast `%.*s\000` to `%.*s\000`", 3, expr_type_sym->name, type_sym->name), it->pos);
			}
		} else {
			v__checker__Checker_error(c, _STR("cannot cast non sum type `%.*s\000` using `as`", 2, type_sym->name), it->pos);
		}
		return v__table__Type_to_ptr(it->typ);
	}else if (node.typ == 134 /* v.ast.AssignExpr */) {
		v__ast__AssignExpr* it = (v__ast__AssignExpr*)node.obj; // ST it
		v__checker__Checker_assign_expr(c, it);
	}else if (node.typ == 200 /* v.ast.Assoc */) {
		v__ast__Assoc* it = (v__ast__Assoc*)node.obj; // ST it
		v__ast__Scope* scope = v__ast__Scope_innermost(c->file.scope, it->pos.pos);
		Option_v__ast__Var_ptr v = v__ast__Scope_find_var(scope, it->var_name);
		if (!v.ok) {
			string err = v.v_error;
			int errcode = v.ecode;
			 // typeof it_expr_type: v.ast.CallExpr
			// last_type: v.ast.ExprStmt
			// last_expr_result_type: void
			v_panic(err);
		};
		// FOR IN array
		array tmp4 = it->fields;
		for (int i = 0; i < tmp4.len; i++) {
			v__checker__Checker_expr(c, (*(v__ast__Expr*)array_get(it->exprs, i)));
		}
		it->typ = /*opt*/(*(v__ast__Var**)v.data)->typ;
		return /*opt*/(*(v__ast__Var**)v.data)->typ;
	}else if (node.typ == 201 /* v.ast.BoolLiteral */) {
		v__ast__BoolLiteral* it = (v__ast__BoolLiteral*)node.obj; // ST it
		return _const_v__table__bool_type;
	}else if (node.typ == 179 /* v.ast.CastExpr */) {
		v__ast__CastExpr* it = (v__ast__CastExpr*)node.obj; // ST it
		it->expr_type = v__checker__Checker_expr(c, it->expr);
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, it->expr_type);
		if (it->typ == _const_v__table__string_type && !((sym->kind == v__table__Kind_byte || sym->kind == v__table__Kind_byteptr) || sym->kind == v__table__Kind_array && string_eq(sym->name, tos3("array_byte")))) {
			string type_name = v__table__Table_type_to_str(c->table, it->expr_type);
			v__checker__Checker_error(c, _STR("cannot cast type `%.*s\000` to string, use `x.str()` instead", 2, type_name), it->pos);
		}
		if (it->has_arg) {
			v__checker__Checker_expr(c, it->arg);
		}
		it->typname = v__table__Table_get_type_symbol(c->table, it->typ)->name;
		return it->typ;
	}else if (node.typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* it = (v__ast__CallExpr*)node.obj; // ST it
		return v__checker__Checker_call_expr(c, it);
	}else if (node.typ == 202 /* v.ast.CharLiteral */) {
		v__ast__CharLiteral* it = (v__ast__CharLiteral*)node.obj; // ST it
		return _const_v__table__byte_type;
	}else if (node.typ == 180 /* v.ast.EnumVal */) {
		v__ast__EnumVal* it = (v__ast__EnumVal*)node.obj; // ST it
		return v__checker__Checker_enum_val(c, it);
	}else if (node.typ == 185 /* v.ast.FloatLiteral */) {
		v__ast__FloatLiteral* it = (v__ast__FloatLiteral*)node.obj; // ST it
		return _const_v__table__f64_type;
	}else if (node.typ == 136 /* v.ast.Ident */) {
		v__ast__Ident* it = (v__ast__Ident*)node.obj; // ST it
		v__table__Type res = v__checker__Checker_ident(c, it);
		return res;
	}else if (node.typ == 154 /* v.ast.IfExpr */) {
		v__ast__IfExpr* it = (v__ast__IfExpr*)node.obj; // ST it
		return v__checker__Checker_if_expr(c, it);
	}else if (node.typ == 158 /* v.ast.IfGuardExpr */) {
		v__ast__IfGuardExpr* it = (v__ast__IfGuardExpr*)node.obj; // ST it
		it->expr_type = v__checker__Checker_expr(c, it->expr);
		return _const_v__table__bool_type;
	}else if (node.typ == 135 /* v.ast.IndexExpr */) {
		v__ast__IndexExpr* it = (v__ast__IndexExpr*)node.obj; // ST it
		return v__checker__Checker_index_expr(c, it);
	}else if (node.typ == 208 /* v.ast.InfixExpr */) {
		v__ast__InfixExpr* it = (v__ast__InfixExpr*)node.obj; // ST it
		return v__checker__Checker_infix_expr(c, it);
	}else if (node.typ == 186 /* v.ast.IntegerLiteral */) {
		v__ast__IntegerLiteral* it = (v__ast__IntegerLiteral*)node.obj; // ST it
		return _const_v__table__int_type;
	}else if (node.typ == 143 /* v.ast.MapInit */) {
		v__ast__MapInit* it = (v__ast__MapInit*)node.obj; // ST it
		return v__checker__Checker_map_init(c, it);
	}else if (node.typ == 159 /* v.ast.MatchExpr */) {
		v__ast__MatchExpr* it = (v__ast__MatchExpr*)node.obj; // ST it
		return v__checker__Checker_match_expr(c, it);
	}else if (node.typ == 209 /* v.ast.PostfixExpr */) {
		v__ast__PostfixExpr* it = (v__ast__PostfixExpr*)node.obj; // ST it
		return v__checker__Checker_postfix_expr(c, */*d*/it);
	}else if (node.typ == 210 /* v.ast.PrefixExpr */) {
		v__ast__PrefixExpr* it = (v__ast__PrefixExpr*)node.obj; // ST it
		v__table__Type right_type = v__checker__Checker_expr(c, it->right);
		if (it->op == v__token__Kind_amp && !v__table__Type_is_ptr(right_type)) {
			return v__table__Type_to_ptr(right_type);
		}
		if (it->op == v__token__Kind_mul && v__table__Type_is_ptr(right_type)) {
			return v__table__Type_deref(right_type);
		}
		if (it->op == v__token__Kind_not && right_type != _const_v__table__bool_type_idx) {
			v__checker__Checker_error(c, tos3("! operator can only be used with bool types"), it->pos);
		}
		return right_type;
	}else if (node.typ == 204 /* v.ast.None */) {
		v__ast__None* it = (v__ast__None*)node.obj; // ST it
		return _const_v__table__none_type;
	}else if (node.typ == 203 /* v.ast.ParExpr */) {
		v__ast__ParExpr* it = (v__ast__ParExpr*)node.obj; // ST it
		return v__checker__Checker_expr(c, it->expr);
	}else if (node.typ == 182 /* v.ast.SelectorExpr */) {
		v__ast__SelectorExpr* it = (v__ast__SelectorExpr*)node.obj; // ST it
		return v__checker__Checker_selector_expr(c, it);
	}else if (node.typ == 205 /* v.ast.SizeOf */) {
		v__ast__SizeOf* it = (v__ast__SizeOf*)node.obj; // ST it
		return _const_v__table__int_type;
	}else if (node.typ == 183 /* v.ast.StringLiteral */) {
		v__ast__StringLiteral* it = (v__ast__StringLiteral*)node.obj; // ST it
		if (it->is_c) {
			return _const_v__table__byteptr_type;
		}
		return _const_v__table__string_type;
	}else if (node.typ == 184 /* v.ast.StringInterLiteral */) {
		v__ast__StringInterLiteral* it = (v__ast__StringInterLiteral*)node.obj; // ST it
		// FOR IN array
		array tmp11 = it->exprs;
		for (int tmp12 = 0; tmp12 < tmp11.len; tmp12++) {
			v__ast__Expr expr = ((v__ast__Expr*)tmp11.data)[tmp12];
			array_push(&it->expr_types, &(v__table__Type[]){ v__checker__Checker_expr(c, expr) });
		}
		return _const_v__table__string_type;
	}else if (node.typ == 214 /* v.ast.StructInit */) {
		v__ast__StructInit* it = (v__ast__StructInit*)node.obj; // ST it
		return v__checker__Checker_struct_init(c, it);
	}else if (node.typ == 162 /* v.ast.Type */) {
		v__ast__Type* it = (v__ast__Type*)node.obj; // ST it
		return it->typ;
	}else if (node.typ == 206 /* v.ast.TypeOf */) {
		v__ast__TypeOf* it = (v__ast__TypeOf*)node.obj; // ST it
		it->expr_type = v__checker__Checker_expr(c, it->expr);
		return _const_v__table__string_type;
	}else if (node.typ == 149 /* v.ast.AnonFn */) {
		v__ast__AnonFn* it = (v__ast__AnonFn*)node.obj; // ST it
		v__table__Type keep_ret_type = c->fn_return_type;
		c->fn_return_type = it->decl.return_type;
		v__checker__Checker_stmts(c, it->decl.stmts);
		c->fn_return_type = keep_ret_type;
		return it->typ;
	}else {
		string tnode = tos3( /* v.ast.Expr */ v_typeof_sumtype_133( (node).typ ));
		if (string_ne(tnode, tos3("unknown v.ast.Expr"))) {
			println(_STR("checker.expr(): unhandled node with typeof(`%.*s\000`)", 2, tnode));
		}
	};
	return _const_v__table__void_type;
}

v__table__Type v__checker__Checker_ident(v__checker__Checker* c, v__ast__Ident* ident) {
	if (string_eq(ident->name, c->var_decl_name)) {
		v__checker__Checker_error(c, _STR("unresolved: `%.*s\000`", 2, ident->name), ident->pos);
		return _const_v__table__void_type;
	}
	if (c->const_deps.len > 0) {
		string name = ident->name;
		if (!string_contains(name, tos3(".")) && !(string_eq(ident->mod, tos3("builtin")) || string_eq(ident->mod, tos3("main")))) {
			name = _STR("%.*s\000.%.*s", 2, ident->mod, ident->name);
		}
		if (string_eq(name, c->const_decl)) {
			v__checker__Checker_error(c, _STR("cycle in constant `%.*s\000`", 2, c->const_decl), ident->pos);
			return _const_v__table__void_type;
		}
		array_push(&c->const_deps, &(string[]){ name });
	}
	if (ident->kind == v__ast__IdentKind_blank_ident) {
		return _const_v__table__void_type;
	}
	if (ident->kind == v__ast__IdentKind_variable) {
		v__ast__IdentVar* info = /* as */ (v__ast__IdentVar*)__as_cast(ident->info.obj, ident->info.typ, /*expected:*/138);
		return info->typ;
	} else if (ident->kind == v__ast__IdentKind_constant) {
		v__ast__IdentVar* info = /* as */ (v__ast__IdentVar*)__as_cast(ident->info.obj, ident->info.typ, /*expected:*/138);
		return info->typ;
	} else if (ident->kind == v__ast__IdentKind_function) {
		v__ast__IdentFn* info = /* as */ (v__ast__IdentFn*)__as_cast(ident->info.obj, ident->info.typ, /*expected:*/221);
		return info->typ;
	} else if (ident->kind == v__ast__IdentKind_unresolved) {
		string name = ident->name;
		if (!string_contains(name, tos3(".")) && !(string_eq(ident->mod, tos3("builtin")) || string_eq(ident->mod, tos3("main")))) {
			name = _STR("%.*s\000.%.*s", 2, ident->mod, ident->name);
		}
		v__ast__Scope* start_scope = v__ast__Scope_innermost(c->file.scope, ident->pos.pos);
		bool tmp9;
		{ /* if guard */ Option_v__ast__ScopeObject obj = v__ast__Scope_find(start_scope, ident->name);
		if ((tmp9 = obj.ok)) {
			if (/*opt*/(*(v__ast__ScopeObject*)obj.data).typ == 131 /* v.ast.Var */) {
				v__ast__Var* it = (v__ast__Var*)/*opt*/(*(v__ast__ScopeObject*)obj.data).obj; // ST it
				v__table__Type typ = it->typ;
				if (typ == 0) {
					typ = v__checker__Checker_expr(c, it->expr);
				}
				v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(c->table, typ);
				if (sym->info.typ == 83 /* v.table.FnType */) {
					v__table__FnType* info = /* as */ (v__table__FnType*)__as_cast(sym->info.obj, sym->info.typ, /*expected:*/83);
					v__table__Type fn_type = v__table__new_type(v__table__Table_find_or_register_fn_type(c->table, info->func, true, true));
					ident->kind = v__ast__IdentKind_function;
					ident->info = /* sum type cast */ (v__ast__IdentInfo) {.obj = memdup(&(v__ast__IdentFn[]) {(v__ast__IdentFn){
						.typ = fn_type,
					}}, sizeof(v__ast__IdentFn)), .typ = 221 /* v.ast.IdentFn */};
					return fn_type;
				} else {
					bool is_optional = v__table__Type_flag_is(typ, v__table__TypeFlag_optional);
					ident->kind = v__ast__IdentKind_variable;
					ident->info = /* sum type cast */ (v__ast__IdentInfo) {.obj = memdup(&(v__ast__IdentVar[]) {(v__ast__IdentVar){
						.typ = typ,
						.is_optional = is_optional,
						.is_mut = 0,
						.is_static = 0,
					}}, sizeof(v__ast__IdentVar)), .typ = 138 /* v.ast.IdentVar */};
					it->typ = typ;
					if (is_optional) {
						return v__table__Type_set_flag(typ, v__table__TypeFlag_unset);
					}
					return typ;
				}
			}else {
			};
		}}
		bool tmp14;
		{ /* if guard */ Option_v__ast__ScopeObject obj = v__ast__Scope_find(c->file.global_scope, name);
		if ((tmp14 = obj.ok)) {
			if (/*opt*/(*(v__ast__ScopeObject*)obj.data).typ == 192 /* v.ast.GlobalDecl */) {
				v__ast__GlobalDecl* it = (v__ast__GlobalDecl*)/*opt*/(*(v__ast__ScopeObject*)obj.data).obj; // ST it
				ident->kind = v__ast__IdentKind_global;
				ident->info = /* sum type cast */ (v__ast__IdentInfo) {.obj = memdup(&(v__ast__IdentVar[]) {(v__ast__IdentVar){
					.typ = it->typ,
					.is_mut = 0,
					.is_static = 0,
					.is_optional = 0,
				}}, sizeof(v__ast__IdentVar)), .typ = 138 /* v.ast.IdentVar */};
				return it->typ;
			}else if (/*opt*/(*(v__ast__ScopeObject*)obj.data).typ == 189 /* v.ast.ConstField */) {
				v__ast__ConstField* it = (v__ast__ConstField*)/*opt*/(*(v__ast__ScopeObject*)obj.data).obj; // ST it
				v__table__Type typ = it->typ;
				if (typ == 0) {
					typ = v__checker__Checker_expr(c, it->expr);
				}
				ident->name = name;
				ident->kind = v__ast__IdentKind_constant;
				ident->info = /* sum type cast */ (v__ast__IdentInfo) {.obj = memdup(&(v__ast__IdentVar[]) {(v__ast__IdentVar){
					.typ = typ,
					.is_mut = 0,
					.is_static = 0,
					.is_optional = 0,
				}}, sizeof(v__ast__IdentVar)), .typ = 138 /* v.ast.IdentVar */};
				it->typ = typ;
				return typ;
			}else {
			};
		}}
		bool tmp17;
		{ /* if guard */ Option_v__table__Fn func = v__table__Table_find_fn(c->table, name);
		if ((tmp17 = func.ok)) {
			v__table__Type fn_type = v__table__new_type(v__table__Table_find_or_register_fn_type(c->table, /*opt*/(*(v__table__Fn*)func.data), false, true));
			ident->name = name;
			ident->kind = v__ast__IdentKind_function;
			ident->info = /* sum type cast */ (v__ast__IdentInfo) {.obj = memdup(&(v__ast__IdentFn[]) {(v__ast__IdentFn){
				.typ = fn_type,
			}}, sizeof(v__ast__IdentFn)), .typ = 221 /* v.ast.IdentFn */};
			return fn_type;
		}}
	}
	if (ident->is_c) {
		return _const_v__table__int_type;
	}
	if (string_ne(ident->name, tos3("_"))) {
		v__checker__Checker_error(c, _STR("undefined: `%.*s\000`", 2, ident->name), ident->pos);
	}
	if (v__table__Table_known_type(c->table, ident->name)) {
		return _const_v__table__void_type;
	}
	return _const_v__table__void_type;
}

v__table__Type v__checker__Checker_match_expr(v__checker__Checker* c, v__ast__MatchExpr* node) {
	node->is_expr = c->expected_type != _const_v__table__void_type;
	node->expected_type = c->expected_type;
	v__table__Type cond_type = v__checker__Checker_expr(c, node->cond);
	if (cond_type == 0) {
		v__checker__Checker_error(c, tos3("match 0 cond type"), node->pos);
	}
	v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(c->table, cond_type);
	if (type_sym->kind != v__table__Kind_sum_type) {
		node->is_sum_type = false;
	}
	v__checker__Checker_match_exprs(c, node, */*d*/type_sym);
	c->expected_type = cond_type;
	v__table__Type ret_type = _const_v__table__void_type;
	// FOR IN array
	array tmp3 = node->branches;
	for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)tmp3.data)[tmp4];
		// FOR IN array
		array tmp5 = branch.exprs;
		for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
			v__ast__Expr expr = ((v__ast__Expr*)tmp5.data)[tmp6];
			c->expected_type = cond_type;
			v__table__Type typ = v__checker__Checker_expr(c, expr);
			v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
			if (!node->is_sum_type && !v__table__Table_check(c->table, typ, cond_type)) {
				v__table__TypeSymbol* exp_sym = v__table__Table_get_type_symbol(c->table, cond_type);
				v__checker__Checker_error(c, _STR("cannot use `%.*s\000` as `%.*s\000` in `match`", 3, typ_sym->name, exp_sym->name), node->pos);
			}
			if (typ_sym->kind == v__table__Kind_sum_type) {
			}
		}
		v__checker__Checker_stmts(c, branch.stmts);
		if (branch.stmts.len > 0) {
			if ((*(v__ast__Stmt*)array_get(branch.stmts, branch.stmts.len - 1)).typ == 177 /* v.ast.ExprStmt */) {
				v__ast__ExprStmt* it = (v__ast__ExprStmt*)(*(v__ast__Stmt*)array_get(branch.stmts, branch.stmts.len - 1)).obj; // ST it
				ret_type = v__checker__Checker_expr(c, it->expr);
			}else {
			};
		}
	}
	node->return_type = ret_type;
	node->cond_type = cond_type;
	return ret_type;
}

static void v__checker__Checker_match_exprs(v__checker__Checker* c, v__ast__MatchExpr* node, v__table__TypeSymbol type_sym) {
	map_string_int branch_exprs = new_map_1(sizeof(int));
	// FOR IN array
	array tmp1 = node->branches;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)tmp1.data)[tmp2];
		// FOR IN array
		array tmp3 = branch.exprs;
		for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
			v__ast__Expr expr = ((v__ast__Expr*)tmp3.data)[tmp4];
			string key = tos3("");
			if (expr.typ == 162 /* v.ast.Type */) {
				v__ast__Type* it = (v__ast__Type*)expr.obj; // ST it
				key = v__table__Table_type_to_str(c->table, it->typ);
			}else if (expr.typ == 180 /* v.ast.EnumVal */) {
				v__ast__EnumVal* it = (v__ast__EnumVal*)expr.obj; // ST it
				key = it->val;
			}else {
				key = v__ast__Expr_str(expr);
			};
			int val = (_IN_MAP(key, branch_exprs) ?  ( (*(int*)map_get3(branch_exprs, key, &(int[]){ 0 })) )  :  ( 0 ) );
			if (val == 1) {
				v__checker__Checker_error(c, _STR("match case `%.*s\000` is handled more than once", 2, key), branch.pos);
			}
			map_set(&branch_exprs, key, &(int[]) { val + 1 });
		}
	}
	bool is_exhaustive = true;
	array_string unhandled = __new_array(0, 0, sizeof(string));
	if (type_sym.info.typ == 88 /* v.table.SumType */) {
		v__table__SumType* it = (v__table__SumType*)type_sym.info.obj; // ST it
		// FOR IN array
		array tmp9 = it->variants;
		for (int tmp10 = 0; tmp10 < tmp9.len; tmp10++) {
			v__table__Type v = ((v__table__Type*)tmp9.data)[tmp10];
			string v_str = v__table__Table_type_to_str(c->table, v);
			if (!_IN_MAP(v_str, branch_exprs)) {
				is_exhaustive = false;
				array_push(&unhandled, &(string[]){ _STR("`%.*s\000`", 2, v_str) });
			}
		}
	}else if (type_sym.info.typ == 82 /* v.table.Enum */) {
		v__table__Enum* it = (v__table__Enum*)type_sym.info.obj; // ST it
		// FOR IN array
		array tmp13 = it->vals;
		for (int tmp14 = 0; tmp14 < tmp13.len; tmp14++) {
			string v = ((string*)tmp13.data)[tmp14];
			if (!_IN_MAP(v, branch_exprs)) {
				is_exhaustive = false;
				array_push(&unhandled, &(string[]){ _STR("`.%.*s\000`", 2, v) });
			}
		}
	}else {
		is_exhaustive = false;
	};
	v__ast__MatchBranch else_branch = (*(v__ast__MatchBranch*)array_get(node->branches, node->branches.len - 1));
	bool has_else = else_branch.is_else;
	if (!has_else) {
		// FOR IN array
		array tmp18 = node->branches;
		for (int i = 0; i < tmp18.len; i++) {
			v__ast__MatchBranch branch = ((v__ast__MatchBranch*)tmp18.data)[i];
			if (branch.is_else && i != node->branches.len - 1) {
				v__checker__Checker_error(c, tos3("`else` must be the last branch of `match`"), branch.pos);
				else_branch = branch;
				has_else = true;
			}
		}
	}
	if (is_exhaustive) {
		if (has_else) {
			v__checker__Checker_error(c, tos3("match expression is exhaustive, `else` is unnecessary"), else_branch.pos);
		}
		return ;
	}
	if (has_else) {
		return ;
	}
	string err_details = tos3("match must be exhaustive");
	if (unhandled.len > 0) {
		err_details = string_add(err_details, string_add(string_add(tos3(" (add match branches for: "), array_string_join(unhandled, tos3(", "))), tos3(" or `else {}` at the end)")));
	} else {
		err_details = string_add(err_details, tos3(" (add `else {}` at the end)"));
	}
	v__checker__Checker_error(c, err_details, node->pos);
}

v__table__Type v__checker__Checker_if_expr(v__checker__Checker* c, v__ast__IfExpr* node) {
	if (c->expected_type != _const_v__table__void_type) {
		node->is_expr = true;
	}
	node->typ = _const_v__table__void_type;
	int first_typ = 0;
	bool is_ternary = node->is_expr && node->branches.len >= 2 && node->has_else;
	// FOR IN array
	array tmp2 = node->branches;
	for (int i = 0; i < tmp2.len; i++) {
		v__ast__IfBranch branch = ((v__ast__IfBranch*)tmp2.data)[i];
		if (branch.cond.typ == 203 /* v.ast.ParExpr */) {
			v__checker__Checker_error(c, tos3("unnecessary `()` in an if condition. use `if expr {` instead of `if (expr) {`."), branch.pos);
		}
		v__table__Type typ = v__checker__Checker_expr(c, branch.cond);
		if (i < node->branches.len - 1 || !node->has_else) {
			v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
			if (v__table__Type_idx(typ) != _const_v__table__bool_type_idx) {
				v__checker__Checker_error(c, _STR("non-bool (`%.*s\000`) used as if condition", 2, typ_sym->name), node->pos);
			}
		}
		if (is_ternary && i < node->branches.len - 1 && branch.stmts.len > 0) {
			v__ast__Stmt last_stmt = (*(v__ast__Stmt*)array_get(branch.stmts, branch.stmts.len - 1));
			if (last_stmt.typ == 177 /* v.ast.ExprStmt */) {
				v__ast__ExprStmt* last_expr = /* as */ (v__ast__ExprStmt*)__as_cast(last_stmt.obj, last_stmt.typ, /*expected:*/177);
				first_typ = v__checker__Checker_expr(c, last_expr->expr);
			}
		}
		v__checker__Checker_stmts(c, branch.stmts);
	}
	if (node->has_else && node->is_expr) {
		v__ast__IfBranch last_branch = (*(v__ast__IfBranch*)array_get(node->branches, node->branches.len - 1));
		if (last_branch.stmts.len > 0) {
			if ((*(v__ast__Stmt*)array_get(last_branch.stmts, last_branch.stmts.len - 1)).typ == 177 /* v.ast.ExprStmt */) {
				v__ast__ExprStmt* it = (v__ast__ExprStmt*)(*(v__ast__Stmt*)array_get(last_branch.stmts, last_branch.stmts.len - 1)).obj; // ST it
				v__table__Type t = v__checker__Checker_expr(c, it->expr);
				if (is_ternary && t != first_typ) {
					v__checker__Checker_error(c, _STR("mismatched types `%.*s\000` and `%.*s\000`", 3, v__table__Table_type_to_str(c->table, first_typ), v__table__Table_type_to_str(c->table, t)), node->pos);
				}
				node->typ = t;
				return t;
			}else {
			};
		}
	}
	return _const_v__table__bool_type;
}

v__table__Type v__checker__Checker_postfix_expr(v__checker__Checker* c, v__ast__PostfixExpr node) {
	v__table__Type typ = v__checker__Checker_expr(c, node.expr);
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
	if (!v__table__TypeSymbol_is_number(typ_sym)) {
		println(v__table__Kind_str(typ_sym->kind));
		v__checker__Checker_error(c, _STR("invalid operation: %.*s\000 (non-numeric type `%.*s\000`)", 3, v__token__Kind_str(node.op), typ_sym->name), node.pos);
	} else {
		v__checker__Checker_fail_if_immutable(c, node.expr);
	}
	return typ;
}

v__table__Type v__checker__Checker_index_expr(v__checker__Checker* c, v__ast__IndexExpr* node) {
	v__table__Type typ = v__checker__Checker_expr(c, node->left);
	node->left_type = typ;
	bool is_range = false;
	if (node->index.typ == 181 /* v.ast.RangeExpr */) {
		v__ast__RangeExpr* it = (v__ast__RangeExpr*)node->index.obj; // ST it
		is_range = true;
		if (it->has_low) {
			v__checker__Checker_expr(c, it->low);
		}
		if (it->has_high) {
			v__checker__Checker_expr(c, it->high);
		}
	}else {
	};
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
	if (!is_range) {
		v__table__Type index_type = v__checker__Checker_expr(c, node->index);
		v__table__TypeSymbol* index_type_sym = v__table__Table_get_type_symbol(c->table, index_type);
		if ((typ_sym->kind == v__table__Kind_array || typ_sym->kind == v__table__Kind_array_fixed) && !(v__table__Type_is_number(index_type) || index_type_sym->kind == v__table__Kind_enum_)) {
			v__checker__Checker_error(c, _STR("non-integer index `%.*s\000` (array type `%.*s\000`)", 3, index_type_sym->name, typ_sym->name), node->pos);
		} else if (typ_sym->kind == v__table__Kind_map && v__table__Type_idx(index_type) != _const_v__table__string_type_idx) {
			v__checker__Checker_error(c, _STR("non-string map index (map type `%.*s\000`)", 2, typ_sym->name), node->pos);
		}
		v__table__Type value_type = v__table__Table_value_type(c->table, typ);
		if (value_type != _const_v__table__void_type) {
			return value_type;
		}
	} else if (is_range) {
		if (typ_sym->kind == v__table__Kind_array_fixed) {
			v__table__Type elem_type = v__table__Table_value_type(c->table, typ);
			int idx = v__table__Table_find_or_register_array(c->table, elem_type, 1);
			return v__table__new_type(idx);
		}
	}
	return typ;
}

v__table__Type v__checker__Checker_enum_val(v__checker__Checker* c, v__ast__EnumVal* node) {
	int typ_idx = (string_eq(node->enum_name, tos3("")) ?  ( v__table__Type_idx(c->expected_type) )  :  ( v__table__Table_find_type_idx(c->table, node->enum_name) ) );
	if (typ_idx == 0) {
		v__checker__Checker_error(c, _STR("not an enum (name=%.*s\000) (type_idx=0)", 2, node->enum_name), node->pos);
	}
	v__table__Type typ = v__table__new_type(typ_idx);
	if (typ == _const_v__table__void_type) {
		v__checker__Checker_error(c, tos3("not an enum"), node->pos);
	}
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(c->table, typ);
	if (typ_sym->kind != v__table__Kind_enum_) {
		v__checker__Checker_error(c, tos3("not an enum"), node->pos);
	}
	v__table__Enum info = v__table__TypeSymbol_enum_info(typ_sym);
	if (!_IN(string, node->val, info.vals)) {
		v__checker__Checker_error(c, _STR("enum `%.*s\000` does not have a value `%.*s\000`", 3, typ_sym->name, node->val), node->pos);
	}
	node->typ = typ;
	return typ;
}

v__table__Type v__checker__Checker_map_init(v__checker__Checker* c, v__ast__MapInit* node) {
	if (node->typ != 0) {
		v__table__Map info = v__table__TypeSymbol_map_info(v__table__Table_get_type_symbol(c->table, node->typ));
		node->key_type = info.key_type;
		node->value_type = info.value_type;
		return node->typ;
	}
	v__table__Type key0_type = v__checker__Checker_expr(c, (*(v__ast__Expr*)array_get(node->keys, 0)));
	v__table__Type val0_type = v__checker__Checker_expr(c, (*(v__ast__Expr*)array_get(node->vals, 0)));
	// FOR IN array
	array tmp2 = node->keys;
	for (int i = 0; i < tmp2.len; i++) {
		v__ast__Expr key = ((v__ast__Expr*)tmp2.data)[i];
		if (i == 0) {
			continue;
		}
		v__ast__Expr val = (*(v__ast__Expr*)array_get(node->vals, i));
		v__table__Type key_type = v__checker__Checker_expr(c, key);
		v__table__Type val_type = v__checker__Checker_expr(c, val);
		if (!v__table__Table_check(c->table, key_type, key0_type)) {
			v__table__TypeSymbol* key0_type_sym = v__table__Table_get_type_symbol(c->table, key0_type);
			v__table__TypeSymbol* key_type_sym = v__table__Table_get_type_symbol(c->table, key_type);
			v__checker__Checker_error(c, _STR("map init: cannot use `%.*s\000` as `%.*s\000` for map key", 3, key_type_sym->name, key0_type_sym->name), node->pos);
		}
		if (!v__table__Table_check(c->table, val_type, val0_type)) {
			v__table__TypeSymbol* val0_type_sym = v__table__Table_get_type_symbol(c->table, val0_type);
			v__table__TypeSymbol* val_type_sym = v__table__Table_get_type_symbol(c->table, val_type);
			v__checker__Checker_error(c, _STR("map init: cannot use `%.*s\000` as `%.*s\000` for map value", 3, val_type_sym->name, val0_type_sym->name), node->pos);
		}
	}
	v__table__Type map_type = v__table__new_type(v__table__Table_find_or_register_map(c->table, key0_type, val0_type));
	node->typ = map_type;
	node->key_type = key0_type;
	node->value_type = val0_type;
	return map_type;
}

void v__checker__Checker_warn(v__checker__Checker* c, string s, v__token__Position pos) {
	bool allow_warnings = !c->pref->is_prod;
	v__checker__Checker_warn_or_error(c, s, pos, allow_warnings);
}

void v__checker__Checker_error(v__checker__Checker* c, string message, v__token__Position pos) {
	if (c->pref->is_verbose) {
		print_backtrace();
	}
	v__checker__Checker_warn_or_error(c, message, pos, false);
}

static void v__checker__Checker_warn_or_error(v__checker__Checker* c, string message, v__token__Position pos, bool warn) {
	if (warn) {
		c->nr_warnings++;
		array_push(&c->warnings, &(v__errors__Warning[]){ (v__errors__Warning){
			.reporter = v__errors__Reporter_checker,
			.pos = pos,
			.file_path = c->file.path,
			.message = message,
		} });
	} else {
		c->nr_errors++;
		if (!_IN(int, pos.line_nr, c->error_lines)) {
			array_push(&c->errors, &(v__errors__Error[]){ (v__errors__Error){
				.reporter = v__errors__Reporter_checker,
				.pos = pos,
				.file_path = c->file.path,
				.message = message,
				.backtrace = (string){.str=""},
			} });
			array_push(&c->error_lines, &(int[]){ pos.line_nr });
		}
	}
}

static bool v__checker__Checker_fileis(v__checker__Checker* c, string s) {
	return string_contains(c->file.path, s);
}

static void v__gen__foo(v__token__Token t) {
	v__util__full_hash();
}

string v__gen__cgen(array_v__ast__File files, v__table__Table* table, v__pref__Preferences* pref) {
	v__gen__Gen g = (v__gen__Gen){
		.out = strings__new_builder(1000),
		.cheaders = strings__new_builder(8192),
		.includes = strings__new_builder(100),
		.typedefs = strings__new_builder(100),
		.typedefs2 = strings__new_builder(100),
		.definitions = strings__new_builder(100),
		.gowrappers = strings__new_builder(100),
		.stringliterals = strings__new_builder(100),
		.auto_str_funcs = strings__new_builder(100),
		.comptime_defines = strings__new_builder(100),
		.inits = strings__new_builder(100),
		.pcs_declarations = strings__new_builder(100),
		.hotcode_definitions = strings__new_builder(100),
		.table = table,
		.pref = pref,
		.fn_decl = 0,
		.fn_main = 0,
		.autofree = true,
		.indent = -1,
		.module_built = string_after(pref->path, tos3("vlib/")),
		.file = {0},
		.last_fn_c_name = (string){.str=""},
		.tmp_count = 0,
		.variadic_args = new_map_1(sizeof(int)),
		.is_c_call = 0,
		.is_assign_lhs = 0,
		.is_assign_rhs = 0,
		.is_array_set = 0,
		.is_amp = 0,
		.optionals = __new_array(0, 1, sizeof(string)),
		.inside_ternary = 0,
		.stmt_start_pos = 0,
		.right_is_opt = 0,
		.empty_line = 0,
		.is_test = 0,
		.assign_op = {0},
		.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),
		.defer_ifdef = (string){.str=""},
		.defer_profile_code = (string){.str=""},
		.str_types = __new_array(0, 1, sizeof(string)),
		.threaded_fns = __new_array(0, 1, sizeof(string)),
		.array_fn_definitions = __new_array(0, 1, sizeof(string)),
		.is_json_fn = 0,
		.json_types = __new_array(0, 1, sizeof(string)),
		.pcs = __new_array(0, 1, sizeof(v__gen__ProfileCounterMeta)),
		.attr = (string){.str=""},
		.is_builtin_mod = 0,
		.hotcode_fn_names = __new_array(0, 1, sizeof(string)),
	};
	v__gen__Gen_init(&g);
	bool tests_inited = false;
	bool autofree_used = false;
	// FOR IN array
	array tmp1 = files;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__File file = ((v__ast__File*)tmp1.data)[tmp2];
		g.file = file;
		bool is_test = string_ends_with(g.file.path, tos3(".vv")) || string_ends_with(g.file.path, tos3("_test.v"));
		if (string_ends_with(g.file.path, tos3("_test.v"))) {
			g.is_test = is_test;
		}
		if (string_eq(g.file.path, tos3("")) || is_test || !g.pref->autofree) {
			g.autofree = false;
		} else {
			g.autofree = true;
			autofree_used = true;
		}
		if (g.is_test && !tests_inited) {
			v__gen__Gen_write_tests_main(&g);
			tests_inited = true;
		}
		v__gen__Gen_stmts(&g, file.stmts);
	}
	if (autofree_used) {
		g.autofree = true;
	}
	v__gen__Gen_write_variadic_types(&g);
	if (g.pref->build_mode != v__pref__BuildMode_build_module) {
		v__gen__Gen_write_init_function(&g);
	}
	v__gen__Gen_finish(&g);
	strings__Builder b = strings__new_builder(250000);
	strings__Builder_writeln(&b, v__gen__Gen_hashes(g));
	strings__Builder_writeln(&b, strings__Builder_str(&g.comptime_defines));
	strings__Builder_writeln(&b, tos3("\n// V typedefs:"));
	strings__Builder_writeln(&b, strings__Builder_str(&g.typedefs));
	strings__Builder_writeln(&b, tos3("\n// V typedefs2:"));
	strings__Builder_writeln(&b, strings__Builder_str(&g.typedefs2));
	strings__Builder_writeln(&b, tos3("\n// V cheaders:"));
	strings__Builder_writeln(&b, strings__Builder_str(&g.cheaders));
	strings__Builder_writeln(&b, tos3("\n// V includes:"));
	strings__Builder_writeln(&b, strings__Builder_str(&g.includes));
	strings__Builder_writeln(&b, tos3("\n// V definitions:"));
	strings__Builder_writeln(&b, strings__Builder_str(&g.definitions));
	strings__Builder_writeln(&b, tos3("\n// V profile counters:"));
	strings__Builder_writeln(&b, strings__Builder_str(&g.pcs_declarations));
	strings__Builder_writeln(&b, tos3("\n// V interface table:"));
	strings__Builder_writeln(&b, v__gen__Gen_interface_table(&g));
	strings__Builder_writeln(&b, tos3("\n// V gowrappers:"));
	strings__Builder_writeln(&b, strings__Builder_str(&g.gowrappers));
	strings__Builder_writeln(&b, tos3("\n// V hotcode definitions:"));
	strings__Builder_writeln(&b, strings__Builder_str(&g.hotcode_definitions));
	strings__Builder_writeln(&b, tos3("\n// V stringliterals:"));
	strings__Builder_writeln(&b, strings__Builder_str(&g.stringliterals));
	strings__Builder_writeln(&b, tos3("\n// V auto str functions:"));
	strings__Builder_writeln(&b, strings__Builder_str(&g.auto_str_funcs));
	strings__Builder_writeln(&b, tos3("\n// V out"));
	strings__Builder_writeln(&b, strings__Builder_str(&g.out));
	strings__Builder_writeln(&b, tos3("\n// THE END."));
	return strings__Builder_str(&b);
}

string v__gen__Gen_hashes(v__gen__Gen g) {
	string res = string_replace(_const_v__gen__c_commit_hash_default, tos3("@@@"), v__util__vhash());
	res = string_add(res, string_replace(_const_v__gen__c_current_commit_hash_default, tos3("@@@"), v__util__githash(g.pref->building_v)));
	return res;
}

void v__gen__Gen_init(v__gen__Gen* g) {
	strings__Builder_writeln(&g->cheaders, tos3("// Generated by the V compiler"));
	strings__Builder_writeln(&g->cheaders, tos3("#include <inttypes.h>"));
	strings__Builder_writeln(&g->cheaders, _const_v__gen__c_builtin_types);
	strings__Builder_writeln(&g->cheaders, _const_v__gen__c_headers);
	strings__Builder_writeln(&g->definitions, tos3("\nvoid _STR_PRINT_ARG(const char*, char**, int*, int*, int, ...);\n"));
	strings__Builder_writeln(&g->definitions, tos3("\nstring _STR(const char*, int, ...);\n"));
	strings__Builder_writeln(&g->definitions, tos3("\nstring _STR_TMP(const char*, ...);\n"));
	v__gen__Gen_write_builtin_types(g);
	v__gen__Gen_write_typedef_types(g);
	v__gen__Gen_write_typeof_functions(g);
	if (g->pref->build_mode != v__pref__BuildMode_build_module) {
		v__gen__Gen_write_str_fn_definitions(g);
	}
	v__gen__Gen_write_sorted_types(g);
	v__gen__Gen_write_multi_return_types(g);
	strings__Builder_writeln(&g->definitions, tos3("// end of definitions #endif"));
	strings__Builder_writeln(&g->stringliterals, tos3(""));
	strings__Builder_writeln(&g->stringliterals, tos3("// >> string literal consts"));
	if (g->pref->build_mode != v__pref__BuildMode_build_module) {
		strings__Builder_writeln(&g->stringliterals, tos3("void vinit_string_literals(){"));
	}
	if (g->pref->compile_defines_all.len > 0) {
		strings__Builder_writeln(&g->comptime_defines, tos3("// V compile time defines by -d or -define flags:"));
		strings__Builder_writeln(&g->comptime_defines, string_add(tos3("//     All custom defines      : "), array_string_join(g->pref->compile_defines_all, tos3(","))));
		strings__Builder_writeln(&g->comptime_defines, string_add(tos3("//     Turned ON custom defines: "), array_string_join(g->pref->compile_defines, tos3(","))));
		// FOR IN array
		array tmp4 = g->pref->compile_defines;
		for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
			string cdefine = ((string*)tmp4.data)[tmp5];
			strings__Builder_writeln(&g->comptime_defines, _STR("#define CUSTOM_DEFINE_%.*s", 1, cdefine));
		}
		strings__Builder_writeln(&g->comptime_defines, tos3(""));
	}
	if (g->pref->is_debug || _IN(string, tos3("debug"), g->pref->compile_defines)) {
		strings__Builder_writeln(&g->comptime_defines, tos3("#define _VDEBUG (1)"));
	}
	if (g->pref->is_livemain || g->pref->is_liveshared) {
		v__gen__Gen_generate_hotcode_reloading_declarations(g);
	}
}

void v__gen__Gen_finish(v__gen__Gen* g) {
	if (g->pref->build_mode != v__pref__BuildMode_build_module) {
		strings__Builder_writeln(&g->stringliterals, tos3("}"));
	}
	strings__Builder_writeln(&g->stringliterals, tos3("// << string literal consts"));
	strings__Builder_writeln(&g->stringliterals, tos3(""));
	if (g->pref->is_prof) {
		v__gen__Gen_gen_vprint_profile_stats(g);
	}
	if (g->pref->is_livemain || g->pref->is_liveshared) {
		v__gen__Gen_generate_hotcode_reloader_code(g);
	}
	if (g->fn_main != 0) {
		strings__Builder_writeln(&g->out, tos3(""));
		g->fn_decl = g->fn_main;
		v__gen__Gen_gen_fn_decl(g, */*d*/g->fn_main);
	}
}

void v__gen__Gen_write_typeof_functions(v__gen__Gen* g) {
	v__gen__Gen_writeln(g, tos3(""));
	v__gen__Gen_writeln(g, tos3("// >> typeof() support for sum types"));
	// FOR IN array
	array tmp1 = g->table->types;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__TypeSymbol typ = ((v__table__TypeSymbol*)tmp1.data)[tmp2];
		if (typ.kind == v__table__Kind_sum_type) {
			v__table__SumType* sum_info = /* as */ (v__table__SumType*)__as_cast(typ.info.obj, typ.info.typ, /*expected:*/88);
			int tidx = v__table__Table_find_type_idx(g->table, typ.name);
			v__gen__Gen_writeln(g, _STR("char * v_typeof_sumtype_%"PRId32"\000(int sidx) { /* %.*s\000 */ ", 3, tidx, typ.name));
			v__gen__Gen_writeln(g, tos3("	switch(sidx) {"));
			v__gen__Gen_writeln(g, _STR("		case %"PRId32"\000: return \"%.*s\000\";", 3, tidx, typ.name));
			// FOR IN array
			array tmp4 = sum_info->variants;
			for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
				v__table__Type v = ((v__table__Type*)tmp4.data)[tmp5];
				v__table__TypeSymbol* subtype = v__table__Table_get_type_symbol(g->table, v);
				v__gen__Gen_writeln(g, _STR("		case %"PRId32"\000: return \"%.*s\000\";", 3, v, subtype->name));
			}
			v__gen__Gen_writeln(g, _STR("		default: return \"unknown %.*s\000\";", 2, typ.name));
			v__gen__Gen_writeln(g, tos3("	}"));
			v__gen__Gen_writeln(g, tos3("}"));
		}
	}
	v__gen__Gen_writeln(g, tos3("// << typeof() support for sum types"));
	v__gen__Gen_writeln(g, tos3(""));
}

static string v__gen__Gen_typ(v__gen__Gen* g, v__table__Type t) {
	string styp = v__gen__Gen_base_type(g, t);
	if (v__table__Type_flag_is(t, v__table__TypeFlag_optional)) {
		styp = string_add(tos3("Option_"), styp);
		if (v__table__Type_is_ptr(t)) {
			styp = string_replace(styp, tos3("*"), tos3("_ptr"));
		}
		if (!_IN(string, styp, g->optionals)) {
			string x = styp;
			strings__Builder_writeln(&g->typedefs2, _STR("typedef Option %.*s\000;", 2, x));
			array_push(&g->optionals, &(string[]){ styp });
		}
	}
	return styp;
}

static string v__gen__Gen_base_type(v__gen__Gen* g, v__table__Type t) {
	string styp = v__gen__Gen_cc_type(g, t);
	int nr_muls = v__table__Type_nr_muls(t);
	if (nr_muls > 0) {
		styp = string_add(styp, strings__repeat('*', nr_muls));
	}
	return styp;
}

static string v__gen__Gen_cc_type(v__gen__Gen* g, v__table__Type t) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, t);
	string styp = string_replace(sym->name, tos3("."), tos3("__"));
	if (string_starts_with(styp, tos3("C__"))) {
		styp = string_substr(styp, 3, styp.len);
		if (sym->kind == v__table__Kind_struct_) {
			v__table__Struct* info = /* as */ (v__table__Struct*)__as_cast(sym->info.obj, sym->info.typ, /*expected:*/87);
			if (!info->is_typedef) {
				styp = _STR("struct %.*s", 1, styp);
			}
		}
	}
	return styp;
}

void v__gen__Gen_write_typedef_types(v__gen__Gen* g) {
	strings__Builder_writeln(&g->typedefs, tos3("\ntypedef struct {\n	void* _object;\n	int _interface_idx;\n} _Interface;\n"));
	// FOR IN array
	array tmp1 = g->table->types;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__TypeSymbol typ = ((v__table__TypeSymbol*)tmp1.data)[tmp2];
		if (typ.kind == v__table__Kind_alias) {
			v__table__TypeSymbol* parent = &(*(v__table__TypeSymbol*)array_get(g->table->types, typ.parent_idx));
			string styp = string_replace(typ.name, tos3("."), tos3("__"));
			string parent_styp = string_replace(parent->name, tos3("."), tos3("__"));
			strings__Builder_writeln(&g->definitions, _STR("typedef %.*s\000 %.*s\000;", 3, parent_styp, styp));
		}else if (typ.kind == v__table__Kind_array) {
			string styp = string_replace(typ.name, tos3("."), tos3("__"));
			strings__Builder_writeln(&g->definitions, _STR("typedef array %.*s\000;", 2, styp));
		}else if (typ.kind == v__table__Kind_interface_) {
			strings__Builder_writeln(&g->definitions, _STR("typedef _Interface %.*s\000;", 2, v__gen__c_name(typ.name)));
		}else if (typ.kind == v__table__Kind_map) {
			string styp = string_replace(typ.name, tos3("."), tos3("__"));
			strings__Builder_writeln(&g->definitions, _STR("typedef map %.*s\000;", 2, styp));
		}else if (typ.kind == v__table__Kind_function) {
			v__table__FnType* info = /* as */ (v__table__FnType*)__as_cast(typ.info.obj, typ.info.typ, /*expected:*/83);
			v__table__Fn func = info->func;
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, func.return_type);
			bool is_multi = sym->kind == v__table__Kind_multi_return;
			bool is_fn_sig = string_eq(func.name, tos3(""));
			bool not_anon = !info->is_anon;
			if (!info->has_decl && !is_multi && (not_anon || is_fn_sig)) {
				string fn_name = (func.is_c ?  ( string_replace(func.name, tos3("."), tos3("__")) )  : info->is_anon ?  ( typ.name )  :  ( v__gen__c_name(func.name) ) );
				strings__Builder_write(&g->definitions, _STR("typedef %.*s\000 (*%.*s\000)(", 3, v__gen__Gen_typ(g, func.return_type), fn_name));
				// FOR IN array
				array tmp6 = func.args;
				for (int i = 0; i < tmp6.len; i++) {
					v__table__Arg arg = ((v__table__Arg*)tmp6.data)[i];
					strings__Builder_write(&g->definitions, v__gen__Gen_typ(g, arg.typ));
					if (i < func.args.len - 1) {
						strings__Builder_write(&g->definitions, tos3(","));
					}
				}
				strings__Builder_writeln(&g->definitions, tos3(");"));
			}
		}else {
			continue;
		};
	}
}

void v__gen__Gen_write_multi_return_types(v__gen__Gen* g) {
	strings__Builder_writeln(&g->definitions, tos3("// multi return structs"));
	// FOR IN array
	array tmp1 = g->table->types;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__TypeSymbol typ = ((v__table__TypeSymbol*)tmp1.data)[tmp2];
		if (typ.kind != v__table__Kind_multi_return) {
			continue;
		}
		string name = string_replace(typ.name, tos3("."), tos3("__"));
		v__table__MultiReturn* info = /* as */ (v__table__MultiReturn*)__as_cast(typ.info.obj, typ.info.typ, /*expected:*/86);
		strings__Builder_writeln(&g->definitions, tos3("typedef struct {"));
		// FOR IN array
		array tmp4 = info->types;
		for (int i = 0; i < tmp4.len; i++) {
			v__table__Type mr_typ = ((v__table__Type*)tmp4.data)[i];
			string type_name = v__gen__Gen_typ(g, mr_typ);
			strings__Builder_writeln(&g->definitions, _STR("\t%.*s\000 arg%"PRId32"\000;", 3, type_name, i));
		}
		strings__Builder_writeln(&g->definitions, _STR("} %.*s\000;\n", 2, name));
	}
}

void v__gen__Gen_write_variadic_types(v__gen__Gen* g) {
	if (g->variadic_args.size > 0) {
		strings__Builder_writeln(&g->definitions, tos3("// variadic structs"));
	}
	// FOR IN map
	array_string keys_tmp2 = map_keys(&g->variadic_args);
	for (int tmp3 = 0; tmp3 < keys_tmp2.len; tmp3++) {
		string type_str = ((string*)keys_tmp2.data)[tmp3];
		int arg_len = (*(int*)map_get3(g->variadic_args, type_str, &(int[]){ 0 }));
		v__table__Type typ = ((v__table__Type)(string_int(type_str)));
		string type_name = v__gen__Gen_typ(g, typ);
		string struct_name = string_add(tos3("varg_"), string_replace(type_name, tos3("*"), tos3("_ptr")));
		strings__Builder_writeln(&g->definitions, _STR("struct %.*s\000 {", 2, struct_name));
		strings__Builder_writeln(&g->definitions, tos3("\tint len;"));
		strings__Builder_writeln(&g->definitions, _STR("\t%.*s\000 args[%"PRId32"\000];", 3, type_name, arg_len));
		strings__Builder_writeln(&g->definitions, tos3("};\n"));
		strings__Builder_writeln(&g->typedefs, _STR("typedef struct %.*s\000 %.*s\000;", 3, struct_name, struct_name));
	}
}

void v__gen__Gen_save(v__gen__Gen g) {
}

void v__gen__Gen_write(v__gen__Gen* g, string s) {
	if (g->indent > 0 && g->empty_line) {
		strings__Builder_write(&g->out, (*(string*)array_get(_const_v__gen__tabs, g->indent)));
	}
	strings__Builder_write(&g->out, s);
	g->empty_line = false;
}

void v__gen__Gen_writeln(v__gen__Gen* g, string s) {
	if (g->indent > 0 && g->empty_line) {
		strings__Builder_write(&g->out, (*(string*)array_get(_const_v__gen__tabs, g->indent)));
	}
	strings__Builder_writeln(&g->out, s);
	g->empty_line = true;
}

string v__gen__Gen_new_tmp_var(v__gen__Gen* g) {
	g->tmp_count++;
	return _STR("tmp%"PRId32"", 1, g->tmp_count);
}

void v__gen__Gen_reset_tmp_count(v__gen__Gen* g) {
	g->tmp_count = 0;
}

static void v__gen__Gen_stmts(v__gen__Gen* g, array_v__ast__Stmt stmts) {
	g->indent++;
	if (g->inside_ternary) {
		v__gen__Gen_write(g, tos3(" ( "));
	}
	// FOR IN array
	array tmp2 = stmts;
	for (int i = 0; i < tmp2.len; i++) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)tmp2.data)[i];
		v__gen__Gen_stmt(g, stmt);
		if (g->inside_ternary && i < stmts.len - 1) {
			v__gen__Gen_write(g, tos3(", "));
		}
	}
	if (g->inside_ternary) {
		v__gen__Gen_write(g, tos3(" ) "));
	}
	g->indent--;
}

static void v__gen__Gen_stmt(v__gen__Gen* g, v__ast__Stmt node) {
	g->stmt_start_pos = g->out.len;
	if (node.typ == 170 /* v.ast.AssertStmt */) {
		v__ast__AssertStmt* it = (v__ast__AssertStmt*)node.obj; // ST it
		v__gen__Gen_gen_assert_stmt(g, */*d*/it);
	}else if (node.typ == 132 /* v.ast.AssignStmt */) {
		v__ast__AssignStmt* it = (v__ast__AssignStmt*)node.obj; // ST it
		v__gen__Gen_gen_assign_stmt(g, */*d*/it);
	}else if (node.typ == 178 /* v.ast.Attr */) {
		v__ast__Attr* it = (v__ast__Attr*)node.obj; // ST it
		g->attr = it->name;
		v__gen__Gen_writeln(g, _STR("// Attr: [%.*s\000]", 2, it->name));
	}else if (node.typ == 169 /* v.ast.Block */) {
		v__ast__Block* it = (v__ast__Block*)node.obj; // ST it
		v__gen__Gen_writeln(g, tos3("{"));
		v__gen__Gen_stmts(g, it->stmts);
		v__gen__Gen_writeln(g, tos3("}"));
	}else if (node.typ == 171 /* v.ast.BranchStmt */) {
		v__ast__BranchStmt* it = (v__ast__BranchStmt*)node.obj; // ST it
		v__gen__Gen_write(g, v__token__Kind_str(it->tok.kind));
		v__gen__Gen_writeln(g, tos3(";"));
	}else if (node.typ == 188 /* v.ast.ConstDecl */) {
		v__ast__ConstDecl* it = (v__ast__ConstDecl*)node.obj; // ST it
		v__gen__Gen_const_decl(g, */*d*/it);
	}else if (node.typ == 141 /* v.ast.CompIf */) {
		v__ast__CompIf* it = (v__ast__CompIf*)node.obj; // ST it
		v__gen__Gen_comp_if(g, */*d*/it);
	}else if (node.typ == 173 /* v.ast.DeferStmt */) {
		v__ast__DeferStmt* it = (v__ast__DeferStmt*)node.obj; // ST it
		v__ast__DeferStmt defer_stmt = *it;
		defer_stmt.ifdef = g->defer_ifdef;
		array_push(&g->defer_stmts, &(v__ast__DeferStmt[]){ defer_stmt });
	}else if (node.typ == 193 /* v.ast.EnumDecl */) {
		v__ast__EnumDecl* it = (v__ast__EnumDecl*)node.obj; // ST it
		string enum_name = string_replace(it->name, tos3("."), tos3("__"));
		strings__Builder_writeln(&g->typedefs, tos3("typedef enum {"));
		string cur_enum_expr = tos3("");
		int cur_enum_offset = 0;
		// FOR IN array
		array tmp3 = it->fields;
		for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
			v__ast__EnumField field = ((v__ast__EnumField*)tmp3.data)[tmp4];
			strings__Builder_write(&g->typedefs, _STR("\t%.*s\000_%.*s", 2, enum_name, field.name));
			if (field.has_expr) {
				strings__Builder_write(&g->typedefs, tos3(" = "));
				int pos = g->out.len;
				v__gen__Gen_expr(g, field.expr);
				string expr_str = strings__Builder_after(&g->out, pos);
				strings__Builder_go_back(&g->out, expr_str.len);
				strings__Builder_write(&g->typedefs, expr_str);
				cur_enum_expr = expr_str;
				cur_enum_offset = 0;
			}
			string cur_value = (cur_enum_offset > 0 ?  ( _STR("%.*s\000+%"PRId32"", 2, cur_enum_expr, cur_enum_offset) )  :  ( cur_enum_expr ) );
			strings__Builder_writeln(&g->typedefs, _STR(", // %.*s", 1, cur_value));
			cur_enum_offset++;
		}
		strings__Builder_writeln(&g->typedefs, _STR("} %.*s\000;\n", 2, enum_name));
	}else if (node.typ == 177 /* v.ast.ExprStmt */) {
		v__ast__ExprStmt* it = (v__ast__ExprStmt*)node.obj; // ST it
		v__gen__Gen_expr(g, it->expr);
		v__ast__Expr expr = it->expr;
		if (expr.typ == 154 /* v.ast.IfExpr */) {
			v__ast__IfExpr* it = (v__ast__IfExpr*)expr.obj; // ST it
		}else {
			if (!g->inside_ternary) {
				v__gen__Gen_writeln(g, tos3(";"));
			}
		};
	}else if (node.typ == 111 /* v.ast.FnDecl */) {
		v__ast__FnDecl* it = (v__ast__FnDecl*)node.obj; // ST it
		bool skip = false;
		int pos = g->out.buf.len;
		if (g->pref->build_mode == v__pref__BuildMode_build_module) {
			if (!string_starts_with(it->name, string_add(g->module_built, tos3(".")))) {
				skip = true;
			}
			if (g->is_builtin_mod && string_eq(g->module_built, tos3("builtin"))) {
				skip = false;
			}
			if (!skip) {
				println(_STR("build module `%.*s\000` fn `%.*s\000`", 3, g->module_built, it->name));
			}
		}
		v__ast__FnDecl* keep_fn_decl = g->fn_decl;
		g->fn_decl = it;
		if (string_eq(it->name, tos3("main"))) {
			g->fn_main = it;
		} else {
			v__gen__Gen_gen_fn_decl(g, */*d*/it);
		}
		g->fn_decl = keep_fn_decl;
		if (skip) {
			strings__Builder_go_back_to(&g->out, pos);
		}
		v__gen__Gen_writeln(g, tos3(""));
		g->attr = tos3("");
	}else if (node.typ == 152 /* v.ast.ForCStmt */) {
		v__ast__ForCStmt* it = (v__ast__ForCStmt*)node.obj; // ST it
		v__gen__Gen_write(g, tos3("for ("));
		if (!it->has_init) {
			v__gen__Gen_write(g, tos3("; "));
		} else {
			v__gen__Gen_stmt(g, it->init);
		}
		if (it->has_cond) {
			v__gen__Gen_expr(g, it->cond);
		}
		v__gen__Gen_write(g, tos3("; "));
		if (it->has_inc) {
			v__gen__Gen_expr(g, it->inc);
		}
		v__gen__Gen_writeln(g, tos3(") {"));
		v__gen__Gen_stmts(g, it->stmts);
		v__gen__Gen_writeln(g, tos3("}"));
	}else if (node.typ == 153 /* v.ast.ForInStmt */) {
		v__ast__ForInStmt* it = (v__ast__ForInStmt*)node.obj; // ST it
		v__gen__Gen_for_in(g, */*d*/it);
	}else if (node.typ == 151 /* v.ast.ForStmt */) {
		v__ast__ForStmt* it = (v__ast__ForStmt*)node.obj; // ST it
		v__gen__Gen_write(g, tos3("while ("));
		if (it->is_inf) {
			v__gen__Gen_write(g, tos3("1"));
		} else {
			v__gen__Gen_expr(g, it->cond);
		}
		v__gen__Gen_writeln(g, tos3(") {"));
		v__gen__Gen_stmts(g, it->stmts);
		v__gen__Gen_writeln(g, tos3("}"));
	}else if (node.typ == 192 /* v.ast.GlobalDecl */) {
		v__ast__GlobalDecl* it = (v__ast__GlobalDecl*)node.obj; // ST it
		string styp = v__gen__Gen_typ(g, it->typ);
		strings__Builder_writeln(&g->definitions, _STR("%.*s\000 %.*s\000; // global", 3, styp, it->name));
	}else if (node.typ == 174 /* v.ast.GoStmt */) {
		v__ast__GoStmt* it = (v__ast__GoStmt*)node.obj; // ST it
		v__gen__Gen_go_stmt(g, */*d*/it);
	}else if (node.typ == 176 /* v.ast.GotoLabel */) {
		v__ast__GotoLabel* it = (v__ast__GotoLabel*)node.obj; // ST it
		v__gen__Gen_writeln(g, _STR("%.*s\000:", 2, it->name));
	}else if (node.typ == 175 /* v.ast.GotoStmt */) {
		v__ast__GotoStmt* it = (v__ast__GotoStmt*)node.obj; // ST it
		v__gen__Gen_writeln(g, _STR("goto %.*s\000;", 2, it->name));
	}else if (node.typ == 140 /* v.ast.HashStmt */) {
		v__ast__HashStmt* it = (v__ast__HashStmt*)node.obj; // ST it
		string typ = string_all_before(it->val, tos3(" "));
		if (string_eq(typ, tos3("include"))) {
			strings__Builder_writeln(&g->includes, _STR("// added by module `%.*s\000`:", 2, it->mod));
			strings__Builder_writeln(&g->includes, _STR("#%.*s", 1, it->val));
		}
		if (string_eq(typ, tos3("define"))) {
			strings__Builder_writeln(&g->definitions, _STR("#%.*s", 1, it->val));
		}
	}else if (node.typ == 165 /* v.ast.Import */) {
		v__ast__Import* it = (v__ast__Import*)node.obj; // ST it
	}else if (node.typ == 217 /* v.ast.InterfaceDecl */) {
		v__ast__InterfaceDecl* it = (v__ast__InterfaceDecl*)node.obj; // ST it
	}else if (node.typ == 187 /* v.ast.Module */) {
		v__ast__Module* it = (v__ast__Module*)node.obj; // ST it
		g->is_builtin_mod = string_eq(it->name, tos3("builtin"));
	}else if (node.typ == 191 /* v.ast.Return */) {
		v__ast__Return* it = (v__ast__Return*)node.obj; // ST it
		v__gen__Gen_write_defer_stmts_when_needed(g);
		v__gen__Gen_write_autofree_stmts_when_needed(g, */*d*/it);
		v__gen__Gen_return_statement(g, */*d*/it);
	}else if (node.typ == 211 /* v.ast.StructDecl */) {
		v__ast__StructDecl* it = (v__ast__StructDecl*)node.obj; // ST it
		string name = (it->is_c ?  ( string_replace(it->name, tos3("."), tos3("__")) )  :  ( v__gen__c_name(it->name) ) );
		if (it->is_c) {
			return ;
		}
		if (it->is_union) {
			strings__Builder_writeln(&g->typedefs, _STR("typedef union %.*s\000 %.*s\000;", 3, name, name));
		} else {
			strings__Builder_writeln(&g->typedefs, _STR("typedef struct %.*s\000 %.*s\000;", 3, name, name));
		}
	}else if (node.typ == 196 /* v.ast.TypeDecl */) {
		v__ast__TypeDecl* it = (v__ast__TypeDecl*)node.obj; // ST it
		v__gen__Gen_writeln(g, tos3("// TypeDecl"));
	}else if (node.typ == 172 /* v.ast.UnsafeStmt */) {
		v__ast__UnsafeStmt* it = (v__ast__UnsafeStmt*)node.obj; // ST it
		v__gen__Gen_stmts(g, it->stmts);
	}else {
		v__gen__verror(string_add(tos3("cgen.stmt(): unhandled node "), tos3( /* v.ast.Stmt */ v_typeof_sumtype_108( (node).typ ))));
	};
}

static void v__gen__Gen_write_defer_stmts(v__gen__Gen* g) {
	// FOR IN array
	array tmp1 = g->defer_stmts;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__DeferStmt defer_stmt = ((v__ast__DeferStmt*)tmp1.data)[tmp2];
		v__gen__Gen_writeln(g, tos3("// defer"));
		if (defer_stmt.ifdef.len > 0) {
			v__gen__Gen_writeln(g, defer_stmt.ifdef);
			v__gen__Gen_stmts(g, defer_stmt.stmts);
			v__gen__Gen_writeln(g, tos3(""));
			v__gen__Gen_writeln(g, tos3("#endif"));
		} else {
			v__gen__Gen_stmts(g, defer_stmt.stmts);
		}
	}
}

static void v__gen__Gen_for_in(v__gen__Gen* g, v__ast__ForInStmt it) {
	if (it.is_range) {
		string i = v__gen__Gen_new_tmp_var(g);
		v__gen__Gen_write(g, _STR("for (int %.*s\000 = ", 2, i));
		v__gen__Gen_expr(g, it.cond);
		v__gen__Gen_write(g, _STR("; %.*s\000 < ", 2, i));
		v__gen__Gen_expr(g, it.high);
		v__gen__Gen_writeln(g, _STR("; %.*s\000++) {", 2, i));
		if (string_ne(it.val_var, tos3("_"))) {
			v__gen__Gen_writeln(g, _STR("\tint %.*s\000 = %.*s\000;", 3, v__gen__c_name(it.val_var), i));
		}
		v__gen__Gen_stmts(g, it.stmts);
		v__gen__Gen_writeln(g, tos3("}"));
	} else if (it.kind == v__table__Kind_array) {
		v__gen__Gen_writeln(g, tos3("// FOR IN array"));
		string styp = v__gen__Gen_typ(g, it.val_type);
		bool cond_type_is_ptr = v__table__Type_is_ptr(it.cond_type);
		string atmp = v__gen__Gen_new_tmp_var(g);
		string atmp_type = (cond_type_is_ptr ?  ( tos3("array *") )  :  ( tos3("array") ) );
		v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, atmp_type, atmp));
		v__gen__Gen_expr(g, it.cond);
		v__gen__Gen_writeln(g, tos3(";"));
		string i = ((string_eq(it.key_var, tos3("")) || string_eq(it.key_var, tos3("_"))) ?  ( v__gen__Gen_new_tmp_var(g) )  :  ( it.key_var ) );
		string op_field = (cond_type_is_ptr ?  ( tos3("->") )  :  ( tos3(".") ) );
		v__gen__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 < %.*s\000%.*s\000len; %.*s\000++) {", 6, i, i, atmp, op_field, i));
		if (string_ne(it.val_var, tos3("_"))) {
			v__gen__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000 = ((%.*s\000*)%.*s\000%.*s\000data)[%.*s\000];", 7, styp, v__gen__c_name(it.val_var), styp, atmp, op_field, i));
		}
		v__gen__Gen_stmts(g, it.stmts);
		v__gen__Gen_writeln(g, tos3("}"));
	} else if (it.kind == v__table__Kind_map) {
		v__gen__Gen_writeln(g, tos3("// FOR IN map"));
		string key_styp = v__gen__Gen_typ(g, it.key_type);
		string val_styp = v__gen__Gen_typ(g, it.val_type);
		string keys_tmp = string_add(tos3("keys_"), v__gen__Gen_new_tmp_var(g));
		string idx = v__gen__Gen_new_tmp_var(g);
		string key = ((string_eq(it.key_var, tos3("")) || string_eq(it.key_var, tos3("_"))) ?  ( v__gen__Gen_new_tmp_var(g) )  :  ( it.key_var ) );
		string zero = v__gen__Gen_type_default(/*rec*/*g, it.val_type);
		v__gen__Gen_write(g, _STR("array_%.*s\000 %.*s\000 = map_keys(&", 3, key_styp, keys_tmp));
		v__gen__Gen_expr(g, it.cond);
		v__gen__Gen_writeln(g, tos3(");"));
		v__gen__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 < %.*s\000.len; %.*s\000++) {", 5, idx, idx, keys_tmp, idx));
		v__gen__Gen_writeln(g, _STR("\t%.*s\000 %.*s\000 = ((%.*s\000*)%.*s\000.data)[%.*s\000];", 6, key_styp, key, key_styp, keys_tmp, idx));
		if (string_ne(it.val_var, tos3("_"))) {
			v__gen__Gen_write(g, _STR("\t%.*s\000 %.*s\000 = (*(%.*s\000*)map_get3(", 4, val_styp, v__gen__c_name(it.val_var), val_styp));
			v__gen__Gen_expr(g, it.cond);
			v__gen__Gen_writeln(g, _STR(", %.*s\000, &(%.*s\000[]){ %.*s\000 }));", 4, key, val_styp, zero));
		}
		v__gen__Gen_stmts(g, it.stmts);
		v__gen__Gen_writeln(g, tos3("}"));
	} else if (v__table__Type_flag_is(it.cond_type, v__table__TypeFlag_variadic)) {
		v__gen__Gen_writeln(g, tos3("// FOR IN cond_type/variadic"));
		string i = ((string_eq(it.key_var, tos3("")) || string_eq(it.key_var, tos3("_"))) ?  ( v__gen__Gen_new_tmp_var(g) )  :  ( it.key_var ) );
		string styp = v__gen__Gen_typ(g, it.cond_type);
		v__gen__Gen_write(g, _STR("for (int %.*s\000 = 0; %.*s\000 < ", 3, i, i));
		v__gen__Gen_expr(g, it.cond);
		v__gen__Gen_writeln(g, _STR(".len; %.*s\000++) {", 2, i));
		v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, styp, v__gen__c_name(it.val_var)));
		v__gen__Gen_expr(g, it.cond);
		v__gen__Gen_writeln(g, _STR(".args[%.*s\000];", 2, i));
		v__gen__Gen_stmts(g, it.stmts);
		v__gen__Gen_writeln(g, tos3("}"));
	} else if (it.kind == v__table__Kind_string) {
		string i = ((string_eq(it.key_var, tos3("")) || string_eq(it.key_var, tos3("_"))) ?  ( v__gen__Gen_new_tmp_var(g) )  :  ( it.key_var ) );
		v__gen__Gen_write(g, _STR("for (int %.*s\000 = 0; %.*s\000 < ", 3, i, i));
		v__gen__Gen_expr(g, it.cond);
		v__gen__Gen_writeln(g, _STR(".len; %.*s\000++) {", 2, i));
		if (string_ne(it.val_var, tos3("_"))) {
			v__gen__Gen_write(g, _STR("byte %.*s\000 = ", 2, v__gen__c_name(it.val_var)));
			v__gen__Gen_expr(g, it.cond);
			v__gen__Gen_writeln(g, _STR(".str[%.*s\000];", 2, i));
		}
		v__gen__Gen_stmts(g, it.stmts);
		v__gen__Gen_writeln(g, tos3("}"));
	}
}

static void v__gen__Gen_expr_with_cast(v__gen__Gen* g, v__ast__Expr expr, v__table__Type got_type, v__table__Type exp_type) {
	if (exp_type != _const_v__table__void_type) {
		v__table__TypeSymbol* exp_sym = v__table__Table_get_type_symbol(g->table, exp_type);
		if (exp_sym->kind == v__table__Kind_sum_type) {
			v__table__SumType* sum_info = /* as */ (v__table__SumType*)__as_cast(exp_sym->info.obj, exp_sym->info.typ, /*expected:*/88);
			if (_IN(v__table__Type, got_type, sum_info->variants)) {
				v__table__TypeSymbol* got_sym = v__table__Table_get_type_symbol(g->table, got_type);
				string got_styp = v__gen__Gen_typ(g, got_type);
				string exp_styp = v__gen__Gen_typ(g, exp_type);
				int got_idx = v__table__Type_idx(got_type);
				v__gen__Gen_write(g, _STR("/* sum type cast */ (%.*s\000) {.obj = memdup(&(%.*s\000[]) {", 3, exp_styp, got_styp));
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_write(g, _STR("}, sizeof(%.*s\000)), .typ = %"PRId32"\000 /* %.*s\000 */}", 4, got_styp, got_idx, got_sym->name));
				return ;
			}
		}
	}
	v__gen__Gen_expr(g, expr);
}

static void v__gen__Gen_gen_assert_stmt(v__gen__Gen* g, v__ast__AssertStmt a) {
	v__gen__Gen_writeln(g, tos3("// assert"));
	g->inside_ternary = true;
	v__gen__Gen_write(g, tos3("if ("));
	v__gen__Gen_expr(g, a.expr);
	v__gen__Gen_write(g, tos3(")"));
	g->inside_ternary = false;
	string s_assertion = string_replace(v__ast__Expr_str(a.expr), tos3("\""), tos3("\'"));
	string mod_path = g->file.path;
	
// $if  windows {
#ifdef _WIN32
		mod_path = string_replace(g->file.path, tos3("\\"), tos3("\\\\"));
	
// } windows
#endif

	if (g->is_test) {
		v__gen__Gen_writeln(g, tos3("{"));
		v__gen__Gen_writeln(g, tos3("	g_test_oks++;"));
		v__gen__Gen_writeln(g, _STR("	cb_assertion_ok( tos3(\"%.*s\000\"), %"PRId32"\000, tos3(\"assert %.*s\000\"), tos3(\"%.*s\000()\") );", 5, mod_path, a.pos.line_nr + 1, s_assertion, g->fn_decl->name));
		v__gen__Gen_writeln(g, tos3("}else{"));
		v__gen__Gen_writeln(g, tos3("	g_test_fails++;"));
		v__gen__Gen_writeln(g, _STR("	cb_assertion_failed( tos3(\"%.*s\000\"), %"PRId32"\000, tos3(\"assert %.*s\000\"), tos3(\"%.*s\000()\") );", 5, mod_path, a.pos.line_nr + 1, s_assertion, g->fn_decl->name));
		v__gen__Gen_writeln(g, tos3("	exit(1);"));
		v__gen__Gen_writeln(g, tos3("	// TODO"));
		v__gen__Gen_writeln(g, tos3("	// Maybe print all vars in a test function if it fails?"));
		v__gen__Gen_writeln(g, tos3("}"));
		return ;
	}
	v__gen__Gen_writeln(g, tos3("{}else{"));
	v__gen__Gen_writeln(g, _STR("	eprintln( tos3(\"%.*s\000:%"PRId32"\000: FAIL: fn %.*s\000(): assert %.*s\000\"));", 5, mod_path, a.pos.line_nr + 1, g->fn_decl->name, s_assertion));
	v__gen__Gen_writeln(g, tos3("	exit(1);"));
	v__gen__Gen_writeln(g, tos3("}"));
}

static void v__gen__Gen_gen_assign_stmt(v__gen__Gen* g, v__ast__AssignStmt assign_stmt) {
	if (assign_stmt.is_static) {
		v__gen__Gen_write(g, tos3("static "));
	}
	v__table__Type return_type = _const_v__table__void_type;
	if ((*(v__ast__Expr*)array_get(assign_stmt.right, 0)).typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* it = /* as */ (v__ast__CallExpr*)__as_cast((*(v__ast__Expr*)array_get(assign_stmt.right, 0)).obj, (*(v__ast__Expr*)array_get(assign_stmt.right, 0)).typ, /*expected:*/144);
		return_type = it->return_type;
	}
	bool is_multi = false;
	if (return_type != 0) {
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, return_type);
		is_multi = sym->kind == v__table__Kind_multi_return || assign_stmt.left.len > assign_stmt.right.len || assign_stmt.left.len > 1;
	}
	if (is_multi) {
		array_v__ast__Stmt or_stmts = __new_array(0, 0, sizeof(v__ast__Stmt));
		bool is_optional = v__table__Type_flag_is(return_type, v__table__TypeFlag_optional);
		string mr_var_name = _STR("mr_%"PRId32"", 1, assign_stmt.pos.pos);
		string mr_styp = v__gen__Gen_typ(g, return_type);
		v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, mr_styp, mr_var_name));
		g->is_assign_rhs = true;
		v__gen__Gen_expr(g, (*(v__ast__Expr*)array_get(assign_stmt.right, 0)));
		g->is_assign_rhs = false;
		if (is_optional) {
			v__ast__Expr val = (*(v__ast__Expr*)array_get(assign_stmt.right, 0));
			if (val.typ == 144 /* v.ast.CallExpr */) {
				v__ast__CallExpr* it = (v__ast__CallExpr*)val.obj; // ST it
				or_stmts = it->or_block.stmts;
				return_type = it->return_type;
				v__gen__Gen_or_block(g, mr_var_name, or_stmts, return_type);
			}else {
			};
		}
		v__gen__Gen_writeln(g, tos3(";"));
		// FOR IN array
		array tmp7 = assign_stmt.left;
		for (int i = 0; i < tmp7.len; i++) {
			v__ast__Ident ident = ((v__ast__Ident*)tmp7.data)[i];
			if (ident.kind == v__ast__IdentKind_blank_ident) {
				continue;
			}
			v__ast__IdentVar ident_var_info = v__ast__Ident_var_info(&ident);
			string styp = v__gen__Gen_typ(g, ident_var_info.typ);
			if (assign_stmt.op == v__token__Kind_decl_assign) {
				v__gen__Gen_write(g, _STR("%.*s\000 ", 2, styp));
			}
			v__gen__Gen_expr(g, /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__Ident[]) {ident}, sizeof(v__ast__Ident)), .typ = 136 /* v.ast.Ident */});
			if (is_optional) {
				string mr_base_styp = v__gen__Gen_base_type(g, return_type);
				v__gen__Gen_writeln(g, _STR(" = (*(%.*s\000*)%.*s\000.data).arg%"PRId32"\000;", 4, mr_base_styp, mr_var_name, i));
			} else {
				v__gen__Gen_writeln(g, _STR(" = %.*s\000.arg%"PRId32"\000;", 3, mr_var_name, i));
			}
		}
	} else {
		// FOR IN array
		array tmp11 = assign_stmt.left;
		for (int i = 0; i < tmp11.len; i++) {
			v__ast__Ident ident = ((v__ast__Ident*)tmp11.data)[i];
			v__ast__Expr val = (*(v__ast__Expr*)array_get(assign_stmt.right, i));
			v__ast__IdentVar ident_var_info = v__ast__Ident_var_info(&ident);
			string styp = v__gen__Gen_typ(g, ident_var_info.typ);
			bool is_call = false;
			array_v__ast__Stmt or_stmts = __new_array(0, 0, sizeof(v__ast__Stmt));
			bool blank_assign = ident.kind == v__ast__IdentKind_blank_ident;
			if (val.typ == 144 /* v.ast.CallExpr */) {
				v__ast__CallExpr* it = (v__ast__CallExpr*)val.obj; // ST it
				is_call = true;
				or_stmts = it->or_block.stmts;
				return_type = it->return_type;
			}else if (val.typ == 149 /* v.ast.AnonFn */) {
				v__ast__AnonFn* it = (v__ast__AnonFn*)val.obj; // ST it
				if (blank_assign) {
					v__gen__Gen_write(g, tos3("{"));
				}
				string ret_styp = v__gen__Gen_typ(g, it->decl.return_type);
				v__gen__Gen_write(g, _STR("%.*s\000 (*%.*s\000) (", 3, ret_styp, ident.name));
				int def_pos = g->definitions.len;
				v__gen__Gen_fn_args(g, it->decl.args, it->decl.is_variadic);
				strings__Builder_go_back(&g->definitions, g->definitions.len - def_pos);
				v__gen__Gen_write(g, tos3(") = "));
				v__gen__Gen_expr(g, /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__AnonFn[]) {*it}, sizeof(v__ast__AnonFn)), .typ = 149 /* v.ast.AnonFn */});
				v__gen__Gen_writeln(g, tos3(";"));
				if (blank_assign) {
					v__gen__Gen_write(g, tos3("}"));
				}
				continue;
			}else if (val.typ == 136 /* v.ast.Ident */) {
				v__ast__Ident* it = (v__ast__Ident*)val.obj; // ST it
				if (it->info.typ == 221 /* v.ast.IdentFn */) {
					v__ast__IdentFn* thing = /* as */ (v__ast__IdentFn*)__as_cast(it->info.obj, it->info.typ, /*expected:*/221);
					v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, thing->typ);
					v__table__FnType* info = /* as */ (v__table__FnType*)__as_cast(sym->info.obj, sym->info.typ, /*expected:*/83);
					v__table__Fn func = info->func;
					string ret_styp = v__gen__Gen_typ(g, func.return_type);
					v__gen__Gen_write(g, _STR("%.*s\000 (*%.*s\000) (", 3, ret_styp, ident.name));
					int def_pos = g->definitions.len;
					v__gen__Gen_fn_args(g, func.args, func.is_variadic);
					strings__Builder_go_back(&g->definitions, g->definitions.len - def_pos);
					v__gen__Gen_write(g, tos3(") = "));
					v__gen__Gen_expr(g, /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__Ident[]) {*it}, sizeof(v__ast__Ident)), .typ = 136 /* v.ast.Ident */});
					v__gen__Gen_writeln(g, tos3(";"));
					continue;
				}
			}else {
			};
			bool gen_or = is_call && v__table__Type_flag_is(return_type, v__table__TypeFlag_optional);
			g->is_assign_rhs = true;
			if (blank_assign) {
				if (is_call) {
					v__gen__Gen_expr(g, val);
				} else {
					v__gen__Gen_write(g, _STR("{%.*s\000 _ = ", 2, styp));
					v__gen__Gen_expr(g, val);
					v__gen__Gen_writeln(g, tos3(";}"));
				}
			} else {
				v__table__TypeSymbol* right_sym = v__table__Table_get_type_symbol(g->table, (*(v__table__Type*)array_get(assign_stmt.right_types, i)));
				bool is_fixed_array_init = false;
				bool has_val = false;
				if (val.typ == 142 /* v.ast.ArrayInit */) {
					v__ast__ArrayInit* it = (v__ast__ArrayInit*)val.obj; // ST it
					is_fixed_array_init = it->is_fixed;
					has_val = it->has_val;
				}else {
				};
				bool is_decl = assign_stmt.op == v__token__Kind_decl_assign;
				if (is_decl) {
					v__gen__Gen_write(g, _STR("%.*s\000 ", 2, styp));
				}
				v__gen__Gen_ident(g, ident);
				if (g->autofree && (right_sym->kind == v__table__Kind_array || right_sym->kind == v__table__Kind_string)) {
					if (v__gen__Gen_gen_clone_assignment(g, val, */*d*/right_sym, true)) {
						v__gen__Gen_writeln(g, tos3(";"));
						return ;
					}
				}
				if (is_fixed_array_init) {
					if (has_val) {
						v__gen__Gen_write(g, tos3(" = "));
						v__gen__Gen_expr(g, val);
					} else {
						v__gen__Gen_write(g, tos3(" = {0}"));
					}
				} else {
					v__gen__Gen_write(g, tos3(" = "));
					if (!is_decl) {
						v__gen__Gen_expr_with_cast(g, val, (*(v__table__Type*)array_get(assign_stmt.left_types, i)), ident_var_info.typ);
					} else {
						v__gen__Gen_expr(g, val);
					}
				}
				if (gen_or) {
					v__gen__Gen_or_block(g, ident.name, or_stmts, return_type);
				}
			}
			g->is_assign_rhs = false;
			v__gen__Gen_writeln(g, tos3(";"));
		}
	}
}

static bool v__gen__Gen_gen_clone_assignment(v__gen__Gen* g, v__ast__Expr val, v__table__TypeSymbol right_sym, bool add_eq) {
	bool is_ident = false;
	if (val.typ == 136 /* v.ast.Ident */) {
		v__ast__Ident* it = (v__ast__Ident*)val.obj; // ST it
		is_ident = true;
	}else if (val.typ == 182 /* v.ast.SelectorExpr */) {
		v__ast__SelectorExpr* it = (v__ast__SelectorExpr*)val.obj; // ST it
		is_ident = true;
	}else {
		return false;
	};
	if (g->autofree && right_sym.kind == v__table__Kind_array && is_ident) {
		if (add_eq) {
			v__gen__Gen_write(g, tos3("="));
		}
		v__gen__Gen_write(g, tos3(" array_clone_static("));
		v__gen__Gen_expr(g, val);
		v__gen__Gen_write(g, tos3(")"));
	} else if (g->autofree && right_sym.kind == v__table__Kind_string && is_ident) {
		if (add_eq) {
			v__gen__Gen_write(g, tos3("="));
		}
		v__gen__Gen_write(g, tos3(" string_clone_static("));
		v__gen__Gen_expr(g, val);
		v__gen__Gen_write(g, tos3(")"));
	}
	return true;
}

static string v__gen__Gen_autofree_scope_vars(v__gen__Gen* g, int pos) {
	string freeing_code = tos3("");
	v__ast__Scope* scope = v__ast__Scope_innermost(g->file.scope, pos);
	// FOR IN map
	array_string keys_tmp1 = map_keys(&scope->objects);
	for (int tmp2 = 0; tmp2 < keys_tmp1.len; tmp2++) {
		string tmp3 = ((string*)keys_tmp1.data)[tmp2];
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)map_get3(scope->objects, tmp3, &(v__ast__ScopeObject[]){ {0} }));
		if (obj.typ == 131 /* v.ast.Var */) {
			v__ast__Var* it = (v__ast__Var*)obj.obj; // ST it
			v__ast__Var v = *it;
			bool is_optional = v__table__Type_flag_is(v.typ, v__table__TypeFlag_optional);
			if (is_optional) {
				continue;
			}
			freeing_code = string_add(freeing_code, v__gen__Gen_autofree_variable(g, v));
		}else {
		};
	}
	return freeing_code;
}

static string v__gen__Gen_autofree_variable(v__gen__Gen* g, v__ast__Var v) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, v.typ);
	if (sym->kind == v__table__Kind_array) {
		return v__gen__Gen_autofree_var_call(g, tos3("array_free"), v);
	}
	if (sym->kind == v__table__Kind_string) {
		string t = tos3( /* v.ast.Expr */ v_typeof_sumtype_133( (v.expr).typ ));
		if (v.expr.typ == 183 /* v.ast.StringLiteral */) {
			v__ast__StringLiteral* it = (v__ast__StringLiteral*)v.expr.obj; // ST it
			return tos3("// str literal\n");
		}else {
			return string_add(string_add(tos3("// other "), t), tos3("\n"));
		};
		return v__gen__Gen_autofree_var_call(g, tos3("string_free"), v);
	}
	if (v__table__TypeSymbol_has_method(sym, tos3("free"))) {
		return v__gen__Gen_autofree_var_call(g, string_add(v__gen__c_name(sym->name), tos3("_free")), v);
	}
	return tos3("");
}

static string v__gen__Gen_autofree_var_call(v__gen__Gen* g, string free_fn_name, v__ast__Var v) {
	if (v.is_arg) {
		return tos3("");
	}
	if (v__table__Type_is_ptr(v.typ)) {
		return _STR("\t%.*s\000(%.*s\000); // autofreed ptr var\n", 3, free_fn_name, v.name);
	} else {
		return _STR("\t%.*s\000(&%.*s\000); // autofreed var\n", 3, free_fn_name, v.name);
	}
}

static void v__gen__Gen_expr(v__gen__Gen* g, v__ast__Expr node) {
	if (node.typ == 142 /* v.ast.ArrayInit */) {
		v__ast__ArrayInit* it = (v__ast__ArrayInit*)node.obj; // ST it
		v__gen__Gen_array_init(g, */*d*/it);
	}else if (node.typ == 207 /* v.ast.AsCast */) {
		v__ast__AsCast* it = (v__ast__AsCast*)node.obj; // ST it
		v__gen__Gen_as_cast(g, */*d*/it);
	}else if (node.typ == 134 /* v.ast.AssignExpr */) {
		v__ast__AssignExpr* it = (v__ast__AssignExpr*)node.obj; // ST it
		v__gen__Gen_assign_expr(g, */*d*/it);
	}else if (node.typ == 200 /* v.ast.Assoc */) {
		v__ast__Assoc* it = (v__ast__Assoc*)node.obj; // ST it
		v__gen__Gen_assoc(g, */*d*/it);
	}else if (node.typ == 201 /* v.ast.BoolLiteral */) {
		v__ast__BoolLiteral* it = (v__ast__BoolLiteral*)node.obj; // ST it
		v__gen__Gen_write(g, bool_str(it->val));
	}else if (node.typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* it = (v__ast__CallExpr*)node.obj; // ST it
		v__gen__Gen_call_expr(g, */*d*/it);
	}else if (node.typ == 179 /* v.ast.CastExpr */) {
		v__ast__CastExpr* it = (v__ast__CastExpr*)node.obj; // ST it
		if (g->is_amp) {
			strings__Builder_go_back(&g->out, 1);
		}
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, it->typ);
		if (sym->kind == v__table__Kind_string && !v__table__Type_is_ptr(it->typ)) {
			if (it->has_arg) {
				v__gen__Gen_write(g, tos3("tos("));
			} else {
				v__gen__Gen_write(g, tos3("tos2("));
			}
			v__gen__Gen_expr(g, it->expr);
			v__table__TypeSymbol* expr_sym = v__table__Table_get_type_symbol(g->table, it->expr_type);
			if (expr_sym->kind == v__table__Kind_array) {
				v__gen__Gen_write(g, tos3(".data"));
			}
			if (it->has_arg) {
				v__gen__Gen_write(g, tos3(", "));
				v__gen__Gen_expr(g, it->arg);
			}
			v__gen__Gen_write(g, tos3(")"));
		} else if (sym->kind == v__table__Kind_sum_type) {
			v__gen__Gen_expr_with_cast(g, it->expr, it->expr_type, it->typ);
		} else {
			string styp = v__gen__Gen_typ(g, it->typ);
			v__gen__Gen_write(g, _STR("((%.*s\000)(", 2, styp));
			v__gen__Gen_expr(g, it->expr);
			v__gen__Gen_write(g, tos3("))"));
		}
	}else if (node.typ == 202 /* v.ast.CharLiteral */) {
		v__ast__CharLiteral* it = (v__ast__CharLiteral*)node.obj; // ST it
		v__gen__Gen_write(g, _STR("'%.*s\000'", 2, it->val));
	}else if (node.typ == 180 /* v.ast.EnumVal */) {
		v__ast__EnumVal* it = (v__ast__EnumVal*)node.obj; // ST it
		string styp = v__gen__Gen_typ(g, it->typ);
		v__gen__Gen_write(g, _STR("%.*s\000_%.*s", 2, styp, it->val));
	}else if (node.typ == 185 /* v.ast.FloatLiteral */) {
		v__ast__FloatLiteral* it = (v__ast__FloatLiteral*)node.obj; // ST it
		v__gen__Gen_write(g, it->val);
	}else if (node.typ == 136 /* v.ast.Ident */) {
		v__ast__Ident* it = (v__ast__Ident*)node.obj; // ST it
		v__gen__Gen_ident(g, */*d*/it);
	}else if (node.typ == 154 /* v.ast.IfExpr */) {
		v__ast__IfExpr* it = (v__ast__IfExpr*)node.obj; // ST it
		v__gen__Gen_if_expr(g, */*d*/it);
	}else if (node.typ == 158 /* v.ast.IfGuardExpr */) {
		v__ast__IfGuardExpr* it = (v__ast__IfGuardExpr*)node.obj; // ST it
		v__gen__Gen_write(g, tos3("/* guard */"));
	}else if (node.typ == 135 /* v.ast.IndexExpr */) {
		v__ast__IndexExpr* it = (v__ast__IndexExpr*)node.obj; // ST it
		v__gen__Gen_index_expr(g, */*d*/it);
	}else if (node.typ == 208 /* v.ast.InfixExpr */) {
		v__ast__InfixExpr* it = (v__ast__InfixExpr*)node.obj; // ST it
		v__gen__Gen_infix_expr(g, */*d*/it);
	}else if (node.typ == 186 /* v.ast.IntegerLiteral */) {
		v__ast__IntegerLiteral* it = (v__ast__IntegerLiteral*)node.obj; // ST it
		if (string_starts_with(it->val, tos3("0o"))) {
			v__gen__Gen_write(g, tos3("0"));
			v__gen__Gen_write(g, string_substr(it->val, 2, it->val.len));
		} else {
			v__gen__Gen_write(g, it->val);
		}
	}else if (node.typ == 159 /* v.ast.MatchExpr */) {
		v__ast__MatchExpr* it = (v__ast__MatchExpr*)node.obj; // ST it
		v__gen__Gen_match_expr(g, */*d*/it);
	}else if (node.typ == 143 /* v.ast.MapInit */) {
		v__ast__MapInit* it = (v__ast__MapInit*)node.obj; // ST it
		string key_typ_str = v__gen__Gen_typ(g, it->key_type);
		string value_typ_str = v__gen__Gen_typ(g, it->value_type);
		int size = it->vals.len;
		if (size > 0) {
			v__gen__Gen_write(g, _STR("new_map_init(%"PRId32"\000, sizeof(%.*s\000), (%.*s\000[%"PRId32"\000]){", 5, size, value_typ_str, key_typ_str, size));
			// FOR IN array
			array tmp9 = it->keys;
			for (int tmp10 = 0; tmp10 < tmp9.len; tmp10++) {
				v__ast__Expr expr = ((v__ast__Expr*)tmp9.data)[tmp10];
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_write(g, tos3(", "));
			}
			v__gen__Gen_write(g, _STR("}, (%.*s\000[%"PRId32"\000]){", 3, value_typ_str, size));
			// FOR IN array
			array tmp11 = it->vals;
			for (int tmp12 = 0; tmp12 < tmp11.len; tmp12++) {
				v__ast__Expr expr = ((v__ast__Expr*)tmp11.data)[tmp12];
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_write(g, tos3(", "));
			}
			v__gen__Gen_write(g, tos3("})"));
		} else {
			v__gen__Gen_write(g, _STR("new_map_1(sizeof(%.*s\000))", 2, value_typ_str));
		}
	}else if (node.typ == 204 /* v.ast.None */) {
		v__ast__None* it = (v__ast__None*)node.obj; // ST it
		v__gen__Gen_write(g, tos3("opt_none()"));
	}else if (node.typ == 203 /* v.ast.ParExpr */) {
		v__ast__ParExpr* it = (v__ast__ParExpr*)node.obj; // ST it
		v__gen__Gen_write(g, tos3("("));
		v__gen__Gen_expr(g, it->expr);
		v__gen__Gen_write(g, tos3(")"));
	}else if (node.typ == 209 /* v.ast.PostfixExpr */) {
		v__ast__PostfixExpr* it = (v__ast__PostfixExpr*)node.obj; // ST it
		v__gen__Gen_expr(g, it->expr);
		v__gen__Gen_write(g, v__token__Kind_str(it->op));
	}else if (node.typ == 210 /* v.ast.PrefixExpr */) {
		v__ast__PrefixExpr* it = (v__ast__PrefixExpr*)node.obj; // ST it
		if (it->op == v__token__Kind_amp) {
			g->is_amp = true;
		}
		v__gen__Gen_write(g, v__token__Kind_str(it->op));
		v__gen__Gen_expr(g, it->right);
		g->is_amp = false;
	}else if (node.typ == 205 /* v.ast.SizeOf */) {
		v__ast__SizeOf* it = (v__ast__SizeOf*)node.obj; // ST it
		string styp = it->type_name;
		if (string_eq(it->type_name, tos3(""))) {
			styp = v__gen__Gen_typ(g, it->typ);
		}
		v__gen__Gen_write(g, _STR("sizeof(%.*s\000)", 2, styp));
	}else if (node.typ == 183 /* v.ast.StringLiteral */) {
		v__ast__StringLiteral* it = (v__ast__StringLiteral*)node.obj; // ST it
		if (it->is_raw) {
			string escaped_val = string_replace_each(it->val, new_array_from_c_array(4, 4, sizeof(string), (string[4]){
		tos3("\""), tos3("\\\""), tos3("\\"), tos3("\\\\"), 
}));
			v__gen__Gen_write(g, _STR("tos3(\"%.*s\000\")", 2, escaped_val));
			return ;
		}
		string escaped_val = string_replace_each(it->val, new_array_from_c_array(6, 6, sizeof(string), (string[6]){
		tos3("\""), tos3("\\\""), tos3("\r\n"), tos3("\\n"), tos3("\n"), tos3("\\n"), 
}));
		if (g->is_c_call || it->is_c) {
			v__gen__Gen_write(g, _STR("\"%.*s\000\"", 2, escaped_val));
		} else {
			v__gen__Gen_write(g, _STR("tos3(\"%.*s\000\")", 2, escaped_val));
		}
	}else if (node.typ == 184 /* v.ast.StringInterLiteral */) {
		v__ast__StringInterLiteral* it = (v__ast__StringInterLiteral*)node.obj; // ST it
		v__gen__Gen_string_inter_literal(g, */*d*/it);
	}else if (node.typ == 214 /* v.ast.StructInit */) {
		v__ast__StructInit* it = (v__ast__StructInit*)node.obj; // ST it
		v__gen__Gen_struct_init(g, */*d*/it);
	}else if (node.typ == 182 /* v.ast.SelectorExpr */) {
		v__ast__SelectorExpr* it = (v__ast__SelectorExpr*)node.obj; // ST it
		v__gen__Gen_expr(g, it->expr);
		if (v__table__Type_is_ptr(it->expr_type)) {
			v__gen__Gen_write(g, tos3("->"));
		} else {
			v__gen__Gen_write(g, tos3("."));
		}
		if (it->expr_type == 0) {
			v__gen__verror(_STR("cgen: SelectorExpr | expr_type: 0 | it.expr: `%.*s\000` | field: `%.*s\000` | file: %.*s\000 | line: %"PRId32"", 4, v__ast__Expr_str(it->expr), it->field, g->file.path, it->pos.line_nr));
		}
		v__gen__Gen_write(g, v__gen__c_name(it->field));
	}else if (node.typ == 162 /* v.ast.Type */) {
		v__ast__Type* it = (v__ast__Type*)node.obj; // ST it
		int type_idx = v__table__Type_idx(it->typ);
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, it->typ);
		v__gen__Gen_write(g, _STR("%"PRId32"\000 /* %.*s\000 */", 3, type_idx, sym->name));
	}else if (node.typ == 206 /* v.ast.TypeOf */) {
		v__ast__TypeOf* it = (v__ast__TypeOf*)node.obj; // ST it
		v__gen__Gen_typeof_expr(g, */*d*/it);
	}else if (node.typ == 149 /* v.ast.AnonFn */) {
		v__ast__AnonFn* it = (v__ast__AnonFn*)node.obj; // ST it
		int pos = g->out.len;
		int def_pos = g->definitions.len;
		v__gen__Gen_stmt(g, /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__FnDecl[]) {it->decl}, sizeof(v__ast__FnDecl)), .typ = 111 /* v.ast.FnDecl */});
		string fn_body = strings__Builder_after(&g->out, pos);
		strings__Builder_go_back(&g->out, fn_body.len);
		strings__Builder_go_back(&g->definitions, g->definitions.len - def_pos);
		strings__Builder_write(&g->definitions, fn_body);
		v__table__TypeSymbol* fsym = v__table__Table_get_type_symbol(g->table, it->typ);
		v__gen__Gen_write(g, _STR("&%.*s", 1, fsym->name));
	}else {
		println(term__red(string_add(tos3("cgen.expr(): bad node "), tos3( /* v.ast.Expr */ v_typeof_sumtype_133( (node).typ )))));
	};
}

static void v__gen__Gen_typeof_expr(v__gen__Gen* g, v__ast__TypeOf node) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.expr_type);
	if (sym->kind == v__table__Kind_sum_type) {
		int sum_type_idx = v__table__Type_idx(node.expr_type);
		v__gen__Gen_write(g, _STR("tos3( /* %.*s\000 */ v_typeof_sumtype_%"PRId32"\000( (", 3, sym->name, sum_type_idx));
		v__gen__Gen_expr(g, node.expr);
		v__gen__Gen_write(g, tos3(").typ ))"));
	} else if (sym->kind == v__table__Kind_array_fixed) {
		v__table__ArrayFixed* fixed_info = /* as */ (v__table__ArrayFixed*)__as_cast(sym->info.obj, sym->info.typ, /*expected:*/81);
		string typ_name = v__table__Table_get_type_name(g->table, fixed_info->elem_type);
		v__gen__Gen_write(g, _STR("tos3(\"[%"PRId32"\000]%.*s\000\")", 3, fixed_info->size, typ_name));
	} else if (sym->kind == v__table__Kind_function) {
		v__table__FnType* info = /* as */ (v__table__FnType*)__as_cast(sym->info.obj, sym->info.typ, /*expected:*/83);
		v__table__Fn fn_info = info->func;
		string repr = tos3("fn (");
		// FOR IN array
		array tmp2 = fn_info.args;
		for (int i = 0; i < tmp2.len; i++) {
			v__table__Arg arg = ((v__table__Arg*)tmp2.data)[i];
			if (i > 0) {
				repr = string_add(repr, tos3(", "));
			}
			repr = string_add(repr, v__table__Table_get_type_name(g->table, arg.typ));
		}
		repr = string_add(repr, tos3(")"));
		if (fn_info.return_type != _const_v__table__void_type) {
			repr = string_add(repr, _STR(" %.*s", 1, v__table__Table_get_type_name(g->table, fn_info.return_type)));
		}
		v__gen__Gen_write(g, _STR("tos3(\"%.*s\000\")", 2, repr));
	} else {
		v__gen__Gen_write(g, _STR("tos3(\"%.*s\000\")", 2, sym->name));
	}
}

static void v__gen__Gen_enum_expr(v__gen__Gen* g, v__ast__Expr node) {
	if (node.typ == 180 /* v.ast.EnumVal */) {
		v__ast__EnumVal* it = (v__ast__EnumVal*)node.obj; // ST it
		v__gen__Gen_write(g, it->val);
	}else {
		v__gen__Gen_expr(g, node);
	};
}

static void v__gen__Gen_assign_expr(v__gen__Gen* g, v__ast__AssignExpr node) {
	bool is_call = false;
	array_v__ast__Stmt or_stmts = __new_array(0, 0, sizeof(v__ast__Stmt));
	v__table__Type return_type = _const_v__table__void_type;
	if (node.val.typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* it = (v__ast__CallExpr*)node.val.obj; // ST it
		is_call = true;
		or_stmts = it->or_block.stmts;
		return_type = it->return_type;
	}else {
	};
	bool gen_or = is_call && v__table__Type_flag_is(return_type, v__table__TypeFlag_optional);
	string tmp_opt = (gen_or ?  ( v__gen__Gen_new_tmp_var(g) )  :  ( tos3("") ) );
	if (gen_or) {
		string rstyp = v__gen__Gen_typ(g, return_type);
		v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 =", 3, rstyp, tmp_opt));
	}
	g->is_assign_rhs = true;
	if (v__ast__expr_is_blank_ident(node.left)) {
		if (is_call) {
			v__gen__Gen_expr(g, node.val);
		} else {
			v__gen__Gen_write(g, tos3("{"));
			v__gen__Gen_expr(g, node.val);
			v__gen__Gen_writeln(g, tos3(";}"));
		}
	} else {
		g->is_assign_lhs = true;
		if (v__table__Type_flag_is(node.right_type, v__table__TypeFlag_optional)) {
			g->right_is_opt = true;
		}
		bool str_add = false;
		if (node.left_type == _const_v__table__string_type_idx && node.op == v__token__Kind_plus_assign) {
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos3(" = string_add("));
			str_add = true;
		}
		v__table__TypeSymbol* right_sym = v__table__Table_get_type_symbol(g->table, node.right_type);
		if (right_sym->kind == v__table__Kind_array_fixed && node.op == v__token__Kind_assign) {
			v__ast__ArrayInit* right = /* as */ (v__ast__ArrayInit*)__as_cast(node.val.obj, node.val.typ, /*expected:*/142);
			// FOR IN array
			array tmp9 = right->exprs;
			for (int j = 0; j < tmp9.len; j++) {
				v__ast__Expr expr = ((v__ast__Expr*)tmp9.data)[j];
				v__gen__Gen_expr(g, node.left);
				v__gen__Gen_write(g, _STR("[%"PRId32"\000] = ", 2, j));
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_writeln(g, tos3(";"));
			}
		} else {
			g->assign_op = node.op;
			v__gen__Gen_expr(g, node.left);
			if (!g->is_array_set && !str_add) {
				v__gen__Gen_write(g, _STR(" %.*s\000 ", 2, v__token__Kind_str(node.op)));
			} else if (str_add) {
				v__gen__Gen_write(g, tos3(", "));
			}
			g->is_assign_lhs = false;
			bool cloned = false;
			if (g->autofree && (right_sym->kind == v__table__Kind_array || right_sym->kind == v__table__Kind_string)) {
				if (v__gen__Gen_gen_clone_assignment(g, node.val, */*d*/right_sym, false)) {
					cloned = true;
				}
			}
			if (!cloned) {
				v__gen__Gen_expr_with_cast(g, node.val, node.right_type, node.left_type);
			}
			if (g->is_array_set) {
				v__gen__Gen_write(g, tos3(" })"));
				g->is_array_set = false;
			} else if (str_add) {
				v__gen__Gen_write(g, tos3(")"));
			}
		}
		g->right_is_opt = false;
	}
	if (gen_or) {
		v__gen__Gen_or_block(g, tmp_opt, or_stmts, return_type);
	}
	g->is_assign_rhs = false;
}

static void v__gen__Gen_infix_expr(v__gen__Gen* g, v__ast__InfixExpr node) {
	v__table__TypeSymbol* left_sym = v__table__Table_get_type_symbol(g->table, node.left_type);
	if (node.op == v__token__Kind_key_is) {
		v__gen__Gen_is_expr(g, node);
		return ;
	}
	v__table__TypeSymbol* right_sym = v__table__Table_get_type_symbol(g->table, node.right_type);
	if (node.left_type == _const_v__table__ustring_type_idx && node.op != v__token__Kind_key_in && node.op != v__token__Kind_not_in) {
		string fn_name = (node.op == v__token__Kind_plus) ?  ( tos3("ustring_add(") )  : (node.op == v__token__Kind_eq) ?  ( tos3("ustring_eq(") )  : (node.op == v__token__Kind_ne) ?  ( tos3("ustring_ne(") )  : (node.op == v__token__Kind_lt) ?  ( tos3("ustring_lt(") )  : (node.op == v__token__Kind_le) ?  ( tos3("ustring_le(") )  : (node.op == v__token__Kind_gt) ?  ( tos3("ustring_gt(") )  : (node.op == v__token__Kind_ge) ?  ( tos3("ustring_ge(") )  :  ( tos3("/*node error*/") ) ;
		v__gen__Gen_write(g, fn_name);
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos3(", "));
		v__gen__Gen_expr(g, node.right);
		v__gen__Gen_write(g, tos3(")"));
	} else if (node.left_type == _const_v__table__string_type_idx && node.op != v__token__Kind_key_in && node.op != v__token__Kind_not_in) {
		string fn_name = (node.op == v__token__Kind_plus) ?  ( tos3("string_add(") )  : (node.op == v__token__Kind_eq) ?  ( tos3("string_eq(") )  : (node.op == v__token__Kind_ne) ?  ( tos3("string_ne(") )  : (node.op == v__token__Kind_lt) ?  ( tos3("string_lt(") )  : (node.op == v__token__Kind_le) ?  ( tos3("string_le(") )  : (node.op == v__token__Kind_gt) ?  ( tos3("string_gt(") )  : (node.op == v__token__Kind_ge) ?  ( tos3("string_ge(") )  :  ( tos3("/*node error*/") ) ;
		v__gen__Gen_write(g, fn_name);
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos3(", "));
		v__gen__Gen_expr(g, node.right);
		v__gen__Gen_write(g, tos3(")"));
	} else if ((node.op == v__token__Kind_eq || node.op == v__token__Kind_ne) && left_sym->kind == v__table__Kind_array && right_sym->kind == v__table__Kind_array) {
		v__table__Type styp = v__table__Table_value_type(g->table, node.left_type);
		string ptr_typ = (*(string*)array_get(string_split(v__gen__Gen_typ(g, node.left_type), tos3("_")), 1));
		if (!_IN(string, ptr_typ, g->array_fn_definitions)) {
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, v__table__TypeSymbol_array_info(left_sym).elem_type);
			v__gen__Gen_generate_array_equality_fn(g, ptr_typ, styp, sym);
		}
		if (node.op == v__token__Kind_eq) {
			v__gen__Gen_write(g, _STR("%.*s\000_arr_eq(", 2, ptr_typ));
		} else if (node.op == v__token__Kind_ne) {
			v__gen__Gen_write(g, _STR("!%.*s\000_arr_eq(", 2, ptr_typ));
		}
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos3(", "));
		v__gen__Gen_expr(g, node.right);
		v__gen__Gen_write(g, tos3(")"));
	} else if ((node.op == v__token__Kind_key_in || node.op == v__token__Kind_not_in)) {
		if (node.op == v__token__Kind_not_in) {
			v__gen__Gen_write(g, tos3("!"));
		}
		if (right_sym->kind == v__table__Kind_array) {
			if (node.right.typ == 142 /* v.ast.ArrayInit */) {
				v__ast__ArrayInit* it = (v__ast__ArrayInit*)node.right.obj; // ST it
				v__gen__Gen_write(g, tos3("("));
				v__gen__Gen_in_optimization(g, node.left, */*d*/it);
				v__gen__Gen_write(g, tos3(")"));
				return ;
			}else {
			};
			string styp = v__gen__Gen_typ(g, node.left_type);
			v__gen__Gen_write(g, _STR("_IN(%.*s\000, ", 2, styp));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos3(", "));
			v__gen__Gen_expr(g, node.right);
			v__gen__Gen_write(g, tos3(")"));
		} else if (right_sym->kind == v__table__Kind_map) {
			v__gen__Gen_write(g, tos3("_IN_MAP("));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos3(", "));
			v__gen__Gen_expr(g, node.right);
			v__gen__Gen_write(g, tos3(")"));
		} else if (right_sym->kind == v__table__Kind_string) {
			v__gen__Gen_write(g, tos3("string_contains("));
			v__gen__Gen_expr(g, node.right);
			v__gen__Gen_write(g, tos3(", "));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos3(")"));
		}
	} else if (node.op == v__token__Kind_left_shift && v__table__Table_get_type_symbol(g->table, node.left_type)->kind == v__table__Kind_array) {
		string tmp = v__gen__Gen_new_tmp_var(g);
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.left_type);
		v__table__Array* info = /* as */ (v__table__Array*)__as_cast(sym->info.obj, sym->info.typ, /*expected:*/80);
		if (right_sym->kind == v__table__Kind_array && info->elem_type != node.right_type) {
			v__gen__Gen_write(g, tos3("_PUSH_MANY(&"));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos3(", ("));
			v__gen__Gen_expr_with_cast(g, node.right, node.right_type, node.left_type);
			string styp = v__gen__Gen_typ(g, node.left_type);
			v__gen__Gen_write(g, _STR("), %.*s\000, %.*s\000)", 3, tmp, styp));
		} else {
			string elem_type_str = v__gen__Gen_typ(g, info->elem_type);
			v__gen__Gen_write(g, tos3("array_push(&"));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, _STR(", &(%.*s\000[]){ ", 2, elem_type_str));
			v__table__TypeSymbol* elem_sym = v__table__Table_get_type_symbol(g->table, info->elem_type);
			if (elem_sym->kind == v__table__Kind_interface_ && node.right_type != info->elem_type) {
				v__gen__Gen_interface_call(g, node.right_type, info->elem_type);
			}
			v__gen__Gen_expr_with_cast(g, node.right, node.right_type, info->elem_type);
			if (elem_sym->kind == v__table__Kind_interface_ && node.right_type != info->elem_type) {
				v__gen__Gen_write(g, tos3(")"));
			}
			v__gen__Gen_write(g, tos3(" })"));
		}
	} else if ((node.left_type == node.right_type) && v__table__Type_is_float(node.left_type) && (node.op == v__token__Kind_eq || node.op == v__token__Kind_ne)) {
		if (node.left_type == _const_v__table__f64_type_idx) {
			if (node.op == v__token__Kind_eq) {
				v__gen__Gen_write(g, tos3("f64_eq("));
			} else {
				v__gen__Gen_write(g, tos3("f64_ne("));
			}
		} else {
			if (node.op == v__token__Kind_eq) {
				v__gen__Gen_write(g, tos3("f32_eq("));
			} else {
				v__gen__Gen_write(g, tos3("f32_ne("));
			}
		}
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos3(","));
		v__gen__Gen_expr(g, node.right);
		v__gen__Gen_write(g, tos3(")"));
	} else if ((node.op == v__token__Kind_plus || node.op == v__token__Kind_minus || node.op == v__token__Kind_mul || node.op == v__token__Kind_div || node.op == v__token__Kind_mod) && (byte_is_capital(string_at(left_sym->name, 0)) || string_contains(left_sym->name, tos3("."))) && left_sym->kind != v__table__Kind_alias) {
		v__gen__Gen_write(g, v__gen__Gen_typ(g, node.left_type));
		v__gen__Gen_write(g, tos3("_"));
		v__gen__Gen_write(g, v__util__replace_op(v__token__Kind_str(node.op)));
		v__gen__Gen_write(g, tos3("("));
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos3(", "));
		v__gen__Gen_expr(g, node.right);
		v__gen__Gen_write(g, tos3(")"));
	} else {
		bool need_par = (node.op == v__token__Kind_amp || node.op == v__token__Kind_pipe || node.op == v__token__Kind_xor);
		if (need_par) {
			v__gen__Gen_write(g, tos3("("));
		}
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, _STR(" %.*s\000 ", 2, v__token__Kind_str(node.op)));
		v__gen__Gen_expr(g, node.right);
		if (need_par) {
			v__gen__Gen_write(g, tos3(")"));
		}
	}
}

static void v__gen__Gen_match_expr(v__gen__Gen* g, v__ast__MatchExpr node) {
	if (node.cond_type == 0) {
		v__gen__Gen_writeln(g, tos3("// match 0"));
		return ;
	}
	bool was_inside_ternary = g->inside_ternary;
	bool is_expr = (node.is_expr && node.return_type != _const_v__table__void_type) || was_inside_ternary;
	if (is_expr) {
		g->inside_ternary = true;
	}
	v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(g->table, node.cond_type);
	string tmp = tos3("");
	if (type_sym->kind != v__table__Kind_void) {
		tmp = v__gen__Gen_new_tmp_var(g);
	}
	// FOR IN array
	array tmp4 = node.branches;
	for (int j = 0; j < tmp4.len; j++) {
		v__ast__MatchBranch branch = ((v__ast__MatchBranch*)tmp4.data)[j];
		bool is_last = j == node.branches.len - 1;
		if (branch.is_else || node.is_expr && is_last) {
			if (node.branches.len > 1) {
				if (is_expr) {
					v__gen__Gen_write(g, tos3(" : "));
				} else {
					v__gen__Gen_writeln(g, tos3("else {"));
				}
			}
		} else {
			if (j > 0) {
				if (is_expr) {
					v__gen__Gen_write(g, tos3(" : "));
				} else {
					v__gen__Gen_write(g, tos3("else "));
				}
			}
			if (is_expr) {
				v__gen__Gen_write(g, tos3("("));
			} else {
				v__gen__Gen_write(g, tos3("if ("));
			}
			// FOR IN array
			array tmp11 = branch.exprs;
			for (int i = 0; i < tmp11.len; i++) {
				v__ast__Expr expr = ((v__ast__Expr*)tmp11.data)[i];
				if (node.is_sum_type) {
					v__gen__Gen_expr(g, node.cond);
					v__gen__Gen_write(g, tos3(".typ == "));
				} else if (type_sym->kind == v__table__Kind_string) {
					v__gen__Gen_write(g, tos3("string_eq("));
					v__gen__Gen_expr(g, node.cond);
					v__gen__Gen_write(g, tos3(", "));
				} else {
					v__gen__Gen_expr(g, node.cond);
					v__gen__Gen_write(g, tos3(" == "));
				}
				v__gen__Gen_expr(g, expr);
				if (type_sym->kind == v__table__Kind_string) {
					v__gen__Gen_write(g, tos3(")"));
				}
				if (i < branch.exprs.len - 1) {
					v__gen__Gen_write(g, tos3(" || "));
				}
			}
			if (is_expr) {
				v__gen__Gen_write(g, tos3(") ? "));
			} else {
				v__gen__Gen_writeln(g, tos3(") {"));
			}
		}
		if (node.is_sum_type && branch.exprs.len > 0 && !node.is_expr) {
			v__ast__Expr first_expr = (*(v__ast__Expr*)array_get(branch.exprs, 0));
			if (first_expr.typ == 162 /* v.ast.Type */) {
				v__ast__Type* it = (v__ast__Type*)first_expr.obj; // ST it
				string it_type = v__gen__Gen_typ(g, it->typ);
				v__gen__Gen_write(g, _STR("\t%.*s\000* it = (%.*s\000*)", 3, it_type, it_type));
				v__gen__Gen_expr(g, node.cond);
				v__gen__Gen_writeln(g, tos3(".obj; // ST it"));
			}else {
				v__gen__verror(tos3("match sum type"));
			};
		}
		v__gen__Gen_stmts(g, branch.stmts);
		if (!g->inside_ternary && node.branches.len > 1) {
			v__gen__Gen_write(g, tos3("}"));
		}
	}
	g->inside_ternary = was_inside_ternary;
}

static void v__gen__Gen_ident(v__gen__Gen* g, v__ast__Ident node) {
	if (string_eq(node.name, tos3("lld"))) {
		return ;
	}
	if (string_starts_with(node.name, tos3("C."))) {
		v__gen__Gen_write(g, string_replace(string_substr(node.name, 2, node.name.len), tos3("."), tos3("__")));
		return ;
	}
	if (node.kind == v__ast__IdentKind_constant && !string_starts_with(node.name, tos3("g_"))) {
		v__gen__Gen_write(g, tos3("_const_"));
	}
	string name = v__gen__c_name(node.name);
	if (node.info.typ == 138 /* v.ast.IdentVar */) {
		v__ast__IdentVar* ident_var = /* as */ (v__ast__IdentVar*)__as_cast(node.info.obj, node.info.typ, /*expected:*/138);
		if (ident_var->is_optional && !(g->is_assign_lhs && g->right_is_opt)) {
			v__gen__Gen_write(g, tos3("/*opt*/"));
			string styp = v__gen__Gen_base_type(g, ident_var->typ);
			v__gen__Gen_write(g, _STR("(*(%.*s\000*)%.*s\000.data)", 3, styp, name));
			return ;
		}
	}
	v__gen__Gen_write(g, name);
}

static void v__gen__Gen_if_expr(v__gen__Gen* g, v__ast__IfExpr node) {
	v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(g->table, node.typ);
	string tmp = tos3("");
	if (type_sym->kind != v__table__Kind_void) {
		tmp = v__gen__Gen_new_tmp_var(g);
	}
	if (node.is_expr && node.branches.len >= 2 && node.has_else && type_sym->kind != v__table__Kind_void) {
		g->inside_ternary = true;
		v__gen__Gen_write(g, tos3("("));
		// FOR IN array
		array tmp3 = node.branches;
		for (int i = 0; i < tmp3.len; i++) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)tmp3.data)[i];
			if (i > 0) {
				v__gen__Gen_write(g, tos3(" : "));
			}
			if (i < node.branches.len - 1 || !node.has_else) {
				v__gen__Gen_expr(g, branch.cond);
				v__gen__Gen_write(g, tos3(" ? "));
			}
			v__gen__Gen_stmts(g, branch.stmts);
		}
		v__gen__Gen_write(g, tos3(")"));
		g->inside_ternary = false;
	} else {
		string guard_ok = v__gen__Gen_new_tmp_var(g);
		bool is_guard = false;
		// FOR IN array
		array tmp6 = node.branches;
		for (int i = 0; i < tmp6.len; i++) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)tmp6.data)[i];
			if (i == 0) {
				if (branch.cond.typ == 158 /* v.ast.IfGuardExpr */) {
					v__ast__IfGuardExpr* it = (v__ast__IfGuardExpr*)branch.cond.obj; // ST it
					is_guard = true;
					v__gen__Gen_writeln(g, _STR("bool %.*s\000;", 2, guard_ok));
					v__gen__Gen_write(g, _STR("{ /* if guard */ %.*s\000 %.*s\000 = ", 3, v__gen__Gen_typ(g, it->expr_type), it->var_name));
					v__gen__Gen_expr(g, it->expr);
					v__gen__Gen_writeln(g, tos3(";"));
					v__gen__Gen_writeln(g, _STR("if ((%.*s\000 = %.*s\000.ok)) {", 3, guard_ok, it->var_name));
				}else {
					v__gen__Gen_write(g, tos3("if ("));
					v__gen__Gen_expr(g, branch.cond);
					v__gen__Gen_writeln(g, tos3(") {"));
				};
			} else if (i < node.branches.len - 1 || !node.has_else) {
				v__gen__Gen_write(g, tos3("} else if ("));
				v__gen__Gen_expr(g, branch.cond);
				v__gen__Gen_writeln(g, tos3(") {"));
			} else if (i == node.branches.len - 1 && node.has_else) {
				if (is_guard) {
					v__gen__Gen_writeln(g, _STR("} if (!%.*s\000) { /* else */", 2, guard_ok));
				} else {
					v__gen__Gen_writeln(g, tos3("} else {"));
				}
			}
			v__gen__Gen_stmts(g, branch.stmts);
		}
		if (is_guard) {
			v__gen__Gen_write(g, tos3("}"));
		}
		v__gen__Gen_writeln(g, tos3("}"));
	}
}

static void v__gen__Gen_index_expr(v__gen__Gen* g, v__ast__IndexExpr node) {
	bool is_range = false;
	if (node.index.typ == 181 /* v.ast.RangeExpr */) {
		v__ast__RangeExpr* it = (v__ast__RangeExpr*)node.index.obj; // ST it
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.left_type);
		is_range = true;
		if (sym->kind == v__table__Kind_string) {
			v__gen__Gen_write(g, tos3("string_substr("));
			v__gen__Gen_expr(g, node.left);
		} else if (sym->kind == v__table__Kind_array) {
			v__gen__Gen_write(g, tos3("array_slice("));
			v__gen__Gen_expr(g, node.left);
		} else if (sym->kind == v__table__Kind_array_fixed) {
			v__gen__Gen_write(g, tos3("array_slice(new_array_from_c_array(_ARR_LEN("));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos3("), _ARR_LEN("));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos3("), sizeof("));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos3("[0]), "));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos3(")"));
		} else {
			v__gen__Gen_expr(g, node.left);
		}
		v__gen__Gen_write(g, tos3(", "));
		if (it->has_low) {
			v__gen__Gen_expr(g, it->low);
		} else {
			v__gen__Gen_write(g, tos3("0"));
		}
		v__gen__Gen_write(g, tos3(", "));
		if (it->has_high) {
			v__gen__Gen_expr(g, it->high);
		} else {
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos3(".len"));
		}
		v__gen__Gen_write(g, tos3(")"));
		return ;
	}else {
	};
	if (!is_range) {
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.left_type);
		bool left_is_ptr = v__table__Type_is_ptr(node.left_type);
		if (v__table__Type_flag_is(node.left_type, v__table__TypeFlag_variadic)) {
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos3(".args"));
			v__gen__Gen_write(g, tos3("["));
			v__gen__Gen_expr(g, node.index);
			v__gen__Gen_write(g, tos3("]"));
		} else if (sym->kind == v__table__Kind_array) {
			v__table__Array* info = /* as */ (v__table__Array*)__as_cast(sym->info.obj, sym->info.typ, /*expected:*/80);
			string elem_type_str = v__gen__Gen_typ(g, info->elem_type);
			bool is_selector = node.left.typ == 182 /* v.ast.SelectorExpr */;
			if (g->is_assign_lhs && !is_selector && node.is_setter) {
				g->is_array_set = true;
				v__gen__Gen_write(g, tos3("array_set("));
				if (!left_is_ptr) {
					v__gen__Gen_write(g, tos3("&"));
				}
				v__gen__Gen_expr(g, node.left);
				v__gen__Gen_write(g, tos3(", "));
				v__gen__Gen_expr(g, node.index);
				bool need_wrapper = true;
				if (need_wrapper) {
					v__gen__Gen_write(g, _STR(", &(%.*s\000[]) { ", 2, elem_type_str));
				} else {
					v__gen__Gen_write(g, tos3(", &"));
				}
				if (g->assign_op != v__token__Kind_assign && _IN(v__token__Kind, g->assign_op, _const_v__token__assign_tokens)) {
					v__gen__Gen_write(g, _STR("*(%.*s\000*)array_get(", 2, elem_type_str));
					if (left_is_ptr) {
						v__gen__Gen_write(g, tos3("*"));
					}
					v__gen__Gen_expr(g, node.left);
					v__gen__Gen_write(g, tos3(", "));
					v__gen__Gen_expr(g, node.index);
					v__gen__Gen_write(g, tos3(") "));
					string op = (g->assign_op == v__token__Kind_mult_assign) ?  ( tos3("*") )  : (g->assign_op == v__token__Kind_plus_assign) ?  ( tos3("+") )  : (g->assign_op == v__token__Kind_minus_assign) ?  ( tos3("-") )  : (g->assign_op == v__token__Kind_div_assign) ?  ( tos3("/") )  : (g->assign_op == v__token__Kind_xor_assign) ?  ( tos3("^") )  : (g->assign_op == v__token__Kind_mod_assign) ?  ( tos3("%") )  : (g->assign_op == v__token__Kind_or_assign) ?  ( tos3("|") )  : (g->assign_op == v__token__Kind_and_assign) ?  ( tos3("&") )  : (g->assign_op == v__token__Kind_left_shift_assign) ?  ( tos3("<<") )  : (g->assign_op == v__token__Kind_right_shift_assign) ?  ( tos3(">>") )  :  ( tos3("") ) ;
					v__gen__Gen_write(g, op);
				}
			} else {
				v__gen__Gen_write(g, _STR("(*(%.*s\000*)array_get(", 2, elem_type_str));
				if (left_is_ptr) {
					v__gen__Gen_write(g, tos3("*"));
				}
				v__gen__Gen_expr(g, node.left);
				v__gen__Gen_write(g, tos3(", "));
				v__gen__Gen_expr(g, node.index);
				v__gen__Gen_write(g, tos3("))"));
			}
		} else if (sym->kind == v__table__Kind_map) {
			v__table__Map* info = /* as */ (v__table__Map*)__as_cast(sym->info.obj, sym->info.typ, /*expected:*/85);
			string elem_type_str = v__gen__Gen_typ(g, info->value_type);
			if (g->is_assign_lhs && !g->is_array_set) {
				g->is_array_set = true;
				v__gen__Gen_write(g, tos3("map_set("));
				if (!left_is_ptr) {
					v__gen__Gen_write(g, tos3("&"));
				}
				v__gen__Gen_expr(g, node.left);
				v__gen__Gen_write(g, tos3(", "));
				v__gen__Gen_expr(g, node.index);
				v__gen__Gen_write(g, _STR(", &(%.*s\000[]) { ", 2, elem_type_str));
			} else {
				string zero = v__gen__Gen_type_default(/*rec*/*g, info->value_type);
				v__gen__Gen_write(g, _STR("(*(%.*s\000*)map_get3(", 2, elem_type_str));
				v__gen__Gen_expr(g, node.left);
				v__gen__Gen_write(g, tos3(", "));
				v__gen__Gen_expr(g, node.index);
				v__gen__Gen_write(g, _STR(", &(%.*s\000[]){ %.*s\000 }))", 3, elem_type_str, zero));
			}
		} else if (sym->kind == v__table__Kind_string && !v__table__Type_is_ptr(node.left_type)) {
			v__gen__Gen_write(g, tos3("string_at("));
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos3(", "));
			v__gen__Gen_expr(g, node.index);
			v__gen__Gen_write(g, tos3(")"));
		} else {
			v__gen__Gen_expr(g, node.left);
			v__gen__Gen_write(g, tos3("["));
			v__gen__Gen_expr(g, node.index);
			v__gen__Gen_write(g, tos3("]"));
		}
	}
}

static void v__gen__Gen_return_statement(v__gen__Gen* g, v__ast__Return node) {
	v__gen__Gen_write(g, tos3("return "));
	if (string_eq(g->fn_decl->name, tos3("main"))) {
		v__gen__Gen_writeln(g, tos3("0;"));
		return ;
	}
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, g->fn_decl->return_type);
	bool fn_return_is_multi = sym->kind == v__table__Kind_multi_return;
	bool fn_return_is_optional = v__table__Type_flag_is(g->fn_decl->return_type, v__table__TypeFlag_optional);
	if (fn_return_is_optional) {
		bool optional_none = (*(v__ast__Expr*)array_get(node.exprs, 0)).typ == 204 /* v.ast.None */;
		bool optional_error = false;
		if ((*(v__ast__Expr*)array_get(node.exprs, 0)).typ == 144 /* v.ast.CallExpr */) {
			v__ast__CallExpr* it = (v__ast__CallExpr*)(*(v__ast__Expr*)array_get(node.exprs, 0)).obj; // ST it
			optional_error = string_eq(it->name, tos3("error"));
		}else {
			false;
		};
		if (optional_none || optional_error) {
			v__gen__Gen_expr_with_cast(g, (*(v__ast__Expr*)array_get(node.exprs, 0)), (*(v__table__Type*)array_get(node.types, 0)), g->fn_decl->return_type);
			v__gen__Gen_write(g, tos3(";"));
			return ;
		}
	}
	if (fn_return_is_multi) {
		string styp = tos3("");
		if (fn_return_is_optional) {
			styp = v__gen__Gen_base_type(g, g->fn_decl->return_type);
			v__gen__Gen_write(g, _STR("opt_ok(&(%.*s\000/*X*/[]) { ", 2, styp));
		} else {
			styp = v__gen__Gen_typ(g, g->fn_decl->return_type);
		}
		v__gen__Gen_write(g, _STR("(%.*s\000){", 2, styp));
		// FOR IN array
		array tmp7 = node.exprs;
		for (int i = 0; i < tmp7.len; i++) {
			v__ast__Expr expr = ((v__ast__Expr*)tmp7.data)[i];
			v__gen__Gen_write(g, _STR(".arg%"PRId32"\000=", 2, i));
			v__gen__Gen_expr(g, expr);
			if (i < node.exprs.len - 1) {
				v__gen__Gen_write(g, tos3(","));
			}
		}
		v__gen__Gen_write(g, tos3("}"));
		if (fn_return_is_optional) {
			v__gen__Gen_write(g, _STR(" }, sizeof(%.*s\000))", 2, styp));
		}
	} else if (node.exprs.len >= 1) {
		v__table__TypeSymbol* return_sym = v__table__Table_get_type_symbol(g->table, (*(v__table__Type*)array_get(node.types, 0)));
		if (fn_return_is_optional && !v__table__Type_flag_is((*(v__table__Type*)array_get(node.types, 0)), v__table__TypeFlag_optional) && string_ne(return_sym->name, tos3("Option"))) {
			string styp = v__gen__Gen_base_type(g, g->fn_decl->return_type);
			v__gen__Gen_write(g, _STR("/*:)%.*s\000*/opt_ok(&(%.*s\000[]) { ", 3, return_sym->name, styp));
			if (!v__table__Type_is_ptr(g->fn_decl->return_type) && v__table__Type_is_ptr((*(v__table__Type*)array_get(node.types, 0)))) {
				v__gen__Gen_write(g, tos3("*"));
			}
			// FOR IN array
			array tmp12 = node.exprs;
			for (int i = 0; i < tmp12.len; i++) {
				v__ast__Expr expr = ((v__ast__Expr*)tmp12.data)[i];
				v__gen__Gen_expr(g, expr);
				if (i < node.exprs.len - 1) {
					v__gen__Gen_write(g, tos3(", "));
				}
			}
			v__gen__Gen_writeln(g, _STR(" }, sizeof(%.*s\000));", 2, styp));
			return ;
		}
		if (!v__table__Type_is_ptr(g->fn_decl->return_type) && v__table__Type_is_ptr((*(v__table__Type*)array_get(node.types, 0)))) {
			v__gen__Gen_write(g, tos3("*"));
		}
		v__gen__Gen_expr_with_cast(g, (*(v__ast__Expr*)array_get(node.exprs, 0)), (*(v__table__Type*)array_get(node.types, 0)), g->fn_decl->return_type);
	}
	v__gen__Gen_writeln(g, tos3(";"));
}

static void v__gen__Gen_const_decl(v__gen__Gen* g, v__ast__ConstDecl node) {
	// FOR IN array
	array tmp1 = node.fields;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__ConstField field = ((v__ast__ConstField*)tmp1.data)[tmp2];
		string name = v__gen__c_name(field.name);
		int pos = g->out.len;
		v__gen__Gen_expr(g, field.expr);
		string val = strings__Builder_after(&g->out, pos);
		strings__Builder_go_back(&g->out, val.len);
		if (field.expr.typ == 202 /* v.ast.CharLiteral */) {
			v__ast__CharLiteral* it = (v__ast__CharLiteral*)field.expr.obj; // ST it
			v__gen__Gen_const_decl_simple_define(g, name, val);
		}else if (field.expr.typ == 185 /* v.ast.FloatLiteral */) {
			v__ast__FloatLiteral* it = (v__ast__FloatLiteral*)field.expr.obj; // ST it
			v__gen__Gen_const_decl_simple_define(g, name, val);
		}else if (field.expr.typ == 186 /* v.ast.IntegerLiteral */) {
			v__ast__IntegerLiteral* it = (v__ast__IntegerLiteral*)field.expr.obj; // ST it
			v__gen__Gen_const_decl_simple_define(g, name, val);
		}else if (field.expr.typ == 142 /* v.ast.ArrayInit */) {
			v__ast__ArrayInit* it = (v__ast__ArrayInit*)field.expr.obj; // ST it
			if (it->is_fixed) {
				string styp = v__gen__Gen_typ(g, it->typ);
				strings__Builder_writeln(&g->definitions, _STR("%.*s\000 _const_%.*s\000 = %.*s\000; // fixed array const", 4, styp, name, val));
			} else {
				v__gen__Gen_const_decl_init_later(g, name, val, field.typ);
			}
		}else if (field.expr.typ == 183 /* v.ast.StringLiteral */) {
			v__ast__StringLiteral* it = (v__ast__StringLiteral*)field.expr.obj; // ST it
			strings__Builder_writeln(&g->definitions, _STR("string _const_%.*s\000; // a string literal, inited later", 2, name));
			if (g->pref->build_mode != v__pref__BuildMode_build_module) {
				strings__Builder_writeln(&g->stringliterals, _STR("\t_const_%.*s\000 = %.*s\000;", 3, name, val));
			}
		}else {
			v__gen__Gen_const_decl_init_later(g, name, val, field.typ);
		};
	}
}

static void v__gen__Gen_const_decl_simple_define(v__gen__Gen* g, string name, string val) {
	strings__Builder_write(&g->definitions, _STR("#define _const_%.*s\000 ", 2, name));
	strings__Builder_writeln(&g->definitions, val);
}

static void v__gen__Gen_const_decl_init_later(v__gen__Gen* g, string name, string val, v__table__Type typ) {
	string styp = v__gen__Gen_typ(g, typ);
	strings__Builder_writeln(&g->definitions, _STR("%.*s\000 _const_%.*s\000; // inited later", 3, styp, name));
	strings__Builder_writeln(&g->inits, _STR("\t_const_%.*s\000 = %.*s\000;", 3, name, val));
}

static void v__gen__Gen_struct_init(v__gen__Gen* g, v__ast__StructInit struct_init) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, struct_init.typ);
	string styp = v__gen__Gen_typ(g, struct_init.typ);
	bool is_amp = g->is_amp;
	if (is_amp) {
		strings__Builder_go_back(&g->out, 1);
		v__gen__Gen_write(g, _STR("(%.*s\000*)memdup(&(%.*s\000){", 3, styp, styp));
	} else {
		v__gen__Gen_writeln(g, _STR("(%.*s\000){", 2, styp));
	}
	array_string inited_fields = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp2 = struct_init.fields;
	for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
		v__ast__StructInitField field = ((v__ast__StructInitField*)tmp2.data)[tmp3];
		string field_name = v__gen__c_name(field.name);
		array_push(&inited_fields, &(string[]){ field.name });
		v__gen__Gen_write(g, _STR("\t.%.*s\000 = ", 2, field_name));
		v__gen__Gen_expr_with_cast(g, field.expr, field.typ, field.expected_type);
		v__gen__Gen_writeln(g, tos3(","));
	}
	int nr_info_fields = 0;
	if (sym->kind == v__table__Kind_struct_) {
		v__table__Struct* info = /* as */ (v__table__Struct*)__as_cast(sym->info.obj, sym->info.typ, /*expected:*/87);
		nr_info_fields = info->fields.len;
		// FOR IN array
		array tmp6 = info->fields;
		for (int tmp7 = 0; tmp7 < tmp6.len; tmp7++) {
			v__table__Field field = ((v__table__Field*)tmp6.data)[tmp7];
			if (_IN(string, field.name, inited_fields)) {
				continue;
			}
			if (v__table__Type_flag_is(field.typ, v__table__TypeFlag_optional)) {
				continue;
			}
			string field_name = v__gen__c_name(field.name);
			v__gen__Gen_write(g, _STR("\t.%.*s\000 = ", 2, field_name));
			if (field.has_default_expr) {
				v__gen__Gen_expr(g, v__ast__fe2ex(field.default_expr));
			} else {
				v__gen__Gen_write(g, v__gen__Gen_type_default(/*rec*/*g, field.typ));
			}
			v__gen__Gen_writeln(g, tos3(","));
		}
	}
	if (struct_init.fields.len == 0 && nr_info_fields == 0) {
		v__gen__Gen_write(g, tos3("0"));
	}
	v__gen__Gen_write(g, tos3("}"));
	if (is_amp) {
		v__gen__Gen_write(g, _STR(", sizeof(%.*s\000))", 2, styp));
	}
}

static void v__gen__Gen_assoc(v__gen__Gen* g, v__ast__Assoc node) {
	v__gen__Gen_writeln(g, tos3("// assoc"));
	if (node.typ == 0) {
		return ;
	}
	string styp = v__gen__Gen_typ(g, node.typ);
	v__gen__Gen_writeln(g, _STR("(%.*s\000){", 2, styp));
	// FOR IN array
	array tmp2 = node.fields;
	for (int i = 0; i < tmp2.len; i++) {
		string field = ((string*)tmp2.data)[i];
		string field_name = v__gen__c_name(field);
		v__gen__Gen_write(g, _STR("\t.%.*s\000 = ", 2, field_name));
		v__gen__Gen_expr(g, (*(v__ast__Expr*)array_get(node.exprs, i)));
		v__gen__Gen_writeln(g, tos3(", "));
	}
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.typ);
	v__table__Struct* info = /* as */ (v__table__Struct*)__as_cast(sym->info.obj, sym->info.typ, /*expected:*/87);
	// FOR IN array
	array tmp3 = info->fields;
	for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
		v__table__Field field = ((v__table__Field*)tmp3.data)[tmp4];
		if (_IN(string, field.name, node.fields)) {
			continue;
		}
		string field_name = v__gen__c_name(field.name);
		v__gen__Gen_writeln(g, _STR("\t.%.*s\000 = %.*s\000.%.*s\000,", 4, field_name, node.var_name, field_name));
	}
	v__gen__Gen_write(g, tos3("}"));
	if (g->is_amp) {
		v__gen__Gen_write(g, _STR(", sizeof(%.*s\000))", 2, styp));
	}
}

static void v__gen__Gen_generate_array_equality_fn(v__gen__Gen* g, string ptr_typ, v__table__Type styp, v__table__TypeSymbol* sym) {
	array_push(&g->array_fn_definitions, &(string[]){ ptr_typ });
	strings__Builder_writeln(&g->definitions, _STR("bool %.*s\000_arr_eq(array_%.*s\000 a, array_%.*s\000 b) {", 4, ptr_typ, ptr_typ, ptr_typ));
	strings__Builder_writeln(&g->definitions, tos3("\tif (a.len != b.len) {"));
	strings__Builder_writeln(&g->definitions, tos3("\t\treturn false;"));
	strings__Builder_writeln(&g->definitions, tos3("\t}"));
	strings__Builder_writeln(&g->definitions, tos3("\tfor (int i = 0; i < a.len; i++) {"));
	if (styp == _const_v__table__string_type_idx) {
		strings__Builder_writeln(&g->definitions, _STR("\t\tif (string_ne(*((%.*s\000*)((byte*)a.data+(i*a.element_size))), *((%.*s\000*)((byte*)b.data+(i*b.element_size))))) {", 3, ptr_typ, ptr_typ));
	} else if (sym->kind == v__table__Kind_struct_) {
		strings__Builder_writeln(&g->definitions, tos3("\t\tif (memcmp((byte*)a.data+(i*a.element_size), (byte*)b.data+(i*b.element_size), a.element_size)) {"));
	} else {
		strings__Builder_writeln(&g->definitions, _STR("\t\tif (*((%.*s\000*)((byte*)a.data+(i*a.element_size))) != *((%.*s\000*)((byte*)b.data+(i*b.element_size)))) {", 3, ptr_typ, ptr_typ));
	}
	strings__Builder_writeln(&g->definitions, tos3("\t\t\treturn false;"));
	strings__Builder_writeln(&g->definitions, tos3("\t\t}"));
	strings__Builder_writeln(&g->definitions, tos3("\t}"));
	strings__Builder_writeln(&g->definitions, tos3("\treturn true;"));
	strings__Builder_writeln(&g->definitions, tos3("}"));
}

static void v__gen__verror(string s) {
	v__util__verror(tos3("cgen error"), s);
}

static void v__gen__Gen_write_init_function(v__gen__Gen* g) {
	if (g->pref->is_liveshared) {
		return ;
	}
	v__gen__Gen_writeln(g, tos3("void _vinit() {"));
	v__gen__Gen_writeln(g, tos3("\tbuiltin_init();"));
	v__gen__Gen_writeln(g, tos3("\tvinit_string_literals();"));
	v__gen__Gen_writeln(g, strings__Builder_str(&g->inits));
	// FOR IN array
	array tmp2 = g->table->imports;
	for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
		string mod_name = ((string*)tmp2.data)[tmp3];
		string init_fn_name = _STR("%.*s\000.init", 2, mod_name);
		bool tmp4;
		{ /* if guard */ Option_v__table__Fn _ = v__table__Table_find_fn(g->table, init_fn_name);
		if ((tmp4 = _.ok)) {
			string mod_c_name = string_replace(mod_name, tos3("."), tos3("__"));
			string init_fn_c_name = _STR("%.*s\000__init", 2, mod_c_name);
			v__gen__Gen_writeln(g, _STR("\t%.*s\000();", 2, init_fn_c_name));
		}}
	}
	v__gen__Gen_writeln(g, tos3("}"));
	if (g->autofree) {
		v__gen__Gen_writeln(g, tos3("void _vcleanup() {"));
		if (v__gen__Gen_is_importing_os(/*rec*/*g)) {
			v__gen__Gen_writeln(g, tos3("array_free(&_const_os__args);"));
			v__gen__Gen_writeln(g, tos3("string_free(&_const_os__wd_at_startup);"));
		}
		v__gen__Gen_writeln(g, tos3("array_free(&_const_strconv__ftoa__powers_of_10);"));
		v__gen__Gen_writeln(g, tos3("}"));
	}
}

static void v__gen__Gen_write_builtin_types(v__gen__Gen* g) {
	array_v__table__TypeSymbol builtin_types = __new_array(0, 0, sizeof(v__table__TypeSymbol));
	// FOR IN array
	array tmp1 = _const_v__gen__builtins;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string builtin_name = ((string*)tmp1.data)[tmp2];
		array_push(&builtin_types, &(v__table__TypeSymbol[]){ (*(v__table__TypeSymbol*)array_get(g->table->types, (*(int*)map_get3(g->table->type_idxs, builtin_name, &(int[]){ 0 })))) });
	}
	v__gen__Gen_write_types(g, builtin_types);
}

static void v__gen__Gen_write_sorted_types(v__gen__Gen* g) {
	array_v__table__TypeSymbol types = __new_array(0, 0, sizeof(v__table__TypeSymbol));
	// FOR IN array
	array tmp1 = g->table->types;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__TypeSymbol typ = ((v__table__TypeSymbol*)tmp1.data)[tmp2];
		if (!_IN(string, typ.name, _const_v__gen__builtins)) {
			array_push(&types, &(v__table__TypeSymbol[]){ typ });
		}
	}
	array_v__table__TypeSymbol types_sorted = v__gen__Gen_sort_structs(/*rec*/*g, types);
	strings__Builder_writeln(&g->definitions, tos3("// builtin types:"));
	strings__Builder_writeln(&g->definitions, tos3("//------------------ #endbuiltin"));
	v__gen__Gen_write_types(g, types_sorted);
}

static void v__gen__Gen_write_types(v__gen__Gen* g, array_v__table__TypeSymbol types) {
	// FOR IN array
	array tmp1 = types;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__TypeSymbol typ = ((v__table__TypeSymbol*)tmp1.data)[tmp2];
		if (string_starts_with(typ.name, tos3("C."))) {
			continue;
		}
		string name = string_replace(typ.name, tos3("."), tos3("__"));
		if (typ.info.typ == 87 /* v.table.Struct */) {
			v__table__Struct* it = (v__table__Struct*)typ.info.obj; // ST it
			v__table__Struct* info = /* as */ (v__table__Struct*)__as_cast(typ.info.obj, typ.info.typ, /*expected:*/87);
			if (info->is_union) {
				strings__Builder_writeln(&g->definitions, _STR("union %.*s\000 {", 2, name));
			} else {
				strings__Builder_writeln(&g->definitions, _STR("struct %.*s\000 {", 2, name));
			}
			if (info->fields.len > 0) {
				// FOR IN array
				array tmp7 = info->fields;
				for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
					v__table__Field field = ((v__table__Field*)tmp7.data)[tmp8];
					string type_name = v__gen__Gen_typ(g, field.typ);
					string field_name = v__gen__c_name(field.name);
					strings__Builder_writeln(&g->definitions, _STR("\t%.*s\000 %.*s\000;", 3, type_name, field_name));
				}
			} else {
				strings__Builder_writeln(&g->definitions, tos3("EMPTY_STRUCT_DECLARATION;"));
			}
			strings__Builder_writeln(&g->definitions, tos3("};\n"));
		}else if (typ.info.typ == 79 /* v.table.Alias */) {
			v__table__Alias* it = (v__table__Alias*)typ.info.obj; // ST it
		}else if (typ.info.typ == 88 /* v.table.SumType */) {
			v__table__SumType* it = (v__table__SumType*)typ.info.obj; // ST it
			strings__Builder_writeln(&g->definitions, tos3(""));
			strings__Builder_writeln(&g->definitions, _STR("// Sum type %.*s\000 = ", 2, name));
			// FOR IN array
			array tmp9 = it->variants;
			for (int tmp10 = 0; tmp10 < tmp9.len; tmp10++) {
				v__table__Type sv = ((v__table__Type*)tmp9.data)[tmp10];
				strings__Builder_writeln(&g->definitions, _STR("//          | %4"PRId32"\000 = %*.*s", 2, sv, v__gen__Gen_typ(g, sv), -20));
			}
			strings__Builder_writeln(&g->definitions, tos3("typedef struct {"));
			strings__Builder_writeln(&g->definitions, tos3("    void* obj;"));
			strings__Builder_writeln(&g->definitions, tos3("    int typ;"));
			strings__Builder_writeln(&g->definitions, _STR("} %.*s\000;", 2, name));
			strings__Builder_writeln(&g->definitions, tos3(""));
		}else if (typ.info.typ == 81 /* v.table.ArrayFixed */) {
			v__table__ArrayFixed* it = (v__table__ArrayFixed*)typ.info.obj; // ST it
			string styp = string_replace(typ.name, tos3("."), tos3("__"));
			string fixed = string_substr(styp, 12, styp.len);
			string len = string_after(styp, tos3("_"));
			fixed = string_substr(fixed, 0, fixed.len - len.len - 1);
			strings__Builder_writeln(&g->definitions, _STR("typedef %.*s\000 %.*s\000 [%.*s\000];", 4, fixed, styp, len));
		}else {
		};
	}
}

static array_v__table__TypeSymbol v__gen__Gen_sort_structs(v__gen__Gen g, array_v__table__TypeSymbol typesa) {
	v__depgraph__DepGraph* dep_graph = v__depgraph__new_dep_graph();
	array_string type_names = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp1 = typesa;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__TypeSymbol typ = ((v__table__TypeSymbol*)tmp1.data)[tmp2];
		array_push(&type_names, &(string[]){ typ.name });
	}
	// FOR IN array
	array tmp4 = typesa;
	for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
		v__table__TypeSymbol t = ((v__table__TypeSymbol*)tmp4.data)[tmp5];
		if (t.kind == v__table__Kind_interface_) {
			v__depgraph__DepGraph_add(dep_graph, t.name, __new_array(0, 0, sizeof(string)));
			continue;
		}
		array_string field_deps = __new_array(0, 0, sizeof(string));
		if (t.info.typ == 81 /* v.table.ArrayFixed */) {
			v__table__ArrayFixed* it = (v__table__ArrayFixed*)t.info.obj; // ST it
			string dep = v__table__Table_get_type_symbol(g.table, it->elem_type)->name;
			if (_IN(string, dep, type_names)) {
				array_push(&field_deps, &(string[]){ dep });
			}
		}else if (t.info.typ == 87 /* v.table.Struct */) {
			v__table__Struct* it = (v__table__Struct*)t.info.obj; // ST it
			v__table__Struct* info = /* as */ (v__table__Struct*)__as_cast(t.info.obj, t.info.typ, /*expected:*/87);
			// FOR IN array
			array tmp10 = info->fields;
			for (int tmp11 = 0; tmp11 < tmp10.len; tmp11++) {
				v__table__Field field = ((v__table__Field*)tmp10.data)[tmp11];
				string dep = v__table__Table_get_type_symbol(g.table, field.typ)->name;
				if (!_IN(string, dep, type_names) || _IN(string, dep, field_deps) || v__table__Type_is_ptr(field.typ)) {
					continue;
				}
				array_push(&field_deps, &(string[]){ dep });
			}
		}else {
		};
		v__depgraph__DepGraph_add(dep_graph, t.name, field_deps);
	}
	v__depgraph__DepGraph* dep_graph_sorted = v__depgraph__DepGraph_resolve(dep_graph);
	if (!dep_graph_sorted->acyclic) {
		v__gen__verror(string_add(string_add(string_add(tos3("cgen.sort_structs(): the following structs form a dependency cycle:\n"), v__depgraph__DepGraph_display_cycles(dep_graph_sorted)), tos3("\nyou can solve this by making one or both of the dependant struct fields references, eg: field &MyStruct")), tos3("\nif you feel this is an error, please create a new issue here: https://github.com/vlang/v/issues and tag @joe-conigliaro")));
	}
	array_v__table__TypeSymbol types_sorted = __new_array(0, 0, sizeof(v__table__TypeSymbol));
	// FOR IN array
	array tmp15 = dep_graph_sorted->nodes;
	for (int tmp16 = 0; tmp16 < tmp15.len; tmp16++) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)tmp15.data)[tmp16];
		array_push(&types_sorted, &(v__table__TypeSymbol[]){ (*(v__table__TypeSymbol*)array_get(g.table->types, (*(int*)map_get3(g.table->type_idxs, node.name, &(int[]){ 0 })))) });
	}
	return types_sorted;
}

static void v__gen__Gen_string_inter_literal(v__gen__Gen* g, v__ast__StringInterLiteral node) {
	v__gen__Gen_write(g, tos3("_STR(\""));
	array_int fieldwidths = __new_array(0, 0, sizeof(int));
	array_byte specs = __new_array(0, 0, sizeof(byte));
	bool end_string = false;
	// FOR IN array
	array tmp1 = node.vals;
	for (int i = 0; i < tmp1.len; i++) {
		string val = ((string*)tmp1.data)[i];
		string escaped_val = string_replace_each(val, new_array_from_c_array(8, 8, sizeof(string), (string[8]){
		tos3("\""), tos3("\\\""), tos3("\r\n"), tos3("\\n"), tos3("\n"), tos3("\\n"), tos3("%"), tos3("%%"), 
}));
		if (i >= node.exprs.len) {
			if (escaped_val.len > 0) {
				end_string = true;
				v__gen__Gen_write(g, tos3("\\000"));
				v__gen__Gen_write(g, escaped_val);
			}
			continue;
		}
		v__gen__Gen_write(g, escaped_val);
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, (*(v__table__Type*)array_get(node.expr_types, i)));
		string sfmt = (*(string*)array_get(node.expr_fmts, i));
		byte fspec = '_';
		string fmt = tos3("");
		if (sfmt.len > 0) {
			if ((string_at(sfmt, sfmt.len - 1) == 'E' || string_at(sfmt, sfmt.len - 1) == 'F' || string_at(sfmt, sfmt.len - 1) == 'G' || string_at(sfmt, sfmt.len - 1) == 'e' || string_at(sfmt, sfmt.len - 1) == 'f' || string_at(sfmt, sfmt.len - 1) == 'g' || string_at(sfmt, sfmt.len - 1) == 'd' || string_at(sfmt, sfmt.len - 1) == 'u' || string_at(sfmt, sfmt.len - 1) == 'x' || string_at(sfmt, sfmt.len - 1) == 'X' || string_at(sfmt, sfmt.len - 1) == 'o' || string_at(sfmt, sfmt.len - 1) == 'c' || string_at(sfmt, sfmt.len - 1) == 's' || string_at(sfmt, sfmt.len - 1) == 'p')) {
				fspec = string_at(sfmt, sfmt.len - 1);
			}
			fmt = (fspec == '_' ?  ( string_substr(sfmt, 1, sfmt.len) )  :  ( string_substr(sfmt, 1, sfmt.len - 1) ) );
		}
		if (fspec == '_') {
			if (v__table__Type_is_float((*(v__table__Type*)array_get(node.expr_types, i)))) {
				fspec = 'g';
			} else if (v__table__Type_is_signed((*(v__table__Type*)array_get(node.expr_types, i)))) {
				fspec = 'd';
			} else if (v__table__Type_is_unsigned((*(v__table__Type*)array_get(node.expr_types, i)))) {
				fspec = 'u';
			} else if (v__table__Type_is_pointer((*(v__table__Type*)array_get(node.expr_types, i)))) {
				fspec = 'p';
			} else if (((*(v__table__Type*)array_get(node.expr_types, i)) == _const_v__table__string_type || (*(v__table__Type*)array_get(node.expr_types, i)) == _const_v__table__bool_type) || (sym->kind == v__table__Kind_enum_ || sym->kind == v__table__Kind_array || sym->kind == v__table__Kind_array_fixed || sym->kind == v__table__Kind_struct_ || sym->kind == v__table__Kind_map) || string_starts_with(v__gen__Gen_typ(g, (*(v__table__Type*)array_get(node.expr_types, i))), tos3("Option")) || v__table__TypeSymbol_has_method(sym, tos3("str"))) {
				fspec = 's';
			} else {
				fspec = 'd';
			}
		}
		array_string fields = string_split(fmt, tos3("."));
		if (fields.len > 2 || fields.len == 2 && !(v__table__Type_is_float((*(v__table__Type*)array_get(node.expr_types, i)))) || v__table__Type_is_signed((*(v__table__Type*)array_get(node.expr_types, i))) && !((fspec == 'd' || fspec == 'c' || fspec == 'x' || fspec == 'X' || fspec == 'o')) || v__table__Type_is_unsigned((*(v__table__Type*)array_get(node.expr_types, i))) && !((fspec == 'u' || fspec == 'x' || fspec == 'X' || fspec == 'o' || fspec == 'c')) || v__table__Type_is_float((*(v__table__Type*)array_get(node.expr_types, i))) && !((fspec == 'E' || fspec == 'F' || fspec == 'G' || fspec == 'e' || fspec == 'f' || fspec == 'g')) || v__table__Type_is_pointer((*(v__table__Type*)array_get(node.expr_types, i))) && !((fspec == 'p' || fspec == 'x' || fspec == 'X'))) {
			v__gen__verror(_STR("illegal format specifier %c\000 for type %.*s", 2, fspec, v__table__Table_get_type_name(g->table, (*(v__table__Type*)array_get(node.expr_types, i)))));
		}
		// FOR IN array
		array tmp10 = fields;
		for (int j = 0; j < tmp10.len; j++) {
			string f = ((string*)tmp10.data)[j];
			for (int k = 0; k < f.len; k++) {
			byte c = f.str[k];
				if ((c < '0' || c > '9') && !(j == 0 && k == 0 && (v__table__Type_is_number((*(v__table__Type*)array_get(node.expr_types, i))) && c == '+' || c == '-'))) {
					v__gen__verror(_STR("illegal character %c\000 in format specifier %.*s", 2, c, fmt));
				}
			}
		}
		array_push(&specs, &(byte[]){ fspec });
		array_push(&fieldwidths, &(int[]){ (fields.len == 0 ?  ( 0 )  :  ( strconv__atoi((*(string*)array_get(fields, 0))) ) ) });
		v__gen__Gen_write(g, tos3("%"));
		if (fspec == 's') {
			if (fields.len == 0 || strconv__atoi((*(string*)array_get(fields, 0))) == 0) {
				v__gen__Gen_write(g, tos3(".*s"));
			} else {
				v__gen__Gen_write(g, tos3("*.*s"));
			}
		} else if (v__table__Type_is_float((*(v__table__Type*)array_get(node.expr_types, i))) || v__table__Type_is_pointer((*(v__table__Type*)array_get(node.expr_types, i)))) {
			v__gen__Gen_write(g, _STR("%.*s\000%c", 2, fmt, fspec));
		} else if (v__table__Type_is_pointer((*(v__table__Type*)array_get(node.expr_types, i)))) {
			if (fspec == 'p') {
				v__gen__Gen_write(g, _STR("%.*s\000p", 2, fmt));
			} else {
				v__gen__Gen_write(g, _STR("%.*s\000\"PRI%c\000PTR\"", 3, fmt, fspec));
			}
		} else if (v__table__Type_is_int((*(v__table__Type*)array_get(node.expr_types, i)))) {
			if (fspec == 'c') {
				if ((v__table__Type_idx((*(v__table__Type*)array_get(node.expr_types, i))) == _const_v__table__i64_type_idx || v__table__Type_idx((*(v__table__Type*)array_get(node.expr_types, i))) == _const_v__table__f64_type_idx)) {
					v__gen__verror(tos3("64 bit integer types cannot be interpolated as character"));
				} else {
					v__gen__Gen_write(g, _STR("%.*s\000c", 2, fmt));
				}
			} else {
				v__gen__Gen_write(g, _STR("%.*s\000\"PRI%c", 2, fmt, fspec));
				if (((*(v__table__Type*)array_get(node.expr_types, i)) == _const_v__table__i8_type || (*(v__table__Type*)array_get(node.expr_types, i)) == _const_v__table__byte_type)) {
					v__gen__Gen_write(g, tos3("8"));
				} else if (((*(v__table__Type*)array_get(node.expr_types, i)) == _const_v__table__i16_type || (*(v__table__Type*)array_get(node.expr_types, i)) == _const_v__table__u16_type)) {
					v__gen__Gen_write(g, tos3("16"));
				} else if (((*(v__table__Type*)array_get(node.expr_types, i)) == _const_v__table__i64_type || (*(v__table__Type*)array_get(node.expr_types, i)) == _const_v__table__u64_type)) {
					v__gen__Gen_write(g, tos3("64"));
				} else {
					v__gen__Gen_write(g, tos3("32"));
				}
				v__gen__Gen_write(g, tos3("\""));
			}
		} else {
			v__gen__Gen_write(g, _STR("%.*s\000\"PRId32\"", 2, fmt));
		}
		if (i < node.exprs.len - 1) {
			v__gen__Gen_write(g, tos3("\\000"));
		}
	}
	int num_string_parts = (end_string ?  ( node.exprs.len + 1 )  :  ( node.exprs.len ) );
	v__gen__Gen_write(g, _STR("\", %"PRId32"\000, ", 2, num_string_parts));
	// FOR IN array
	array tmp23 = node.exprs;
	for (int i = 0; i < tmp23.len; i++) {
		v__ast__Expr expr = ((v__ast__Expr*)tmp23.data)[i];
		if ((*(v__table__Type*)array_get(node.expr_types, i)) == _const_v__table__string_type) {
			v__gen__Gen_expr(g, expr);
		} else if ((*(v__table__Type*)array_get(node.expr_types, i)) == _const_v__table__bool_type) {
			v__gen__Gen_expr(g, expr);
			v__gen__Gen_write(g, tos3(" ? _SLIT(\"true\") : _SLIT(\"false\")"));
		} else if (v__table__Type_is_number((*(v__table__Type*)array_get(node.expr_types, i))) || v__table__Type_is_pointer((*(v__table__Type*)array_get(node.expr_types, i))) || (*(byte*)array_get(specs, i)) == 'd') {
			if (v__table__Type_is_signed((*(v__table__Type*)array_get(node.expr_types, i))) && ((*(byte*)array_get(specs, i)) == 'x' || (*(byte*)array_get(specs, i)) == 'X' || (*(byte*)array_get(specs, i)) == 'o')) {
				if ((*(v__table__Type*)array_get(node.expr_types, i)) == _const_v__table__i8_type) {
					v__gen__Gen_write(g, tos3("(byte)("));
				} else if ((*(v__table__Type*)array_get(node.expr_types, i)) == _const_v__table__i16_type) {
					v__gen__Gen_write(g, tos3("(u16)("));
				} else if ((*(v__table__Type*)array_get(node.expr_types, i)) == _const_v__table__int_type) {
					v__gen__Gen_write(g, tos3("(u32)("));
				} else {
					v__gen__Gen_write(g, tos3("(u64)("));
				}
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_write(g, tos3(")"));
			} else {
				v__gen__Gen_expr(g, expr);
			}
		} else if ((*(byte*)array_get(specs, i)) == 's') {
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, (*(v__table__Type*)array_get(node.expr_types, i)));
			if (v__table__Type_flag_is((*(v__table__Type*)array_get(node.expr_types, i)), v__table__TypeFlag_variadic)) {
				string str_fn_name = v__gen__Gen_gen_str_for_type(g, (*(v__table__Type*)array_get(node.expr_types, i)));
				v__gen__Gen_write(g, _STR("%.*s\000(", 2, str_fn_name));
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_write(g, tos3(")"));
			} else if (sym->kind == v__table__Kind_enum_) {
				bool is_var = ((*(v__ast__Expr*)array_get(node.exprs, i)).typ == 182 /* v.ast.SelectorExpr */) ?  ( true )  : ((*(v__ast__Expr*)array_get(node.exprs, i)).typ == 136 /* v.ast.Ident */) ?  ( true )  :  ( false ) ;
				if (is_var) {
					string str_fn_name = v__gen__Gen_gen_str_for_type(g, (*(v__table__Type*)array_get(node.expr_types, i)));
					v__gen__Gen_write(g, _STR("%.*s\000(", 2, str_fn_name));
					v__gen__Gen_enum_expr(g, expr);
					v__gen__Gen_write(g, tos3(")"));
				} else {
					v__gen__Gen_write(g, tos3("tos3(\""));
					v__gen__Gen_enum_expr(g, expr);
					v__gen__Gen_write(g, tos3("\")"));
				}
			} else if (v__table__TypeSymbol_has_method(sym, tos3("str")) || (sym->kind == v__table__Kind_array || sym->kind == v__table__Kind_array_fixed || sym->kind == v__table__Kind_map || sym->kind == v__table__Kind_struct_)) {
				bool is_p = v__table__Type_is_ptr((*(v__table__Type*)array_get(node.expr_types, i)));
				v__table__Type val_type = (is_p ?  ( v__table__Type_deref((*(v__table__Type*)array_get(node.expr_types, i))) )  :  ( (*(v__table__Type*)array_get(node.expr_types, i)) ) );
				string str_fn_name = v__gen__Gen_gen_str_for_type(g, val_type);
				if (is_p) {
					v__gen__Gen_write(g, _STR("string_add(_SLIT(\"&\"), %.*s\000(*(", 2, str_fn_name));
				} else {
					v__gen__Gen_write(g, _STR("%.*s\000(", 2, str_fn_name));
				}
				v__gen__Gen_expr(g, expr);
				if (sym->kind == v__table__Kind_struct_ && !v__table__TypeSymbol_has_method(sym, tos3("str"))) {
					if (is_p) {
						v__gen__Gen_write(g, tos3("),0))"));
					} else {
						v__gen__Gen_write(g, tos3(",0)"));
					}
				} else {
					if (is_p) {
						v__gen__Gen_write(g, tos3(")))"));
					} else {
						v__gen__Gen_write(g, tos3(")"));
					}
				}
			} else if (string_starts_with(v__gen__Gen_typ(g, (*(v__table__Type*)array_get(node.expr_types, i))), tos3("Option"))) {
				string str_fn_name = tos3("Option_str");
				v__gen__Gen_write(g, _STR("%.*s\000(*(Option*)&", 2, str_fn_name));
				v__gen__Gen_expr(g, expr);
				v__gen__Gen_write(g, tos3(")"));
			} else {
				v__gen__verror(tos3("cannot convert to string"));
			}
		} else {
			v__gen__Gen_expr(g, expr);
		}
		if ((*(byte*)array_get(specs, i)) == 's' && (*(int*)array_get(fieldwidths, i)) != 0) {
			v__gen__Gen_write(g, _STR(", %"PRId32"", 1, (*(int*)array_get(fieldwidths, i))));
		}
		if (i < node.exprs.len - 1) {
			v__gen__Gen_write(g, tos3(", "));
		}
	}
	v__gen__Gen_write(g, tos3(")"));
}

static void v__gen__Gen_gen_map(v__gen__Gen* g, v__ast__CallExpr node) {
	string tmp = v__gen__Gen_new_tmp_var(g);
	string s = strings__Builder_after(&g->out, g->stmt_start_pos);
	strings__Builder_go_back(&g->out, s.len);
	string ret_typ = v__gen__Gen_typ(g, node.return_type);
	v__table__TypeSymbol* ret_sym = v__table__Table_get_type_symbol(g->table, node.return_type);
	v__table__TypeSymbol* inp_sym = v__table__Table_get_type_symbol(g->table, node.receiver_type);
	v__table__Array* ret_info = /* as */ (v__table__Array*)__as_cast(ret_sym->info.obj, ret_sym->info.typ, /*expected:*/80);
	string ret_elem_type = v__gen__Gen_typ(g, ret_info->elem_type);
	v__table__Array* inp_info = /* as */ (v__table__Array*)__as_cast(inp_sym->info.obj, inp_sym->info.typ, /*expected:*/80);
	string inp_elem_type = v__gen__Gen_typ(g, inp_info->elem_type);
	if (inp_sym->kind != v__table__Kind_array) {
		v__gen__verror(tos3("map() requires an array"));
	}
	v__gen__Gen_writeln(g, tos3(""));
	v__gen__Gen_write(g, _STR("int %.*s\000_len = ", 2, tmp));
	v__gen__Gen_expr(g, node.left);
	v__gen__Gen_writeln(g, tos3(".len;"));
	v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000 = __new_array(0, %.*s\000_len, sizeof(%.*s\000));", 5, ret_typ, tmp, tmp, ret_elem_type));
	string i = v__gen__Gen_new_tmp_var(g);
	v__gen__Gen_writeln(g, _STR("for (int %.*s\000 = 0; %.*s\000 < %.*s\000_len; %.*s\000++) {", 5, i, i, tmp, i));
	v__gen__Gen_write(g, _STR("\t%.*s\000 it = ((%.*s\000*) ", 3, inp_elem_type, inp_elem_type));
	v__gen__Gen_expr(g, node.left);
	v__gen__Gen_writeln(g, _STR(".data)[%.*s\000];", 2, i));
	v__gen__Gen_write(g, _STR("\t%.*s\000 ti = ", 2, ret_elem_type));
	v__gen__Gen_expr(g, (*(v__ast__CallArg*)array_get(node.args, 0)).expr);
	v__gen__Gen_writeln(g, tos3(";"));
	v__gen__Gen_writeln(g, _STR("\tarray_push(&%.*s\000, &ti);", 2, tmp));
	v__gen__Gen_writeln(g, tos3("}"));
	v__gen__Gen_write(g, s);
	v__gen__Gen_write(g, tmp);
}

static void v__gen__Gen_gen_filter(v__gen__Gen* g, v__ast__CallExpr node) {
	string tmp = v__gen__Gen_new_tmp_var(g);
	string s = strings__Builder_after(&g->out, g->stmt_start_pos);
	strings__Builder_go_back(&g->out, s.len);
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, node.return_type);
	if (sym->kind != v__table__Kind_array) {
		v__gen__verror(tos3("filter() requires an array"));
	}
	v__table__Array* info = /* as */ (v__table__Array*)__as_cast(sym->info.obj, sym->info.typ, /*expected:*/80);
	string styp = v__gen__Gen_typ(g, node.return_type);
	string elem_type_str = v__gen__Gen_typ(g, info->elem_type);
	v__gen__Gen_write(g, _STR("\nint %.*s\000_len = ", 2, tmp));
	v__gen__Gen_expr(g, node.left);
	v__gen__Gen_writeln(g, tos3(".len;"));
	v__gen__Gen_writeln(g, _STR("%.*s\000 %.*s\000 = __new_array(0, %.*s\000_len, sizeof(%.*s\000));", 5, styp, tmp, tmp, elem_type_str));
	v__gen__Gen_writeln(g, _STR("for (int i = 0; i < %.*s\000_len; i++) {", 2, tmp));
	v__gen__Gen_write(g, _STR("  %.*s\000 it = ((%.*s\000*) ", 3, elem_type_str, elem_type_str));
	v__gen__Gen_expr(g, node.left);
	v__gen__Gen_writeln(g, tos3(".data)[i];"));
	v__gen__Gen_write(g, tos3("if ("));
	v__gen__Gen_expr(g, (*(v__ast__CallArg*)array_get(node.args, 0)).expr);
	v__gen__Gen_writeln(g, _STR(") array_push(&%.*s\000, &it); \n }", 2, tmp));
	v__gen__Gen_write(g, s);
	v__gen__Gen_write(g, tos3(" "));
	v__gen__Gen_write(g, tmp);
}

static void v__gen__Gen_insert_before(v__gen__Gen* g, string s) {
	string cur_line = strings__Builder_after(&g->out, g->stmt_start_pos);
	strings__Builder_go_back(&g->out, cur_line.len);
	v__gen__Gen_writeln(g, s);
	v__gen__Gen_write(g, cur_line);
}

static void v__gen__Gen_or_block(v__gen__Gen* g, string var_name, array_v__ast__Stmt stmts, v__table__Type return_type) {
	string cvar_name = v__gen__c_name(var_name);
	string mr_styp = v__gen__Gen_base_type(g, return_type);
	v__gen__Gen_writeln(g, tos3(";"));
	v__gen__Gen_writeln(g, _STR("if (!%.*s\000.ok) {", 2, cvar_name));
	v__gen__Gen_writeln(g, _STR("\tstring err = %.*s\000.v_error;", 2, cvar_name));
	v__gen__Gen_writeln(g, _STR("\tint errcode = %.*s\000.ecode;", 2, cvar_name));
	multi_return_string_string mr_73933 = v__gen__Gen_type_of_last_statement(g, stmts);
	string last_type = mr_73933.arg0;
	string type_of_last_expression = mr_73933.arg1;
	if (string_eq(last_type, tos3("v.ast.ExprStmt")) && string_ne(type_of_last_expression, tos3("void"))) {
		g->indent++;
		// FOR IN array
		array tmp2 = stmts;
		for (int i = 0; i < tmp2.len; i++) {
			v__ast__Stmt stmt = ((v__ast__Stmt*)tmp2.data)[i];
			if (i == stmts.len - 1) {
				g->indent--;
				v__gen__Gen_write(g, _STR("\t*(%.*s\000*) %.*s\000.data = ", 3, mr_styp, cvar_name));
			}
			v__gen__Gen_stmt(g, stmt);
		}
	} else {
		v__gen__Gen_stmts(g, stmts);
	}
	v__gen__Gen_write(g, tos3("}"));
}

static multi_return_string_string v__gen__Gen_type_of_last_statement(v__gen__Gen* g, array_v__ast__Stmt stmts) {
	string last_type = tos3("");
	string last_expr_result_type = tos3("");
	if (stmts.len > 0) {
		v__ast__Stmt last_stmt = (*(v__ast__Stmt*)array_get(stmts, stmts.len - 1));
		last_type = tos3( /* v.ast.Stmt */ v_typeof_sumtype_108( (last_stmt).typ ));
		if (string_eq(last_type, tos3("v.ast.ExprStmt"))) {
			if (last_stmt.typ == 177 /* v.ast.ExprStmt */) {
				v__ast__ExprStmt* it = (v__ast__ExprStmt*)last_stmt.obj; // ST it
				string it_expr_type = tos3( /* v.ast.Expr */ v_typeof_sumtype_133( (it->expr).typ ));
				if (string_eq(it_expr_type, tos3("v.ast.CallExpr"))) {
					v__gen__Gen_writeln(g, _STR("\t // typeof it_expr_type: %.*s", 1, it_expr_type));
					last_expr_result_type = v__gen__Gen_type_of_call_expr(g, it->expr);
				} else {
					last_expr_result_type = it_expr_type;
				}
			}else {
				last_expr_result_type = last_type;
			};
		}
	}
	v__gen__Gen_writeln(g, _STR("\t// last_type: %.*s", 1, last_type));
	v__gen__Gen_writeln(g, _STR("\t// last_expr_result_type: %.*s", 1, last_expr_result_type));
	return (multi_return_string_string){.arg0=last_type,.arg1=last_expr_result_type};
}

static string v__gen__Gen_type_of_call_expr(v__gen__Gen* g, v__ast__Expr node) {
	if (node.typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* it = (v__ast__CallExpr*)node.obj; // ST it
		return v__gen__Gen_typ(g, it->return_type);
	}else {
		return tos3( /* v.ast.Expr */ v_typeof_sumtype_133( (node).typ ));
	};
	return tos3("");
}

static void v__gen__Gen_in_optimization(v__gen__Gen* g, v__ast__Expr left, v__ast__ArrayInit right) {
	bool is_str = right.elem_type == _const_v__table__string_type;
	// FOR IN array
	array tmp1 = right.exprs;
	for (int i = 0; i < tmp1.len; i++) {
		v__ast__Expr array_expr = ((v__ast__Expr*)tmp1.data)[i];
		if (is_str) {
			v__gen__Gen_write(g, tos3("string_eq("));
		}
		v__gen__Gen_expr(g, left);
		if (is_str) {
			v__gen__Gen_write(g, tos3(", "));
		} else {
			v__gen__Gen_write(g, tos3(" == "));
		}
		v__gen__Gen_expr(g, array_expr);
		if (is_str) {
			v__gen__Gen_write(g, tos3(")"));
		}
		if (i < right.exprs.len - 1) {
			v__gen__Gen_write(g, tos3(" || "));
		}
	}
}

static string v__gen__op_to_fn_name(string name) {
	return (string_eq(name, tos3("+"))) ?  ( tos3("_op_plus") )  : (string_eq(name, tos3("-"))) ?  ( tos3("_op_minus") )  : (string_eq(name, tos3("*"))) ?  ( tos3("_op_mul") )  : (string_eq(name, tos3("/"))) ?  ( tos3("_op_div") )  : (string_eq(name, tos3("%"))) ?  ( tos3("_op_mod") )  :  ( _STR("bad op %.*s", 1, name) ) ;
}

static string v__gen__Gen_comp_if_to_ifdef(v__gen__Gen* g, string name, bool is_comptime_optional) {
	if (string_eq(name, tos3("windows"))) {
		return tos3("_WIN32");
	}else if (string_eq(name, tos3("mac"))) {
		return tos3("__APPLE__");
	}else if (string_eq(name, tos3("macos"))) {
		return tos3("__APPLE__");
	}else if (string_eq(name, tos3("linux"))) {
		return tos3("__linux__");
	}else if (string_eq(name, tos3("freebsd"))) {
		return tos3("__FreeBSD__");
	}else if (string_eq(name, tos3("openbsd"))) {
		return tos3("__OpenBSD__");
	}else if (string_eq(name, tos3("netbsd"))) {
		return tos3("__NetBSD__");
	}else if (string_eq(name, tos3("dragonfly"))) {
		return tos3("__DragonFly__");
	}else if (string_eq(name, tos3("android"))) {
		return tos3("__ANDROID__");
	}else if (string_eq(name, tos3("solaris"))) {
		return tos3("__sun");
	}else if (string_eq(name, tos3("haiku"))) {
		return tos3("__haiku__");
	}else if (string_eq(name, tos3("linux_or_macos"))) {
		return tos3("");
	}else if (string_eq(name, tos3("js"))) {
		return tos3("_VJS");
	}else if (string_eq(name, tos3("tinyc"))) {
		return tos3("__TINYC__");
	}else if (string_eq(name, tos3("clang"))) {
		return tos3("__clang__");
	}else if (string_eq(name, tos3("mingw"))) {
		return tos3("__MINGW32__");
	}else if (string_eq(name, tos3("msvc"))) {
		return tos3("_MSC_VER");
	}else if (string_eq(name, tos3("debug"))) {
		return tos3("_VDEBUG");
	}else if (string_eq(name, tos3("glibc"))) {
		return tos3("__GLIBC__");
	}else if (string_eq(name, tos3("prealloc"))) {
		return tos3("VPREALLOC");
	}else if (string_eq(name, tos3("no_bounds_checking"))) {
		return tos3("CUSTOM_DEFINE_no_bounds_checking");
	}else if (string_eq(name, tos3("x64"))) {
		return tos3("TARGET_IS_64BIT");
	}else if (string_eq(name, tos3("x32"))) {
		return tos3("TARGET_IS_32BIT");
	}else if (string_eq(name, tos3("little_endian"))) {
		return tos3("TARGET_ORDER_IS_LITTLE");
	}else if (string_eq(name, tos3("big_endian"))) {
		return tos3("TARGET_ORDER_IS_BIG");
	}else {
		if (is_comptime_optional || g->pref->compile_defines_all.len > 0 && _IN(string, name, g->pref->compile_defines_all)) {
			return _STR("CUSTOM_DEFINE_%.*s", 1, name);
		}
		v__gen__verror(_STR("bad os ifdef name \"%.*s\000\"", 2, name));
	};
	return tos3("");
}

// Attr: [inline]
inline static string v__gen__c_name(string name_) {
	string name = string_replace(name_, tos3("."), tos3("__"));
	if (_IN(string, name, _const_v__gen__c_reserved)) {
		return _STR("v_%.*s", 1, name);
	}
	return name;
}

static string v__gen__Gen_type_default(v__gen__Gen g, v__table__Type typ) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g.table, typ);
	if (sym->kind == v__table__Kind_array) {
		v__table__TypeSymbol* elem_sym = v__table__Table_get_type_symbol(g.table, v__table__TypeSymbol_array_info(sym).elem_type);
		string elem_type_str = string_replace(elem_sym->name, tos3("."), tos3("__"));
		if (string_starts_with(elem_type_str, tos3("C__"))) {
			elem_type_str = string_substr(elem_type_str, 3, elem_type_str.len);
		}
		return _STR("__new_array(0, 1, sizeof(%.*s\000))", 2, elem_type_str);
	}
	if (sym->kind == v__table__Kind_map) {
		string value_type_str = v__gen__Gen_typ(&g, v__table__TypeSymbol_map_info(sym).value_type);
		return _STR("new_map_1(sizeof(%.*s\000))", 2, value_type_str);
	}
	if (v__table__Type_is_ptr(typ)) {
		return tos3("0");
	}
	if (sym->kind == v__table__Kind_struct_) {
		return tos3("{0}");
	}
	int idx = ((int)(typ));
	if (idx >= 1 && idx <= 17) {
		return tos3("0");
	}
	if (string_eq(sym->name, tos3("string"))) {
		return tos3("(string){.str=\"\"}");
	}else if (string_eq(sym->name, tos3("rune"))) {
		return tos3("0");
	}else {
	};
	return tos3("{0}");
}

void v__gen__Gen_write_tests_main(v__gen__Gen* g) {
	strings__Builder_writeln(&g->definitions, tos3("int g_test_oks = 0;"));
	strings__Builder_writeln(&g->definitions, tos3("int g_test_fails = 0;"));
	
// $if  windows {
#ifdef _WIN32
		v__gen__Gen_writeln(g, tos3("int wmain() {"));
	
#else
		v__gen__Gen_writeln(g, tos3("int main() {"));
	
// } windows
#endif

	v__gen__Gen_writeln(g, tos3("\t_vinit();"));
	v__gen__Gen_writeln(g, tos3(""));
	array_string all_tfuncs = v__gen__Gen_get_all_test_function_names(/*rec*/*g);
	if (g->pref->is_stats) {
		v__gen__Gen_writeln(g, _STR("\tBenchedTests bt = start_testing(%"PRId32"\000, tos3(\"%.*s\000\"));", 3, all_tfuncs.len, g->pref->path));
	}
	// FOR IN array
	array tmp2 = all_tfuncs;
	for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
		string t = ((string*)tmp2.data)[tmp3];
		v__gen__Gen_writeln(g, tos3(""));
		if (g->pref->is_stats) {
			v__gen__Gen_writeln(g, _STR("\tBenchedTests_testing_step_start(&bt, tos3(\"%.*s\000\"));", 2, t));
		}
		v__gen__Gen_writeln(g, _STR("\t%.*s\000();", 2, t));
		if (g->pref->is_stats) {
			v__gen__Gen_writeln(g, tos3("\tBenchedTests_testing_step_end(&bt);"));
		}
	}
	v__gen__Gen_writeln(g, tos3(""));
	if (g->pref->is_stats) {
		v__gen__Gen_writeln(g, tos3("\tBenchedTests_end_testing(&bt);"));
	}
	v__gen__Gen_writeln(g, tos3(""));
	if (g->autofree) {
		v__gen__Gen_writeln(g, tos3("\t_vcleanup();"));
	}
	v__gen__Gen_writeln(g, tos3("\treturn g_test_fails > 0;"));
	v__gen__Gen_writeln(g, tos3("}"));
}

static array_string v__gen__Gen_get_all_test_function_names(v__gen__Gen g) {
	array_string tfuncs = __new_array(0, 0, sizeof(string));
	string tsuite_begin = tos3("");
	string tsuite_end = tos3("");
	// FOR IN map
	array_string keys_tmp1 = map_keys(&g.table->fns);
	for (int tmp2 = 0; tmp2 < keys_tmp1.len; tmp2++) {
		string tmp3 = ((string*)keys_tmp1.data)[tmp2];
		v__table__Fn f = (*(v__table__Fn*)map_get3(g.table->fns, tmp3, &(v__table__Fn[]){ {0} }));
		if (string_eq(f.name, tos3("testsuite_begin"))) {
			tsuite_begin = f.name;
			continue;
		}
		if (string_eq(f.name, tos3("testsuite_end"))) {
			tsuite_end = f.name;
			continue;
		}
		if (string_starts_with(f.name, tos3("test_"))) {
			array_push(&tfuncs, &(string[]){ f.name });
			continue;
		}
		if (string_contains(f.name, tos3(".test_"))) {
			array_push(&tfuncs, &(string[]){ f.name });
			continue;
		}
		if (string_ends_with(f.name, tos3(".testsuite_begin"))) {
			tsuite_begin = f.name;
			continue;
		}
		if (string_ends_with(f.name, tos3(".testsuite_end"))) {
			tsuite_end = f.name;
			continue;
		}
	}
	array_string all_tfuncs = __new_array(0, 0, sizeof(string));
	if (tsuite_begin.len > 0) {
		array_push(&all_tfuncs, &(string[]){ tsuite_begin });
	}
	_PUSH_MANY(&all_tfuncs, (tfuncs), tmp14, array_string);
	if (tsuite_end.len > 0) {
		array_push(&all_tfuncs, &(string[]){ tsuite_end });
	}
	array_string all_tfuncs_c = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp17 = all_tfuncs;
	for (int tmp18 = 0; tmp18 < tmp17.len; tmp18++) {
		string f = ((string*)tmp17.data)[tmp18];
		array_push(&all_tfuncs_c, &(string[]){ string_replace(f, tos3("."), tos3("__")) });
	}
	return all_tfuncs_c;
}

static bool v__gen__Gen_is_importing_os(v__gen__Gen g) {
	return _IN(string, tos3("os"), g.table->imports);
}

static void v__gen__Gen_comp_if(v__gen__Gen* g, v__ast__CompIf it) {
	string ifdef = v__gen__Gen_comp_if_to_ifdef(g, it.val, it.is_opt);
	if (it.is_not) {
		v__gen__Gen_writeln(g, string_add(_STR("\n// \$if !%.*s\000 {\n#ifndef ", 2, it.val), ifdef));
	} else {
		v__gen__Gen_writeln(g, string_add(_STR("\n// \$if  %.*s\000 {\n#ifdef ", 2, it.val), ifdef));
	}
	g->defer_ifdef = (it.is_not ?  ( string_add(tos3("\n#ifndef "), ifdef) )  :  ( string_add(tos3("\n#ifdef "), ifdef) ) );
	v__gen__Gen_stmts(g, it.stmts);
	g->defer_ifdef = tos3("");
	if (it.has_else) {
		v__gen__Gen_writeln(g, tos3("\n#else"));
		g->defer_ifdef = (it.is_not ?  ( string_add(tos3("\n#ifdef "), ifdef) )  :  ( string_add(tos3("\n#ifndef "), ifdef) ) );
		v__gen__Gen_stmts(g, it.else_stmts);
		g->defer_ifdef = tos3("");
	}
	v__gen__Gen_writeln(g, _STR("\n// } %.*s\000\n#endif\n", 2, it.val));
}

static void v__gen__Gen_go_stmt(v__gen__Gen* g, v__ast__GoStmt node) {
	string tmp = v__gen__Gen_new_tmp_var(g);
	if (node.call_expr.typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* it = (v__ast__CallExpr*)node.call_expr.obj; // ST it
		string name = it->name;
		if (it->is_method) {
			v__table__TypeSymbol* receiver_sym = v__table__Table_get_type_symbol(g->table, it->receiver_type);
			name = string_add(string_add(receiver_sym->name, tos3("_")), name);
		}
		name = string_replace(name, tos3("."), tos3("__"));
		v__gen__Gen_writeln(g, tos3("// go"));
		string wrapper_struct_name = string_add(tos3("thread_arg_"), name);
		string wrapper_fn_name = string_add(name, tos3("_thread_wrapper"));
		string arg_tmp_var = string_add(tos3("arg_"), tmp);
		v__gen__Gen_writeln(g, _STR("%.*s\000 *%.*s\000 = malloc(sizeof(thread_arg_%.*s\000));", 4, wrapper_struct_name, arg_tmp_var, name));
		if (it->is_method) {
			v__gen__Gen_write(g, _STR("%.*s\000->arg0 = ", 2, arg_tmp_var));
			v__gen__Gen_expr(g, it->left);
			v__gen__Gen_writeln(g, tos3(";"));
		}
		// FOR IN array
		array tmp4 = it->args;
		for (int i = 0; i < tmp4.len; i++) {
			v__ast__CallArg arg = ((v__ast__CallArg*)tmp4.data)[i];
			v__gen__Gen_write(g, _STR("%.*s\000->arg%"PRId32"\000 = ", 3, arg_tmp_var, i + 1));
			v__gen__Gen_expr(g, arg.expr);
			v__gen__Gen_writeln(g, tos3(";"));
		}
		if (g->pref->os == v__pref__OS_windows) {
			v__gen__Gen_writeln(g, _STR("CreateThread(0,0, (LPTHREAD_START_ROUTINE)%.*s\000, %.*s\000, 0,0);", 3, wrapper_fn_name, arg_tmp_var));
		} else {
			v__gen__Gen_writeln(g, _STR("pthread_t thread_%.*s\000;", 2, tmp));
			v__gen__Gen_writeln(g, _STR("pthread_create(&thread_%.*s\000, NULL, (void*)%.*s\000, %.*s\000);", 4, tmp, wrapper_fn_name, arg_tmp_var));
		}
		v__gen__Gen_writeln(g, tos3("// endgo\n"));
		if (_IN(string, name, g->threaded_fns)) {
			return ;
		}
		strings__Builder_writeln(&g->definitions, _STR("\ntypedef struct %.*s\000 {", 2, wrapper_struct_name));
		if (it->is_method) {
			string styp = v__gen__Gen_typ(g, it->receiver_type);
			strings__Builder_writeln(&g->definitions, _STR("\t%.*s\000 arg0;", 2, styp));
		}
		// FOR IN array
		array tmp8 = it->args;
		for (int i = 0; i < tmp8.len; i++) {
			v__ast__CallArg arg = ((v__ast__CallArg*)tmp8.data)[i];
			string styp = v__gen__Gen_typ(g, arg.typ);
			strings__Builder_writeln(&g->definitions, _STR("\t%.*s\000 arg%"PRId32"\000;", 3, styp, i + 1));
		}
		strings__Builder_writeln(&g->definitions, _STR("} %.*s\000;", 2, wrapper_struct_name));
		strings__Builder_writeln(&g->definitions, _STR("void* %.*s\000(%.*s\000 *arg);", 3, wrapper_fn_name, wrapper_struct_name));
		strings__Builder_writeln(&g->gowrappers, _STR("void* %.*s\000(%.*s\000 *arg) {", 3, wrapper_fn_name, wrapper_struct_name));
		strings__Builder_write(&g->gowrappers, _STR("\t%.*s\000(", 2, name));
		if (it->is_method) {
			strings__Builder_write(&g->gowrappers, tos3("arg->arg0"));
			if (it->args.len > 0) {
				strings__Builder_write(&g->gowrappers, tos3(", "));
			}
		}
		for (int tmp11 = 0; tmp11 < it->args.len; tmp11++) {
			int i = tmp11;
			strings__Builder_write(&g->gowrappers, _STR("arg->arg%"PRId32"", 1, i + 1));
			if (i < it->args.len - 1) {
				strings__Builder_write(&g->gowrappers, tos3(", "));
			}
		}
		strings__Builder_writeln(&g->gowrappers, tos3(");"));
		strings__Builder_writeln(&g->gowrappers, tos3("\treturn 0;"));
		strings__Builder_writeln(&g->gowrappers, tos3("}"));
		array_push(&g->threaded_fns, &(string[]){ name });
	}else {
	};
}

static void v__gen__Gen_as_cast(v__gen__Gen* g, v__ast__AsCast node) {
	string styp = v__gen__Gen_typ(g, node.typ);
	v__table__TypeSymbol* expr_type_sym = v__table__Table_get_type_symbol(g->table, node.expr_type);
	if (expr_type_sym->kind == v__table__Kind_sum_type) {
		string dot = (v__table__Type_is_ptr(node.expr_type) ?  ( tos3("->") )  :  ( tos3(".") ) );
		v__gen__Gen_write(g, _STR("/* as */ (%.*s\000*)__as_cast(", 2, styp));
		v__gen__Gen_expr(g, node.expr);
		v__gen__Gen_write(g, dot);
		v__gen__Gen_write(g, tos3("obj, "));
		v__gen__Gen_expr(g, node.expr);
		v__gen__Gen_write(g, dot);
		v__gen__Gen_write(g, _STR("typ, /*expected:*/%"PRId32"\000)", 2, node.typ));
	}
}

static void v__gen__Gen_is_expr(v__gen__Gen* g, v__ast__InfixExpr node) {
	v__gen__Gen_expr(g, node.left);
	if (v__table__Type_is_ptr(node.left_type)) {
		v__gen__Gen_write(g, tos3("->"));
	} else {
		v__gen__Gen_write(g, tos3("."));
	}
	v__gen__Gen_write(g, tos3("typ == "));
	v__gen__Gen_expr(g, node.right);
}

// Attr: [inline]
inline static string v__gen__styp_to_str_fn_name(string styp) {
	return string_add(string_replace(styp, tos3("*"), tos3("_ptr")), tos3("_str"));
}

// Attr: [inline]
inline static string v__gen__Gen_gen_str_for_type(v__gen__Gen* g, v__table__Type typ) {
	string styp = v__gen__Gen_typ(g, typ);
	return v__gen__Gen_gen_str_for_type_with_styp(g, typ, styp);
}

static string v__gen__Gen_gen_str_for_type_with_styp(v__gen__Gen* g, v__table__Type typ, string styp) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, typ);
	string str_fn_name = v__gen__styp_to_str_fn_name(styp);
	string already_generated_key = _STR("%.*s\000:%.*s", 2, styp, str_fn_name);
	if (!v__table__TypeSymbol_has_method(sym, tos3("str")) && !_IN(string, already_generated_key, g->str_types)) {
		array_push(&g->str_types, &(string[]){ already_generated_key });
		if (sym->info.typ == 79 /* v.table.Alias */) {
			v__table__Alias* it = (v__table__Alias*)sym->info.obj; // ST it
			v__gen__Gen_gen_str_default(g, */*d*/sym, styp, str_fn_name);
		}else if (sym->info.typ == 80 /* v.table.Array */) {
			v__table__Array* it = (v__table__Array*)sym->info.obj; // ST it
			v__gen__Gen_gen_str_for_array(g, */*d*/it, styp, str_fn_name);
		}else if (sym->info.typ == 81 /* v.table.ArrayFixed */) {
			v__table__ArrayFixed* it = (v__table__ArrayFixed*)sym->info.obj; // ST it
			v__gen__Gen_gen_str_for_array_fixed(g, */*d*/it, styp, str_fn_name);
		}else if (sym->info.typ == 82 /* v.table.Enum */) {
			v__table__Enum* it = (v__table__Enum*)sym->info.obj; // ST it
			v__gen__Gen_gen_str_for_enum(g, */*d*/it, styp, str_fn_name);
		}else if (sym->info.typ == 87 /* v.table.Struct */) {
			v__table__Struct* it = (v__table__Struct*)sym->info.obj; // ST it
			v__gen__Gen_gen_str_for_struct(g, */*d*/it, styp, str_fn_name);
		}else if (sym->info.typ == 85 /* v.table.Map */) {
			v__table__Map* it = (v__table__Map*)sym->info.obj; // ST it
			v__gen__Gen_gen_str_for_map(g, */*d*/it, styp, str_fn_name);
		}else {
			v__gen__verror(_STR("could not generate string method %.*s\000 for type \'%.*s\000\'", 3, str_fn_name, styp));
		};
	}
	if (v__table__Type_flag_is(typ, v__table__TypeFlag_variadic)) {
		string varg_already_generated_key = _STR("varg_%.*s", 1, already_generated_key);
		if (!_IN(string, varg_already_generated_key, g->str_types)) {
			v__gen__Gen_gen_str_for_varg(g, styp, str_fn_name);
			array_push(&g->str_types, &(string[]){ varg_already_generated_key });
		}
		return _STR("varg_%.*s", 1, str_fn_name);
	}
	return str_fn_name;
}

static void v__gen__Gen_gen_str_default(v__gen__Gen* g, v__table__TypeSymbol sym, string styp, string str_fn_name) {
	string convertor = tos3("");
	string typename = tos3("");
	if (_IN(int, sym.parent_idx, _const_v__table__integer_type_idxs)) {
		convertor = tos3("int");
		typename = tos3("int");
	} else if (sym.parent_idx == _const_v__table__f32_type_idx) {
		convertor = tos3("float");
		typename = tos3("f32");
	} else if (sym.parent_idx == _const_v__table__f64_type_idx) {
		convertor = tos3("double");
		typename = tos3("f64");
	} else if (sym.parent_idx == _const_v__table__bool_type_idx) {
		convertor = tos3("bool");
		typename = tos3("bool");
	} else {
		v__gen__verror(_STR("could not generate string method for type \'%.*s\000\'", 2, styp));
	}
	strings__Builder_writeln(&g->definitions, _STR("string %.*s\000(%.*s\000 it); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 it) {", 3, str_fn_name, styp));
	if (string_eq(convertor, tos3("bool"))) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstring tmp1 = string_add(tos3(\"%.*s\000(\"), (%.*s\000)it ? tos3(\"true\") : tos3(\"false\"));", 3, styp, convertor));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstring tmp1 = string_add(tos3(\"%.*s\000(\"), tos3(%.*s\000_str((%.*s\000)it).str));", 4, styp, typename, convertor));
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstring tmp2 = string_add(tmp1, tos3(\")\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstring_free(&tmp1);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\treturn tmp2;"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("}"));
}

static void v__gen__Gen_gen_str_for_enum(v__gen__Gen* g, v__table__Enum info, string styp, string str_fn_name) {
	string s = string_replace(styp, tos3("."), tos3("__"));
	strings__Builder_writeln(&g->definitions, _STR("string %.*s\000(%.*s\000 it); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 it) { /* gen_str_for_enum */", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tswitch(it) {"));
	// FOR IN array
	array tmp1 = info.vals;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string val = ((string*)tmp1.data)[tmp2];
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tcase %.*s\000_%.*s\000: return tos3(\"%.*s\000\");", 4, s, val, val));
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tdefault: return tos3(\"unknown enum value\");"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("}"));
}

static void v__gen__Gen_gen_str_for_struct(v__gen__Gen* g, v__table__Struct info, string styp, string str_fn_name) {
	map_string_string fnames2strfunc = new_map_init(1, sizeof(string), (string[1]){tos3(""), }, (string[1]){tos3(""), });
	// FOR IN array
	array tmp1 = info.fields;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__Field field = ((v__table__Field*)tmp1.data)[tmp2];
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, field.typ);
		if (!v__table__TypeSymbol_has_method(sym, tos3("str"))) {
			string field_styp = v__gen__Gen_typ(g, field.typ);
			string field_fn_name = v__gen__Gen_gen_str_for_type_with_styp(g, field.typ, field_styp);
			map_set(&fnames2strfunc, field_styp, &(string[]) { field_fn_name });
		}
	}
	strings__Builder_writeln(&g->definitions, _STR("string %.*s\000(%.*s\000 x, int indent_count); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 x, int indent_count) {", 3, str_fn_name, styp));
	string clean_struct_v_type_name = string_replace(styp, tos3("__"), tos3("."));
	if (string_ends_with(styp, tos3("*"))) {
		string deref_typ = string_replace(styp, tos3("*"), tos3(""));
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t%.*s\000 *it = x;", 2, deref_typ));
		clean_struct_v_type_name = string_add(tos3("&"), string_replace(clean_struct_v_type_name, tos3("*"), tos3("")));
	} else {
		string deref_typ = styp;
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t%.*s\000 *it = &x;", 2, deref_typ));
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstring indents = tos3(\"\");"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tfor (int i = 0; i < indent_count; i++) {"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tindents = string_add(indents, tos3(\"    \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\treturn _STR(\"%.*s\000 {\\n\"", 2, clean_struct_v_type_name));
	// FOR IN array
	array tmp5 = info.fields;
	for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
		v__table__Field field = ((v__table__Field*)tmp5.data)[tmp6];
		string fmt = v__gen__Gen_type_to_fmt(/*rec*/*g, field.typ);
		strings__Builder_writeln(&g->auto_str_funcs, string_add(tos3("\t\t\"%.*s\\000    "), _STR("%.*s\000: %.*s\000\\n\"", 3, field.name, fmt)));
	}
	strings__Builder_write(&g->auto_str_funcs, _STR("\t\t\"%%.*s\\000}\", %"PRId32"", 1, 2 * (info.fields.len + 1)));
	if (info.fields.len > 0) {
		strings__Builder_write(&g->auto_str_funcs, tos3(",\n\t\t"));
		// FOR IN array
		array tmp8 = info.fields;
		for (int i = 0; i < tmp8.len; i++) {
			v__table__Field field = ((v__table__Field*)tmp8.data)[i];
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, field.typ);
			bool has_custom_str = v__table__TypeSymbol_has_method(sym, tos3("str"));
			string second_str_param = (has_custom_str ?  ( tos3("") )  :  ( tos3(", indent_count + 1") ) );
			string field_styp = v__gen__Gen_typ(g, field.typ);
			string field_styp_fn_name = (has_custom_str ?  ( _STR("%.*s\000_str", 2, field_styp) )  :  ( (*(string*)map_get3(fnames2strfunc, field_styp, &(string[]){ (string){.str=""} })) ) );
			if (sym->kind == v__table__Kind_enum_) {
				strings__Builder_write(&g->auto_str_funcs, tos3("indents, "));
				strings__Builder_write(&g->auto_str_funcs, _STR("%.*s\000( it->%.*s\000 ) ", 3, field_styp_fn_name, field.name));
			} else if (sym->kind == v__table__Kind_struct_) {
				strings__Builder_write(&g->auto_str_funcs, tos3("indents, "));
				strings__Builder_write(&g->auto_str_funcs, _STR("%.*s\000( it->%.*s\000%.*s\000 ) ", 4, field_styp_fn_name, field.name, second_str_param));
			} else if ((sym->kind == v__table__Kind_array || sym->kind == v__table__Kind_array_fixed || sym->kind == v__table__Kind_map)) {
				strings__Builder_write(&g->auto_str_funcs, tos3("indents, "));
				strings__Builder_write(&g->auto_str_funcs, _STR("%.*s\000( it->%.*s\000) ", 3, field_styp_fn_name, field.name));
			} else {
				strings__Builder_write(&g->auto_str_funcs, _STR("indents, it->%.*s", 1, field.name));
				if (field.typ == _const_v__table__bool_type) {
					strings__Builder_write(&g->auto_str_funcs, tos3(" ? _SLIT(\"true\") : _SLIT(\"false\")"));
				}
			}
			if (i < info.fields.len - 1) {
				strings__Builder_write(&g->auto_str_funcs, tos3(",\n\t\t"));
			}
		}
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos3(","));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tindents);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("}"));
}

static void v__gen__Gen_gen_str_for_array(v__gen__Gen* g, v__table__Array info, string styp, string str_fn_name) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, info.elem_type);
	string field_styp = v__gen__Gen_typ(g, info.elem_type);
	if (!v__table__TypeSymbol_has_method(sym, tos3("str"))) {
		v__gen__Gen_gen_str_for_type_with_styp(g, info.elem_type, field_styp);
	}
	strings__Builder_writeln(&g->definitions, _STR("string %.*s\000(%.*s\000 a); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 a) {", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstrings__Builder sb = strings__new_builder(a.len * 10);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstrings__Builder_write(&sb, tos3(\"[\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tfor (int i = 0; i < a.len; i++) {"));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\t%.*s\000 it = (*(%.*s\000*)array_get(a, i));", 3, field_styp, field_styp));
	if (sym->kind == v__table__Kind_struct_ && !v__table__TypeSymbol_has_method(sym, tos3("str"))) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = %.*s\000_str(it,0);", 2, field_styp));
	} else if ((sym->kind == v__table__Kind_f32 || sym->kind == v__table__Kind_f64)) {
		strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tstring x = _STR(\"%g\", 1, it);"));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstring x = %.*s\000_str(it);", 2, field_styp));
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tstrings__Builder_write(&sb, x);"));
	if (g->pref->autofree && info.elem_type != _const_v__table__bool_type) {
		strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tstring_free(&x);"));
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tif (i < a.len-1) {"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\t\tstrings__Builder_write(&sb, tos3(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstrings__Builder_write(&sb, tos3(\"]\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstring res = strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstrings__Builder_free(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\treturn res;"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("}"));
}

static void v__gen__Gen_gen_str_for_array_fixed(v__gen__Gen* g, v__table__ArrayFixed info, string styp, string str_fn_name) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, info.elem_type);
	string field_styp = v__gen__Gen_typ(g, info.elem_type);
	if (!v__table__TypeSymbol_has_method(sym, tos3("str"))) {
		v__gen__Gen_gen_str_for_type_with_styp(g, info.elem_type, field_styp);
	}
	strings__Builder_writeln(&g->definitions, _STR("string %.*s\000(%.*s\000 a); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 a) {", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\tstrings__Builder sb = strings__new_builder(%"PRId32"\000 * 10);", 2, info.size));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstrings__Builder_write(&sb, tos3(\"[\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\tfor (int i = 0; i < %"PRId32"\000; i++) {", 2, info.size));
	if (sym->kind == v__table__Kind_struct_ && !v__table__TypeSymbol_has_method(sym, tos3("str"))) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write(&sb, %.*s\000_str(a[i],0));", 2, field_styp));
	} else if ((sym->kind == v__table__Kind_f32 || sym->kind == v__table__Kind_f64)) {
		strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tstrings__Builder_write(&sb, _STR(\"%g\", 1, a[i]));"));
	} else if (sym->kind == v__table__Kind_string) {
		strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tstrings__Builder_write(&sb, _STR(\"\'%.*s\\000\'\", 2, a[i]));"));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write(&sb, %.*s\000_str(a[i]));", 2, field_styp));
	}
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tif (i < %"PRId32"\000) {", 2, info.size - 1));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\t\tstrings__Builder_write(&sb, tos3(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstrings__Builder_write(&sb, tos3(\"]\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\treturn strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("}"));
}

static void v__gen__Gen_gen_str_for_map(v__gen__Gen* g, v__table__Map info, string styp, string str_fn_name) {
	v__table__TypeSymbol* key_sym = v__table__Table_get_type_symbol(g->table, info.key_type);
	string key_styp = v__gen__Gen_typ(g, info.key_type);
	if (!v__table__TypeSymbol_has_method(key_sym, tos3("str"))) {
		v__gen__Gen_gen_str_for_type_with_styp(g, info.key_type, key_styp);
	}
	v__table__TypeSymbol* val_sym = v__table__Table_get_type_symbol(g->table, info.value_type);
	string val_styp = v__gen__Gen_typ(g, info.value_type);
	if (!v__table__TypeSymbol_has_method(val_sym, tos3("str"))) {
		v__gen__Gen_gen_str_for_type_with_styp(g, info.value_type, val_styp);
	}
	string zero = v__gen__Gen_type_default(/*rec*/*g, info.value_type);
	strings__Builder_writeln(&g->definitions, _STR("string %.*s\000(%.*s\000 m); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string %.*s\000(%.*s\000 m) { /* gen_str_for_map */", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstrings__Builder sb = strings__new_builder(m.key_values.size*10);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstrings__Builder_write(&sb, tos3(\"{\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tfor (unsigned int i = 0; i < m.key_values.size; i++) {"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tstring key = (*(string*)DenseArray_get(m.key_values, i));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tstrings__Builder_write(&sb, _STR(\"\'%.*s\\000\'\", 2, key));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tstrings__Builder_write(&sb, tos3(\": \"));"));
	strings__Builder_write(&g->auto_str_funcs, _STR("\t%.*s\000 it = (*(%.*s\000*)map_get3(", 3, val_styp, val_styp));
	strings__Builder_write(&g->auto_str_funcs, tos3("m, (*(string*)DenseArray_get(m.key_values, i))"));
	strings__Builder_write(&g->auto_str_funcs, tos3(", "));
	strings__Builder_writeln(&g->auto_str_funcs, _STR(" &(%.*s\000[]) { %.*s\000 }));", 3, val_styp, zero));
	if (val_sym->kind == v__table__Kind_string) {
		strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tstrings__Builder_write(&sb, _STR(\"\'%.*s\\000\'\", 2, it));"));
	} else if (val_sym->kind == v__table__Kind_struct_ && !v__table__TypeSymbol_has_method(val_sym, tos3("str"))) {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write(&sb, %.*s\000_str(it,0));", 2, val_styp));
	} else if ((val_sym->kind == v__table__Kind_f32 || val_sym->kind == v__table__Kind_f64)) {
		strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tstrings__Builder_write(&sb, _STR(\"%g\", 1, it));"));
	} else {
		strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write(&sb, %.*s\000_str(it));", 2, val_styp));
	}
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tif (i != m.key_values.size-1) {"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\t\tstrings__Builder_write(&sb, tos3(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstrings__Builder_write(&sb, tos3(\"}\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\treturn strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("}"));
}

static void v__gen__Gen_gen_str_for_varg(v__gen__Gen* g, string styp, string str_fn_name) {
	strings__Builder_writeln(&g->definitions, _STR("string varg_%.*s\000(varg_%.*s\000 it); // auto", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("string varg_%.*s\000(varg_%.*s\000 it) {", 3, str_fn_name, styp));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstrings__Builder sb = strings__new_builder(it.len);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstrings__Builder_write(&sb, tos3(\"[\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tfor(int i=0; i<it.len; i++) {"));
	strings__Builder_writeln(&g->auto_str_funcs, _STR("\t\tstrings__Builder_write(&sb, %.*s\000(it.args[i], 0));", 2, str_fn_name));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\tif (i < it.len-1) {"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\t\tstrings__Builder_write(&sb, tos3(\", \"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\t}"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\tstrings__Builder_write(&sb, tos3(\"]\"));"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("\treturn strings__Builder_str(&sb);"));
	strings__Builder_writeln(&g->auto_str_funcs, tos3("}"));
}

static string v__gen__Gen_type_to_fmt(v__gen__Gen g, v__table__Type typ) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g.table, typ);
	if ((sym->kind == v__table__Kind_struct_ || sym->kind == v__table__Kind_array || sym->kind == v__table__Kind_array_fixed || sym->kind == v__table__Kind_map)) {
		return tos3("%.*s\\000");
	} else if (typ == _const_v__table__string_type) {
		return tos3("\'%.*s\\000\'");
	} else if (typ == _const_v__table__bool_type) {
		return tos3("%.*s\\000");
	} else if (sym->kind == v__table__Kind_enum_) {
		return tos3("%.*s\\000");
	} else if ((typ == _const_v__table__f32_type || typ == _const_v__table__f64_type)) {
		return tos3("%g\\000");
	}
	return tos3("%d\\000");
}

static string v__gen__Gen_interface_table(v__gen__Gen* g) {
	strings__Builder sb = strings__new_builder(100);
	// FOR IN array
	array tmp1 = g->table->types;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__TypeSymbol ityp = ((v__table__TypeSymbol*)tmp1.data)[tmp2];
		if (ityp.kind != v__table__Kind_interface_) {
			continue;
		}
		v__table__Interface* inter_info = /* as */ (v__table__Interface*)__as_cast(ityp.info.obj, ityp.info.typ, /*expected:*/84);
		if (inter_info->types.len == 0) {
			continue;
		}
		strings__Builder_writeln(&sb, _STR("// NR interfaced types= %"PRId32"", 1, inter_info->types.len));
		string interface_name = v__gen__c_name(ityp.name);
		string methods_struct_name = _STR("struct _%.*s\000_interface_methods", 2, interface_name);
		strings__Builder methods_typ_def = strings__new_builder(100);
		strings__Builder methods_struct_def = strings__new_builder(100);
		strings__Builder_writeln(&methods_struct_def, _STR("%.*s\000 {", 2, methods_struct_name));
		map_string_string imethods = new_map_1(sizeof(string));
		// FOR IN array
		array tmp5 = ityp.methods;
		for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
			v__table__Fn method = ((v__table__Fn*)tmp5.data)[tmp6];
			string typ_name = _STR("_%.*s\000_%.*s\000_fn", 3, interface_name, method.name);
			string ret_styp = v__gen__Gen_typ(g, method.return_type);
			strings__Builder_write(&methods_typ_def, _STR("typedef %.*s\000 (*%.*s\000)(void* _", 3, ret_styp, typ_name));
			for (int tmp7 = 1; tmp7 < method.args.len; tmp7++) {
				int i = tmp7;
				v__table__Arg arg = (*(v__table__Arg*)array_get(method.args, i));
				strings__Builder_write(&methods_typ_def, _STR(", %.*s\000 %.*s", 2, v__gen__Gen_typ(g, arg.typ), arg.name));
			}
			strings__Builder_writeln(&methods_typ_def, tos3(");"));
			strings__Builder_writeln(&methods_struct_def, _STR("\t%.*s\000 %.*s\000;", 3, typ_name, v__gen__c_name(method.name)));
			map_set(&imethods, method.name, &(string[]) { typ_name });
		}
		strings__Builder_writeln(&methods_struct_def, tos3("};"));
		strings__Builder methods_struct = strings__new_builder(100);
		strings__Builder_writeln(&methods_struct, _STR("%.*s\000 %.*s\000_name_table[%"PRId32"\000] = {", 4, methods_struct_name, interface_name, inter_info->types.len));
		strings__Builder cast_functions = strings__new_builder(100);
		strings__Builder_write(&cast_functions, _STR("// Casting functions for interface \"%.*s\000\"", 2, interface_name));
		strings__Builder methods_wrapper = strings__new_builder(100);
		strings__Builder_writeln(&methods_wrapper, _STR("// Methods wrapper for interface \"%.*s\000\"", 2, interface_name));
		// FOR IN array
		array tmp8 = inter_info->types;
		for (int i = 0; i < tmp8.len; i++) {
			v__table__Type st = ((v__table__Type*)tmp8.data)[i];
			string cctype = v__gen__Gen_cc_type(g, st);
			string interface_index_name = _STR("_%.*s\000_%.*s\000_index", 3, interface_name, cctype);
			strings__Builder_writeln(&cast_functions, _STR("\n_Interface I_%.*s\000_to_Interface_%.*s\000(%.*s\000* x) {\n	return (_Interface) {\n		._object = (void*) (x),\n		._interface_idx = %.*s\000\n	};\n}", 5, cctype, interface_name, cctype, interface_index_name));
			strings__Builder_writeln(&methods_struct, tos3("\t{"));
			v__table__TypeSymbol* st_sym = v__table__Table_get_type_symbol(g->table, st);
			// FOR IN array
			array tmp9 = st_sym->methods;
			for (int tmp10 = 0; tmp10 < tmp9.len; tmp10++) {
				v__table__Fn method = ((v__table__Fn*)tmp9.data)[tmp10];
				if (!_IN_MAP(method.name, imethods)) {
					continue;
				}
				string method_call = _STR("%.*s\000_%.*s", 2, cctype, method.name);
				if (!v__table__Type_is_ptr((*(v__table__Arg*)array_get(method.args, 0)).typ)) {
					strings__Builder_write(&methods_wrapper, _STR("static inline %.*s", 1, v__gen__Gen_typ(g, method.return_type)));
					strings__Builder_write(&methods_wrapper, _STR(" %.*s\000_method_wrapper(", 2, method_call));
					strings__Builder_write(&methods_wrapper, _STR("%.*s\000* %.*s", 2, cctype, (*(v__table__Arg*)array_get(method.args, 0)).name));
					for (int tmp13 = 1; tmp13 < method.args.len; tmp13++) {
						int j = tmp13;
						v__table__Arg arg = (*(v__table__Arg*)array_get(method.args, j));
						strings__Builder_write(&methods_wrapper, _STR(", %.*s\000 %.*s", 2, v__gen__Gen_typ(g, arg.typ), arg.name));
					}
					strings__Builder_writeln(&methods_wrapper, tos3(") {"));
					strings__Builder_write(&methods_wrapper, tos3("\t"));
					if (method.return_type != _const_v__table__void_type) {
						strings__Builder_write(&methods_wrapper, tos3("return "));
					}
					strings__Builder_write(&methods_wrapper, _STR("%.*s\000(*%.*s", 2, method_call, (*(v__table__Arg*)array_get(method.args, 0)).name));
					for (int tmp15 = 1; tmp15 < method.args.len; tmp15++) {
						int j = tmp15;
						strings__Builder_write(&methods_wrapper, _STR(", %.*s", 1, (*(v__table__Arg*)array_get(method.args, j)).name));
					}
					strings__Builder_writeln(&methods_wrapper, tos3(");"));
					strings__Builder_writeln(&methods_wrapper, tos3("}"));
					method_call = string_add(method_call, tos3("_method_wrapper"));
				}
				strings__Builder_writeln(&methods_struct, _STR("\t\t.%.*s\000 = %.*s\000,", 3, v__gen__c_name(method.name), method_call));
			}
			strings__Builder_writeln(&methods_struct, tos3("\t},"));
			strings__Builder_writeln(&sb, _STR("int %.*s\000 = %"PRId32"\000;", 3, interface_index_name, i));
		}
		strings__Builder_writeln(&methods_struct, tos3("};"));
		strings__Builder_writeln(&sb, tos3(""));
		strings__Builder_writeln(&sb, strings__Builder_str(&methods_wrapper));
		strings__Builder_writeln(&sb, strings__Builder_str(&methods_typ_def));
		strings__Builder_writeln(&sb, strings__Builder_str(&methods_struct_def));
		strings__Builder_writeln(&sb, strings__Builder_str(&methods_struct));
		strings__Builder_writeln(&sb, strings__Builder_str(&cast_functions));
	}
	return strings__Builder_str(&sb);
}

static void v__gen__Gen_array_init(v__gen__Gen* g, v__ast__ArrayInit it) {
	v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(g->table, it.typ);
	if (type_sym->kind == v__table__Kind_array_fixed) {
		v__gen__Gen_write(g, tos3("{"));
		// FOR IN array
		array tmp2 = it.exprs;
		for (int i = 0; i < tmp2.len; i++) {
			v__ast__Expr expr = ((v__ast__Expr*)tmp2.data)[i];
			v__gen__Gen_expr(g, expr);
			if (i != it.exprs.len - 1) {
				v__gen__Gen_write(g, tos3(", "));
			}
		}
		v__gen__Gen_write(g, tos3("}"));
		return ;
	}
	string elem_type_str = v__gen__Gen_typ(g, it.elem_type);
	if (it.exprs.len == 0) {
		v__gen__Gen_write(g, tos3("__new_array("));
		if (it.has_len) {
			v__gen__Gen_expr(g, it.len_expr);
			v__gen__Gen_write(g, tos3(", "));
		} else {
			v__gen__Gen_write(g, tos3("0, "));
		}
		if (it.has_cap) {
			v__gen__Gen_expr(g, it.cap_expr);
			v__gen__Gen_write(g, tos3(", "));
		} else {
			v__gen__Gen_write(g, tos3("0, "));
		}
		v__gen__Gen_write(g, _STR("sizeof(%.*s\000))", 2, elem_type_str));
		return ;
	}
	int len = it.exprs.len;
	v__gen__Gen_write(g, _STR("new_array_from_c_array(%"PRId32"\000, %"PRId32"\000, sizeof(%.*s\000), ", 4, len, len, elem_type_str));
	v__gen__Gen_write(g, _STR("(%.*s\000[%"PRId32"\000]){\n\t\t", 3, elem_type_str, len));
	// FOR IN array
	array tmp7 = it.exprs;
	for (int i = 0; i < tmp7.len; i++) {
		v__ast__Expr expr = ((v__ast__Expr*)tmp7.data)[i];
		if (it.is_interface) {
			v__gen__Gen_interface_call(g, (*(v__table__Type*)array_get(it.interface_types, i)), it.interface_type);
		}
		v__gen__Gen_expr(g, expr);
		if (it.is_interface) {
			v__gen__Gen_write(g, tos3(")"));
		}
		v__gen__Gen_write(g, tos3(", "));
	}
	v__gen__Gen_write(g, tos3("\n})"));
}

static void v__gen__Gen_interface_call(v__gen__Gen* g, v__table__Type typ, v__table__Type interface_type) {
	string interface_styp = v__gen__Gen_cc_type(g, interface_type);
	string styp = v__gen__Gen_cc_type(g, typ);
	v__gen__Gen_write(g, _STR("/* %.*s\000 */ I_%.*s\000_to_Interface_%.*s\000(", 4, interface_styp, styp, interface_styp));
	if (!v__table__Type_is_ptr(typ)) {
		v__gen__Gen_write(g, tos3("&"));
	}
}

static void v__gen__Gen_gen_fn_decl(v__gen__Gen* g, v__ast__FnDecl it) {
	if (it.is_c) {
		return ;
	}
	bool is_main = string_eq(it.name, tos3("main"));
	if (is_main && g->pref->is_liveshared) {
		return ;
	}
	int fn_start_pos = g->out.len;
	if (string_eq(g->attr, tos3("inline"))) {
		v__gen__Gen_write(g, tos3("inline "));
	}
	bool is_livefn = string_eq(g->attr, tos3("live"));
	bool is_livemain = g->pref->is_livemain && is_livefn;
	bool is_liveshared = g->pref->is_liveshared && is_livefn;
	bool is_livemode = g->pref->is_livemain || g->pref->is_liveshared;
	bool is_live_wrap = is_livefn && is_livemode;
	if (is_livefn && !is_livemode) {
		eprintln(_STR("INFO: compile with `v -live %.*s\000 `, if you want to use the [live] function %.*s\000 .", 3, g->pref->path, it.name));
	}
	v__gen__Gen_reset_tmp_count(g);
	if (is_main) {
		if (g->pref->os == v__pref__OS_windows) {
			if (v__gen__Gen_is_gui_app(g)) {
				v__gen__Gen_writeln(g, tos3("int WINAPI wWinMain(HINSTANCE instance, HINSTANCE prev_instance, LPWSTR cmd_line, int show_cmd){"));
				g->last_fn_c_name = tos3("wWinMain");
			} else {
				v__gen__Gen_writeln(g, tos3("int wmain(int ___argc, wchar_t* ___argv[], wchar_t* ___envp[]){"));
				g->last_fn_c_name = tos3("wmain");
			}
		} else {
			v__gen__Gen_writeln(g, tos3("int main(int ___argc, char** ___argv){"));
			g->last_fn_c_name = it.name;
		}
	} else {
		string name = it.name;
		if ((string_at(name, 0) == '+' || string_at(name, 0) == '-' || string_at(name, 0) == '*' || string_at(name, 0) == '/' || string_at(name, 0) == '%')) {
			name = v__util__replace_op(name);
		}
		if (it.is_method) {
			name = string_add(string_add(v__table__Table_get_type_symbol(g->table, it.receiver.typ)->name, tos3("_")), name);
		}
		if (it.is_c) {
			name = string_replace(name, tos3("."), tos3("__"));
		} else {
			name = v__gen__c_name(name);
		}
		if (is_livemain) {
			array_push(&g->hotcode_fn_names, &(string[]){ name });
		}
		string impl_fn_name = (is_live_wrap ?  ( _STR("impl_live_%.*s", 1, name) )  :  ( name ) );
		g->last_fn_c_name = impl_fn_name;
		string type_name = v__gen__Gen_typ(g, it.return_type);
		if (is_live_wrap) {
			if (is_livemain) {
				strings__Builder_write(&g->definitions, _STR("%.*s\000 (* %.*s\000)(", 3, type_name, impl_fn_name));
				v__gen__Gen_write(g, _STR("%.*s\000 no_impl_%.*s\000(", 3, type_name, name));
			}
			if (is_liveshared) {
				strings__Builder_write(&g->definitions, _STR("%.*s\000 %.*s\000(", 3, type_name, impl_fn_name));
				v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000(", 3, type_name, impl_fn_name));
			}
		} else {
			if (!it.is_pub) {
				v__gen__Gen_write(g, tos3("static "));
				strings__Builder_write(&g->definitions, tos3("static "));
			}
			strings__Builder_write(&g->definitions, _STR("%.*s\000 %.*s\000(", 3, type_name, name));
			v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000(", 3, type_name, name));
		}
		multi_return_array_string_array_string mr_2825 = v__gen__Gen_fn_args(g, it.args, it.is_variadic);
		array_string fargs = mr_2825.arg0;
		array_string fargtypes = mr_2825.arg1;
		if (it.no_body || (g->pref->use_cache && it.is_builtin)) {
			strings__Builder_writeln(&g->definitions, tos3(");"));
			v__gen__Gen_writeln(g, tos3(");"));
			return ;
		}
		strings__Builder_writeln(&g->definitions, tos3(");"));
		v__gen__Gen_writeln(g, tos3(") {"));
		if (is_live_wrap) {
			array_string fn_args_list = __new_array(0, 0, sizeof(string));
			// FOR IN array
			array tmp20 = fargs;
			for (int ia = 0; ia < tmp20.len; ia++) {
				string fa = ((string*)tmp20.data)[ia];
				array_push(&fn_args_list, &(string[]){ _STR("%.*s\000 %.*s", 2, (*(string*)array_get(fargtypes, ia)), fa) });
			}
			string live_fncall = string_add(string_add(_STR("%.*s\000(", 2, impl_fn_name), array_string_join(fargs, tos3(", "))), tos3(");"));
			string live_fnreturn = tos3("");
			if (string_ne(type_name, tos3("void"))) {
				live_fncall = _STR("%.*s\000 res = %.*s", 2, type_name, live_fncall);
				live_fnreturn = tos3("return res;");
			}
			strings__Builder_writeln(&g->definitions, string_add(string_add(_STR("%.*s\000 %.*s\000(", 3, type_name, name), array_string_join(fn_args_list, tos3(", "))), tos3(");")));
			strings__Builder_writeln(&g->hotcode_definitions, string_add(string_add(_STR("%.*s\000 %.*s\000(", 3, type_name, name), array_string_join(fn_args_list, tos3(", "))), tos3("){")));
			strings__Builder_writeln(&g->hotcode_definitions, tos3("  pthread_mutex_lock(&live_fn_mutex);"));
			strings__Builder_writeln(&g->hotcode_definitions, _STR("  %.*s", 1, live_fncall));
			strings__Builder_writeln(&g->hotcode_definitions, tos3("  pthread_mutex_unlock(&live_fn_mutex);"));
			strings__Builder_writeln(&g->hotcode_definitions, _STR("  %.*s", 1, live_fnreturn));
			strings__Builder_writeln(&g->hotcode_definitions, tos3("}"));
		}
	}
	if (is_main) {
		if (g->pref->os == v__pref__OS_windows && v__gen__Gen_is_gui_app(g)) {
			v__gen__Gen_writeln(g, tos3("\ttypedef LPWSTR*(WINAPI *cmd_line_to_argv)(LPCWSTR, int*);"));
			v__gen__Gen_writeln(g, tos3("\tHMODULE shell32_module = LoadLibrary(L\"shell32.dll\");"));
			v__gen__Gen_writeln(g, tos3("\tcmd_line_to_argv CommandLineToArgvW = (cmd_line_to_argv)GetProcAddress(shell32_module, \"CommandLineToArgvW\");"));
			v__gen__Gen_writeln(g, tos3("\tint ___argc;"));
			v__gen__Gen_writeln(g, tos3("\twchar_t** ___argv = CommandLineToArgvW(cmd_line, &___argc);"));
		}
		v__gen__Gen_writeln(g, tos3("\t_vinit();"));
		if (v__gen__Gen_is_importing_os(/*rec*/*g)) {
			if (g->autofree) {
				v__gen__Gen_writeln(g, tos3("free(_const_os__args.data); // empty, inited in _vinit()"));
			}
			if (g->pref->os == v__pref__OS_windows) {
				v__gen__Gen_writeln(g, tos3("\t_const_os__args = os__init_os_args_wide(___argc, ___argv);"));
			} else {
				v__gen__Gen_writeln(g, tos3("\t_const_os__args = os__init_os_args(___argc, (byteptr*)___argv);"));
			}
		}
	}
	if (g->pref->is_livemain && is_main) {
		v__gen__Gen_generate_hotcode_reloading_main_caller(g);
	}
	if (g->pref->is_prof) {
		v__gen__Gen_profile_fn(g, it.name, is_main);
	}
	v__gen__Gen_stmts(g, it.stmts);
	if (is_main) {
		if (g->autofree) {
			v__gen__Gen_writeln(g, tos3("\t_vcleanup();"));
		}
		if (g->is_test) {
			v__gen__verror(tos3("test files cannot have function `main`"));
		}
	}
	v__gen__Gen_write_defer_stmts_when_needed(g);
	if (g->autofree) {
		v__gen__Gen_writeln(g, v__gen__Gen_autofree_scope_vars(g, it.body_pos.pos));
	}
	if (is_main) {
		v__gen__Gen_writeln(g, tos3("\treturn 0;"));
	}
	v__gen__Gen_writeln(g, tos3("}"));
	g->defer_stmts = __new_array(0, 0, sizeof(v__ast__DeferStmt));
	if (g->pref->printfn_list.len > 0 && _IN(string, g->last_fn_c_name, g->pref->printfn_list)) {
		println(strings__Builder_after(&g->out, fn_start_pos));
	}
}

static void v__gen__Gen_write_autofree_stmts_when_needed(v__gen__Gen* g, v__ast__Return r) {
}

static void v__gen__Gen_write_defer_stmts_when_needed(v__gen__Gen* g) {
	if (g->defer_stmts.len > 0) {
		v__gen__Gen_write_defer_stmts(g);
	}
	if (g->defer_profile_code.len > 0) {
		v__gen__Gen_writeln(g, tos3(""));
		v__gen__Gen_writeln(g, tos3("\t// defer_profile_code"));
		v__gen__Gen_writeln(g, g->defer_profile_code);
		v__gen__Gen_writeln(g, tos3(""));
	}
}

static multi_return_array_string_array_string v__gen__Gen_fn_args(v__gen__Gen* g, array_v__table__Arg args, bool is_variadic) {
	array_string fargs = __new_array(0, 0, sizeof(string));
	array_string fargtypes = __new_array(0, 0, sizeof(string));
	bool no_names = args.len > 0 && string_eq((*(v__table__Arg*)array_get(args, 0)).name, tos3("arg_1"));
	// FOR IN array
	array tmp1 = args;
	for (int i = 0; i < tmp1.len; i++) {
		v__table__Arg arg = ((v__table__Arg*)tmp1.data)[i];
		string caname = v__gen__c_name(arg.name);
		v__table__TypeSymbol* arg_type_sym = v__table__Table_get_type_symbol(g->table, arg.typ);
		string arg_type_name = v__gen__Gen_typ(g, arg.typ);
		bool is_varg = i == args.len - 1 && is_variadic;
		if (is_varg) {
			string varg_type_str = int_str(((int)(arg.typ)));
			if (!_IN_MAP(varg_type_str, g->variadic_args)) {
				map_set(&g->variadic_args, varg_type_str, &(int[]) { 0 });
			}
			arg_type_name = string_add(tos3("varg_"), string_replace(v__gen__Gen_typ(g, arg.typ), tos3("*"), tos3("_ptr")));
		}
		if (arg_type_sym->kind == v__table__Kind_function) {
			v__table__FnType* info = /* as */ (v__table__FnType*)__as_cast(arg_type_sym->info.obj, arg_type_sym->info.typ, /*expected:*/83);
			v__table__Fn func = info->func;
			if (!info->is_anon) {
				v__gen__Gen_write(g, string_add(string_add(arg_type_name, tos3(" ")), caname));
				strings__Builder_write(&g->definitions, string_add(string_add(arg_type_name, tos3(" ")), caname));
				array_push(&fargs, &(string[]){ caname });
				array_push(&fargtypes, &(string[]){ arg_type_name });
			} else {
				v__gen__Gen_write(g, _STR("%.*s\000 (*%.*s\000)(", 3, v__gen__Gen_typ(g, func.return_type), caname));
				strings__Builder_write(&g->definitions, _STR("%.*s\000 (*%.*s\000)(", 3, v__gen__Gen_typ(g, func.return_type), caname));
				v__gen__Gen_fn_args(g, func.args, func.is_variadic);
				v__gen__Gen_write(g, tos3(")"));
				strings__Builder_write(&g->definitions, tos3(")"));
			}
		} else if (no_names) {
			v__gen__Gen_write(g, arg_type_name);
			strings__Builder_write(&g->definitions, arg_type_name);
			array_push(&fargs, &(string[]){ tos3("") });
			array_push(&fargtypes, &(string[]){ arg_type_name });
		} else {
			int nr_muls = v__table__Type_nr_muls(arg.typ);
			string s = string_add(string_add(arg_type_name, tos3(" ")), caname);
			if (arg.is_mut) {
				nr_muls = 1;
			}
			v__gen__Gen_write(g, s);
			strings__Builder_write(&g->definitions, s);
			array_push(&fargs, &(string[]){ caname });
			array_push(&fargtypes, &(string[]){ arg_type_name });
		}
		if (i < args.len - 1) {
			v__gen__Gen_write(g, tos3(", "));
			strings__Builder_write(&g->definitions, tos3(", "));
		}
	}
	return (multi_return_array_string_array_string){.arg0=fargs,.arg1=fargtypes};
}

static void v__gen__Gen_call_expr(v__gen__Gen* g, v__ast__CallExpr node) {
	if (node.should_be_skipped) {
		return ;
	}
	bool gen_or = !g->is_assign_rhs && node.or_block.stmts.len > 0;
	string tmp_opt = (gen_or ?  ( v__gen__Gen_new_tmp_var(g) )  :  ( tos3("") ) );
	if (gen_or) {
		string styp = v__gen__Gen_typ(g, node.return_type);
		v__gen__Gen_write(g, _STR("%.*s\000 %.*s\000 = ", 3, styp, tmp_opt));
	}
	if (node.is_method) {
		v__gen__Gen_method_call(g, node);
	} else {
		v__gen__Gen_fn_call(g, node);
	}
	if (gen_or) {
		v__gen__Gen_or_block(g, tmp_opt, node.or_block.stmts, node.return_type);
	}
}

static void v__gen__Gen_method_call(v__gen__Gen* g, v__ast__CallExpr node) {
	if (node.left_type == 0) {
		v__gen__verror(tos3("method receiver type is 0, this means there are some uchecked exprs"));
	}
	string receiver_type_name = v__gen__Gen_cc_type(g, node.receiver_type);
	v__table__TypeSymbol* typ_sym = v__table__Table_get_type_symbol(g->table, node.receiver_type);
	if (typ_sym->kind == v__table__Kind_interface_) {
		v__gen__Gen_write(g, _STR("%.*s\000_name_table[", 2, v__gen__c_name(receiver_type_name)));
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, _STR("._interface_idx].%.*s\000(", 2, node.name));
		v__gen__Gen_expr(g, node.left);
		v__gen__Gen_write(g, tos3("._object"));
		if (node.args.len > 0) {
			v__gen__Gen_write(g, tos3(", "));
			v__gen__Gen_call_args(g, node.args, node.expected_arg_types);
		}
		v__gen__Gen_write(g, tos3(")"));
		return ;
	}
	if (typ_sym->kind == v__table__Kind_array && string_eq(node.name, tos3("map"))) {
		v__gen__Gen_gen_map(g, node);
		return ;
	}
	if (typ_sym->kind == v__table__Kind_array && string_eq(node.name, tos3("filter"))) {
		v__gen__Gen_gen_filter(g, node);
		return ;
	}
	if (string_eq(node.name, tos3("str"))) {
		string styp = v__gen__Gen_typ(g, node.receiver_type);
		if (v__table__Type_is_ptr(node.receiver_type)) {
			styp = string_replace(styp, tos3("*"), tos3(""));
		}
		v__gen__Gen_gen_str_for_type_with_styp(g, node.receiver_type, styp);
	}
	if (typ_sym->kind == v__table__Kind_array && (string_eq(node.name, tos3("repeat")) || string_eq(node.name, tos3("sort_with_compare")) || string_eq(node.name, tos3("free")) || string_eq(node.name, tos3("push_many")) || string_eq(node.name, tos3("trim")) || string_eq(node.name, tos3("first")) || string_eq(node.name, tos3("last")) || string_eq(node.name, tos3("clone")) || string_eq(node.name, tos3("reverse")) || string_eq(node.name, tos3("slice")))) {
		receiver_type_name = tos3("array");
		if ((string_eq(node.name, tos3("last")) || string_eq(node.name, tos3("first")))) {
			string return_type_str = v__gen__Gen_typ(g, node.return_type);
			v__gen__Gen_write(g, _STR("*(%.*s\000*)", 2, return_type_str));
		}
	}
	string name = string_replace(_STR("%.*s\000_%.*s", 2, receiver_type_name, node.name), tos3("."), tos3("__"));
	v__gen__Gen_write(g, _STR("%.*s\000(", 2, name));
	if (v__table__Type_is_ptr(node.receiver_type) && !v__table__Type_is_ptr(node.left_type)) {
		v__gen__Gen_write(g, tos3("&"));
	} else if (!v__table__Type_is_ptr(node.receiver_type) && v__table__Type_is_ptr(node.left_type)) {
		v__gen__Gen_write(g, tos3("/*rec*/*"));
	}
	v__gen__Gen_expr(g, node.left);
	bool is_variadic = node.expected_arg_types.len > 0 && v__table__Type_flag_is((*(v__table__Type*)array_get(node.expected_arg_types, node.expected_arg_types.len - 1)), v__table__TypeFlag_variadic);
	if (node.args.len > 0 || is_variadic) {
		v__gen__Gen_write(g, tos3(", "));
	}
	v__gen__Gen_call_args(g, node.args, node.expected_arg_types);
	v__gen__Gen_write(g, tos3(")"));
}

static void v__gen__Gen_fn_call(v__gen__Gen* g, v__ast__CallExpr node) {
	if (node.left_type != 0) {
		v__gen__Gen_expr(g, node.left);
		if (v__table__Type_is_ptr(node.left_type)) {
			v__gen__Gen_write(g, tos3("->"));
		} else {
			v__gen__Gen_write(g, tos3("."));
		}
	}
	string name = node.name;
	bool is_print = string_eq(name, tos3("println")) || string_eq(name, tos3("print"));
	string print_method = (string_eq(name, tos3("println")) ?  ( tos3("println") )  :  ( tos3("print") ) );
	bool is_json_encode = string_eq(name, tos3("json.encode"));
	bool is_json_decode = string_eq(name, tos3("json.decode"));
	g->is_json_fn = is_json_encode || is_json_decode;
	string json_type_str = tos3("");
	if (g->is_json_fn) {
		if (string_eq(name, tos3("json.encode"))) {
			v__gen__Gen_write(g, tos3("json__json_print("));
			v__gen__Gen_gen_json_for_type(g, (*(v__ast__CallArg*)array_get(node.args, 0)).typ);
			json_type_str = v__table__Table_get_type_symbol(g->table, (*(v__ast__CallArg*)array_get(node.args, 0)).typ)->name;
		} else {
			v__gen__Gen_insert_before(g, tos3("// json.decode"));
			v__ast__Type* ast_type = /* as */ (v__ast__Type*)__as_cast((*(v__ast__CallArg*)array_get(node.args, 0)).expr.obj, (*(v__ast__CallArg*)array_get(node.args, 0)).expr.typ, /*expected:*/162);
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, ast_type->typ);
			name = string_add(name, string_add(tos3("_"), sym->name));
			v__gen__Gen_gen_json_for_type(g, ast_type->typ);
		}
	}
	if (node.is_c) {
		g->is_c_call = true;
		name = string_replace(string_substr(name, 2, name.len), tos3("."), tos3("__"));
	} else {
		name = v__gen__c_name(name);
	}
	if (is_json_encode) {
		name = string_add(name, string_add(tos3("_"), json_type_str));
	}
	if (is_print && (*(v__ast__CallArg*)array_get(node.args, 0)).typ != _const_v__table__string_type) {
		v__table__Type typ = (*(v__ast__CallArg*)array_get(node.args, 0)).typ;
		string styp = v__gen__Gen_typ(g, typ);
		v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, typ);
		if (v__table__Type_is_ptr(typ)) {
			styp = string_replace(styp, tos3("*"), tos3(""));
		}
		string str_fn_name = v__gen__Gen_gen_str_for_type_with_styp(g, typ, styp);
		if (g->autofree && !v__table__Type_flag_is(typ, v__table__TypeFlag_optional)) {
			string tmp = v__gen__Gen_new_tmp_var(g);
			v__gen__Gen_write(g, _STR("string %.*s\000 = %.*s\000(", 3, tmp, str_fn_name));
			v__gen__Gen_expr(g, (*(v__ast__CallArg*)array_get(node.args, 0)).expr);
			v__gen__Gen_writeln(g, _STR("); %.*s\000(%.*s\000); string_free(&%.*s\000); //MEM2 %.*s", 4, print_method, tmp, tmp, styp));
		} else {
			v__ast__Expr expr = (*(v__ast__CallArg*)array_get(node.args, 0)).expr;
			bool is_var = (expr.typ == 182 /* v.ast.SelectorExpr */) ?  ( true )  : (expr.typ == 136 /* v.ast.Ident */) ?  ( true )  :  ( false ) ;
			if (v__table__Type_is_ptr(typ) && sym->kind != v__table__Kind_struct_) {
				styp = tos3("ptr");
				str_fn_name = tos3("ptr_str");
			}
			if (sym->kind == v__table__Kind_enum_) {
				if (is_var) {
					v__gen__Gen_write(g, _STR("%.*s\000(%.*s\000(", 3, print_method, str_fn_name));
				} else {
					v__gen__Gen_write(g, _STR("%.*s\000(tos3(\"", 2, print_method));
				}
				if (v__table__Type_is_ptr(typ)) {
					v__gen__Gen_write(g, tos3("*"));
				}
				v__gen__Gen_enum_expr(g, expr);
				if (!is_var) {
					v__gen__Gen_write(g, tos3("\""));
				}
			} else {
				v__gen__Gen_write(g, _STR("%.*s\000(%.*s\000(", 3, print_method, str_fn_name));
				if (v__table__Type_is_ptr(typ) && sym->kind == v__table__Kind_struct_) {
					v__gen__Gen_write(g, tos3("*"));
				}
				v__gen__Gen_expr(g, expr);
				if (!v__table__Type_flag_is(typ, v__table__TypeFlag_variadic) && sym->kind == v__table__Kind_struct_ && string_ne(styp, tos3("ptr")) && !v__table__TypeSymbol_has_method(sym, tos3("str"))) {
					v__gen__Gen_write(g, tos3(", 0"));
				}
			}
			v__gen__Gen_write(g, tos3("))"));
		}
	} else if (g->pref->is_debug && string_eq(node.name, tos3("panic"))) {
		int paline = node.pos.line_nr + 1;
		string pafile = string_replace(g->fn_decl->file, tos3("\\"), tos3("/"));
		string pafn = string_after(g->fn_decl->name, tos3("."));
		string pamod = string_all_before_last(g->fn_decl->name, tos3("."));
		if (string_eq(pamod, pafn)) {
			pamod = (g->fn_decl->is_builtin ?  ( tos3("builtin") )  :  ( tos3("main") ) );
		}
		v__gen__Gen_write(g, _STR("panic_debug(%"PRId32"\000, tos3(\"%.*s\000\"), tos3(\"%.*s\000\"), tos3(\"%.*s\000\"),  ", 5, paline, pafile, pamod, pafn));
		v__gen__Gen_call_args(g, node.args, node.expected_arg_types);
		v__gen__Gen_write(g, tos3(")"));
	} else {
		v__gen__Gen_write(g, _STR("%.*s\000(", 2, name));
		if (is_json_decode) {
			v__gen__Gen_write(g, tos3("json__json_parse("));
			v__gen__Gen_call_args(g, array_slice(node.args, 1, node.args.len), node.expected_arg_types);
		} else {
			v__gen__Gen_call_args(g, node.args, node.expected_arg_types);
		}
		v__gen__Gen_write(g, tos3(")"));
	}
	g->is_c_call = false;
	if (g->is_json_fn) {
		v__gen__Gen_write(g, tos3(")"));
		g->is_json_fn = false;
	}
}

static void v__gen__Gen_call_args(v__gen__Gen* g, array_v__ast__CallArg args, array_v__table__Type expected_types) {
	bool is_variadic = expected_types.len > 0 && v__table__Type_flag_is((*(v__table__Type*)array_get(expected_types, expected_types.len - 1)), v__table__TypeFlag_variadic);
	bool is_forwarding_varg = args.len > 0 && v__table__Type_flag_is((*(v__ast__CallArg*)array_get(args, args.len - 1)).typ, v__table__TypeFlag_variadic);
	bool gen_vargs = is_variadic && !is_forwarding_varg;
	// FOR IN array
	array tmp1 = args;
	for (int i = 0; i < tmp1.len; i++) {
		v__ast__CallArg arg = ((v__ast__CallArg*)tmp1.data)[i];
		if (gen_vargs && i == expected_types.len - 1) {
			break;
		}
		bool is_interface = false;
		if (i < expected_types.len) {
			if ((*(v__table__Type*)array_get(expected_types, i)) != 0) {
				v__table__TypeSymbol* exp_sym = v__table__Table_get_type_symbol(g->table, (*(v__table__Type*)array_get(expected_types, i)));
				if (exp_sym->kind == v__table__Kind_interface_) {
					v__gen__Gen_interface_call(g, arg.typ, (*(v__table__Type*)array_get(expected_types, i)));
					is_interface = true;
				}
			}
			v__gen__Gen_ref_or_deref_arg(g, arg, (*(v__table__Type*)array_get(expected_types, i)));
		} else {
			v__gen__Gen_expr(g, arg.expr);
		}
		if (is_interface) {
			v__gen__Gen_write(g, tos3(")"));
		}
		if (i < args.len - 1 || gen_vargs) {
			v__gen__Gen_write(g, tos3(", "));
		}
	}
	int arg_nr = expected_types.len - 1;
	if (gen_vargs) {
		v__table__Type varg_type = (*(v__table__Type*)array_get(expected_types, expected_types.len - 1));
		string struct_name = string_add(tos3("varg_"), string_replace(v__gen__Gen_typ(g, varg_type), tos3("*"), tos3("_ptr")));
		int variadic_count = args.len - arg_nr;
		string varg_type_str = int_str(((int)(varg_type)));
		if (variadic_count > (*(int*)map_get3(g->variadic_args, varg_type_str, &(int[]){ 0 }))) {
			map_set(&g->variadic_args, varg_type_str, &(int[]) { variadic_count });
		}
		v__gen__Gen_write(g, _STR("(%.*s\000){.len=%"PRId32"\000,.args={", 3, struct_name, variadic_count));
		if (variadic_count > 0) {
			for (int tmp11 = arg_nr; tmp11 < args.len; tmp11++) {
				int j = tmp11;
				v__gen__Gen_ref_or_deref_arg(g, (*(v__ast__CallArg*)array_get(args, j)), varg_type);
				if (j < args.len - 1) {
					v__gen__Gen_write(g, tos3(", "));
				}
			}
		} else {
			v__gen__Gen_write(g, tos3("0"));
		}
		v__gen__Gen_write(g, tos3("}}"));
	}
}

// Attr: [inline]
inline static void v__gen__Gen_ref_or_deref_arg(v__gen__Gen* g, v__ast__CallArg arg, v__table__Type expected_type) {
	bool arg_is_ptr = v__table__Type_is_ptr(expected_type) || _IN(int, v__table__Type_idx(expected_type), _const_v__table__pointer_type_idxs);
	bool expr_is_ptr = v__table__Type_is_ptr(arg.typ) || _IN(int, v__table__Type_idx(arg.typ), _const_v__table__pointer_type_idxs);
	v__table__TypeSymbol* exp_sym = v__table__Table_get_type_symbol(g->table, expected_type);
	if (arg.is_mut && !arg_is_ptr) {
		v__gen__Gen_write(g, tos3("&/*mut*/"));
	} else if (arg_is_ptr && !expr_is_ptr) {
		if (arg.is_mut) {
			if (exp_sym->kind == v__table__Kind_array) {
				v__gen__Gen_write(g, tos3("&/*111*/(array[]){"));
				v__gen__Gen_expr(g, arg.expr);
				v__gen__Gen_write(g, tos3("}[0]"));
				return ;
			}
		}
		if (!g->is_json_fn) {
			v__gen__Gen_write(g, tos3("&/*qq*/"));
		}
	} else if (!arg_is_ptr && expr_is_ptr && exp_sym->kind != v__table__Kind_interface_) {
		v__gen__Gen_write(g, tos3("*/*d*/"));
	}
	v__gen__Gen_expr_with_cast(g, arg.expr, arg.typ, expected_type);
}

static bool v__gen__Gen_is_gui_app(v__gen__Gen* g) {
	
// $if  windows {
#ifdef _WIN32
		// FOR IN array
		array tmp1 = g->table->cflags;
		for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
			v__cflag__CFlag cf = ((v__cflag__CFlag*)tmp1.data)[tmp2];
			if (string_eq(cf.value, tos3("gdi32"))) {
				return true;
			}
		}
	
// } windows
#endif

	return false;
}

static void v__gen__Gen_gen_json_for_type(v__gen__Gen* g, v__table__Type typ) {
	strings__Builder dec = strings__new_builder(100);
	strings__Builder enc = strings__new_builder(100);
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, typ);
	string styp = v__gen__Gen_typ(g, typ);
	if ((string_eq(sym->name, tos3("int")) || string_eq(sym->name, tos3("string")) || string_eq(sym->name, tos3("bool")))) {
		return ;
	}
	if (sym->kind == v__table__Kind_array) {
	}
	if (_IN(string, sym->name, g->json_types)) {
		return ;
	}
	array_push(&g->json_types, &(string[]){ sym->name });
	string dec_fn_name = v__gen__js_dec_name(sym->name);
	strings__Builder_writeln(&dec, _STR("\n//Option %.*s\000(cJSON* root, %.*s\000* res) {\nOption %.*s\000(cJSON* root) {\n  %.*s\000 res;\n  if (!root) {\n    const char *error_ptr = cJSON_GetErrorPtr();\n    if (error_ptr != NULL)	{\n      fprintf(stderr, \"Error in decode() for %.*s\000 error_ptr=: %%%%s\\n\", error_ptr);\n//      printf(\"\\nbad js=%%%%s\\n\", js.str);\n      return v_error(tos2(error_ptr));\n    }\n  }\n", 6, dec_fn_name, styp, dec_fn_name, styp, styp));
	string enc_fn_name = v__gen__js_enc_name(sym->name);
	strings__Builder_writeln(&enc, _STR("\ncJSON* %.*s\000(%.*s\000 val) {\n\tcJSON *o = cJSON_CreateObject();", 3, enc_fn_name, styp));
	if (sym->kind == v__table__Kind_array) {
		v__table__Type value_type = v__table__Table_value_type(g->table, typ);
		v__gen__Gen_gen_json_for_type(g, value_type);
		strings__Builder_writeln(&dec, v__gen__Gen_decode_array(g, value_type));
		strings__Builder_writeln(&enc, v__gen__Gen_encode_array(g, value_type));
	} else {
		if (!(sym->info.typ == 87 /* v.table.Struct */)) {
			v__gen__verror(_STR("json: %.*s\000 is not struct", 2, sym->name));
		}
		v__table__Struct* info = /* as */ (v__table__Struct*)__as_cast(sym->info.obj, sym->info.typ, /*expected:*/87);
		// FOR IN array
		array tmp7 = info->fields;
		for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
			v__table__Field field = ((v__table__Field*)tmp7.data)[tmp8];
			if (string_eq(field.attr, tos3("skip"))) {
				continue;
			}
			string name = (string_starts_with(field.attr, tos3("json:")) ?  ( string_substr(field.attr, 5, field.attr.len) )  :  ( field.name ) );
			string field_type = v__gen__Gen_typ(g, field.typ);
			string enc_name = v__gen__js_enc_name(field_type);
			if (string_eq(field.attr, tos3("raw"))) {
				strings__Builder_writeln(&dec, string_add(_STR(" res . %.*s\000 = tos2(cJSON_PrintUnformatted(", 2, field.name), _STR("js_get(root, \"%.*s\000\")));", 2, name)));
			} else {
				v__gen__Gen_gen_json_for_type(g, field.typ);
				string dec_name = v__gen__js_dec_name(field_type);
				if (v__gen__is_js_prim(field_type)) {
					strings__Builder_writeln(&dec, _STR(" res . %.*s\000 = %.*s\000 (js_get(root, \"%.*s\000\"));", 4, field.name, dec_name, name));
				} else {
					strings__Builder_writeln(&dec, _STR("  res . %.*s\000 = *(%.*s\000*) %.*s\000 (js_get(root,\"%.*s\000\")).data;", 5, field.name, field_type, dec_name, name));
				}
			}
			strings__Builder_writeln(&enc, _STR("\tcJSON_AddItemToObject(o, \"%.*s\000\", %.*s\000(val.%.*s\000));", 4, name, enc_name, field.name));
		}
	}
	strings__Builder_writeln(&dec, tos3("return opt_ok(&res, sizeof(res)); \n}"));
	strings__Builder_writeln(&enc, tos3("\treturn o;\n}"));
	strings__Builder_writeln(&g->definitions, strings__Builder_str(&dec));
	strings__Builder_writeln(&g->gowrappers, strings__Builder_str(&enc));
}

static string v__gen__js_enc_name(string typ) {
	string name = _STR("json__encode_%.*s", 1, typ);
	return string_replace(name, tos3("."), tos3("__"));
}

static string v__gen__js_dec_name(string typ) {
	string name = _STR("json__decode_%.*s", 1, typ);
	return string_replace(name, tos3("."), tos3("__"));
}

static bool v__gen__is_js_prim(string typ) {
	return string_eq(typ, tos3("int")) || string_eq(typ, tos3("string")) || string_eq(typ, tos3("bool")) || string_eq(typ, tos3("f32")) || string_eq(typ, tos3("f64")) || string_eq(typ, tos3("i8")) || string_eq(typ, tos3("i16")) || string_eq(typ, tos3("i64")) || string_eq(typ, tos3("u16")) || string_eq(typ, tos3("u32")) || string_eq(typ, tos3("u64"));
}

static string v__gen__Gen_decode_array(v__gen__Gen* g, v__table__Type value_type) {
	string styp = v__gen__Gen_typ(g, value_type);
	string fn_name = v__gen__js_dec_name(styp);
	v__gen__Gen_gen_json_for_type(g, value_type);
	string s = tos3("");
	if (v__gen__is_js_prim(styp)) {
		s = _STR("%.*s\000 val = %.*s\000(jsval); ", 3, styp, fn_name);
	} else {
		s = _STR("\t%.*s\000 val = *(%.*s\000*) %.*s\000(jsval).data; ", 4, styp, styp, fn_name);
	}
	return _STR("\nres = __new_array(0, 0, sizeof(%.*s\000));\nconst cJSON *jsval = NULL;\ncJSON_ArrayForEach(jsval, root)\n{\n%.*s\000\n  array_push(&res, &val);\n}\n", 3, styp, s);
}

static string v__gen__Gen_encode_array(v__gen__Gen* g, v__table__Type value_type) {
	string styp = v__gen__Gen_typ(g, value_type);
	string fn_name = v__gen__js_enc_name(styp);
	return _STR("\no = cJSON_CreateArray();\nfor (int i = 0; i < val.len; i++){\n  cJSON_AddItemToArray(o, %.*s\000 (  ((%.*s\000*)val.data)[i]  ));\n}\n", 3, fn_name, styp);
}

static void v__gen__Gen_generate_hotcode_reloading_declarations(v__gen__Gen* g) {
	if (g->pref->os == v__pref__OS_windows) {
		if (g->pref->is_livemain) {
			strings__Builder_writeln(&g->hotcode_definitions, tos3("HANDLE live_fn_mutex = 0;"));
		}
		if (g->pref->is_liveshared) {
			strings__Builder_writeln(&g->hotcode_definitions, tos3("HANDLE live_fn_mutex;"));
		}
		strings__Builder_writeln(&g->hotcode_definitions, tos3("\nvoid pthread_mutex_lock(HANDLE *m) {\n	WaitForSingleObject(*m, INFINITE);\n}\nvoid pthread_mutex_unlock(HANDLE *m) {\n	ReleaseMutex(*m);\n}\n"));
	} else {
		if (g->pref->is_livemain) {
			strings__Builder_writeln(&g->hotcode_definitions, tos3("pthread_mutex_t live_fn_mutex = PTHREAD_MUTEX_INITIALIZER;"));
		}
		if (g->pref->is_liveshared) {
			strings__Builder_writeln(&g->hotcode_definitions, tos3("pthread_mutex_t live_fn_mutex;"));
		}
	}
}

static void v__gen__Gen_generate_hotcode_reloader_code(v__gen__Gen* g) {
	if (g->pref->is_liveshared) {
		strings__Builder_writeln(&g->hotcode_definitions, tos3(""));
		return ;
	}
	if (g->pref->is_livemain) {
		string phd = tos3("");
		array_string load_code = __new_array(0, 0, sizeof(string));
		if (g->pref->os != v__pref__OS_windows) {
			// FOR IN array
			array tmp4 = g->hotcode_fn_names;
			for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
				string so_fn = ((string*)tmp4.data)[tmp5];
				array_push(&load_code, &(string[]){ _STR("impl_live_%.*s\000 = dlsym(live_lib, \"impl_live_%.*s\000\");", 3, so_fn, so_fn) });
			}
			phd = _const_v__gen__posix_hotcode_definitions_1;
		} else {
			// FOR IN array
			array tmp7 = g->hotcode_fn_names;
			for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
				string so_fn = ((string*)tmp7.data)[tmp8];
				array_push(&load_code, &(string[]){ _STR("impl_live_%.*s\000 = (void *)GetProcAddress(live_lib, \"impl_live_%.*s\000\");  ", 3, so_fn, so_fn) });
			}
			phd = _const_v__gen__windows_hotcode_definitions_1;
		}
		strings__Builder_writeln(&g->hotcode_definitions, string_replace(phd, tos3("@LOAD_FNS@"), array_string_join(load_code, tos3("\n"))));
	}
}

static void v__gen__Gen_generate_hotcode_reloading_main_caller(v__gen__Gen* g) {
	if (!g->pref->is_livemain) {
		return ;
	}
	v__gen__Gen_writeln(g, tos3(""));
	v__gen__Gen_writeln(g, tos3("\t// live code initialization section:"));
	v__gen__Gen_writeln(g, tos3("\t{"));
	v__gen__Gen_writeln(g, tos3("\t\t// initialization of live function pointers"));
	// FOR IN array
	array tmp2 = g->hotcode_fn_names;
	for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
		string fname = ((string*)tmp2.data)[tmp3];
		v__gen__Gen_writeln(g, _STR("\t\timpl_live_%.*s\000 = 0;", 2, fname));
	}
	string vexe = v__util__cescaped_path(v__pref__vexe_path());
	string file = v__util__cescaped_path(g->pref->path);
	string msvc = (string_eq(g->pref->ccompiler, tos3("msvc")) ?  ( tos3("-cc msvc") )  :  ( tos3("") ) );
	string so_debug_flag = (g->pref->is_debug ?  ( tos3("-cg") )  :  ( tos3("") ) );
	string vopts = _STR("%.*s\000 %.*s\000 -keepc -sharedlive -shared", 3, msvc, so_debug_flag);
	v__gen__Gen_writeln(g, tos3("\t\t// start background reloading thread"));
	if (g->pref->os == v__pref__OS_windows) {
		v__gen__Gen_writeln(g, tos3("\t\tlive_fn_mutex = CreateMutexA(0, 0, 0);"));
	}
	v__gen__Gen_writeln(g, tos3("\t\tlive__LiveReloadInfo* live_info = live__executable__new_live_reload_info("));
	v__gen__Gen_writeln(g, _STR("\t\t\t\t\t tos2(\"%.*s\000\"),", 2, file));
	v__gen__Gen_writeln(g, _STR("\t\t\t\t\t tos2(\"%.*s\000\"),", 2, vexe));
	v__gen__Gen_writeln(g, _STR("\t\t\t\t\t tos2(\"%.*s\000\"),", 2, vopts));
	v__gen__Gen_writeln(g, tos3("\t\t\t\t\t &live_fn_mutex,"));
	v__gen__Gen_writeln(g, tos3("\t\t\t\t\t v_bind_live_symbols"));
	v__gen__Gen_writeln(g, tos3("\t\t);"));
	v__gen__Gen_writeln(g, tos3("\t\t   g_live_info = (void*)live_info;"));
	v__gen__Gen_writeln(g, tos3("\t\tlive__executable__start_reloader(live_info);"));
	v__gen__Gen_writeln(g, tos3("\t}\t// end of live code initialization section"));
	v__gen__Gen_writeln(g, tos3(""));
}

static void v__gen__Gen_profile_fn(v__gen__Gen* g, string fn_name, bool is_main) {
	if (is_main) {
		v__gen__Gen_writeln(g, tos3(""));
		v__gen__Gen_writeln(g, tos3("\tatexit(vprint_profile_stats);"));
		v__gen__Gen_writeln(g, tos3(""));
	}
	if (string_starts_with(fn_name, tos3("time.vpc_now"))) {
		g->defer_profile_code = tos3("");
	} else {
		string measure_fn_name = (g->pref->os == v__pref__OS_mac ?  ( tos3("time__vpc_now_darwin") )  :  ( tos3("time__vpc_now") ) );
		string fn_profile_counter_name = _STR("vpc_%.*s", 1, g->last_fn_c_name);
		string fn_profile_counter_name_calls = _STR("%.*s\000_calls", 2, fn_profile_counter_name);
		v__gen__Gen_writeln(g, tos3(""));
		v__gen__Gen_writeln(g, _STR("\tdouble _PROF_FN_START = %.*s\000(); %.*s\000++; // %.*s", 3, measure_fn_name, fn_profile_counter_name_calls, fn_name));
		v__gen__Gen_writeln(g, tos3(""));
		g->defer_profile_code = _STR("\t%.*s\000 += %.*s\000() - _PROF_FN_START;", 3, fn_profile_counter_name, measure_fn_name);
		strings__Builder_writeln(&g->pcs_declarations, _STR("double %.*s\000 = 0.0; u64 %.*s\000 = 0;", 3, fn_profile_counter_name, fn_profile_counter_name_calls));
		array_push(&g->pcs, &(v__gen__ProfileCounterMeta[]){ (v__gen__ProfileCounterMeta){
			.fn_name = g->last_fn_c_name,
			.vpc_name = fn_profile_counter_name,
			.vpc_calls = fn_profile_counter_name_calls,
		} });
	}
}

void v__gen__Gen_gen_vprint_profile_stats(v__gen__Gen* g) {
	strings__Builder_writeln(&g->pcs_declarations, tos3("void vprint_profile_stats(){"));
	string fstring = tos3("\"%14llu %14.3fms %14.0fns %s \\n\"");
	if (string_eq(g->pref->profile_file, tos3("-"))) {
		// FOR IN array
		array tmp2 = g->pcs;
		for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
			v__gen__ProfileCounterMeta pc_meta = ((v__gen__ProfileCounterMeta*)tmp2.data)[tmp3];
			strings__Builder_writeln(&g->pcs_declarations, _STR("\tif (%.*s\000) printf(%.*s\000, %.*s\000, %.*s\000/1000000.0, %.*s\000/%.*s\000, \"%.*s\000\" );", 8, pc_meta.vpc_calls, fstring, pc_meta.vpc_calls, pc_meta.vpc_name, pc_meta.vpc_name, pc_meta.vpc_calls, pc_meta.fn_name));
		}
	} else {
		strings__Builder_writeln(&g->pcs_declarations, tos3("\tFILE * fp;"));
		strings__Builder_writeln(&g->pcs_declarations, _STR("\tfp = fopen (\"%.*s\000\", \"w+\");", 2, g->pref->profile_file));
		// FOR IN array
		array tmp4 = g->pcs;
		for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
			v__gen__ProfileCounterMeta pc_meta = ((v__gen__ProfileCounterMeta*)tmp4.data)[tmp5];
			strings__Builder_writeln(&g->pcs_declarations, _STR("\tif (%.*s\000) fprintf(fp, %.*s\000, %.*s\000, %.*s\000/1000000.0, %.*s\000/%.*s\000, \"%.*s\000\" );", 8, pc_meta.vpc_calls, fstring, pc_meta.vpc_calls, pc_meta.vpc_name, pc_meta.vpc_name, pc_meta.vpc_calls, pc_meta.fn_name));
		}
		strings__Builder_writeln(&g->pcs_declarations, tos3("\tfclose(fp);"));
	}
	strings__Builder_writeln(&g->pcs_declarations, tos3("}"));
}

static void v__gen__Gen_write_str_fn_definitions(v__gen__Gen* g) {
	v__gen__Gen_writeln(g, tos3("\nvoid _STR_PRINT_ARG(const char *fmt, char** refbufp, int *nbytes, int *memsize, int guess, ...) {\n	va_list args;\n	va_start(args, guess);\n	for(;;) {\n		if (guess < *memsize - *nbytes) {\n			guess = vsnprintf(*refbufp + *nbytes, *memsize - *nbytes, fmt, args);\n			if (guess < *memsize - *nbytes) { // result did fit into buffer\n				*nbytes += guess;\n				return;\n			}\n		}\n		// increase buffer (somewhat exponentially)\n		*memsize += (*memsize + *memsize) / 3 + guess;\n		*refbufp = realloc(*refbufp, *memsize);\n	}\n}\n\nstring _STR(const char *fmt, int nfmts, ...) {\n	va_list argptr;\n	int memsize = 128;\n	int nbytes = 0;\n	char* buf = malloc(memsize);\n	va_start(argptr, nfmts);\n	for (int i=0; i<nfmts; i++) {\n		int k = strlen(fmt);\n		bool is_fspec = false;\n		for (int j=0; j<k; j++) {\n			if (fmt[j] == '%') {\n				j++;\n				if (fmt[j] != '%') {\n					is_fspec = true;\n					break;\n				}\n			}\n		}\n		if (is_fspec) {\n			char f = fmt[k-1];\n			char fup = f & 0xdf; // toupper\n			bool l = fmt[k-2] == 'l';\n			bool ll = l && fmt[k-3] == 'l';\n			if (f == 'u' || fup == 'X' || f == 'o' || f == 'd' || f == 'c') { // int...\n				if (ll) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+16, va_arg(argptr, long long));\n				else if (l) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, long));\n				else _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+8, va_arg(argptr, int));\n			} else if (fup >= 'E' && fup <= 'G') { // floating point\n				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, double));\n			} else if (f == 'p') {\n				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+14, va_arg(argptr, void*));\n			} else if (f == 's') { // v string\n				string s = va_arg(argptr, string);\n				if (fmt[k-4] == '*') { // %*.*s\n					int fwidth = va_arg(argptr, int);\n					if (fwidth < 0)\n						fwidth -= (s.len - utf8_str_visible_length(s));\n					else\n						fwidth += (s.len - utf8_str_visible_length(s));\n					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+fwidth-4, fwidth, s.len, s.str);\n				} else { // %.*s\n					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+s.len-4, s.len, s.str);\n				}\n			} else {\n				//v_panic(tos3('Invaid format specifier'));\n			}\n		} else {\n			_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k);\n		}\n		fmt += k+1;\n	}\n	va_end(argptr);\n	buf[nbytes] = 0;\n	buf = realloc(buf, nbytes+1);\n#ifdef DEBUG_ALLOC\n	//puts('_STR:');\n	puts(buf);\n#endif\n	return tos2(buf);\n}\n\nstring _STR_TMP(const char *fmt, ...) {\n	va_list argptr;\n	va_start(argptr, fmt);\n	//size_t len = vsnprintf(0, 0, fmt, argptr) + 1;\n	va_end(argptr);\n	va_start(argptr, fmt);\n	vsprintf((char *)g_str_buf, fmt, argptr);\n	va_end(argptr);\n#ifdef DEBUG_ALLOC\n	//puts('_STR_TMP:');\n	//puts(g_str_buf);\n#endif\n	return tos2(g_str_buf);\n} // endof _STR_TMP\n\n"));
}

string v__gen__js__gen(array_v__ast__File files, v__table__Table* table, v__pref__Preferences* pref) {
	v__gen__js__JsGen* g = (v__gen__js__JsGen*)memdup(&(v__gen__js__JsGen){	.out = strings__new_builder(100),
		.definitions = strings__new_builder(100),
		.constants = strings__new_builder(100),
		.table = table,
		.pref = pref,
		.fn_decl = 0,
		.empty_line = true,
		.doc = 0,
		.namespaces = new_map_1(sizeof(strings__Builder)),
		.namespaces_pub = new_map_1(sizeof(array_string)),
		.namespace = (string){.str=""},
		.file = {0},
		.tmp_count = 0,
		.inside_ternary = 0,
		.inside_loop = 0,
		.is_test = 0,
		.indents = new_map_1(sizeof(int)),
		.stmt_start_pos = 0,
		.defer_stmts = __new_array(0, 1, sizeof(v__ast__DeferStmt)),
		.str_types = __new_array(0, 1, sizeof(string)),
		.method_fn_decls = new_map_1(sizeof(array_v__ast__Stmt)),
	}, sizeof(v__gen__js__JsGen));
	g->doc = v__gen__js__new_jsdoc(g);
	v__gen__js__JsGen_init(g);
	// FOR IN array
	array tmp1 = files;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__File file = ((v__ast__File*)tmp1.data)[tmp2];
		g->file = file;
		v__gen__js__JsGen_enter_namespace(g, g->file.mod.name);
		g->is_test = string_ends_with(g->file.path, tos3("_test.v"));
		v__gen__js__JsGen_find_class_methods(g, file.stmts);
		v__gen__js__JsGen_escape_namespace(g);
	}
	// FOR IN array
	array tmp3 = files;
	for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
		v__ast__File file = ((v__ast__File*)tmp3.data)[tmp4];
		g->file = file;
		v__gen__js__JsGen_enter_namespace(g, g->file.mod.name);
		g->is_test = string_ends_with(g->file.path, tos3("_test.v"));
		v__gen__js__JsGen_stmts(g, file.stmts);
		v__gen__js__JsGen_escape_namespace(g);
	}
	v__gen__js__JsGen_finish(g);
	string out = string_add(string_add(v__gen__js__JsGen_hashes(/*rec*/*g), strings__Builder_str(&g->definitions)), strings__Builder_str(&g->constants));
	// FOR IN array
	array tmp5 = map_keys(&g->namespaces);
	for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
		string key = ((string*)tmp5.data)[tmp6];
		out = string_add(out, _STR("/* namespace: %.*s\000 */\n", 2, key));
		out = string_add(out, strings__Builder_str(&(*(strings__Builder*)map_get3(g->namespaces, key, &(strings__Builder[]){ {0} }))));
		out = string_add(out, tos3("\n\t/* module exports */"));
		out = string_add(out, tos3("\n\treturn {"));
		// FOR IN array
		array tmp7 = (*(array_string*)map_get3(g->namespaces_pub, key, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
		for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
			string pub_var = ((string*)tmp7.data)[tmp8];
			out = string_add(out, _STR("\n\t\t%.*s\000,", 2, pub_var));
		}
		out = string_add(out, tos3("\n\t};"));
		out = string_add(out, tos3("\n})();"));
	}
	return out;
}

void v__gen__js__JsGen_enter_namespace(v__gen__js__JsGen* g, string n) {
	g->namespace = n;
	if ((*(strings__Builder*)map_get3(g->namespaces, g->namespace, &(strings__Builder[]){ {0} })).len == 0) {
		g->out = strings__new_builder(100);
		map_set(&g->indents, g->namespace, &(int[]) { 0 });
		strings__Builder_writeln(&g->out, _STR("const %.*s\000 = (function () {", 2, n));
	} else {
		g->out = (*(strings__Builder*)map_get3(g->namespaces, g->namespace, &(strings__Builder[]){ {0} }));
	}
}

void v__gen__js__JsGen_escape_namespace(v__gen__js__JsGen* g) {
	map_set(&g->namespaces, g->namespace, &(strings__Builder[]) { g->out });
	g->namespace = tos3("");
}

void v__gen__js__JsGen_push_pub_var(v__gen__js__JsGen* g, string s) {
	array_string arr = (*(array_string*)map_get3(g->namespaces_pub, g->namespace, &(array_string[]){ __new_array(0, 1, sizeof(string)) }));
	array_push(&arr, &(string[]){ s });
	map_set(&g->namespaces_pub, g->namespace, &(array_string[]) { arr });
}

void v__gen__js__JsGen_find_class_methods(v__gen__js__JsGen* g, array_v__ast__Stmt stmts) {
	// FOR IN array
	array tmp1 = stmts;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)tmp1.data)[tmp2];
		if (stmt.typ == 111 /* v.ast.FnDecl */) {
			v__ast__FnDecl* it = (v__ast__FnDecl*)stmt.obj; // ST it
			if (it->is_method) {
				string class_name = v__table__Table_get_type_symbol(g->table, it->receiver.typ)->name;
				array_v__ast__Stmt arr = (*(array_v__ast__Stmt*)map_get3(g->method_fn_decls, class_name, &(array_v__ast__Stmt[]){ __new_array(0, 1, sizeof(v__ast__Stmt)) }));
				array_push(&arr, &(v__ast__Stmt[]){ stmt });
				map_set(&g->method_fn_decls, class_name, &(array_v__ast__Stmt[]) { arr });
			}
		}else {
		};
	}
}

void v__gen__js__JsGen_init(v__gen__js__JsGen* g) {
	strings__Builder_writeln(&g->definitions, tos3("// Generated by the V compiler"));
	strings__Builder_writeln(&g->definitions, tos3("\"use strict\";"));
	strings__Builder_writeln(&g->definitions, tos3(""));
}

void v__gen__js__JsGen_finish(v__gen__js__JsGen* g) {
	if (g->constants.len > 0) {
		string constants = strings__Builder_str(&g->constants);
		g->constants = strings__new_builder(100);
		strings__Builder_writeln(&g->constants, tos3("const CONSTANTS = Object.freeze({"));
		strings__Builder_write(&g->constants, constants);
		strings__Builder_writeln(&g->constants, tos3("});"));
		strings__Builder_writeln(&g->constants, tos3(""));
	}
}

string v__gen__js__JsGen_hashes(v__gen__js__JsGen g) {
	string res = _STR("// V_COMMIT_HASH %.*s\000\n", 2, v__util__vhash());
	res = string_add(res, _STR("// V_CURRENT_COMMIT_HASH %.*s\000\n\n", 2, v__util__githash(g.pref->building_v)));
	return res;
}

string v__gen__js__JsGen_typ(v__gen__js__JsGen* g, v__table__Type t) {
	v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, t);
	string styp = string_replace(sym->name, tos3("."), tos3("__"));
	if (string_starts_with(styp, tos3("JS__"))) {
		styp = string_substr(styp, 4, styp.len);
	}
	return v__gen__js__JsGen_to_js_typ(g, styp);
}

static string v__gen__js__JsGen_to_js_typ(v__gen__js__JsGen* g, string typ) {
	string styp = tos3("");
	if (string_eq(typ, tos3("int"))) {
		styp = tos3("number");
	}else if (string_eq(typ, tos3("bool"))) {
		styp = tos3("boolean");
	}else if (string_eq(typ, tos3("voidptr"))) {
		styp = tos3("Object");
	}else if (string_eq(typ, tos3("byteptr"))) {
		styp = tos3("string");
	}else if (string_eq(typ, tos3("charptr"))) {
		styp = tos3("string");
	}else {
		if (string_starts_with(typ, tos3("array_"))) {
			styp = string_add(v__gen__js__JsGen_to_js_typ(g, string_replace(typ, tos3("array_"), tos3(""))), tos3("[]"));
		} else if (string_starts_with(typ, tos3("map_"))) {
			array_string tokens = string_split(typ, tos3("_"));
			styp = _STR("Map<%.*s\000, %.*s\000>", 3, (*(string*)array_get(tokens, 1)), (*(string*)array_get(tokens, 2)));
		} else {
			styp = typ;
		}
	};
	return styp;
}

void v__gen__js__JsGen_save(v__gen__js__JsGen* g) {
}

void v__gen__js__JsGen_gen_indent(v__gen__js__JsGen* g) {
	if ((*(int*)map_get3(g->indents, g->namespace, &(int[]){ 0 })) > 0 && g->empty_line) {
		strings__Builder_write(&g->out, (*(string*)array_get(_const_v__gen__js__tabs, (*(int*)map_get3(g->indents, g->namespace, &(int[]){ 0 })))));
	}
	g->empty_line = false;
}

void v__gen__js__JsGen_inc_indent(v__gen__js__JsGen* g) {
	map_set(&g->indents, g->namespace, &(int[]) { (*(int*)map_get3(g->indents, g->namespace, &(int[]){ 0 })) + 1 });
}

void v__gen__js__JsGen_dec_indent(v__gen__js__JsGen* g) {
	map_set(&g->indents, g->namespace, &(int[]) { (*(int*)map_get3(g->indents, g->namespace, &(int[]){ 0 })) - 1 });
}

void v__gen__js__JsGen_write(v__gen__js__JsGen* g, string s) {
	v__gen__js__JsGen_gen_indent(g);
	strings__Builder_write(&g->out, s);
}

void v__gen__js__JsGen_writeln(v__gen__js__JsGen* g, string s) {
	v__gen__js__JsGen_gen_indent(g);
	strings__Builder_writeln(&g->out, s);
	g->empty_line = true;
}

string v__gen__js__JsGen_new_tmp_var(v__gen__js__JsGen* g) {
	g->tmp_count++;
	return _STR("tmp%"PRId32"", 1, g->tmp_count);
}

static void v__gen__js__JsGen_stmts(v__gen__js__JsGen* g, array_v__ast__Stmt stmts) {
	v__gen__js__JsGen_inc_indent(g);
	// FOR IN array
	array tmp1 = stmts;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)tmp1.data)[tmp2];
		v__gen__js__JsGen_stmt(g, stmt);
	}
	v__gen__js__JsGen_dec_indent(g);
}

static void v__gen__js__JsGen_stmt(v__gen__js__JsGen* g, v__ast__Stmt node) {
	g->stmt_start_pos = g->out.len;
	if (node.typ == 187 /* v.ast.Module */) {
		v__ast__Module* it = (v__ast__Module*)node.obj; // ST it
	}else if (node.typ == 170 /* v.ast.AssertStmt */) {
		v__ast__AssertStmt* it = (v__ast__AssertStmt*)node.obj; // ST it
		v__gen__js__JsGen_gen_assert_stmt(g, */*d*/it);
	}else if (node.typ == 132 /* v.ast.AssignStmt */) {
		v__ast__AssignStmt* it = (v__ast__AssignStmt*)node.obj; // ST it
		v__gen__js__JsGen_gen_assign_stmt(g, */*d*/it);
	}else if (node.typ == 178 /* v.ast.Attr */) {
		v__ast__Attr* it = (v__ast__Attr*)node.obj; // ST it
		v__gen__js__JsGen_gen_attr(g, */*d*/it);
	}else if (node.typ == 169 /* v.ast.Block */) {
		v__ast__Block* it = (v__ast__Block*)node.obj; // ST it
		v__gen__js__JsGen_gen_block(g, */*d*/it);
		v__gen__js__JsGen_writeln(g, tos3(""));
	}else if (node.typ == 171 /* v.ast.BranchStmt */) {
		v__ast__BranchStmt* it = (v__ast__BranchStmt*)node.obj; // ST it
		v__gen__js__JsGen_gen_branch_stmt(g, */*d*/it);
	}else if (node.typ == 188 /* v.ast.ConstDecl */) {
		v__ast__ConstDecl* it = (v__ast__ConstDecl*)node.obj; // ST it
		v__gen__js__JsGen_gen_const_decl(g, */*d*/it);
	}else if (node.typ == 141 /* v.ast.CompIf */) {
		v__ast__CompIf* it = (v__ast__CompIf*)node.obj; // ST it
	}else if (node.typ == 173 /* v.ast.DeferStmt */) {
		v__ast__DeferStmt* it = (v__ast__DeferStmt*)node.obj; // ST it
		array_push(&g->defer_stmts, &(v__ast__DeferStmt[]){ *it });
	}else if (node.typ == 193 /* v.ast.EnumDecl */) {
		v__ast__EnumDecl* it = (v__ast__EnumDecl*)node.obj; // ST it
		v__gen__js__JsGen_gen_enum_decl(g, */*d*/it);
		v__gen__js__JsGen_writeln(g, tos3(""));
	}else if (node.typ == 177 /* v.ast.ExprStmt */) {
		v__ast__ExprStmt* it = (v__ast__ExprStmt*)node.obj; // ST it
		v__gen__js__JsGen_gen_expr_stmt(g, */*d*/it);
	}else if (node.typ == 111 /* v.ast.FnDecl */) {
		v__ast__FnDecl* it = (v__ast__FnDecl*)node.obj; // ST it
		g->fn_decl = it;
		v__gen__js__JsGen_gen_fn_decl(g, */*d*/it);
		v__gen__js__JsGen_writeln(g, tos3(""));
	}else if (node.typ == 152 /* v.ast.ForCStmt */) {
		v__ast__ForCStmt* it = (v__ast__ForCStmt*)node.obj; // ST it
		v__gen__js__JsGen_gen_for_c_stmt(g, */*d*/it);
		v__gen__js__JsGen_writeln(g, tos3(""));
	}else if (node.typ == 153 /* v.ast.ForInStmt */) {
		v__ast__ForInStmt* it = (v__ast__ForInStmt*)node.obj; // ST it
		v__gen__js__JsGen_gen_for_in_stmt(g, */*d*/it);
		v__gen__js__JsGen_writeln(g, tos3(""));
	}else if (node.typ == 151 /* v.ast.ForStmt */) {
		v__ast__ForStmt* it = (v__ast__ForStmt*)node.obj; // ST it
		v__gen__js__JsGen_gen_for_stmt(g, */*d*/it);
		v__gen__js__JsGen_writeln(g, tos3(""));
	}else if (node.typ == 174 /* v.ast.GoStmt */) {
		v__ast__GoStmt* it = (v__ast__GoStmt*)node.obj; // ST it
		v__gen__js__JsGen_gen_go_stmt(g, */*d*/it);
		v__gen__js__JsGen_writeln(g, tos3(""));
	}else if (node.typ == 176 /* v.ast.GotoLabel */) {
		v__ast__GotoLabel* it = (v__ast__GotoLabel*)node.obj; // ST it
		v__gen__js__JsGen_writeln(g, _STR("%.*s\000:", 2, it->name));
	}else if (node.typ == 175 /* v.ast.GotoStmt */) {
		v__ast__GotoStmt* it = (v__ast__GotoStmt*)node.obj; // ST it
	}else if (node.typ == 140 /* v.ast.HashStmt */) {
		v__ast__HashStmt* it = (v__ast__HashStmt*)node.obj; // ST it
	}else if (node.typ == 165 /* v.ast.Import */) {
		v__ast__Import* it = (v__ast__Import*)node.obj; // ST it
	}else if (node.typ == 217 /* v.ast.InterfaceDecl */) {
		v__ast__InterfaceDecl* it = (v__ast__InterfaceDecl*)node.obj; // ST it
	}else if (node.typ == 191 /* v.ast.Return */) {
		v__ast__Return* it = (v__ast__Return*)node.obj; // ST it
		if (g->defer_stmts.len > 0) {
			v__gen__js__JsGen_gen_defer_stmts(g);
		}
		v__gen__js__JsGen_gen_return_stmt(g, */*d*/it);
	}else if (node.typ == 211 /* v.ast.StructDecl */) {
		v__ast__StructDecl* it = (v__ast__StructDecl*)node.obj; // ST it
		v__gen__js__JsGen_gen_struct_decl(g, */*d*/it);
	}else if (node.typ == 196 /* v.ast.TypeDecl */) {
		v__ast__TypeDecl* it = (v__ast__TypeDecl*)node.obj; // ST it
	}else if (node.typ == 172 /* v.ast.UnsafeStmt */) {
		v__ast__UnsafeStmt* it = (v__ast__UnsafeStmt*)node.obj; // ST it
		v__gen__js__JsGen_stmts(g, it->stmts);
	}else {
		v__gen__js__verror(_STR("jsgen.stmt(): bad node %.*s", 1, tos3( /* v.ast.Stmt */ v_typeof_sumtype_108( (node).typ ))));
	};
}

static void v__gen__js__JsGen_expr(v__gen__js__JsGen* g, v__ast__Expr node) {
	if (node.typ == 142 /* v.ast.ArrayInit */) {
		v__ast__ArrayInit* it = (v__ast__ArrayInit*)node.obj; // ST it
		v__gen__js__JsGen_gen_array_init_expr(g, */*d*/it);
	}else if (node.typ == 201 /* v.ast.BoolLiteral */) {
		v__ast__BoolLiteral* it = (v__ast__BoolLiteral*)node.obj; // ST it
		if (it->val == true) {
			v__gen__js__JsGen_write(g, tos3("true"));
		} else {
			v__gen__js__JsGen_write(g, tos3("false"));
		}
	}else if (node.typ == 202 /* v.ast.CharLiteral */) {
		v__ast__CharLiteral* it = (v__ast__CharLiteral*)node.obj; // ST it
		v__gen__js__JsGen_write(g, _STR("'%.*s\000'", 2, it->val));
	}else if (node.typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* it = (v__ast__CallExpr*)node.obj; // ST it
		v__gen__js__JsGen_expr(g, it->left);
		if (it->is_method) {
			v__gen__js__JsGen_write(g, tos3("."));
		}
		v__gen__js__JsGen_write(g, _STR("%.*s\000(", 2, it->name));
		// FOR IN array
		array tmp4 = it->args;
		for (int i = 0; i < tmp4.len; i++) {
			v__ast__CallArg arg = ((v__ast__CallArg*)tmp4.data)[i];
			v__gen__js__JsGen_expr(g, arg.expr);
			if (i != it->args.len - 1) {
				v__gen__js__JsGen_write(g, tos3(", "));
			}
		}
		v__gen__js__JsGen_write(g, tos3(")"));
	}else if (node.typ == 180 /* v.ast.EnumVal */) {
		v__ast__EnumVal* it = (v__ast__EnumVal*)node.obj; // ST it
		string styp = v__gen__js__JsGen_typ(g, it->typ);
		v__gen__js__JsGen_write(g, _STR("%.*s\000.%.*s", 2, styp, it->val));
	}else if (node.typ == 185 /* v.ast.FloatLiteral */) {
		v__ast__FloatLiteral* it = (v__ast__FloatLiteral*)node.obj; // ST it
		v__gen__js__JsGen_write(g, it->val);
	}else if (node.typ == 136 /* v.ast.Ident */) {
		v__ast__Ident* it = (v__ast__Ident*)node.obj; // ST it
		v__gen__js__JsGen_gen_ident(g, */*d*/it);
	}else if (node.typ == 154 /* v.ast.IfExpr */) {
		v__ast__IfExpr* it = (v__ast__IfExpr*)node.obj; // ST it
		v__gen__js__JsGen_gen_if_expr(g, */*d*/it);
	}else if (node.typ == 158 /* v.ast.IfGuardExpr */) {
		v__ast__IfGuardExpr* it = (v__ast__IfGuardExpr*)node.obj; // ST it
	}else if (node.typ == 186 /* v.ast.IntegerLiteral */) {
		v__ast__IntegerLiteral* it = (v__ast__IntegerLiteral*)node.obj; // ST it
		v__gen__js__JsGen_write(g, it->val);
	}else if (node.typ == 208 /* v.ast.InfixExpr */) {
		v__ast__InfixExpr* it = (v__ast__InfixExpr*)node.obj; // ST it
		v__gen__js__JsGen_expr(g, it->left);
		string op = v__token__Kind_str(it->op);
		if (string_eq(op, tos3("=="))) {
			op = tos3("===");
		} else if (string_eq(op, tos3("!="))) {
			op = tos3("!==");
		}
		v__gen__js__JsGen_write(g, _STR(" %.*s\000 ", 2, op));
		v__gen__js__JsGen_expr(g, it->right);
	}else if (node.typ == 143 /* v.ast.MapInit */) {
		v__ast__MapInit* it = (v__ast__MapInit*)node.obj; // ST it
		v__gen__js__JsGen_gen_map_init_expr(g, */*d*/it);
	}else if (node.typ == 183 /* v.ast.StringLiteral */) {
		v__ast__StringLiteral* it = (v__ast__StringLiteral*)node.obj; // ST it
		v__gen__js__JsGen_write(g, _STR("\"%.*s\000\"", 2, it->val));
	}else if (node.typ == 184 /* v.ast.StringInterLiteral */) {
		v__ast__StringInterLiteral* it = (v__ast__StringInterLiteral*)node.obj; // ST it
		v__gen__js__JsGen_gen_string_inter_literal(g, */*d*/it);
	}else if (node.typ == 209 /* v.ast.PostfixExpr */) {
		v__ast__PostfixExpr* it = (v__ast__PostfixExpr*)node.obj; // ST it
		v__gen__js__JsGen_expr(g, it->expr);
		v__gen__js__JsGen_write(g, v__token__Kind_str(it->op));
	}else if (node.typ == 214 /* v.ast.StructInit */) {
		v__ast__StructInit* it = (v__ast__StructInit*)node.obj; // ST it
		v__gen__js__JsGen_gen_struct_init(g, */*d*/it);
	}else if (node.typ == 182 /* v.ast.SelectorExpr */) {
		v__ast__SelectorExpr* it = (v__ast__SelectorExpr*)node.obj; // ST it
		v__gen__js__JsGen_gen_selector_expr(g, */*d*/it);
	}else {
		println(term__red(tos3("jsgen.expr(): bad node")));
	};
}

static void v__gen__js__JsGen_gen_string_inter_literal(v__gen__js__JsGen* g, v__ast__StringInterLiteral it) {
	v__gen__js__JsGen_write(g, tos3("tos3(`"));
	// FOR IN array
	array tmp1 = it.vals;
	for (int i = 0; i < tmp1.len; i++) {
		string val = ((string*)tmp1.data)[i];
		string escaped_val = string_replace_each(val, new_array_from_c_array(4, 4, sizeof(string), (string[4]){
		tos3("`"), tos3("\`"), tos3("\r\n"), tos3("\n"), 
}));
		v__gen__js__JsGen_write(g, escaped_val);
		if (i >= it.exprs.len) {
			continue;
		}
		v__ast__Expr expr = (*(v__ast__Expr*)array_get(it.exprs, i));
		string sfmt = (*(string*)array_get(it.expr_fmts, i));
		v__gen__js__JsGen_write(g, tos3("\${"));
		if (sfmt.len > 0) {
			byte fspec = string_at(sfmt, sfmt.len - 1);
			if (fspec == 's' && (*(v__table__Type*)array_get(it.expr_types, i)) == _const_v__table__string_type) {
				v__gen__js__JsGen_expr(g, expr);
				v__gen__js__JsGen_write(g, tos3(".str"));
			} else {
				v__gen__js__JsGen_expr(g, expr);
			}
		} else if ((*(v__table__Type*)array_get(it.expr_types, i)) == _const_v__table__string_type) {
			v__gen__js__JsGen_expr(g, expr);
			v__gen__js__JsGen_write(g, tos3(".str"));
		} else if ((*(v__table__Type*)array_get(it.expr_types, i)) == _const_v__table__bool_type) {
			v__gen__js__JsGen_expr(g, expr);
			v__gen__js__JsGen_write(g, tos3(" ? \"true\" : \"false\""));
		} else {
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(g->table, (*(v__table__Type*)array_get(it.expr_types, i)));
			if (sym->kind == v__table__Kind_struct_) {
				v__gen__js__JsGen_expr(g, expr);
				if (v__table__TypeSymbol_has_method(sym, tos3("str"))) {
					v__gen__js__JsGen_write(g, tos3(".str()"));
				}
			}else {
				v__gen__js__JsGen_expr(g, expr);
			};
		}
		v__gen__js__JsGen_write(g, tos3("}"));
	}
	v__gen__js__JsGen_write(g, tos3("`)"));
}

static void v__gen__js__JsGen_gen_array_init_expr(v__gen__js__JsGen* g, v__ast__ArrayInit it) {
	v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(g->table, it.typ);
	if (type_sym->kind != v__table__Kind_array_fixed) {
		v__gen__js__JsGen_write(g, tos3("["));
		// FOR IN array
		array tmp2 = it.exprs;
		for (int i = 0; i < tmp2.len; i++) {
			v__ast__Expr expr = ((v__ast__Expr*)tmp2.data)[i];
			v__gen__js__JsGen_expr(g, expr);
			if (i < it.exprs.len - 1) {
				v__gen__js__JsGen_write(g, tos3(", "));
			}
		}
		v__gen__js__JsGen_write(g, tos3("]"));
	} else {
	}
}

static void v__gen__js__JsGen_gen_assert_stmt(v__gen__js__JsGen* g, v__ast__AssertStmt a) {
	v__gen__js__JsGen_writeln(g, tos3("// assert"));
	v__gen__js__JsGen_write(g, tos3("if( "));
	v__gen__js__JsGen_expr(g, a.expr);
	v__gen__js__JsGen_write(g, tos3(" ) {"));
	string s_assertion = string_replace(v__ast__Expr_str(a.expr), tos3("\""), tos3("\'"));
	string mod_path = g->file.path;
	if (g->is_test) {
		v__gen__js__JsGen_writeln(g, tos3("	g_test_oks++;"));
		v__gen__js__JsGen_writeln(g, _STR("	cb_assertion_ok(\"%.*s\000\", %"PRId32"\000, \"assert %.*s\000\", \"%.*s\000()\" );", 5, mod_path, a.pos.line_nr + 1, s_assertion, g->fn_decl->name));
		v__gen__js__JsGen_writeln(g, tos3("} else {"));
		v__gen__js__JsGen_writeln(g, tos3("	g_test_fails++;"));
		v__gen__js__JsGen_writeln(g, _STR("	cb_assertion_failed(\"%.*s\000\", %"PRId32"\000, \"assert %.*s\000\", \"%.*s\000()\" );", 5, mod_path, a.pos.line_nr + 1, s_assertion, g->fn_decl->name));
		v__gen__js__JsGen_writeln(g, tos3("	exit(1);"));
		v__gen__js__JsGen_writeln(g, tos3("}"));
		return ;
	}
	v__gen__js__JsGen_writeln(g, tos3("} else {"));
	v__gen__js__JsGen_writeln(g, _STR("	eprintln(\"%.*s\000:%"PRId32"\000: FAIL: fn %.*s\000(): assert %.*s\000\");", 5, mod_path, a.pos.line_nr + 1, g->fn_decl->name, s_assertion));
	v__gen__js__JsGen_writeln(g, tos3("	exit(1);"));
	v__gen__js__JsGen_writeln(g, tos3("}"));
}

static void v__gen__js__JsGen_gen_assign_stmt(v__gen__js__JsGen* g, v__ast__AssignStmt it) {
	if (it.left.len > it.right.len) {
		strings__Builder jsdoc = strings__new_builder(50);
		strings__Builder_write(&jsdoc, tos3("["));
		strings__Builder stmt = strings__new_builder(50);
		strings__Builder_write(&stmt, tos3("const ["));
		// FOR IN array
		array tmp2 = it.left;
		for (int i = 0; i < tmp2.len; i++) {
			v__ast__Ident ident = ((v__ast__Ident*)tmp2.data)[i];
			v__ast__IdentVar ident_var_info = v__ast__Ident_var_info(&ident);
			string styp = v__gen__js__JsGen_typ(g, ident_var_info.typ);
			strings__Builder_write(&jsdoc, styp);
			strings__Builder_write(&stmt, _STR("%.*s", 1, ident.name));
			if (i < it.left.len - 1) {
				strings__Builder_write(&jsdoc, tos3(", "));
				strings__Builder_write(&stmt, tos3(", "));
			}
		}
		strings__Builder_write(&jsdoc, tos3("]"));
		strings__Builder_write(&stmt, tos3("] = "));
		v__gen__js__JsGen_writeln(g, v__gen__js__JsDoc_gen_typ(g->doc, strings__Builder_str(&jsdoc), tos3("")));
		v__gen__js__JsGen_write(g, strings__Builder_str(&stmt));
		v__gen__js__JsGen_expr(g, (*(v__ast__Expr*)array_get(it.right, 0)));
		v__gen__js__JsGen_writeln(g, tos3(";"));
	} else {
		// FOR IN array
		array tmp4 = it.left;
		for (int i = 0; i < tmp4.len; i++) {
			v__ast__Ident ident = ((v__ast__Ident*)tmp4.data)[i];
			v__ast__Expr val = (*(v__ast__Expr*)array_get(it.right, i));
			v__ast__IdentVar ident_var_info = v__ast__Ident_var_info(&ident);
			string styp = v__gen__js__JsGen_typ(g, ident_var_info.typ);
			if (val.typ == 180 /* v.ast.EnumVal */) {
				v__ast__EnumVal* it = (v__ast__EnumVal*)val.obj; // ST it
				styp = tos3("number");
			}else if (val.typ == 214 /* v.ast.StructInit */) {
				v__ast__StructInit* it = (v__ast__StructInit*)val.obj; // ST it
				styp = tos3("");
			}else {
			};
			if (!g->inside_loop && styp.len > 0) {
				v__gen__js__JsGen_writeln(g, v__gen__js__JsDoc_gen_typ(g->doc, styp, ident.name));
			}
			if (g->inside_loop || ident.is_mut) {
				v__gen__js__JsGen_write(g, tos3("let "));
			} else {
				v__gen__js__JsGen_write(g, tos3("const "));
			}
			v__gen__js__JsGen_write(g, _STR("%.*s\000 = ", 2, ident.name));
			v__gen__js__JsGen_expr(g, val);
			if (g->inside_loop) {
				v__gen__js__JsGen_write(g, tos3("; "));
			} else {
				v__gen__js__JsGen_writeln(g, tos3(";"));
			}
		}
	}
}

static void v__gen__js__JsGen_gen_attr(v__gen__js__JsGen* g, v__ast__Attr it) {
	v__gen__js__JsGen_writeln(g, _STR("/* [%.*s\000] */", 2, it.name));
}

static void v__gen__js__JsGen_gen_block(v__gen__js__JsGen* g, v__ast__Block it) {
	v__gen__js__JsGen_writeln(g, tos3("{"));
	v__gen__js__JsGen_stmts(g, it.stmts);
	v__gen__js__JsGen_writeln(g, tos3("}"));
}

static void v__gen__js__JsGen_gen_branch_stmt(v__gen__js__JsGen* g, v__ast__BranchStmt it) {
	v__gen__js__JsGen_write(g, v__token__Kind_str(it.tok.kind));
	v__gen__js__JsGen_writeln(g, tos3(";"));
}

static void v__gen__js__JsGen_gen_const_decl(v__gen__js__JsGen* g, v__ast__ConstDecl it) {
	// FOR IN array
	array tmp1 = it.fields;
	for (int i = 0; i < tmp1.len; i++) {
		v__ast__ConstField field = ((v__ast__ConstField*)tmp1.data)[i];
		int pos = g->out.len;
		v__gen__js__JsGen_expr(g, field.expr);
		string val = strings__Builder_after(&g->out, pos);
		strings__Builder_go_back(&g->out, val.len);
		string typ = v__gen__js__JsGen_typ(g, field.typ);
		strings__Builder_write(&g->constants, tos3("\t"));
		strings__Builder_writeln(&g->constants, v__gen__js__JsDoc_gen_typ(g->doc, typ, field.name));
		strings__Builder_write(&g->constants, tos3("\t"));
		strings__Builder_write(&g->constants, _STR("%.*s\000: %.*s", 2, field.name, val));
		if (i < it.fields.len - 1) {
			strings__Builder_writeln(&g->constants, tos3(","));
		}
	}
	strings__Builder_writeln(&g->constants, tos3(""));
}

static void v__gen__js__JsGen_gen_defer_stmts(v__gen__js__JsGen* g) {
	v__gen__js__JsGen_writeln(g, tos3("(function defer() {"));
	// FOR IN array
	array tmp1 = g->defer_stmts;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__DeferStmt defer_stmt = ((v__ast__DeferStmt*)tmp1.data)[tmp2];
		v__gen__js__JsGen_stmts(g, defer_stmt.stmts);
	}
	v__gen__js__JsGen_writeln(g, tos3("})();"));
}

static void v__gen__js__JsGen_gen_enum_decl(v__gen__js__JsGen* g, v__ast__EnumDecl it) {
	v__gen__js__JsGen_writeln(g, _STR("const %.*s\000 = Object.freeze({", 2, it.name));
	v__gen__js__JsGen_inc_indent(g);
	// FOR IN array
	array tmp1 = it.fields;
	for (int i = 0; i < tmp1.len; i++) {
		v__ast__EnumField field = ((v__ast__EnumField*)tmp1.data)[i];
		v__gen__js__JsGen_write(g, _STR("%.*s\000: ", 2, field.name));
		if (field.has_expr) {
			int pos = g->out.len;
			v__gen__js__JsGen_expr(g, field.expr);
			string expr_str = strings__Builder_after(&g->out, pos);
			strings__Builder_go_back(&g->out, expr_str.len);
			v__gen__js__JsGen_write(g, _STR("%.*s", 1, expr_str));
		} else {
			v__gen__js__JsGen_write(g, _STR("%"PRId32"", 1, i));
		}
		v__gen__js__JsGen_writeln(g, tos3(","));
	}
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_writeln(g, tos3("});"));
	if (it.is_pub) {
		v__gen__js__JsGen_push_pub_var(g, it.name);
	}
}

static void v__gen__js__JsGen_gen_expr_stmt(v__gen__js__JsGen* g, v__ast__ExprStmt it) {
	v__gen__js__JsGen_expr(g, it.expr);
	v__ast__Expr expr = it.expr;
	if (expr.typ == 154 /* v.ast.IfExpr */) {
		v__ast__IfExpr* it = (v__ast__IfExpr*)expr.obj; // ST it
	}else {
		if (!g->inside_ternary) {
			v__gen__js__JsGen_writeln(g, tos3(";"));
		}
	};
}

static void v__gen__js__JsGen_gen_fn_decl(v__gen__js__JsGen* g, v__ast__FnDecl it) {
	if (it.is_method) {
		return ;
	}
	if (it.no_body) {
		return ;
	}
	v__gen__js__JsGen_gen_method_decl(g, it);
}

static void v__gen__js__JsGen_gen_method_decl(v__gen__js__JsGen* g, v__ast__FnDecl it) {
	g->fn_decl = &it;
	bool has_go = v__gen__js__fn_has_go(it);
	bool is_main = string_eq(it.name, tos3("main"));
	if (is_main) {
		v__gen__js__JsGen_writeln(g, tos3("/* program entry point */"));
		v__gen__js__JsGen_write(g, tos3("("));
		if (has_go) {
			v__gen__js__JsGen_write(g, tos3("async "));
		}
		v__gen__js__JsGen_write(g, tos3("function("));
	} else {
		string name = it.name;
		byte c = string_at(name, 0);
		if ((c == '+' || c == '-' || c == '*' || c == '/')) {
			name = v__util__replace_op(name);
		}
		v__gen__js__JsGen_writeln(g, v__gen__js__JsDoc_gen_fn(g->doc, it));
		if (has_go) {
			v__gen__js__JsGen_write(g, tos3("async "));
		}
		if (!it.is_method) {
			v__gen__js__JsGen_write(g, tos3("function "));
		}
		v__gen__js__JsGen_write(g, _STR("%.*s\000(", 2, name));
		if (it.is_pub) {
			v__gen__js__JsGen_push_pub_var(g, name);
		}
	}
	array_v__table__Arg args = it.args;
	if (it.is_method) {
		args = array_slice(args, 1, args.len);
	}
	v__gen__js__JsGen_fn_args(g, args, it.is_variadic);
	v__gen__js__JsGen_writeln(g, tos3(") {"));
	if (it.is_method) {
		v__gen__js__JsGen_inc_indent(g);
		v__gen__js__JsGen_writeln(g, _STR("const %.*s\000 = this;", 2, (*(v__table__Arg*)array_get(it.args, 0)).name));
		v__gen__js__JsGen_dec_indent(g);
	}
	v__gen__js__JsGen_stmts(g, it.stmts);
	v__gen__js__JsGen_write(g, tos3("}"));
	if (is_main) {
		v__gen__js__JsGen_write(g, tos3(")();"));
	}
	v__gen__js__JsGen_writeln(g, tos3(""));
	g->fn_decl = 0;
}

static void v__gen__js__JsGen_gen_for_c_stmt(v__gen__js__JsGen* g, v__ast__ForCStmt it) {
	g->inside_loop = true;
	v__gen__js__JsGen_write(g, tos3("for ("));
	if (it.has_init) {
		v__gen__js__JsGen_stmt(g, it.init);
	} else {
		v__gen__js__JsGen_write(g, tos3("; "));
	}
	if (it.has_cond) {
		v__gen__js__JsGen_expr(g, it.cond);
	}
	v__gen__js__JsGen_write(g, tos3("; "));
	if (it.has_inc) {
		v__gen__js__JsGen_expr(g, it.inc);
	}
	v__gen__js__JsGen_writeln(g, tos3(") {"));
	v__gen__js__JsGen_stmts(g, it.stmts);
	v__gen__js__JsGen_writeln(g, tos3("}"));
	g->inside_loop = false;
}

static void v__gen__js__JsGen_gen_for_in_stmt(v__gen__js__JsGen* g, v__ast__ForInStmt it) {
	if (it.is_range) {
		string i = it.val_var;
		g->inside_loop = true;
		v__gen__js__JsGen_write(g, _STR("for (let %.*s\000 = ", 2, i));
		v__gen__js__JsGen_expr(g, it.cond);
		v__gen__js__JsGen_write(g, _STR("; %.*s\000 < ", 2, i));
		v__gen__js__JsGen_expr(g, it.high);
		v__gen__js__JsGen_writeln(g, _STR("; ++%.*s\000) {", 2, i));
		g->inside_loop = false;
		v__gen__js__JsGen_stmts(g, it.stmts);
		v__gen__js__JsGen_writeln(g, tos3("}"));
	} else if (it.kind == v__table__Kind_array || v__table__Type_flag_is(it.cond_type, v__table__TypeFlag_variadic)) {
		string i = (string_eq(it.key_var, tos3("")) ?  ( v__gen__js__JsGen_new_tmp_var(g) )  :  ( it.key_var ) );
		g->inside_loop = true;
		v__gen__js__JsGen_write(g, _STR("for (let %.*s\000 = 0; %.*s\000 < ", 3, i, i));
		v__gen__js__JsGen_expr(g, it.cond);
		v__gen__js__JsGen_writeln(g, _STR(".length; ++%.*s\000) {", 2, i));
		g->inside_loop = false;
		v__gen__js__JsGen_write(g, _STR("\tlet %.*s\000 = ", 2, it.val_var));
		v__gen__js__JsGen_expr(g, it.cond);
		v__gen__js__JsGen_writeln(g, _STR("[%.*s\000];", 2, i));
		v__gen__js__JsGen_stmts(g, it.stmts);
		v__gen__js__JsGen_writeln(g, tos3("}"));
	} else if (it.kind == v__table__Kind_map) {
		string key = (string_eq(it.key_var, tos3("")) ?  ( v__gen__js__JsGen_new_tmp_var(g) )  :  ( it.key_var ) );
		v__gen__js__JsGen_write(g, _STR("for (let [%.*s\000, %.*s\000] of ", 3, key, it.val_var));
		v__gen__js__JsGen_expr(g, it.cond);
		v__gen__js__JsGen_writeln(g, tos3(") {"));
		v__gen__js__JsGen_stmts(g, it.stmts);
		v__gen__js__JsGen_writeln(g, tos3("}"));
	} else if (it.kind == v__table__Kind_string) {
		string i = (string_eq(it.key_var, tos3("")) ?  ( v__gen__js__JsGen_new_tmp_var(g) )  :  ( it.key_var ) );
		g->inside_loop = true;
		v__gen__js__JsGen_write(g, _STR("for (let %.*s\000 = 0; %.*s\000 < ", 3, i, i));
		v__gen__js__JsGen_expr(g, it.cond);
		v__gen__js__JsGen_writeln(g, _STR(".length; ++%.*s\000) {", 2, i));
		g->inside_loop = false;
		v__gen__js__JsGen_write(g, _STR("\tlet %.*s\000 = ", 2, it.val_var));
		v__gen__js__JsGen_expr(g, it.cond);
		v__gen__js__JsGen_writeln(g, _STR("[%.*s\000];", 2, i));
		v__gen__js__JsGen_stmts(g, it.stmts);
		v__gen__js__JsGen_writeln(g, tos3("}"));
	}
}

static void v__gen__js__JsGen_gen_for_stmt(v__gen__js__JsGen* g, v__ast__ForStmt it) {
	v__gen__js__JsGen_write(g, tos3("while ("));
	if (it.is_inf) {
		v__gen__js__JsGen_write(g, tos3("true"));
	} else {
		v__gen__js__JsGen_expr(g, it.cond);
	}
	v__gen__js__JsGen_writeln(g, tos3(") {"));
	v__gen__js__JsGen_stmts(g, it.stmts);
	v__gen__js__JsGen_writeln(g, tos3("}"));
}

static void v__gen__js__JsGen_fn_args(v__gen__js__JsGen* g, array_v__table__Arg args, bool is_variadic) {
	// FOR IN array
	array tmp1 = args;
	for (int i = 0; i < tmp1.len; i++) {
		v__table__Arg arg = ((v__table__Arg*)tmp1.data)[i];
		bool is_varg = i == args.len - 1 && is_variadic;
		if (is_varg) {
			v__gen__js__JsGen_write(g, _STR("...%.*s", 1, arg.name));
		} else {
			v__gen__js__JsGen_write(g, arg.name);
		}
		if (i < args.len - 1) {
			v__gen__js__JsGen_write(g, tos3(", "));
		}
	}
}

static void v__gen__js__JsGen_gen_go_stmt(v__gen__js__JsGen* g, v__ast__GoStmt node) {
	if (node.call_expr.typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* it = (v__ast__CallExpr*)node.call_expr.obj; // ST it
		string name = it->name;
		if (it->is_method) {
			v__table__TypeSymbol* receiver_sym = v__table__Table_get_type_symbol(g->table, it->receiver_type);
			name = string_add(string_add(receiver_sym->name, tos3(".")), name);
		}
		v__gen__js__JsGen_writeln(g, tos3("await new Promise(function(resolve){"));
		v__gen__js__JsGen_inc_indent(g);
		v__gen__js__JsGen_write(g, _STR("%.*s\000(", 2, name));
		// FOR IN array
		array tmp3 = it->args;
		for (int i = 0; i < tmp3.len; i++) {
			v__ast__CallArg arg = ((v__ast__CallArg*)tmp3.data)[i];
			v__gen__js__JsGen_expr(g, arg.expr);
			if (i < it->args.len - 1) {
				v__gen__js__JsGen_write(g, tos3(", "));
			}
		}
		v__gen__js__JsGen_writeln(g, tos3(");"));
		v__gen__js__JsGen_writeln(g, tos3("resolve();"));
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_writeln(g, tos3("});"));
	}else {
	};
}

static void v__gen__js__JsGen_gen_map_init_expr(v__gen__js__JsGen* g, v__ast__MapInit it) {
	if (it.vals.len > 0) {
		v__gen__js__JsGen_writeln(g, tos3("new Map(["));
		v__gen__js__JsGen_inc_indent(g);
		// FOR IN array
		array tmp2 = it.keys;
		for (int i = 0; i < tmp2.len; i++) {
			v__ast__Expr key = ((v__ast__Expr*)tmp2.data)[i];
			v__ast__Expr val = (*(v__ast__Expr*)array_get(it.vals, i));
			v__gen__js__JsGen_write(g, tos3("["));
			v__gen__js__JsGen_expr(g, key);
			v__gen__js__JsGen_write(g, tos3(", "));
			v__gen__js__JsGen_expr(g, val);
			v__gen__js__JsGen_write(g, tos3("]"));
			if (i < it.keys.len - 1) {
				v__gen__js__JsGen_write(g, tos3(","));
			}
			v__gen__js__JsGen_writeln(g, tos3(""));
		}
		v__gen__js__JsGen_dec_indent(g);
		v__gen__js__JsGen_write(g, tos3("])"));
	} else {
		v__gen__js__JsGen_write(g, tos3("new Map()"));
	}
}

static void v__gen__js__JsGen_gen_return_stmt(v__gen__js__JsGen* g, v__ast__Return it) {
	v__gen__js__JsGen_write(g, tos3("return "));
	if (string_eq(g->fn_decl->name, tos3("main"))) {
		v__gen__js__JsGen_writeln(g, tos3("void;"));
		return ;
	}
	if (it.exprs.len > 1) {
		v__gen__js__JsGen_write(g, tos3("["));
		// FOR IN array
		array tmp3 = it.exprs;
		for (int i = 0; i < tmp3.len; i++) {
			v__ast__Expr expr = ((v__ast__Expr*)tmp3.data)[i];
			v__gen__js__JsGen_expr(g, expr);
			if (i < it.exprs.len - 1) {
				v__gen__js__JsGen_write(g, tos3(", "));
			}
		}
		v__gen__js__JsGen_write(g, tos3("]"));
	} else {
		v__gen__js__JsGen_expr(g, (*(v__ast__Expr*)array_get(it.exprs, 0)));
	}
	v__gen__js__JsGen_writeln(g, tos3(";"));
}

static void v__gen__js__JsGen_enum_expr(v__gen__js__JsGen* g, v__ast__Expr node) {
	if (node.typ == 180 /* v.ast.EnumVal */) {
		v__ast__EnumVal* it = (v__ast__EnumVal*)node.obj; // ST it
		v__gen__js__JsGen_write(g, it->val);
	}else {
		v__gen__js__JsGen_expr(g, node);
	};
}

static void v__gen__js__JsGen_gen_struct_decl(v__gen__js__JsGen* g, v__ast__StructDecl node) {
	v__gen__js__JsGen_writeln(g, _STR("class %.*s\000 {", 2, node.name));
	v__gen__js__JsGen_inc_indent(g);
	v__gen__js__JsGen_writeln(g, v__gen__js__JsDoc_gen_ctor(g->doc, node.fields));
	v__gen__js__JsGen_writeln(g, tos3("constructor(values) {"));
	v__gen__js__JsGen_inc_indent(g);
	// FOR IN array
	array tmp1 = node.fields;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__StructField field = ((v__ast__StructField*)tmp1.data)[tmp2];
		v__gen__js__JsGen_writeln(g, _STR("this.%.*s\000 = values.%.*s", 2, field.name, field.name));
	}
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_writeln(g, tos3("}"));
	v__gen__js__JsGen_writeln(g, tos3(""));
	array_v__ast__Stmt fns = (*(array_v__ast__Stmt*)map_get3(g->method_fn_decls, node.name, &(array_v__ast__Stmt[]){ __new_array(0, 1, sizeof(v__ast__Stmt)) }));
	// FOR IN array
	array tmp3 = fns;
	for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
		v__ast__Stmt cfn = ((v__ast__Stmt*)tmp3.data)[tmp4];
		if (cfn.typ == 111 /* v.ast.FnDecl */) {
			v__ast__FnDecl* it = (v__ast__FnDecl*)cfn.obj; // ST it
			v__gen__js__JsGen_gen_method_decl(g, */*d*/it);
		}else {
		};
	}
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_writeln(g, tos3("}"));
	if (node.is_pub) {
		v__gen__js__JsGen_push_pub_var(g, node.name);
	}
}

static void v__gen__js__JsGen_gen_struct_init(v__gen__js__JsGen* g, v__ast__StructInit it) {
	v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(g->table, it.typ);
	v__gen__js__JsGen_writeln(g, _STR("new %.*s\000({", 2, type_sym->name));
	v__gen__js__JsGen_inc_indent(g);
	// FOR IN array
	array tmp1 = it.fields;
	for (int i = 0; i < tmp1.len; i++) {
		v__ast__StructInitField field = ((v__ast__StructInitField*)tmp1.data)[i];
		v__gen__js__JsGen_write(g, _STR("%.*s\000: ", 2, field.name));
		v__gen__js__JsGen_expr(g, field.expr);
		if (i < it.fields.len - 1) {
			v__gen__js__JsGen_write(g, tos3(", "));
		}
		v__gen__js__JsGen_writeln(g, tos3(""));
	}
	v__gen__js__JsGen_dec_indent(g);
	v__gen__js__JsGen_write(g, tos3("})"));
}

static void v__gen__js__JsGen_gen_ident(v__gen__js__JsGen* g, v__ast__Ident node) {
	if (node.kind == v__ast__IdentKind_constant) {
		v__gen__js__JsGen_write(g, tos3("CONSTANTS."));
	}
	string name = node.name;
	v__gen__js__JsGen_write(g, name);
}

static void v__gen__js__JsGen_gen_selector_expr(v__gen__js__JsGen* g, v__ast__SelectorExpr it) {
	v__gen__js__JsGen_expr(g, it.expr);
	v__gen__js__JsGen_write(g, _STR(".%.*s", 1, it.field));
}

static void v__gen__js__JsGen_gen_if_expr(v__gen__js__JsGen* g, v__ast__IfExpr node) {
	v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(g->table, node.typ);
	if (node.is_expr && node.branches.len >= 2 && node.has_else && type_sym->kind != v__table__Kind_void) {
		v__gen__js__JsGen_write(g, tos3("("));
		g->inside_ternary = true;
		// FOR IN array
		array tmp2 = node.branches;
		for (int i = 0; i < tmp2.len; i++) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)tmp2.data)[i];
			if (i > 0) {
				v__gen__js__JsGen_write(g, tos3(" : "));
			}
			if (i < node.branches.len - 1 || !node.has_else) {
				v__gen__js__JsGen_expr(g, branch.cond);
				v__gen__js__JsGen_write(g, tos3(" ? "));
			}
			v__gen__js__JsGen_stmts(g, branch.stmts);
		}
		g->inside_ternary = false;
		v__gen__js__JsGen_write(g, tos3(")"));
	} else {
		// FOR IN array
		array tmp5 = node.branches;
		for (int i = 0; i < tmp5.len; i++) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)tmp5.data)[i];
			if (i == 0) {
				if (branch.cond.typ == 158 /* v.ast.IfGuardExpr */) {
					v__ast__IfGuardExpr* it = (v__ast__IfGuardExpr*)branch.cond.obj; // ST it
				}else {
					v__gen__js__JsGen_write(g, tos3("if ("));
					v__gen__js__JsGen_expr(g, branch.cond);
					v__gen__js__JsGen_writeln(g, tos3(") {"));
				};
			} else if (i < node.branches.len - 1 || !node.has_else) {
				v__gen__js__JsGen_write(g, tos3("} else if ("));
				v__gen__js__JsGen_expr(g, branch.cond);
				v__gen__js__JsGen_writeln(g, tos3(") {"));
			} else if (i == node.branches.len - 1 && node.has_else) {
				v__gen__js__JsGen_writeln(g, tos3("} else {"));
			}
			v__gen__js__JsGen_stmts(g, branch.stmts);
		}
		v__gen__js__JsGen_writeln(g, tos3("}"));
		v__gen__js__JsGen_writeln(g, tos3(""));
	}
}

static void v__gen__js__verror(string s) {
	v__util__verror(tos3("jsgen error"), s);
}

static bool v__gen__js__fn_has_go(v__ast__FnDecl it) {
	bool has_go = false;
	// FOR IN array
	array tmp1 = it.stmts;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)tmp1.data)[tmp2];
		if (stmt.typ == 174 /* v.ast.GoStmt */) {
			v__ast__GoStmt* it = (v__ast__GoStmt*)stmt.obj; // ST it
			has_go = true;
		}else {
		};
	}
	return has_go;
}

static v__gen__js__JsDoc* v__gen__js__new_jsdoc(v__gen__js__JsGen* gen) {
	return (v__gen__js__JsDoc*)memdup(&(v__gen__js__JsDoc){	.out = strings__new_builder(20),
		.gen = gen,
		.empty_line = 0,
	}, sizeof(v__gen__js__JsDoc));
}

static void v__gen__js__JsDoc_gen_indent(v__gen__js__JsDoc* d) {
	if ((*(int*)map_get3(d->gen->indents, d->gen->namespace, &(int[]){ 0 })) > 0 && d->empty_line) {
		strings__Builder_write(&d->out, (*(string*)array_get(_const_v__gen__js__tabs, (*(int*)map_get3(d->gen->indents, d->gen->namespace, &(int[]){ 0 })))));
	}
	d->empty_line = false;
}

static void v__gen__js__JsDoc_write(v__gen__js__JsDoc* d, string s) {
	v__gen__js__JsDoc_gen_indent(d);
	strings__Builder_write(&d->out, s);
}

static void v__gen__js__JsDoc_writeln(v__gen__js__JsDoc* d, string s) {
	v__gen__js__JsDoc_gen_indent(d);
	strings__Builder_writeln(&d->out, s);
	d->empty_line = true;
}

static void v__gen__js__JsDoc_reset(v__gen__js__JsDoc* d) {
	d->out = strings__new_builder(20);
	d->empty_line = false;
}

static string v__gen__js__JsDoc_gen_typ(v__gen__js__JsDoc* d, string typ, string name) {
	v__gen__js__JsDoc_reset(d);
	v__gen__js__JsDoc_write(d, tos3("/**"));
	v__gen__js__JsDoc_write(d, _STR(" @type {%.*s\000}", 2, typ));
	if (name.len > 0) {
		v__gen__js__JsDoc_write(d, _STR(" - %.*s", 1, name));
	}
	v__gen__js__JsDoc_write(d, tos3(" */"));
	return strings__Builder_str(&d->out);
}

static string v__gen__js__JsDoc_gen_ctor(v__gen__js__JsDoc* d, array_v__ast__StructField fields) {
	v__gen__js__JsDoc_reset(d);
	v__gen__js__JsDoc_writeln(d, tos3("/**"));
	v__gen__js__JsDoc_write(d, tos3("* @param {{"));
	// FOR IN array
	array tmp1 = fields;
	for (int i = 0; i < tmp1.len; i++) {
		v__ast__StructField field = ((v__ast__StructField*)tmp1.data)[i];
		v__gen__js__JsDoc_write(d, _STR("%.*s\000: %.*s", 2, field.name, v__gen__js__JsGen_typ(d->gen, field.typ)));
		if (i < fields.len - 1) {
			v__gen__js__JsDoc_write(d, tos3(", "));
		}
	}
	v__gen__js__JsDoc_writeln(d, tos3("}} values - values for this class fields"));
	v__gen__js__JsDoc_writeln(d, tos3("* @constructor"));
	v__gen__js__JsDoc_write(d, tos3("*/"));
	return strings__Builder_str(&d->out);
}

static string v__gen__js__JsDoc_gen_fn(v__gen__js__JsDoc* d, v__ast__FnDecl it) {
	v__gen__js__JsDoc_reset(d);
	string type_name = v__gen__js__JsGen_typ(d->gen, it.return_type);
	v__gen__js__JsDoc_writeln(d, tos3("/**"));
	// FOR IN array
	array tmp1 = it.args;
	for (int i = 0; i < tmp1.len; i++) {
		v__table__Arg arg = ((v__table__Arg*)tmp1.data)[i];
		if (it.is_method && i == 0) {
			continue;
		}
		string arg_type_name = v__gen__js__JsGen_typ(d->gen, arg.typ);
		bool is_varg = i == it.args.len - 1 && it.is_variadic;
		if (is_varg) {
			v__gen__js__JsDoc_writeln(d, _STR("* @param {...%.*s\000} %.*s", 2, arg_type_name, arg.name));
		} else {
			v__gen__js__JsDoc_writeln(d, _STR("* @param {%.*s\000} %.*s", 2, arg_type_name, arg.name));
		}
	}
	v__gen__js__JsDoc_writeln(d, _STR("* @return {%.*s\000}", 2, type_name));
	v__gen__js__JsDoc_write(d, tos3("*/"));
	return strings__Builder_str(&d->out);
}

void v__gen__x64__Gen_generate_elf_header(v__gen__x64__Gen* g) {
	_PUSH_MANY(&g->buf, (new_array_from_c_array(4, 4, sizeof(byte), (byte[4]){
		((byte)(_const_v__gen__x64__mag0)), _const_v__gen__x64__mag1, _const_v__gen__x64__mag2, _const_v__gen__x64__mag3, 
})), tmp1, array_byte);
	array_push(&g->buf, &(byte[]){ _const_v__gen__x64__elfclass64 });
	array_push(&g->buf, &(byte[]){ _const_v__gen__x64__elfdata2lsb });
	array_push(&g->buf, &(byte[]){ _const_v__gen__x64__ev_current });
	array_push(&g->buf, &(byte[]){ 1 });
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write16(g, 2);
	v__gen__x64__Gen_write16(g, _const_v__gen__x64__e_machine);
	v__gen__x64__Gen_write32(g, _const_v__gen__x64__ev_current);
	int eh_size = 0x40;
	int phent_size = 0x38;
	v__gen__x64__Gen_write64(g, _const_v__gen__x64__segment_start + eh_size + phent_size);
	v__gen__x64__Gen_write64(g, 0x40);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write32(g, 0);
	v__gen__x64__Gen_write16(g, eh_size);
	v__gen__x64__Gen_write16(g, phent_size);
	v__gen__x64__Gen_write16(g, 1);
	v__gen__x64__Gen_write16(g, 0);
	v__gen__x64__Gen_write16(g, 0);
	v__gen__x64__Gen_write16(g, 0);
	v__gen__x64__Gen_write32(g, 1);
	v__gen__x64__Gen_write32(g, 5);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, _const_v__gen__x64__segment_start);
	v__gen__x64__Gen_write64(g, _const_v__gen__x64__segment_start);
	g->file_size_pos = g->buf.len;
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, 0x1000);
	println(_STR("code_start_pos = %.*s", 1, int_hex(g->buf.len)));
	g->code_start_pos = g->buf.len;
	g->debug_pos = g->buf.len;
	v__gen__x64__Gen_call(g, _const_v__gen__x64__PLACEHOLDER);
	v__gen__x64__Gen_println(g, tos3("call fn main"));
}

void v__gen__x64__Gen_generate_elf_footer(v__gen__x64__Gen* g) {
	// FOR IN array
	array tmp1 = g->strings;
	for (int i = 0; i < tmp1.len; i++) {
		string s = ((string*)tmp1.data)[i];
		v__gen__x64__Gen_write64_at(g, _const_v__gen__x64__segment_start + g->buf.len, ((int)((*(i64*)array_get(g->str_pos, i)))));
		v__gen__x64__Gen_write_string(g, s);
		v__gen__x64__Gen_write8(g, 6);
	}
	int file_size = g->buf.len;
	v__gen__x64__Gen_write64_at(g, file_size, g->file_size_pos);
	v__gen__x64__Gen_write64_at(g, file_size, g->file_size_pos + 8);
	v__gen__x64__Gen_write32_at(g, g->code_start_pos + 1, ((int)(g->main_fn_addr - g->code_start_pos)) - 5);
	Option_os__File f = os__create(g->out_name);
	if (!f.ok) {
		string err = f.v_error;
		int errcode = f.ecode;
		 // typeof it_expr_type: v.ast.CallExpr
		// last_type: v.ast.ExprStmt
		// last_expr_result_type: void
		v_panic(err);
	};
	os__chmod(g->out_name, 0775);
	os__File_write_bytes(&/*opt*/(*(os__File*)f.data), g->buf.data, g->buf.len);
	os__File_close(&/*opt*/(*(os__File*)f.data));
	println(tos3("\nx64 elf binary has been successfully generated"));
}

static void v__gen__x64__Gen_section_header(v__gen__x64__Gen* g, v__gen__x64__SectionConfig c) {
	v__gen__x64__Gen_write32(g, g->sect_header_name_pos);
	g->sect_header_name_pos += c.name.len + 1;
	v__gen__x64__Gen_write32(g, ((int)(c.typ)));
	v__gen__x64__Gen_write64(g, c.flags);
	v__gen__x64__Gen_write64(g, 0);
	v__gen__x64__Gen_write64(g, g->offset);
	g->offset += c.datalen + 1;
	v__gen__x64__Gen_write64(g, c.datalen);
	v__gen__x64__Gen_write32(g, c.link);
	v__gen__x64__Gen_write32(g, c.info);
	v__gen__x64__Gen_write64(g, c.align);
	v__gen__x64__Gen_write64(g, c.entsize);
}

static void v__gen__x64__genobj() {
}

void v__gen__x64__gen(array_v__ast__File files, string out_name) {
	v__gen__x64__Gen g = (v__gen__x64__Gen){
		.sect_header_name_pos = 0,
		.out_name = out_name,
		.buf = __new_array(0, 1, sizeof(byte)),
		.offset = 0,
		.str_pos = __new_array(0, 1, sizeof(i64)),
		.strings = __new_array(0, 1, sizeof(string)),
		.file_size_pos = 0,
		.main_fn_addr = 0,
		.code_start_pos = 0,
		.fn_addr = new_map_1(sizeof(i64)),
		.var_offset = new_map_1(sizeof(int)),
		.stack_var_pos = 0,
		.debug_pos = 0,
	};
	v__gen__x64__Gen_generate_elf_header(&g);
	// FOR IN array
	array tmp1 = files;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__File file = ((v__ast__File*)tmp1.data)[tmp2];
		v__gen__x64__Gen_stmts(&g, file.stmts);
	}
	v__gen__x64__Gen_generate_elf_footer(&g);
}

void v__gen__x64__Gen_stmts(v__gen__x64__Gen* g, array_v__ast__Stmt stmts) {
	// FOR IN array
	array tmp1 = stmts;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)tmp1.data)[tmp2];
		v__gen__x64__Gen_stmt(g, stmt);
	}
}

i64 v__gen__x64__Gen_pos(v__gen__x64__Gen* g) {
	return g->buf.len;
}

static void v__gen__x64__Gen_write8(v__gen__x64__Gen* g, int n) {
	array_push(&g->buf, &(byte[]){ ((byte)(n)) });
}

static void v__gen__x64__Gen_write16(v__gen__x64__Gen* g, int n) {
	array_push(&g->buf, &(byte[]){ ((byte)(n)) });
	array_push(&g->buf, &(byte[]){ ((byte)(n >> 8)) });
}

static void v__gen__x64__Gen_write32(v__gen__x64__Gen* g, int n) {
	array_push(&g->buf, &(byte[]){ ((byte)(n)) });
	array_push(&g->buf, &(byte[]){ ((byte)(n >> 8)) });
	array_push(&g->buf, &(byte[]){ ((byte)(n >> 16)) });
	array_push(&g->buf, &(byte[]){ ((byte)(n >> 24)) });
}

static void v__gen__x64__Gen_write64(v__gen__x64__Gen* g, i64 n) {
	array_push(&g->buf, &(byte[]){ ((byte)(n)) });
	array_push(&g->buf, &(byte[]){ ((byte)(n >> 8)) });
	array_push(&g->buf, &(byte[]){ ((byte)(n >> 16)) });
	array_push(&g->buf, &(byte[]){ ((byte)(n >> 24)) });
	array_push(&g->buf, &(byte[]){ ((byte)(n >> 32)) });
	array_push(&g->buf, &(byte[]){ ((byte)(n >> 40)) });
	array_push(&g->buf, &(byte[]){ ((byte)(n >> 48)) });
	array_push(&g->buf, &(byte[]){ ((byte)(n >> 56)) });
}

static void v__gen__x64__Gen_write64_at(v__gen__x64__Gen* g, i64 n, i64 at) {
	(*(byte*)array_get(g->buf, at)) = ((byte)(n));
	(*(byte*)array_get(g->buf, at + 1)) = ((byte)(n >> 8));
	(*(byte*)array_get(g->buf, at + 2)) = ((byte)(n >> 16));
	(*(byte*)array_get(g->buf, at + 3)) = ((byte)(n >> 24));
	(*(byte*)array_get(g->buf, at + 4)) = ((byte)(n >> 32));
	(*(byte*)array_get(g->buf, at + 5)) = ((byte)(n >> 40));
	(*(byte*)array_get(g->buf, at + 6)) = ((byte)(n >> 48));
	(*(byte*)array_get(g->buf, at + 7)) = ((byte)(n >> 56));
}

static void v__gen__x64__Gen_write32_at(v__gen__x64__Gen* g, i64 at, int n) {
	(*(byte*)array_get(g->buf, at)) = ((byte)(n));
	(*(byte*)array_get(g->buf, at + 1)) = ((byte)(n >> 8));
	(*(byte*)array_get(g->buf, at + 2)) = ((byte)(n >> 16));
	(*(byte*)array_get(g->buf, at + 3)) = ((byte)(n >> 24));
}

static void v__gen__x64__Gen_write_string(v__gen__x64__Gen* g, string s) {
	for (int tmp1 = 0; tmp1 < s.len; tmp1++) {
	byte c = s.str[tmp1];
		v__gen__x64__Gen_write8(g, ((int)(c)));
	}
}

static void v__gen__x64__Gen_inc(v__gen__x64__Gen* g, v__gen__x64__Register reg) {
	v__gen__x64__Gen_write16(g, 0xff49);
	if (reg == v__gen__x64__Register_r12) {
		v__gen__x64__Gen_write8(g, 0xc4);
	}else {
		v_panic(_STR("unhandled inc %.*s", 1, v__gen__x64__Register_str(reg)));
	};
}

static void v__gen__x64__Gen_cmp(v__gen__x64__Gen* g, v__gen__x64__Register reg, v__gen__x64__Size size, i64 val) {
	v__gen__x64__Gen_write8(g, 0x49);
	if (size == v__gen__x64__Size__8) {
		v__gen__x64__Gen_write8(g, 0x83);
	}else if (size == v__gen__x64__Size__32) {
		v__gen__x64__Gen_write8(g, 0x81);
	}else {
		v_panic(tos3("unhandled cmp"));
	};
	if (reg == v__gen__x64__Register_r12) {
		v__gen__x64__Gen_write8(g, 0xfc);
	}else {
		v_panic(tos3("unhandled cmp"));
	};
	v__gen__x64__Gen_write8(g, ((int)(val)));
}

static int v__gen__x64__Gen_get_var_offset(v__gen__x64__Gen* g, string var_name) {
	int offset = (*(int*)map_get3(g->var_offset, var_name, &(int[]){ 0 }));
	if (offset == 0) {
		v_panic(_STR("0 offset for var `%.*s\000`", 2, var_name));
	}
	return offset;
}

static void v__gen__x64__Gen_cmp_var(v__gen__x64__Gen* g, string var_name, int val) {
	v__gen__x64__Gen_write8(g, 0x81);
	v__gen__x64__Gen_write8(g, 0x7d);
	int offset = v__gen__x64__Gen_get_var_offset(g, var_name);
	v__gen__x64__Gen_write8(g, 0xff - offset + 1);
	v__gen__x64__Gen_write32(g, val);
	v__gen__x64__Gen_println(g, _STR("cmp var `%.*s\000` %"PRId32"", 2, var_name, val));
}

static void v__gen__x64__Gen_inc_var(v__gen__x64__Gen* g, string var_name) {
	v__gen__x64__Gen_write16(g, 0x4581);
	int offset = v__gen__x64__Gen_get_var_offset(g, var_name);
	v__gen__x64__Gen_write8(g, 0xff - offset + 1);
	v__gen__x64__Gen_write32(g, 1);
	v__gen__x64__Gen_println(g, _STR("inc_var `%.*s\000`", 2, var_name));
}

static int v__gen__x64__Gen_jne(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write16(g, 0x850f);
	i64 pos = v__gen__x64__Gen_pos(g);
	v__gen__x64__Gen_write32(g, _const_v__gen__x64__PLACEHOLDER);
	v__gen__x64__Gen_println(g, tos3("jne"));
	return pos;
}

static int v__gen__x64__Gen_jge(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write16(g, 0x8d0f);
	i64 pos = v__gen__x64__Gen_pos(g);
	v__gen__x64__Gen_write32(g, _const_v__gen__x64__PLACEHOLDER);
	v__gen__x64__Gen_println(g, tos3("jne"));
	return pos;
}

static void v__gen__x64__Gen_jmp(v__gen__x64__Gen* g, int addr) {
	v__gen__x64__Gen_write8(g, 0xe9);
	v__gen__x64__Gen_write32(g, addr);
	v__gen__x64__Gen_println(g, tos3("jmp"));
}

static i64 v__gen__x64__abs(i64 a) {
	return (a < 0 ?  ( -a )  :  ( a ) );
}

static void v__gen__x64__Gen_jle(v__gen__x64__Gen* g, i64 addr) {
	int offset = 0xff - ((int)(v__gen__x64__abs(addr - g->buf.len))) - 1;
	v__gen__x64__Gen_write8(g, 0x7e);
	v__gen__x64__Gen_write8(g, offset);
	v__gen__x64__Gen_println(g, tos3("jle"));
}

static void v__gen__x64__Gen_println(v__gen__x64__Gen* g, string comment) {
	string addr = int_hex(g->debug_pos);
	print(term__red(string_add(string_add(strings__repeat('0', 6 - addr.len), addr), tos3("  "))));
	for (int i = g->debug_pos;
	i < g->buf.len; i++) {
		string s = byte_hex((*(byte*)array_get(g->buf, i)));
		if (s.len == 1) {
			print(term__blue(tos3("0")));
		}
		print(string_add(term__blue(byte_hex((*(byte*)array_get(g->buf, i)))), tos3(" ")));
	}
	g->debug_pos = g->buf.len;
	print(string_add(tos3(" "), comment));
	println(tos3(""));
}

static void v__gen__x64__Gen_jl(v__gen__x64__Gen* g, i64 addr) {
	int offset = 0xff - ((int)(v__gen__x64__abs(addr - g->buf.len))) - 1;
	v__gen__x64__Gen_write8(g, 0x7c);
	v__gen__x64__Gen_write8(g, offset);
	v__gen__x64__Gen_println(g, tos3("jl"));
}

static int v__gen__x64__Gen_abs_to_rel_addr(v__gen__x64__Gen* g, i64 addr) {
	return ((int)(v__gen__x64__abs(addr - g->buf.len))) - 1;
}

static void v__gen__x64__Gen_mov64(v__gen__x64__Gen* g, v__gen__x64__Register reg, i64 val) {
	if (reg == v__gen__x64__Register_rsi) {
		v__gen__x64__Gen_write8(g, 0x48);
		v__gen__x64__Gen_write8(g, 0xbe);
	}else {
		println(_STR("unhandled mov %.*s", 1, v__gen__x64__Register_str(reg)));
	};
	v__gen__x64__Gen_write64(g, val);
	v__gen__x64__Gen_println(g, _STR("mov64 %.*s\000, %"PRId64"", 2, v__gen__x64__Register_str(reg), val));
}

static void v__gen__x64__Gen_mov_from_reg(v__gen__x64__Gen* g, int var_offset, v__gen__x64__Register reg) {
	v__gen__x64__Gen_write8(g, 0x89);
	if (reg == v__gen__x64__Register_edi || reg == v__gen__x64__Register_rdi) {
		v__gen__x64__Gen_write8(g, 0x7d);
	}else if (reg == v__gen__x64__Register_rsi) {
		v__gen__x64__Gen_write8(g, 0x75);
	}else {
		v__gen__x64__verror(_STR("mov_from_reg %.*s", 1, v__gen__x64__Register_str(reg)));
	};
	v__gen__x64__Gen_write8(g, 0xff - var_offset + 1);
	v__gen__x64__Gen_println(g, tos3("mov from reg"));
}

static void v__gen__x64__Gen_call(v__gen__x64__Gen* g, int addr) {
	int rel = 0xffffffff - (g->buf.len + 5 - addr - 1);
	v__gen__x64__Gen_write8(g, 0xe8);
	v__gen__x64__Gen_write32(g, rel);
}

static void v__gen__x64__Gen_syscall(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write8(g, 0x0f);
	v__gen__x64__Gen_write8(g, 0x05);
	v__gen__x64__Gen_println(g, tos3("syscall"));
}

void v__gen__x64__Gen_ret(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write8(g, 0xc3);
	v__gen__x64__Gen_println(g, tos3("ret"));
}

void v__gen__x64__Gen_push(v__gen__x64__Gen* g, v__gen__x64__Register reg) {
	if (reg < v__gen__x64__Register_r8) {
		v__gen__x64__Gen_write8(g, 0x50 + reg);
	} else {
		v__gen__x64__Gen_write8(g, 0x41);
		v__gen__x64__Gen_write8(g, 0x50 + reg - 8);
	}
	v__gen__x64__Gen_println(g, _STR("push %.*s", 1, v__gen__x64__Register_str(reg)));
}

void v__gen__x64__Gen_pop(v__gen__x64__Gen* g, v__gen__x64__Register reg) {
	v__gen__x64__Gen_write8(g, 0x58 + reg);
	v__gen__x64__Gen_println(g, _STR("pop %.*s", 1, v__gen__x64__Register_str(reg)));
}

void v__gen__x64__Gen_sub32(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val) {
	v__gen__x64__Gen_write8(g, 0x48);
	v__gen__x64__Gen_write8(g, 0x81);
	v__gen__x64__Gen_write8(g, 0xe8 + reg);
	v__gen__x64__Gen_write32(g, val);
	v__gen__x64__Gen_println(g, _STR("sub %.*s\000,0x%.*s", 2, v__gen__x64__Register_str(reg), int_hex(val)));
}

void v__gen__x64__Gen_add(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val) {
	v__gen__x64__Gen_write8(g, 0x48);
	v__gen__x64__Gen_write8(g, 0x81);
	v__gen__x64__Gen_write8(g, 0xe8 + reg);
	v__gen__x64__Gen_write32(g, val);
	v__gen__x64__Gen_println(g, _STR("add %.*s\000,0x%.*s", 2, v__gen__x64__Register_str(reg), int_hex(val)));
}

static void v__gen__x64__Gen_leave(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write8(g, 0xc9);
	v__gen__x64__Gen_println(g, tos3("leave"));
}

int v__gen__x64__Gen_gen_loop_start(v__gen__x64__Gen* g, int from) {
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_r12, from);
	int label = g->buf.len;
	v__gen__x64__Gen_inc(g, v__gen__x64__Register_r12);
	return label;
}

void v__gen__x64__Gen_gen_loop_end(v__gen__x64__Gen* g, int to, int label) {
	v__gen__x64__Gen_cmp(g, v__gen__x64__Register_r12, v__gen__x64__Size__8, to);
	v__gen__x64__Gen_jl(g, label);
}

void v__gen__x64__Gen_save_main_fn_addr(v__gen__x64__Gen* g) {
	g->main_fn_addr = g->buf.len;
}

void v__gen__x64__Gen_gen_print_from_expr(v__gen__x64__Gen* g, v__ast__Expr expr, bool newline) {
	if (expr.typ == 183 /* v.ast.StringLiteral */) {
		v__ast__StringLiteral* it = (v__ast__StringLiteral*)expr.obj; // ST it
		if (newline) {
			v__gen__x64__Gen_gen_print(g, string_add(it->val, tos3("\n")));
		} else {
			v__gen__x64__Gen_gen_print(g, it->val);
		}
	}else {
	};
}

void v__gen__x64__Gen_gen_print(v__gen__x64__Gen* g, string s) {
	array_push(&g->strings, &(string[]){ s });
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_eax, 1);
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_edi, 1);
	int str_pos = g->buf.len + 2;
	array_push(&g->str_pos, &(i64[]){ str_pos });
	v__gen__x64__Gen_mov64(g, v__gen__x64__Register_rsi, 0);
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_edx, s.len + 1);
	v__gen__x64__Gen_syscall(g);
}

void v__gen__x64__Gen_gen_exit(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_edi, 0);
	v__gen__x64__Gen_mov(g, v__gen__x64__Register_eax, 60);
	v__gen__x64__Gen_syscall(g);
}

static void v__gen__x64__Gen_mov(v__gen__x64__Gen* g, v__gen__x64__Register reg, int val) {
	if (reg == v__gen__x64__Register_eax || reg == v__gen__x64__Register_rax) {
		v__gen__x64__Gen_write8(g, 0xb8);
	}else if (reg == v__gen__x64__Register_edi || reg == v__gen__x64__Register_rdi) {
		v__gen__x64__Gen_write8(g, 0xbf);
	}else if (reg == v__gen__x64__Register_edx) {
		v__gen__x64__Gen_write8(g, 0xba);
	}else if (reg == v__gen__x64__Register_rsi) {
		v__gen__x64__Gen_write8(g, 0x48);
		v__gen__x64__Gen_write8(g, 0xbe);
	}else if (reg == v__gen__x64__Register_r12) {
		v__gen__x64__Gen_write8(g, 0x41);
		v__gen__x64__Gen_write8(g, 0xbc);
	}else {
		v_panic(_STR("unhandled mov %.*s", 1, v__gen__x64__Register_str(reg)));
	};
	v__gen__x64__Gen_write32(g, val);
	v__gen__x64__Gen_println(g, _STR("mov %.*s\000, %"PRId32"", 2, v__gen__x64__Register_str(reg), val));
}

static void v__gen__x64__Gen_mov_reg(v__gen__x64__Gen* g, v__gen__x64__Register a, v__gen__x64__Register b) {
	if (a == v__gen__x64__Register_rbp) {
		v__gen__x64__Gen_write8(g, 0x48);
		v__gen__x64__Gen_write8(g, 0x89);
	}else {
	};
}

static void v__gen__x64__Gen_mov_rbp_rsp(v__gen__x64__Gen* g) {
	v__gen__x64__Gen_write8(g, 0x48);
	v__gen__x64__Gen_write8(g, 0x89);
	v__gen__x64__Gen_write8(g, 0xe5);
	v__gen__x64__Gen_println(g, tos3("mov rbp,rsp"));
}

void v__gen__x64__Gen_register_function_address(v__gen__x64__Gen* g, string name) {
	i64 addr = v__gen__x64__Gen_pos(g);
	map_set(&g->fn_addr, name, &(i64[]) { addr });
}

void v__gen__x64__Gen_call_fn(v__gen__x64__Gen* g, v__ast__CallExpr node) {
	string name = node.name;
	i64 addr = (*(i64*)map_get3(g->fn_addr, name, &(i64[]){ 0 }));
	if (addr == 0) {
		v__gen__x64__verror(_STR("fn addr of `%.*s\000` = 0", 2, name));
	}
	for (int tmp2 = 0; tmp2 < node.args.len; tmp2++) {
		int i = tmp2;
		v__ast__Expr expr = (*(v__ast__CallArg*)array_get(node.args, i)).expr;
		v__ast__IntegerLiteral* int_lit = /* as */ (v__ast__IntegerLiteral*)__as_cast(expr.obj, expr.typ, /*expected:*/186);
		v__gen__x64__Gen_mov(g, (*(v__gen__x64__Register*)array_get(_const_v__gen__x64__fn_arg_registers, i)), string_int(int_lit->val));
	}
	if (node.args.len > 6) {
		v__gen__x64__verror(tos3("more than 6 args not allowed for now"));
	}
	v__gen__x64__Gen_call(g, ((int)(addr)));
	v__gen__x64__Gen_println(g, _STR("fn call `%.*s\000()`", 2, name));
}

static void v__gen__x64__Gen_stmt(v__gen__x64__Gen* g, v__ast__Stmt node) {
	if (node.typ == 132 /* v.ast.AssignStmt */) {
		v__ast__AssignStmt* it = (v__ast__AssignStmt*)node.obj; // ST it
		v__gen__x64__Gen_assign_stmt(g, */*d*/it);
	}else if (node.typ == 188 /* v.ast.ConstDecl */) {
		v__ast__ConstDecl* it = (v__ast__ConstDecl*)node.obj; // ST it
	}else if (node.typ == 177 /* v.ast.ExprStmt */) {
		v__ast__ExprStmt* it = (v__ast__ExprStmt*)node.obj; // ST it
		v__gen__x64__Gen_expr(g, it->expr);
	}else if (node.typ == 111 /* v.ast.FnDecl */) {
		v__ast__FnDecl* it = (v__ast__FnDecl*)node.obj; // ST it
		v__gen__x64__Gen_fn_decl(g, */*d*/it);
	}else if (node.typ == 151 /* v.ast.ForStmt */) {
		v__ast__ForStmt* it = (v__ast__ForStmt*)node.obj; // ST it
		v__gen__x64__Gen_for_stmt(g, */*d*/it);
	}else if (node.typ == 140 /* v.ast.HashStmt */) {
		v__ast__HashStmt* it = (v__ast__HashStmt*)node.obj; // ST it
		array_string words = string_split(it->val, tos3(" "));
		// FOR IN array
		array tmp2 = words;
		for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
			string word = ((string*)tmp2.data)[tmp3];
			if (word.len != 2) {
				v__gen__x64__verror(tos3("opcodes format: xx xx xx xx"));
			}
			int b = strtol(word.str, 0, 16);
			v__gen__x64__Gen_write8(g, b);
		}
	}else if (node.typ == 187 /* v.ast.Module */) {
		v__ast__Module* it = (v__ast__Module*)node.obj; // ST it
	}else if (node.typ == 191 /* v.ast.Return */) {
		v__ast__Return* it = (v__ast__Return*)node.obj; // ST it
		v__gen__x64__Gen_gen_exit(g);
		v__gen__x64__Gen_ret(g);
	}else if (node.typ == 211 /* v.ast.StructDecl */) {
		v__ast__StructDecl* it = (v__ast__StructDecl*)node.obj; // ST it
	}else {
		println(string_add(tos3("x64.stmt(): bad node: "), tos3( /* v.ast.Stmt */ v_typeof_sumtype_108( (node).typ ))));
	};
}


static void v__gen__x64__Gen_expr(v__gen__x64__Gen* g, v__ast__Expr node) {
	if (node.typ == 142 /* v.ast.ArrayInit */) {
		v__ast__ArrayInit* it = (v__ast__ArrayInit*)node.obj; // ST it
	}else if (node.typ == 134 /* v.ast.AssignExpr */) {
		v__ast__AssignExpr* it = (v__ast__AssignExpr*)node.obj; // ST it
	}else if (node.typ == 144 /* v.ast.CallExpr */) {
		v__ast__CallExpr* it = (v__ast__CallExpr*)node.obj; // ST it
		if ((string_eq(it->name, tos3("println")) || string_eq(it->name, tos3("print")) || string_eq(it->name, tos3("eprintln")) || string_eq(it->name, tos3("eprint")))) {
			v__ast__Expr expr = (*(v__ast__CallArg*)array_get(it->args, 0)).expr;
			v__gen__x64__Gen_gen_print_from_expr(g, expr, (string_eq(it->name, tos3("println")) || string_eq(it->name, tos3("eprintln"))));
			return ;
		}
		v__gen__x64__Gen_call_fn(g, */*d*/it);
	}else if (node.typ == 185 /* v.ast.FloatLiteral */) {
		v__ast__FloatLiteral* it = (v__ast__FloatLiteral*)node.obj; // ST it
	}else if (node.typ == 136 /* v.ast.Ident */) {
		v__ast__Ident* it = (v__ast__Ident*)node.obj; // ST it
	}else if (node.typ == 154 /* v.ast.IfExpr */) {
		v__ast__IfExpr* it = (v__ast__IfExpr*)node.obj; // ST it
		v__gen__x64__Gen_if_expr(g, */*d*/it);
	}else if (node.typ == 208 /* v.ast.InfixExpr */) {
		v__ast__InfixExpr* it = (v__ast__InfixExpr*)node.obj; // ST it
	}else if (node.typ == 186 /* v.ast.IntegerLiteral */) {
		v__ast__IntegerLiteral* it = (v__ast__IntegerLiteral*)node.obj; // ST it
	}else if (node.typ == 209 /* v.ast.PostfixExpr */) {
		v__ast__PostfixExpr* it = (v__ast__PostfixExpr*)node.obj; // ST it
		v__gen__x64__Gen_postfix_expr(g, */*d*/it);
	}else if (node.typ == 183 /* v.ast.StringLiteral */) {
		v__ast__StringLiteral* it = (v__ast__StringLiteral*)node.obj; // ST it
	}else if (node.typ == 214 /* v.ast.StructInit */) {
		v__ast__StructInit* it = (v__ast__StructInit*)node.obj; // ST it
	}else if (node.typ == 201 /* v.ast.BoolLiteral */) {
		v__ast__BoolLiteral* it = (v__ast__BoolLiteral*)node.obj; // ST it
	}else {
	};
}

static void v__gen__x64__Gen_allocate_var(v__gen__x64__Gen* g, string name, int size, int initial_val) {
	if (size == 1) {
		v__gen__x64__Gen_write8(g, 0xc6);
		v__gen__x64__Gen_write8(g, 0x45);
	}else if (size == 4) {
		v__gen__x64__Gen_write8(g, 0xc7);
		v__gen__x64__Gen_write8(g, 0x45);
	}else if (size == 8) {
		v__gen__x64__Gen_write8(g, 0x48);
		v__gen__x64__Gen_write8(g, 0xc7);
		v__gen__x64__Gen_write8(g, 0x45);
	}else {
		v__gen__x64__verror(_STR("allocate_var: bad size %"PRId32"", 1, size));
	};
	int n = g->stack_var_pos + size;
	v__gen__x64__Gen_write8(g, 0xff - n + 1);
	g->stack_var_pos += size;
	map_set(&g->var_offset, name, &(int[]) { g->stack_var_pos });
	v__gen__x64__Gen_write32(g, initial_val);
	v__gen__x64__Gen_println(g, _STR("mov DWORD [rbp-0x%"PRId32"\000],%"PRId32"\000 (Aallocate var `%.*s\000`)", 4, n, initial_val, name));
}

static void v__gen__x64__Gen_assign_stmt(v__gen__x64__Gen* g, v__ast__AssignStmt node) {
	// FOR IN array
	array tmp1 = node.left;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__Ident ident = ((v__ast__Ident*)tmp1.data)[tmp2];
		if ((*(v__ast__Expr*)array_get(node.right, 0)).typ == 186 /* v.ast.IntegerLiteral */) {
			v__ast__IntegerLiteral* it = (v__ast__IntegerLiteral*)(*(v__ast__Expr*)array_get(node.right, 0)).obj; // ST it
			v__gen__x64__Gen_allocate_var(g, ident.name, 4, string_int(it->val));
		}else if ((*(v__ast__Expr*)array_get(node.right, 0)).typ == 208 /* v.ast.InfixExpr */) {
			v__ast__InfixExpr* it = (v__ast__InfixExpr*)(*(v__ast__Expr*)array_get(node.right, 0)).obj; // ST it
			v__gen__x64__Gen_infix_expr(g, */*d*/it);
			v__gen__x64__Gen_allocate_var(g, ident.name, 4, 0);
		}else {
			v__gen__x64__verror(tos3("assign_stmt unhandled expr"));
		};
	}
}

static void v__gen__x64__Gen_infix_expr(v__gen__x64__Gen* g, v__ast__InfixExpr node) {
	println(_STR("infix expr op=%.*s", 1, v__token__Kind_str(node.op)));
	if (node.op == v__token__Kind_plus) {
	}else {
	};
}

static void v__gen__x64__Gen_if_expr(v__gen__x64__Gen* g, v__ast__IfExpr node) {
	v__ast__IfBranch branch = (*(v__ast__IfBranch*)array_get(node.branches, 0));
	v__ast__InfixExpr* infix_expr = /* as */ (v__ast__InfixExpr*)__as_cast(branch.cond.obj, branch.cond.typ, /*expected:*/208);
	int jne_addr = 0;
	if (infix_expr->left.typ == 136 /* v.ast.Ident */) {
		v__ast__Ident* it = (v__ast__Ident*)infix_expr->left.obj; // ST it
		v__ast__IntegerLiteral* lit = /* as */ (v__ast__IntegerLiteral*)__as_cast(infix_expr->right.obj, infix_expr->right.typ, /*expected:*/186);
		v__gen__x64__Gen_cmp_var(g, it->name, string_int(lit->val));
		jne_addr = v__gen__x64__Gen_jne(g);
	}else {
		v__gen__x64__verror(tos3("unhandled infix.left"));
	};
	v__gen__x64__Gen_stmts(g, branch.stmts);
	v__gen__x64__Gen_write32_at(g, jne_addr, v__gen__x64__Gen_pos(g) - jne_addr - 4);
}

static void v__gen__x64__Gen_for_stmt(v__gen__x64__Gen* g, v__ast__ForStmt node) {
	v__ast__InfixExpr* infix_expr = /* as */ (v__ast__InfixExpr*)__as_cast(node.cond.obj, node.cond.typ, /*expected:*/208);
	int jump_addr = 0;
	i64 start = v__gen__x64__Gen_pos(g);
	if (infix_expr->left.typ == 136 /* v.ast.Ident */) {
		v__ast__Ident* it = (v__ast__Ident*)infix_expr->left.obj; // ST it
		v__ast__IntegerLiteral* lit = /* as */ (v__ast__IntegerLiteral*)__as_cast(infix_expr->right.obj, infix_expr->right.typ, /*expected:*/186);
		v__gen__x64__Gen_cmp_var(g, it->name, string_int(lit->val));
		jump_addr = v__gen__x64__Gen_jge(g);
	}else {
		v__gen__x64__verror(tos3("unhandled infix.left"));
	};
	v__gen__x64__Gen_stmts(g, node.stmts);
	v__gen__x64__Gen_jmp(g, 0xffffffff - (v__gen__x64__Gen_pos(g) + 5 - start) + 1);
	v__gen__x64__Gen_write32_at(g, jump_addr, v__gen__x64__Gen_pos(g) - jump_addr - 4);
	v__gen__x64__Gen_println(g, tos3("jpm after for"));
}

static void v__gen__x64__Gen_fn_decl(v__gen__x64__Gen* g, v__ast__FnDecl node) {
	println(term__green(_STR("\n%.*s\000:", 2, node.name)));
	g->stack_var_pos = 0;
	bool is_main = string_eq(node.name, tos3("main"));
	if (is_main) {
		v__gen__x64__Gen_save_main_fn_addr(g);
	} else {
		v__gen__x64__Gen_register_function_address(g, node.name);
	}
	v__gen__x64__Gen_push(g, v__gen__x64__Register_rbp);
	v__gen__x64__Gen_mov_rbp_rsp(g);
	if (!is_main) {
		v__gen__x64__Gen_sub32(g, v__gen__x64__Register_rsp, 0x20);
	}
	if (node.args.len > 0) {
	}
	int offset = 0;
	for (int tmp4 = 0; tmp4 < node.args.len; tmp4++) {
		int i = tmp4;
		string name = (*(v__table__Arg*)array_get(node.args, i)).name;
		v__gen__x64__Gen_allocate_var(g, name, 4, 0);
		offset += 4;
		v__gen__x64__Gen_mov_from_reg(g, offset, (*(v__gen__x64__Register*)array_get(_const_v__gen__x64__fn_arg_registers, i)));
	}
	v__gen__x64__Gen_stmts(g, node.stmts);
	if (is_main) {
		v__gen__x64__Gen_gen_exit(g);
	}
	if (!is_main) {
		v__gen__x64__Gen_leave(g);
	}
	v__gen__x64__Gen_ret(g);
}

static void v__gen__x64__Gen_postfix_expr(v__gen__x64__Gen* g, v__ast__PostfixExpr node) {
	if (!(node.expr.typ == 136 /* v.ast.Ident */)) {
		return ;
	}
	v__ast__Ident* ident = /* as */ (v__ast__Ident*)__as_cast(node.expr.obj, node.expr.typ, /*expected:*/136);
	string var_name = ident->name;
	if (node.op == v__token__Kind_inc) {
		v__gen__x64__Gen_inc_var(g, var_name);
	}
}

static void v__gen__x64__verror(string s) {
	v__util__verror(tos3("x64 gen error"), s);
}

v__scanner__Scanner* v__scanner__new_scanner_file(string file_path, v__scanner__CommentsMode comments_mode) {
	if (!os__exists(file_path)) {
		v__scanner__verror(_STR("%.*s\000 doesn't exist", 2, file_path));
	}
	Option_string raw_text = v__util__read_file(file_path);
	if (!raw_text.ok) {
		string err = raw_text.v_error;
		int errcode = raw_text.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		v__scanner__verror(err);
		return 0;
	};
	v__scanner__Scanner* s = v__scanner__new_scanner(/*opt*/(*(string*)raw_text.data), comments_mode);
	s->file_path = file_path;
	return s;
}

v__scanner__Scanner* v__scanner__new_scanner(string text, v__scanner__CommentsMode comments_mode) {
	v__scanner__Scanner* s = (v__scanner__Scanner*)memdup(&(v__scanner__Scanner){	.text = text,
		.is_print_line_on_error = true,
		.is_print_colored_error = true,
		.is_print_rel_paths_on_error = true,
		.is_fmt = v__util__is_fmt(),
		.comments_mode = comments_mode,
		.file_path = (string){.str=""},
		.pos = 0,
		.line_nr = 0,
		.last_nl_pos = 0,
		.is_inside_string = 0,
		.is_inter_start = 0,
		.is_inter_end = 0,
		.is_debug = 0,
		.line_comment = (string){.str=""},
		.is_started = 0,
		.fn_name = (string){.str=""},
		.quote = 0,
		.line_ends = __new_array(0, 1, sizeof(int)),
		.nr_lines = 0,
		.is_vh = 0,
	}, sizeof(v__scanner__Scanner));
	return s;
}

void v__scanner__Scanner_add_fn_main_and_rescan(v__scanner__Scanner* s, int pos) {
	if (pos > 0) {
		s->text = string_add(string_add(string_add(string_substr(s->text, 0, pos), tos3("fn main() {")), string_substr(s->text, pos, s->text.len)), tos3("\n}"));
		s->pos = pos;
		s->is_started = false;
	} else {
		s->text = string_add(string_add(tos3("fn main() {"), s->text), tos3("\n}"));
		s->pos = 0;
		s->line_nr = 0;
		s->is_started = false;
	}
}

static v__token__Token v__scanner__Scanner_new_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len) {
	return (v__token__Token){
		.kind = tok_kind,
		.lit = lit,
		.line_nr = s->line_nr + 1,
		.pos = s->pos - len + 1,
		.len = len,
	};
}

static string v__scanner__Scanner_ident_name(v__scanner__Scanner* s) {
	int start = s->pos;
	s->pos++;
	while (s->pos < s->text.len && (v__util__is_name_char(string_at(s->text, s->pos)) || byte_is_digit(string_at(s->text, s->pos)))) {
		s->pos++;
	}
	string name = string_substr(s->text, start, s->pos);
	s->pos--;
	return name;
}

static string v__scanner__filter_num_sep(byteptr txt, int start, int end) {
		byteptr b = v_malloc(end - start + 1);
		int i = start;
		int i1 = 0;
		while (i < end) {
			if (txt[i] != _const_v__scanner__num_sep) {
				b[i1] = txt[i];
				i1++;
			}
			i++;
		}
		b[i1] = 0;
		return tos(b, i1);
}

static string v__scanner__Scanner_ident_bin_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	byte first_wrong_digit = '\0';
	int start_pos = s->pos;
	s->pos += 2;
	while (s->pos < s->text.len) {
		byte c = string_at(s->text, s->pos);
		if (!byte_is_bin_digit(c) && c != _const_v__scanner__num_sep) {
			if ((!byte_is_digit(c) && !byte_is_letter(c)) || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (start_pos + 2 == s->pos) {
		v__scanner__Scanner_error(s, tos3("number part of this binary is not provided"));
	} else if (has_wrong_digit) {
		v__scanner__Scanner_error(s, _STR("this binary number has unsuitable digit `%.*s\000`", 2, byte_str(first_wrong_digit)));
	}
	string number = v__scanner__filter_num_sep(s->text.str, start_pos, s->pos);
	s->pos--;
	return number;
}

static string v__scanner__Scanner_ident_hex_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	byte first_wrong_digit = '\0';
	int start_pos = s->pos;
	s->pos += 2;
	while (s->pos < s->text.len) {
		byte c = string_at(s->text, s->pos);
		if (!byte_is_hex_digit(c) && c != _const_v__scanner__num_sep) {
			if (!byte_is_letter(c) || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (start_pos + 2 == s->pos) {
		v__scanner__Scanner_error(s, tos3("number part of this hexadecimal is not provided"));
	} else if (has_wrong_digit) {
		v__scanner__Scanner_error(s, _STR("this hexadecimal number has unsuitable digit `%.*s\000`", 2, byte_str(first_wrong_digit)));
	}
	string number = v__scanner__filter_num_sep(s->text.str, start_pos, s->pos);
	s->pos--;
	return number;
}

static string v__scanner__Scanner_ident_oct_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	byte first_wrong_digit = '\0';
	int start_pos = s->pos;
	s->pos += 2;
	while (s->pos < s->text.len) {
		byte c = string_at(s->text, s->pos);
		if (!byte_is_oct_digit(c) && c != _const_v__scanner__num_sep) {
			if ((!byte_is_digit(c) && !byte_is_letter(c)) || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (start_pos + 2 == s->pos) {
		v__scanner__Scanner_error(s, tos3("number part of this octal is not provided"));
	} else if (has_wrong_digit) {
		v__scanner__Scanner_error(s, _STR("this octal number has unsuitable digit `%.*s\000`", 2, byte_str(first_wrong_digit)));
	}
	string number = v__scanner__filter_num_sep(s->text.str, start_pos, s->pos);
	s->pos--;
	return number;
}

static string v__scanner__Scanner_ident_dec_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	byte first_wrong_digit = '\0';
	int start_pos = s->pos;
	while (s->pos < s->text.len) {
		byte c = string_at(s->text, s->pos);
		if (!byte_is_digit(c) && c != _const_v__scanner__num_sep) {
			if (!byte_is_letter(c) || (c == 'e' || c == 'E') || s->is_inside_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	bool call_method = false;
	bool is_range = false;
	bool is_float_without_fraction = false;
	if (s->pos < s->text.len && string_at(s->text, s->pos) == '.') {
		s->pos++;
		if (s->pos < s->text.len) {
			if (byte_is_digit(string_at(s->text, s->pos))) {
				while (s->pos < s->text.len) {
					byte c = string_at(s->text, s->pos);
					if (!byte_is_digit(c)) {
						if (!byte_is_letter(c) || (c == 'e' || c == 'E') || s->is_inside_string) {
							if (c == '.' && s->pos + 1 < s->text.len && byte_is_letter(string_at(s->text, s->pos + 1))) {
								call_method = true;
							}
							break;
						} else if (!has_wrong_digit) {
							has_wrong_digit = true;
							first_wrong_digit = c;
						}
					}
					s->pos++;
				}
			} else if (string_at(s->text, s->pos) == '.') {
				is_range = true;
				s->pos--;
			} else if ((string_at(s->text, s->pos) == 'e' || string_at(s->text, s->pos) == 'E')) {
			} else if (byte_is_letter(string_at(s->text, s->pos))) {
				call_method = true;
				s->pos--;
			} else if (string_at(s->text, s->pos) != ')') {
				is_float_without_fraction = true;
				s->pos--;
			}
		}
	}
	bool has_exp = false;
	if (s->pos < s->text.len && (string_at(s->text, s->pos) == 'e' || string_at(s->text, s->pos) == 'E')) {
		has_exp = true;
		s->pos++;
		if (s->pos < s->text.len && (string_at(s->text, s->pos) == '-' || string_at(s->text, s->pos) == '+')) {
			s->pos++;
		}
		while (s->pos < s->text.len) {
			byte c = string_at(s->text, s->pos);
			if (!byte_is_digit(c)) {
				if (!byte_is_letter(c) || s->is_inside_string) {
					if (c == '.' && s->pos + 1 < s->text.len && byte_is_letter(string_at(s->text, s->pos + 1))) {
						call_method = true;
					}
					break;
				} else if (!has_wrong_digit) {
					has_wrong_digit = true;
					first_wrong_digit = c;
				}
			}
			s->pos++;
		}
	}
	if (has_wrong_digit) {
		v__scanner__Scanner_error(s, _STR("this number has unsuitable digit `%.*s\000`", 2, byte_str(first_wrong_digit)));
	} else if ((string_at(s->text, s->pos - 1) == 'e' || string_at(s->text, s->pos - 1) == 'E')) {
		v__scanner__Scanner_error(s, tos3("exponent has no digits"));
	} else if (s->pos < s->text.len && string_at(s->text, s->pos) == '.' && !is_range && !is_float_without_fraction && !call_method) {
		if (has_exp) {
			v__scanner__Scanner_error(s, tos3("exponential part should be integer"));
		} else {
			v__scanner__Scanner_error(s, tos3("too many decimal points in number"));
		}
	}
	string number = v__scanner__filter_num_sep(s->text.str, start_pos, s->pos);
	s->pos--;
	return number;
}

static string v__scanner__Scanner_ident_number(v__scanner__Scanner* s) {
	if (v__scanner__Scanner_expect(s, tos3("0b"), s->pos)) {
		return v__scanner__Scanner_ident_bin_number(s);
	} else if (v__scanner__Scanner_expect(s, tos3("0x"), s->pos)) {
		return v__scanner__Scanner_ident_hex_number(s);
	} else if (v__scanner__Scanner_expect(s, tos3("0o"), s->pos)) {
		return v__scanner__Scanner_ident_oct_number(s);
	} else {
		return v__scanner__Scanner_ident_dec_number(s);
	}
}

static void v__scanner__Scanner_skip_whitespace(v__scanner__Scanner* s) {
	while (s->pos < s->text.len && byte_is_space(string_at(s->text, s->pos))) {
		if (v__util__is_nl(string_at(s->text, s->pos)) && s->is_vh) {
			return ;
		}
		if (v__util__is_nl(string_at(s->text, s->pos)) && !v__scanner__Scanner_expect(s, tos3("\r\n"), s->pos - 1)) {
			v__scanner__Scanner_inc_line_number(s);
		}
		s->pos++;
	}
}

static v__token__Token v__scanner__Scanner_end_of_file(v__scanner__Scanner* s) {
	s->pos = s->text.len;
	v__scanner__Scanner_inc_line_number(s);
	return v__scanner__Scanner_new_token(s, v__token__Kind_eof, tos3(""), 1);
}

v__token__Token v__scanner__Scanner_scan(v__scanner__Scanner* s) {
	if (s->is_started) {
		s->pos++;
	}
	s->is_started = true;
	if (s->pos >= s->text.len) {
		return v__scanner__Scanner_end_of_file(s);
	}
	if (!s->is_inside_string) {
		v__scanner__Scanner_skip_whitespace(s);
	}
	if (s->is_inter_end) {
		if (string_at(s->text, s->pos) == s->quote) {
			s->is_inter_end = false;
			return v__scanner__Scanner_new_token(s, v__token__Kind_string, tos3(""), 1);
		}
		s->is_inter_end = false;
		string ident_string = v__scanner__Scanner_ident_string(s);
		return v__scanner__Scanner_new_token(s, v__token__Kind_string, ident_string, ident_string.len + 2);
	}
	v__scanner__Scanner_skip_whitespace(s);
	if (s->pos >= s->text.len) {
		return v__scanner__Scanner_end_of_file(s);
	}
	byte c = string_at(s->text, s->pos);
	byte nextc = (s->pos + 1 < s->text.len ?  ( string_at(s->text, s->pos + 1) )  :  ( '\0' ) );
	if (v__util__is_name_char(c)) {
		string name = v__scanner__Scanner_ident_name(s);
		byte next_char = (s->pos + 1 < s->text.len ?  ( string_at(s->text, s->pos + 1) )  :  ( '\0' ) );
		if (v__token__is_key(name)) {
			return v__scanner__Scanner_new_token(s, v__token__key_to_token(name), name, name.len);
		}
		if (s->is_inside_string) {
			if (next_char == s->quote) {
				s->is_inter_end = true;
				s->is_inter_start = false;
				s->is_inside_string = false;
			}
		}
		if (s->is_inter_start && next_char != '.' && next_char != '(') {
			s->is_inter_end = true;
			s->is_inter_start = false;
		}
		if (s->pos == 0 && next_char == ' ') {
			s->pos++;
		}
		return v__scanner__Scanner_new_token(s, v__token__Kind_name, name, name.len);
	} else if (byte_is_digit(c) || (c == '.' && byte_is_digit(nextc))) {
		if (!s->is_inside_string) {
			int start_pos = s->pos;
			while (start_pos < s->text.len && string_at(s->text, start_pos) == '0') {
				start_pos++;
			}
			int prefix_zero_num = start_pos - s->pos;
			if (start_pos == s->text.len || (c == '0' && !byte_is_digit(string_at(s->text, start_pos)))) {
				prefix_zero_num--;
			}
			s->pos += prefix_zero_num;
		}
		string num = v__scanner__Scanner_ident_number(s);
		return v__scanner__Scanner_new_token(s, v__token__Kind_number, num, num.len);
	}
	if (c == ')' && s->is_inter_start) {
		s->is_inter_end = true;
		s->is_inter_start = false;
		byte next_char = (s->pos + 1 < s->text.len ?  ( string_at(s->text, s->pos + 1) )  :  ( '\0' ) );
		if (next_char == s->quote) {
			s->is_inside_string = false;
		}
		return v__scanner__Scanner_new_token(s, v__token__Kind_rpar, tos3(""), 1);
	}
	if (c == '+') {
		if (nextc == '+') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_inc, tos3(""), 2);
		} else if (nextc == '=') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_plus_assign, tos3(""), 2);
		}
		return v__scanner__Scanner_new_token(s, v__token__Kind_plus, tos3(""), 1);
	}else if (c == '-') {
		if (nextc == '-') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_dec, tos3(""), 2);
		} else if (nextc == '=') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_minus_assign, tos3(""), 2);
		}
		return v__scanner__Scanner_new_token(s, v__token__Kind_minus, tos3(""), 1);
	}else if (c == '*') {
		if (nextc == '=') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_mult_assign, tos3(""), 2);
		}
		return v__scanner__Scanner_new_token(s, v__token__Kind_mul, tos3(""), 1);
	}else if (c == '^') {
		if (nextc == '=') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_xor_assign, tos3(""), 2);
		}
		return v__scanner__Scanner_new_token(s, v__token__Kind_xor, tos3(""), 1);
	}else if (c == '%') {
		if (nextc == '=') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_mod_assign, tos3(""), 2);
		}
		return v__scanner__Scanner_new_token(s, v__token__Kind_mod, tos3(""), 1);
	}else if (c == '?') {
		return v__scanner__Scanner_new_token(s, v__token__Kind_question, tos3(""), 1);
	}else if (c == _const_v__scanner__single_quote || c == _const_v__scanner__double_quote) {
		string ident_string = v__scanner__Scanner_ident_string(s);
		return v__scanner__Scanner_new_token(s, v__token__Kind_string, ident_string, ident_string.len + 2);
	}else if (c == '\`') {
		string ident_char = v__scanner__Scanner_ident_char(s);
		return v__scanner__Scanner_new_token(s, v__token__Kind_chartoken, ident_char, ident_char.len + 2);
	}else if (c == '(') {
		return v__scanner__Scanner_new_token(s, v__token__Kind_lpar, tos3(""), 1);
	}else if (c == ')') {
		return v__scanner__Scanner_new_token(s, v__token__Kind_rpar, tos3(""), 1);
	}else if (c == '[') {
		return v__scanner__Scanner_new_token(s, v__token__Kind_lsbr, tos3(""), 1);
	}else if (c == ']') {
		return v__scanner__Scanner_new_token(s, v__token__Kind_rsbr, tos3(""), 1);
	}else if (c == '{') {
		if (s->is_inside_string) {
			return v__scanner__Scanner_scan(s);
		}
		return v__scanner__Scanner_new_token(s, v__token__Kind_lcbr, tos3(""), 1);
	}else if (c == '$') {
		if (s->is_inside_string) {
			return v__scanner__Scanner_new_token(s, v__token__Kind_str_dollar, tos3(""), 1);
		} else {
			return v__scanner__Scanner_new_token(s, v__token__Kind_dollar, tos3(""), 1);
		}
	}else if (c == '}') {
		if (s->is_inside_string) {
			s->pos++;
			if (string_at(s->text, s->pos) == s->quote) {
				s->is_inside_string = false;
				return v__scanner__Scanner_new_token(s, v__token__Kind_string, tos3(""), 1);
			}
			string ident_string = v__scanner__Scanner_ident_string(s);
			return v__scanner__Scanner_new_token(s, v__token__Kind_string, ident_string, ident_string.len + 2);
		} else {
			return v__scanner__Scanner_new_token(s, v__token__Kind_rcbr, tos3(""), 1);
		}
	}else if (c == '&') {
		if (nextc == '=') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_and_assign, tos3(""), 2);
		}
		if (nextc == '&') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_and, tos3(""), 2);
		}
		return v__scanner__Scanner_new_token(s, v__token__Kind_amp, tos3(""), 1);
	}else if (c == '|') {
		if (nextc == '|') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_logical_or, tos3(""), 2);
		}
		if (nextc == '=') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_or_assign, tos3(""), 2);
		}
		return v__scanner__Scanner_new_token(s, v__token__Kind_pipe, tos3(""), 1);
	}else if (c == ',') {
		return v__scanner__Scanner_new_token(s, v__token__Kind_comma, tos3(""), 1);
	}else if (c == '@') {
		s->pos++;
		string name = v__scanner__Scanner_ident_name(s);
		if (string_eq(name, tos3("FN"))) {
			return v__scanner__Scanner_new_token(s, v__token__Kind_string, s->fn_name, 3);
		}
		if (string_eq(name, tos3("VEXE"))) {
			string vexe = v__pref__vexe_path();
			return v__scanner__Scanner_new_token(s, v__token__Kind_string, v__util__cescaped_path(vexe), 5);
		}
		if (string_eq(name, tos3("FILE"))) {
			return v__scanner__Scanner_new_token(s, v__token__Kind_string, v__util__cescaped_path(os__real_path(s->file_path)), 5);
		}
		if (string_eq(name, tos3("LINE"))) {
			return v__scanner__Scanner_new_token(s, v__token__Kind_string, int_str((s->line_nr + 1)), 5);
		}
		if (string_eq(name, tos3("COLUMN"))) {
			return v__scanner__Scanner_new_token(s, v__token__Kind_string, int_str(v__scanner__Scanner_current_column(s)), 7);
		}
		if (string_eq(name, tos3("VHASH"))) {
			return v__scanner__Scanner_new_token(s, v__token__Kind_string, v__util__vhash(), 6);
		}
		if (!v__token__is_key(name)) {
			v__scanner__Scanner_error(s, tos3("@ must be used before keywords (e.g. `@type string`)"));
		}
		return v__scanner__Scanner_new_token(s, v__token__Kind_name, name, name.len);
	}else if (c == '.') {
		if (nextc == '.') {
			s->pos++;
			if (string_at(s->text, s->pos + 1) == '.') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind_ellipsis, tos3(""), 3);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind_dotdot, tos3(""), 2);
		}
		return v__scanner__Scanner_new_token(s, v__token__Kind_dot, tos3(""), 1);
	}else if (c == '#') {
		int start = s->pos + 1;
		v__scanner__Scanner_ignore_line(s);
		if (nextc == '!') {
			s->line_comment = string_trim_space(string_substr(s->text, start + 1, s->pos));
			return v__scanner__Scanner_scan(s);
		}
		string hash = string_trim_space(string_substr(s->text, start, s->pos));
		return v__scanner__Scanner_new_token(s, v__token__Kind_hash, hash, hash.len);
	}else if (c == '>') {
		if (nextc == '=') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_ge, tos3(""), 2);
		} else if (nextc == '>') {
			if (s->pos + 2 < s->text.len && string_at(s->text, s->pos + 2) == '=') {
				s->pos += 2;
				return v__scanner__Scanner_new_token(s, v__token__Kind_right_shift_assign, tos3(""), 3);
			}
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_right_shift, tos3(""), 2);
		} else {
			return v__scanner__Scanner_new_token(s, v__token__Kind_gt, tos3(""), 1);
		}
	}else if (c == 0xE2) {
		if (nextc == 0x89 && string_at(s->text, s->pos + 2) == 0xA0) {
			s->pos += 2;
			return v__scanner__Scanner_new_token(s, v__token__Kind_ne, tos3(""), 3);
		} else if (nextc == 0x89 && string_at(s->text, s->pos + 2) == 0xBD) {
			s->pos += 2;
			return v__scanner__Scanner_new_token(s, v__token__Kind_le, tos3(""), 3);
		} else if (nextc == 0xA9 && string_at(s->text, s->pos + 2) == 0xBE) {
			s->pos += 2;
			return v__scanner__Scanner_new_token(s, v__token__Kind_ge, tos3(""), 3);
		}
	}else if (c == '<') {
		if (nextc == '=') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_le, tos3(""), 2);
		} else if (nextc == '<') {
			if (s->pos + 2 < s->text.len && string_at(s->text, s->pos + 2) == '=') {
				s->pos += 2;
				return v__scanner__Scanner_new_token(s, v__token__Kind_left_shift_assign, tos3(""), 3);
			}
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_left_shift, tos3(""), 2);
		} else {
			return v__scanner__Scanner_new_token(s, v__token__Kind_lt, tos3(""), 1);
		}
	}else if (c == '=') {
		if (nextc == '=') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_eq, tos3(""), 2);
		} else if (nextc == '>') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_arrow, tos3(""), 2);
		} else {
			return v__scanner__Scanner_new_token(s, v__token__Kind_assign, tos3(""), 1);
		}
	}else if (c == ':') {
		if (nextc == '=') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_decl_assign, tos3(""), 2);
		} else {
			return v__scanner__Scanner_new_token(s, v__token__Kind_colon, tos3(""), 1);
		}
	}else if (c == ';') {
		return v__scanner__Scanner_new_token(s, v__token__Kind_semicolon, tos3(""), 1);
	}else if (c == '!') {
		if (nextc == '=') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_ne, tos3(""), 2);
		} else if (nextc == 'i' && string_at(s->text, s->pos + 2) == 'n' && byte_is_space(string_at(s->text, s->pos + 3))) {
			s->pos += 2;
			return v__scanner__Scanner_new_token(s, v__token__Kind_not_in, tos3(""), 3);
		} else {
			return v__scanner__Scanner_new_token(s, v__token__Kind_not, tos3(""), 1);
		}
	}else if (c == '~') {
		return v__scanner__Scanner_new_token(s, v__token__Kind_bit_not, tos3(""), 1);
	}else if (c == '/') {
		if (nextc == '=') {
			s->pos++;
			return v__scanner__Scanner_new_token(s, v__token__Kind_div_assign, tos3(""), 2);
		}
		if (nextc == '/') {
			int start = s->pos + 1;
			v__scanner__Scanner_ignore_line(s);
			s->line_comment = string_substr(s->text, start + 1, s->pos);
			string comment = string_trim_space(s->line_comment);
			s->pos--;
			s->line_nr--;
			if (s->comments_mode == v__scanner__CommentsMode_parse_comments) {
				bool is_separate_line_comment = true;
				for (int j = start - 2;
				j >= 0 && string_at(s->text, j) != '\n'; j--) {
					if (!(string_at(s->text, j) == '\t' || string_at(s->text, j) == ' ')) {
						is_separate_line_comment = false;
					}
				}
				if (is_separate_line_comment) {
					comment = string_add(tos3("|"), comment);
				}
				return v__scanner__Scanner_new_token(s, v__token__Kind_comment, comment, comment.len + 2);
			}
			return v__scanner__Scanner_scan(s);
		}
		if (nextc == '*') {
			int start = s->pos + 2;
			int nest_count = 1;
			while (nest_count > 0) {
				s->pos++;
				if (s->pos >= s->text.len) {
					s->line_nr--;
					v__scanner__Scanner_error(s, tos3("comment not terminated"));
				}
				if (string_at(s->text, s->pos) == '\n') {
					v__scanner__Scanner_inc_line_number(s);
					continue;
				}
				if (v__scanner__Scanner_expect(s, tos3("/*"), s->pos)) {
					nest_count++;
					continue;
				}
				if (v__scanner__Scanner_expect(s, tos3("*/"), s->pos)) {
					nest_count--;
				}
			}
			s->pos++;
			if (s->comments_mode == v__scanner__CommentsMode_parse_comments) {
				string comment = string_trim_space(string_substr(s->text, start, (s->pos - 1)));
				return v__scanner__Scanner_new_token(s, v__token__Kind_comment, comment, comment.len + 4);
			}
			return v__scanner__Scanner_scan(s);
		}
		return v__scanner__Scanner_new_token(s, v__token__Kind_div, tos3(""), 1);
	}else {
	};
	
// $if  windows {
#ifdef _WIN32
		if (c == '\0') {
			return v__scanner__Scanner_end_of_file(s);
		}
	
// } windows
#endif

	v__scanner__Scanner_error(s, _STR("invalid character `%.*s\000`", 2, byte_str(c)));
	return v__scanner__Scanner_end_of_file(s);
}

static int v__scanner__Scanner_current_column(v__scanner__Scanner* s) {
	return s->pos - s->last_nl_pos;
}

static int v__scanner__Scanner_count_symbol_before(v__scanner__Scanner* s, int p, byte sym) {
	int count = 0;
	for (int i = p;
	i >= 0; i--) {
		if (string_at(s->text, i) != sym) {
			break;
		}
		count++;
	}
	return count;
}

static string v__scanner__Scanner_ident_string(v__scanner__Scanner* s) {
	byte q = string_at(s->text, s->pos);
	bool is_quote = q == _const_v__scanner__single_quote || q == _const_v__scanner__double_quote;
	bool is_raw = is_quote && s->pos > 0 && string_at(s->text, s->pos - 1) == 'r';
	if (is_quote && !s->is_inside_string) {
		s->quote = q;
	}
	int start = s->pos;
	s->is_inside_string = false;
	byte slash = '\\';
	while (1) {
		s->pos++;
		if (s->pos >= s->text.len) {
			break;
		}
		byte c = string_at(s->text, s->pos);
		byte prevc = string_at(s->text, s->pos - 1);
		if (c == s->quote && (prevc != slash || (prevc == slash && string_at(s->text, s->pos - 2) == slash))) {
			break;
		}
		if (c == '\n') {
			v__scanner__Scanner_inc_line_number(s);
		}
		if (c == '0' && s->pos > 2 && string_at(s->text, s->pos - 1) == slash) {
			if (s->pos < s->text.len - 1 && byte_is_digit(string_at(s->text, s->pos + 1))) {
			} else {
				v__scanner__Scanner_error(s, tos3("0 character in a string literal"));
			}
		}
		if (c == '0' && s->pos > 5 && v__scanner__Scanner_expect(s, tos3("\\x0"), s->pos - 3)) {
			v__scanner__Scanner_error(s, tos3("0 character in a string literal"));
		}
		if (c == '{' && prevc == '$' && !is_raw && !s->is_fmt && v__scanner__Scanner_count_symbol_before(s, s->pos - 2, slash) % 2 == 0) {
			s->is_inside_string = true;
			s->pos -= 2;
			break;
		}
		if (v__util__is_name_char(c) && prevc == '$' && !s->is_fmt && !is_raw && v__scanner__Scanner_count_symbol_before(s, s->pos - 2, slash) % 2 == 0) {
			s->is_inside_string = true;
			s->is_inter_start = true;
			s->pos -= 2;
			break;
		}
	}
	string lit = tos3("");
	if (string_at(s->text, start) == s->quote) {
		start++;
	}
	int end = s->pos;
	if (s->is_inside_string) {
		end++;
	}
	if (start <= s->pos) {
		if (string_contains(string_substr(s->text, start, end), tos3("\\\n"))) {
			lit = v__scanner__trim_slash_line_break(string_substr(s->text, start, end));
		} else {
			lit = string_substr(s->text, start, end);
		}
	}
	return lit;
}

static string v__scanner__trim_slash_line_break(string s) {
	int start = 0;
	string ret_str = s;
	while (1) {
		int idx = string_index_after(ret_str, tos3("\\\n"), start);
		if (idx != -1) {
			ret_str = string_add(string_substr(ret_str, 0, idx), string_trim_left(string_substr(ret_str, idx + 2, ret_str.len), tos3(" \n\t\v\f\r")));
			start = idx;
		} else {
			break;
		}
	}
	return ret_str;
}

static string v__scanner__Scanner_ident_char(v__scanner__Scanner* s) {
	int start = s->pos;
	byte slash = '\\';
	int len = 0;
	while (1) {
		s->pos++;
		if (s->pos >= s->text.len) {
			break;
		}
		if (string_at(s->text, s->pos) != slash) {
			len++;
		}
		bool double_slash = v__scanner__Scanner_expect(s, tos3("\\\\"), s->pos - 2);
		if (string_at(s->text, s->pos) == '\`' && (string_at(s->text, s->pos - 1) != slash || double_slash)) {
			if (double_slash) {
				len++;
			}
			break;
		}
	}
	len--;
	string c = string_substr(s->text, start + 1, s->pos);
	if (len != 1) {
		ustring u = string_ustring(c);
		if (u.len != 1) {
			v__scanner__Scanner_error(s, string_add(tos3("invalid character literal (more than one character)\n"), tos3("use quotes for strings, backticks for characters")));
		}
	}
	return (string_eq(c, tos3("\'")) ?  ( string_add(tos3("\\"), c) )  :  ( c ) );
}

static bool v__scanner__Scanner_expect(v__scanner__Scanner* s, string want, int start_pos) {
	int end_pos = start_pos + want.len;
	if (start_pos < 0 || start_pos >= s->text.len) {
		return false;
	}
	if (end_pos < 0 || end_pos > s->text.len) {
		return false;
	}
	for (int tmp3 = start_pos; tmp3 < end_pos; tmp3++) {
		int pos = tmp3;
		if (string_at(s->text, pos) != string_at(want, pos - start_pos)) {
			return false;
		}
	}
	return true;
}

static void v__scanner__Scanner_debug_tokens(v__scanner__Scanner* s) {
	s->pos = 0;
	s->is_started = false;
	s->is_debug = true;
	string fname = string_all_after(s->file_path, _const_os__path_separator);
	println(_STR("\n===DEBUG TOKENS %.*s\000===", 2, fname));
	while (1) {
		v__token__Token tok = v__scanner__Scanner_scan(s);
		v__token__Kind tok_kind = tok.kind;
		string lit = tok.lit;
		print(v__token__Kind_str(tok_kind));
		if (string_ne(lit, tos3(""))) {
			println(_STR(" `%.*s\000`", 2, lit));
		} else {
			println(tos3(""));
		}
		if (tok_kind == v__token__Kind_eof) {
			println(tos3("============ END OF DEBUG TOKENS =================="));
			break;
		}
	}
}

static void v__scanner__Scanner_ignore_line(v__scanner__Scanner* s) {
	v__scanner__Scanner_eat_to_end_of_line(s);
	v__scanner__Scanner_inc_line_number(s);
}

static void v__scanner__Scanner_eat_to_end_of_line(v__scanner__Scanner* s) {
	while (s->pos < s->text.len && string_at(s->text, s->pos) != '\n') {
		s->pos++;
	}
}

static void v__scanner__Scanner_inc_line_number(v__scanner__Scanner* s) {
	s->last_nl_pos = s->pos;
	s->line_nr++;
	array_push(&s->line_ends, &(int[]){ s->pos });
	if (s->line_nr > s->nr_lines) {
		s->nr_lines = s->line_nr;
	}
}

void v__scanner__Scanner_error(v__scanner__Scanner* s, string msg) {
	v__token__Position pos = (v__token__Position){
		.line_nr = s->line_nr,
		.pos = s->pos,
		.len = 0,
	};
	eprintln(v__util__formatted_error(tos3("error"), msg, s->file_path, pos));
	v_exit(1);
}

void v__scanner__verror(string s) {
	v__util__verror(tos3("scanner error"), s);
}

static v__ast__Stmt v__parser__Parser_assign_stmt(v__parser__Parser* p) {
	bool is_static = p->tok.kind == v__token__Kind_key_static;
	if (is_static) {
		v__parser__Parser_next(p);
	}
	array_v__ast__Ident idents = v__parser__Parser_parse_assign_lhs(p);
	v__token__Kind op = p->tok.kind;
	v__parser__Parser_next(p);
	v__token__Position pos = v__token__Token_position(&p->tok);
	array_v__ast__Expr exprs = v__parser__Parser_parse_assign_rhs(p);
	bool is_decl = op == v__token__Kind_decl_assign;
	// FOR IN array
	array tmp2 = idents;
	for (int i = 0; i < tmp2.len; i++) {
		v__ast__Ident ident = ((v__ast__Ident*)tmp2.data)[i];
		bool known_var = v__ast__Scope_known_var(p->scope, ident.name);
		if (!is_decl && !known_var) {
			v__parser__Parser_error(p, _STR("unknown variable `%.*s\000`", 2, ident.name));
		}
		if (is_decl && ident.kind != v__ast__IdentKind_blank_ident) {
			if (v__ast__Scope_known_var(p->scope, ident.name)) {
				v__parser__Parser_error(p, _STR("redefinition of `%.*s\000`", 2, ident.name));
			}
			if (idents.len == exprs.len) {
				v__ast__Scope_register(p->scope, ident.name, /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
					.name = ident.name,
					.expr = (*(v__ast__Expr*)array_get(exprs, i)),
					.is_mut = ident.is_mut || p->inside_for,
					.pos = ident.pos,
					.is_arg = 0,
					.typ = {0},
					.is_used = 0,
				}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
			} else {
				v__ast__Scope_register(p->scope, ident.name, /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
					.name = ident.name,
					.is_mut = ident.is_mut || p->inside_for,
					.pos = ident.pos,
					.expr = {0},
					.is_arg = 0,
					.typ = {0},
					.is_used = 0,
				}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
			}
		}
	}
	return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__AssignStmt[]) {(v__ast__AssignStmt){
		.left = idents,
		.right = exprs,
		.op = op,
		.pos = pos,
		.is_static = is_static,
		.left_types = __new_array(0, 1, sizeof(v__table__Type)),
		.right_types = __new_array(0, 1, sizeof(v__table__Type)),
	}}, sizeof(v__ast__AssignStmt)), .typ = 132 /* v.ast.AssignStmt */};
}

v__ast__AssignExpr v__parser__Parser_assign_expr(v__parser__Parser* p, v__ast__Expr left) {
	v__token__Kind op = p->tok.kind;
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	v__ast__Expr val = v__parser__Parser_expr(p, 0);
	if (left.typ == 135 /* v.ast.IndexExpr */) {
		v__ast__IndexExpr* it = (v__ast__IndexExpr*)left.obj; // ST it
		it->is_setter = true;
	}else {
	};
	v__ast__AssignExpr node = (v__ast__AssignExpr){
		.left = left,
		.val = val,
		.op = op,
		.pos = pos,
		.left_type = {0},
		.right_type = {0},
	};
	return node;
}

static array_v__ast__Ident v__parser__Parser_parse_assign_lhs(v__parser__Parser* p) {
	array_v__ast__Ident idents = __new_array(0, 0, sizeof(v__ast__Ident));
	while (1) {
		bool is_mut = p->tok.kind == v__token__Kind_key_mut;
		if (is_mut) {
			v__parser__Parser_next(p);
		}
		bool is_static = p->tok.kind == v__token__Kind_key_static;
		if (is_static) {
			v__parser__Parser_next(p);
		}
		v__ast__Ident ident = v__parser__Parser_parse_ident(p, false, false);
		ident.is_mut = is_mut;
		ident.info = /* sum type cast */ (v__ast__IdentInfo) {.obj = memdup(&(v__ast__IdentVar[]) {(v__ast__IdentVar){
			.is_mut = is_mut,
			.is_static = is_static,
			.typ = {0},
			.is_optional = 0,
		}}, sizeof(v__ast__IdentVar)), .typ = 138 /* v.ast.IdentVar */};
		array_push(&idents, &(v__ast__Ident[]){ ident });
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		} else {
			break;
		}
	}
	return idents;
}

static array_v__ast__Expr v__parser__Parser_parse_assign_rhs(v__parser__Parser* p) {
	array_v__ast__Expr exprs = __new_array(0, 0, sizeof(v__ast__Expr));
	while (1) {
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		array_push(&exprs, &(v__ast__Expr[]){ expr });
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		} else {
			break;
		}
	}
	return exprs;
}

static v__ast__HashStmt v__parser__Parser_hash(v__parser__Parser* p) {
	string val = p->tok.lit;
	v__parser__Parser_next(p);
	if (string_starts_with(val, tos3("flag"))) {
		string flag = string_substr(val, 5, val.len);
		if (string_contains(flag, tos3("@VROOT"))) {
			v__vmod__ModFileAndFolder vmod_file_location = v__vmod__ModFileCacher_get(_const_v__vmod__mod_file_cacher, p->file_name_dir);
			if (vmod_file_location.vmod_file.len == 0) {
				v__parser__Parser_error(p, string_add(string_add(tos3("To use @VROOT, you need"), _STR(" to have a \"v.mod\" file in %.*s\000,", 2, p->file_name_dir)), tos3(" or in one of its parent folders.")));
			}
			flag = string_replace(flag, tos3("@VROOT"), vmod_file_location.vmod_folder);
		}
		// FOR IN array
		array tmp4 = new_array_from_c_array(4, 4, sizeof(string), (string[4]){
		tos3("@VMOD"), tos3("@VMODULE"), tos3("@VPATH"), tos3("@VLIB_PATH"), 
});
		for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
			string deprecated = ((string*)tmp4.data)[tmp5];
			if (string_contains(flag, deprecated)) {
				v__parser__Parser_error(p, _STR("%.*s\000 had been deprecated, use @VROOT instead.", 2, deprecated));
			}
		}
		Option_bool tmp7 = v__table__Table_parse_cflag(p->table, flag, p->mod, p->pref->compile_defines_all);
		if (!tmp7.ok) {
			string err = tmp7.v_error;
			int errcode = tmp7.ecode;
			 // typeof it_expr_type: v.ast.CallExpr
			// last_type: v.ast.ExprStmt
			// last_expr_result_type: void
			v__parser__Parser_error(p, err);
		};
	}
	return (v__ast__HashStmt){
		.val = val,
		.mod = p->mod,
	};
}

static v__ast__CompIf v__parser__Parser_comp_if(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	v__parser__Parser_check(p, v__token__Kind_key_if);
	bool is_not = p->tok.kind == v__token__Kind_not;
	if (is_not) {
		v__parser__Parser_next(p);
	}
	string val = v__parser__Parser_check_name(p);
	array_v__ast__Stmt stmts = __new_array(0, 0, sizeof(v__ast__Stmt));
	bool skip_os = false;
	if (_IN(string, val, _const_v__parser__supported_platforms)) {
		v__pref__OS os = v__parser__os_from_string(val);
		if (!p->pref->is_fmt && ((!is_not && os != p->pref->os) || (is_not && os == p->pref->os)) && !p->pref->output_cross_c) {
			skip_os = true;
			v__parser__Parser_check(p, v__token__Kind_lcbr);
			int stack = 1;
			while (1) {
				if (p->tok.kind == v__token__Kind_key_return) {
					p->returns = true;
				}
				if (p->tok.kind == v__token__Kind_lcbr) {
					stack++;
				} else if (p->tok.kind == v__token__Kind_rcbr) {
					stack--;
				}
				if (p->tok.kind == v__token__Kind_eof) {
					break;
				}
				if (stack <= 0 && p->tok.kind == v__token__Kind_rcbr) {
					v__parser__Parser_next(p);
					break;
				}
				v__parser__Parser_next(p);
			}
		}
	}
	bool is_opt = false;
	if (p->tok.kind == v__token__Kind_question) {
		v__parser__Parser_next(p);
		is_opt = true;
	}
	if (!skip_os) {
		stmts = v__parser__Parser_parse_block(p);
	}
	v__ast__CompIf node = (v__ast__CompIf){
		.is_not = is_not,
		.is_opt = is_opt,
		.pos = pos,
		.val = val,
		.stmts = stmts,
		.has_else = 0,
		.else_stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),
	};
	if (p->tok.kind == v__token__Kind_dollar && p->peek_tok.kind == v__token__Kind_key_else) {
		v__parser__Parser_next(p);
		v__parser__Parser_next(p);
		node.has_else = true;
		node.else_stmts = v__parser__Parser_parse_block(p);
	}
	return node;
}

static v__pref__OS v__parser__os_from_string(string os) {
	if (string_eq(os, tos3("linux"))) {
		return v__pref__OS_linux;
	}else if (string_eq(os, tos3("windows"))) {
		return v__pref__OS_windows;
	}else if (string_eq(os, tos3("mac"))) {
		return v__pref__OS_mac;
	}else if (string_eq(os, tos3("macos"))) {
		return v__pref__OS_mac;
	}else if (string_eq(os, tos3("freebsd"))) {
		return v__pref__OS_freebsd;
	}else if (string_eq(os, tos3("openbsd"))) {
		return v__pref__OS_openbsd;
	}else if (string_eq(os, tos3("netbsd"))) {
		return v__pref__OS_netbsd;
	}else if (string_eq(os, tos3("dragonfly"))) {
		return v__pref__OS_dragonfly;
	}else if (string_eq(os, tos3("js"))) {
		return v__pref__OS_js;
	}else if (string_eq(os, tos3("solaris"))) {
		return v__pref__OS_solaris;
	}else if (string_eq(os, tos3("android"))) {
		return v__pref__OS_android;
	}else if (string_eq(os, tos3("msvc"))) {
		v__parser__verror(tos3("use the flag `-cc msvc` to build using msvc"));
	}else if (string_eq(os, tos3("haiku"))) {
		return v__pref__OS_haiku;
	}else if (string_eq(os, tos3("linux_or_macos"))) {
		return v__pref__OS_linux;
	}else {
		v_panic(_STR("bad os %.*s", 1, os));
	};
	return v__pref__OS_linux;
}

static v__ast__ArrayInit v__parser__Parser_array_init(v__parser__Parser* p) {
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	v__token__Position last_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_lsbr);
	v__table__Type array_type = _const_v__table__void_type;
	v__table__Type elem_type = _const_v__table__void_type;
	array_v__ast__Expr exprs = __new_array(0, 0, sizeof(v__ast__Expr));
	bool is_fixed = false;
	bool has_val = false;
	bool has_type = false;
	if (p->tok.kind == v__token__Kind_rsbr) {
		int line_nr = p->tok.line_nr;
		v__parser__Parser_next(p);
		if ((p->tok.kind == v__token__Kind_name || p->tok.kind == v__token__Kind_amp) && p->tok.line_nr == line_nr) {
			elem_type = v__parser__Parser_parse_type(p);
			int idx = v__table__Table_find_or_register_array(p->table, elem_type, 1);
			array_type = v__table__new_type(idx);
			has_type = true;
		}
	} else {
		for (int i = 0;
		p->tok.kind != v__token__Kind_rsbr; i++) {
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			array_push(&exprs, &(v__ast__Expr[]){ expr });
			if (p->tok.kind == v__token__Kind_comma) {
				v__parser__Parser_next(p);
			}
		}
		int line_nr = p->tok.line_nr;
		
// $if  tinyc {
#ifdef __TINYC__
			int tcc_stack_bug = 12345;
			{tcc_stack_bug;}
			;
		
// } tinyc
#endif

		last_pos = v__token__Token_position(&p->tok);
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		if (exprs.len == 1 && (p->tok.kind == v__token__Kind_name || p->tok.kind == v__token__Kind_amp) && p->tok.line_nr == line_nr) {
			elem_type = v__parser__Parser_parse_type(p);
			is_fixed = true;
		} else {
			if (p->tok.kind == v__token__Kind_not) {
				last_pos = v__token__Token_position(&p->tok);
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind_not) {
				last_pos = v__token__Token_position(&p->tok);
				v__parser__Parser_next(p);
				is_fixed = true;
				has_val = true;
			}
		}
	}
	if (exprs.len == 0 && p->tok.kind != v__token__Kind_lcbr && has_type) {
		v__parser__Parser_warn_with_pos(p, tos3("use `x := []Type{}` instead of `x := []Type`"), last_pos);
	}
	bool has_len = false;
	bool has_cap = false;
	v__ast__Expr len_expr = (v__ast__Expr){
	0};
	v__ast__Expr cap_expr = (v__ast__Expr){
	0};
	if (p->tok.kind == v__token__Kind_lcbr && exprs.len == 0) {
		v__parser__Parser_next(p);
		while (p->tok.kind != v__token__Kind_rcbr) {
			string key = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind_colon);
			if (string_eq(key, tos3("len"))) {
				has_len = true;
				len_expr = v__parser__Parser_expr(p, 0);
			}else if (string_eq(key, tos3("cap"))) {
				has_cap = true;
				cap_expr = v__parser__Parser_expr(p, 0);
			}else if (string_eq(key, tos3("default"))) {
				v__parser__Parser_expr(p, 0);
			}else {
				v__parser__Parser_error(p, _STR("wrong field `%.*s\000`, expecting `len`, `cap`, or `default`", 2, key));
			};
			if (p->tok.kind != v__token__Kind_rcbr) {
				v__parser__Parser_check(p, v__token__Kind_comma);
			}
		}
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	v__token__Position pos = (v__token__Position){
		.line_nr = first_pos.line_nr,
		.pos = first_pos.pos,
		.len = last_pos.pos - first_pos.pos + last_pos.len,
	};
	return (v__ast__ArrayInit){
		.is_fixed = is_fixed,
		.has_val = has_val,
		.mod = p->mod,
		.elem_type = elem_type,
		.typ = array_type,
		.exprs = exprs,
		.pos = pos,
		.has_len = has_len,
		.len_expr = len_expr,
		.has_cap = has_cap,
		.cap_expr = cap_expr,
		.is_interface = 0,
		.interface_types = __new_array(0, 1, sizeof(v__table__Type)),
		.interface_type = {0},
	};
}

static v__ast__MapInit v__parser__Parser_map_init(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	array_v__ast__Expr keys = __new_array(0, 0, sizeof(v__ast__Expr));
	array_v__ast__Expr vals = __new_array(0, 0, sizeof(v__ast__Expr));
	while (p->tok.kind != v__token__Kind_rcbr && p->tok.kind != v__token__Kind_eof) {
		v__ast__Expr key = v__parser__Parser_expr(p, 0);
		array_push(&keys, &(v__ast__Expr[]){ key });
		v__parser__Parser_check(p, v__token__Kind_colon);
		v__ast__Expr val = v__parser__Parser_expr(p, 0);
		array_push(&vals, &(v__ast__Expr[]){ val });
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		}
	}
	return (v__ast__MapInit){
		.keys = keys,
		.vals = vals,
		.pos = pos,
		.typ = {0},
		.key_type = {0},
		.value_type = {0},
	};
}

v__ast__CallExpr v__parser__Parser_call_expr(v__parser__Parser* p, bool is_c, bool is_js, string mod) {
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	string name = v__parser__Parser_check_name(p);
	string fn_name = (is_c ?  ( _STR("C.%.*s", 1, name) )  : is_js ?  ( _STR("JS.%.*s", 1, name) )  : mod.len > 0 ?  ( _STR("%.*s\000.%.*s", 2, mod, name) )  :  ( name ) );
	if (string_eq(fn_name, tos3("json.decode"))) {
		p->expecting_type = true;
		p->expr_mod = tos3("");
	}
	v__parser__Parser_check(p, v__token__Kind_lpar);
	array_v__ast__CallArg args = v__parser__Parser_call_args(p);
	v__token__Position last_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_rpar);
	v__token__Position pos = (v__token__Position){
		.line_nr = first_pos.line_nr,
		.pos = first_pos.pos,
		.len = last_pos.pos - first_pos.pos + last_pos.len,
	};
	array_v__ast__Stmt or_stmts = __new_array(0, 0, sizeof(v__ast__Stmt));
	bool is_or_block_used = false;
	if (p->tok.kind == v__token__Kind_key_orelse) {
		v__parser__Parser_next(p);
		v__parser__Parser_open_scope(p);
		v__ast__Scope_register(p->scope, tos3("err"), /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
			.name = tos3("err"),
			.typ = _const_v__table__string_type,
			.pos = v__token__Token_position(&p->tok),
			.is_used = true,
			.expr = {0},
			.is_mut = 0,
			.is_arg = 0,
		}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
		v__ast__Scope_register(p->scope, tos3("errcode"), /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
			.name = tos3("errcode"),
			.typ = _const_v__table__int_type,
			.pos = v__token__Token_position(&p->tok),
			.is_used = true,
			.expr = {0},
			.is_mut = 0,
			.is_arg = 0,
		}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
		is_or_block_used = true;
		or_stmts = v__parser__Parser_parse_block_no_scope(p);
		v__parser__Parser_close_scope(p);
	}
	v__ast__CallExpr node = (v__ast__CallExpr){
		.name = fn_name,
		.args = args,
		.mod = p->mod,
		.pos = pos,
		.is_c = is_c,
		.is_js = is_js,
		.or_block = (v__ast__OrExpr){
		.stmts = or_stmts,
		.is_used = is_or_block_used,
	},
		.left = {0},
		.is_method = 0,
		.expected_arg_types = __new_array(0, 1, sizeof(v__table__Type)),
		.left_type = {0},
		.receiver_type = {0},
		.return_type = {0},
		.should_be_skipped = 0,
	};
	return node;
}

array_v__ast__CallArg v__parser__Parser_call_args(v__parser__Parser* p) {
	array_v__ast__CallArg args = __new_array(0, 0, sizeof(v__ast__CallArg));
	while (p->tok.kind != v__token__Kind_rpar) {
		bool is_mut = false;
		if (p->tok.kind == v__token__Kind_key_mut) {
			v__parser__Parser_next(p);
			is_mut = true;
		}
		v__ast__Expr e = v__parser__Parser_expr(p, 0);
		array_push(&args, &(v__ast__CallArg[]){ (v__ast__CallArg){
			.is_mut = is_mut,
			.expr = e,
			.typ = {0},
		} });
		if (p->tok.kind != v__token__Kind_rpar) {
			v__parser__Parser_check(p, v__token__Kind_comma);
		}
	}
	return args;
}

static v__ast__FnDecl v__parser__Parser_fn_decl(v__parser__Parser* p) {
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_deprecated = string_eq(p->attr, tos3("deprecated"));
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind_key_fn);
	v__parser__Parser_open_scope(p);
	bool is_c = p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos3("C"));
	bool is_js = p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos3("JS"));
	if (is_c || is_js) {
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_dot);
	}
	string rec_name = tos3("");
	bool is_method = false;
	v__token__Position receiver_pos = (v__token__Position){
		.line_nr = 0,
		.pos = 0,
		.len = 0,
	};
	v__table__Type rec_type = _const_v__table__void_type;
	bool rec_mut = false;
	array_v__table__Arg args = __new_array(0, 0, sizeof(v__table__Arg));
	if (p->tok.kind == v__token__Kind_lpar) {
		v__parser__Parser_next(p);
		is_method = true;
		rec_mut = p->tok.kind == v__token__Kind_key_mut;
		if (rec_mut) {
			v__parser__Parser_next(p);
		}
		v__token__Position rec_start_pos = v__token__Token_position(&p->tok);
		rec_name = v__parser__Parser_check_name(p);
		if (!rec_mut) {
			rec_mut = p->tok.kind == v__token__Kind_key_mut;
		}
		bool is_amp = p->tok.kind == v__token__Kind_amp;
		receiver_pos = v__token__Position_extend(rec_start_pos, v__token__Token_position(&p->tok));
		rec_type = v__parser__Parser_parse_type_with_mut(p, rec_mut);
		if (is_amp && rec_mut) {
			v__parser__Parser_error(p, tos3("use `(mut f Foo)` or `(f &Foo)` instead of `(mut f &Foo)`"));
		}
		array_push(&args, &(v__table__Arg[]){ (v__table__Arg){
			.name = rec_name,
			.is_mut = rec_mut,
			.typ = rec_type,
			.is_hidden = 0,
		} });
		v__parser__Parser_check(p, v__token__Kind_rpar);
	}
	string name = tos3("");
	if (p->tok.kind == v__token__Kind_name) {
		name = v__parser__Parser_check_name(p);
		if (!is_js && !is_c && !p->pref->translated && v__util__contains_capital(name)) {
			v__parser__Parser_error(p, tos3("function names cannot contain uppercase letters, use snake_case instead"));
		}
		if (is_method && v__table__TypeSymbol_has_method(v__table__Table_get_type_symbol(p->table, rec_type), name)) {
			v__parser__Parser_error(p, _STR("duplicate method `%.*s\000`", 2, name));
		}
	}
	if ((p->tok.kind == v__token__Kind_plus || p->tok.kind == v__token__Kind_minus || p->tok.kind == v__token__Kind_mul || p->tok.kind == v__token__Kind_div || p->tok.kind == v__token__Kind_mod)) {
		name = v__token__Kind_str(p->tok.kind);
		v__parser__Parser_next(p);
	}
	bool is_generic = p->tok.kind == v__token__Kind_lt;
	if (is_generic) {
		v__parser__Parser_next(p);
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_gt);
	}
	multi_return_array_v__table__Arg_bool mr_3819 = v__parser__Parser_fn_args(p);
	array_v__table__Arg args2 = mr_3819.arg0;
	bool is_variadic = mr_3819.arg1;
	_PUSH_MANY(&args, (args2), tmp13, array_v__table__Arg);
	// FOR IN array
	array tmp14 = args;
	for (int i = 0; i < tmp14.len; i++) {
		v__table__Arg arg = ((v__table__Arg*)tmp14.data)[i];
		if (v__ast__Scope_known_var(p->scope, arg.name)) {
			v__parser__Parser_error(p, _STR("redefinition of parameter `%.*s\000`", 2, arg.name));
		}
		v__ast__Scope_register(p->scope, arg.name, /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
			.name = arg.name,
			.typ = arg.typ,
			.is_mut = arg.is_mut,
			.pos = v__token__Token_position(&p->tok),
			.is_used = true,
			.is_arg = true,
			.expr = {0},
		}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
		if (arg.is_mut) {
			if (i == 0 && is_method) {
				continue;
			}
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(p->table, arg.typ);
			if (!(sym->kind == v__table__Kind_array || sym->kind == v__table__Kind_struct_ || sym->kind == v__table__Kind_map || sym->kind == v__table__Kind_placeholder) && !v__table__Type_is_ptr(arg.typ)) {
				v__parser__Parser_error(p, string_add(tos3("mutable arguments are only allowed for arrays, maps, and structs\n"), tos3("return values instead: `fn foo(n mut int) {` => `fn foo(n int) int {`")));
			}
		}
	}
	v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
	v__table__Type return_type = _const_v__table__void_type;
	if (v__token__Kind_is_start_of_type(p->tok.kind)) {
		end_pos = v__token__Token_position(&p->tok);
		return_type = v__parser__Parser_parse_type(p);
	}
	string ctdefine = p->attr_ctdefine;
	if (is_method) {
		v__table__TypeSymbol* type_sym = v__table__Table_get_type_symbol(p->table, rec_type);
		v__table__TypeSymbol_register_method(type_sym, (v__table__Fn){
			.name = name,
			.args = args,
			.return_type = return_type,
			.is_variadic = is_variadic,
			.is_generic = is_generic,
			.is_pub = is_pub,
			.ctdefine = ctdefine,
			.is_c = 0,
			.is_js = 0,
			.mod = (string){.str=""},
		});
	} else {
		if (is_c) {
			name = _STR("C.%.*s", 1, name);
		} else if (is_js) {
			name = _STR("JS.%.*s", 1, name);
		} else {
			name = v__parser__Parser_prepend_mod(p, name);
		}
		bool tmp22;
		{ /* if guard */ Option_v__table__Fn _ = v__table__Table_find_fn(p->table, name);
		if ((tmp22 = _.ok)) {
			v__parser__Parser_fn_redefinition_error(p, name);
		}}
		v__table__Table_register_fn(p->table, (v__table__Fn){
			.name = name,
			.args = args,
			.return_type = return_type,
			.is_variadic = is_variadic,
			.is_c = is_c,
			.is_js = is_js,
			.is_generic = is_generic,
			.is_pub = is_pub,
			.ctdefine = ctdefine,
			.mod = (string){.str=""},
		});
	}
	array_v__ast__Stmt stmts = __new_array(0, 0, sizeof(v__ast__Stmt));
	bool no_body = p->tok.kind != v__token__Kind_lcbr;
	v__token__Position body_start_pos = v__token__Token_position(&p->peek_tok);
	if (p->tok.kind == v__token__Kind_lcbr) {
		stmts = v__parser__Parser_parse_block_no_scope(p);
	}
	v__parser__Parser_close_scope(p);
	p->attr = tos3("");
	p->attr_ctdefine = tos3("");
	return (v__ast__FnDecl){
		.name = name,
		.stmts = stmts,
		.return_type = return_type,
		.args = args,
		.is_deprecated = is_deprecated,
		.is_pub = is_pub,
		.is_variadic = is_variadic,
		.receiver = (v__ast__Field){
		.name = rec_name,
		.typ = rec_type,
		.pos = {0},
	},
		.receiver_pos = receiver_pos,
		.is_method = is_method,
		.rec_mut = rec_mut,
		.is_c = is_c,
		.is_js = is_js,
		.no_body = no_body,
		.pos = v__token__Position_extend(start_pos, end_pos),
		.body_pos = body_start_pos,
		.file = p->file_name,
		.is_builtin = p->builtin_mod || _IN(string, p->mod, _const_v__util__builtin_module_parts),
		.ctdefine = ctdefine,
		.is_anon = 0,
	};
}

static v__ast__AnonFn v__parser__Parser_anon_fn(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_key_fn);
	v__parser__Parser_open_scope(p);
	multi_return_array_v__table__Arg_bool mr_6389 = v__parser__Parser_fn_args(p);
	array_v__table__Arg args = mr_6389.arg0;
	bool is_variadic = mr_6389.arg1;
	// FOR IN array
	array tmp1 = args;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__Arg arg = ((v__table__Arg*)tmp1.data)[tmp2];
		v__ast__Scope_register(p->scope, arg.name, /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
			.name = arg.name,
			.typ = arg.typ,
			.pos = v__token__Token_position(&p->tok),
			.is_used = true,
			.is_arg = true,
			.expr = {0},
			.is_mut = 0,
		}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
	}
	v__table__Type return_type = _const_v__table__void_type;
	if (v__token__Kind_is_start_of_type(p->tok.kind)) {
		return_type = v__parser__Parser_parse_type(p);
	}
	array_v__ast__Stmt stmts = __new_array(0, 0, sizeof(v__ast__Stmt));
	bool no_body = p->tok.kind != v__token__Kind_lcbr;
	if (p->tok.kind == v__token__Kind_lcbr) {
		stmts = v__parser__Parser_parse_block_no_scope(p);
	}
	v__parser__Parser_close_scope(p);
	v__table__Fn func = (v__table__Fn){
		.args = args,
		.is_variadic = is_variadic,
		.return_type = return_type,
		.is_c = 0,
		.is_js = 0,
		.is_generic = 0,
		.is_pub = 0,
		.mod = (string){.str=""},
		.ctdefine = (string){.str=""},
		.name = (string){.str=""},
	};
	string name = _STR("anon_%"PRId32"\000_%.*s", 2, p->tok.pos, v__table__Fn_signature(&func));
	func.name = name;
	int idx = v__table__Table_find_or_register_fn_type(p->table, func, true, false);
	v__table__Type typ = v__table__new_type(idx);
	return (v__ast__AnonFn){
		.decl = (v__ast__FnDecl){
		.name = name,
		.stmts = stmts,
		.return_type = return_type,
		.args = args,
		.is_variadic = is_variadic,
		.is_method = false,
		.is_anon = true,
		.no_body = no_body,
		.pos = pos,
		.file = p->file_name,
		.is_deprecated = 0,
		.is_pub = 0,
		.receiver = {0},
		.receiver_pos = {0},
		.rec_mut = 0,
		.is_c = 0,
		.is_js = 0,
		.is_builtin = 0,
		.ctdefine = (string){.str=""},
		.body_pos = {0},
	},
		.typ = typ,
	};
}

static multi_return_array_v__table__Arg_bool v__parser__Parser_fn_args(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_lpar);
	array_v__table__Arg args = __new_array(0, 0, sizeof(v__table__Arg));
	bool is_variadic = false;
	bool types_only = (p->tok.kind == v__token__Kind_amp || p->tok.kind == v__token__Kind_and) || (p->peek_tok.kind == v__token__Kind_comma && v__table__Table_known_type(p->table, p->tok.lit)) || p->peek_tok.kind == v__token__Kind_rpar;
	if (types_only) {
		int arg_no = 1;
		while (p->tok.kind != v__token__Kind_rpar) {
			string arg_name = _STR("arg_%"PRId32"", 1, arg_no);
			bool is_mut = p->tok.kind == v__token__Kind_key_mut;
			if (is_mut) {
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind_ellipsis) {
				v__parser__Parser_next(p);
				is_variadic = true;
			}
			v__table__Type arg_type = v__parser__Parser_parse_type(p);
			if (is_variadic) {
				arg_type = v__table__Type_set_flag(arg_type, v__table__TypeFlag_variadic);
			}
			if (p->tok.kind == v__token__Kind_comma) {
				if (is_variadic) {
					v__parser__Parser_error(p, _STR("cannot use ...(variadic) with non-final parameter no %"PRId32"", 1, arg_no));
				}
				v__parser__Parser_next(p);
			}
			array_push(&args, &(v__table__Arg[]){ (v__table__Arg){
				.name = arg_name,
				.is_mut = is_mut,
				.typ = arg_type,
				.is_hidden = 0,
			} });
			arg_no++;
		}
	} else {
		while (p->tok.kind != v__token__Kind_rpar) {
			bool is_mut = p->tok.kind == v__token__Kind_key_mut;
			if (is_mut) {
				v__parser__Parser_next(p);
			}
			array_string arg_names = new_array_from_c_array(1, 1, sizeof(string), (string[1]){
		v__parser__Parser_check_name(p), 
});
			while (p->tok.kind == v__token__Kind_comma) {
				v__parser__Parser_next(p);
				array_push(&arg_names, &(string[]){ v__parser__Parser_check_name(p) });
			}
			if (p->tok.kind == v__token__Kind_key_mut) {
				is_mut = true;
			}
			if (p->tok.kind == v__token__Kind_ellipsis) {
				v__parser__Parser_next(p);
				is_variadic = true;
			}
			v__table__Type typ = v__parser__Parser_parse_type(p);
			if (is_variadic) {
				typ = v__table__Type_set_flag(typ, v__table__TypeFlag_variadic);
			}
			// FOR IN array
			array tmp13 = arg_names;
			for (int tmp14 = 0; tmp14 < tmp13.len; tmp14++) {
				string arg_name = ((string*)tmp13.data)[tmp14];
				array_push(&args, &(v__table__Arg[]){ (v__table__Arg){
					.name = arg_name,
					.is_mut = is_mut,
					.typ = typ,
					.is_hidden = 0,
				} });
				if (is_variadic && p->tok.kind == v__token__Kind_comma) {
					v__parser__Parser_error(p, _STR("cannot use ...(variadic) with non-final parameter %.*s", 1, arg_name));
				}
			}
			if (p->tok.kind != v__token__Kind_rpar) {
				v__parser__Parser_check(p, v__token__Kind_comma);
			}
		}
	}
	v__parser__Parser_check(p, v__token__Kind_rpar);
	return (multi_return_array_v__table__Arg_bool){.arg0=args,.arg1=is_variadic};
}

static bool v__parser__Parser_fileis(v__parser__Parser* p, string s) {
	return string_contains(p->file_name, s);
}

static void v__parser__Parser_fn_redefinition_error(v__parser__Parser* p, string name) {
	v__parser__Parser_error(p, _STR("redefinition of function `%.*s\000`", 2, name));
}

static bool v__parser__have_fn_main(array_v__ast__Stmt stmts) {
	bool has_main_fn = false;
	// FOR IN array
	array tmp1 = stmts;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)tmp1.data)[tmp2];
		if (stmt.typ == 111 /* v.ast.FnDecl */) {
			v__ast__FnDecl* it = (v__ast__FnDecl*)stmt.obj; // ST it
			if (string_eq(it->name, tos3("main"))) {
				has_main_fn = true;
			}
		}else {
		};
	}
	return has_main_fn;
}

static v__ast__Stmt v__parser__Parser_for_stmt(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_key_for);
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_open_scope(p);
	p->inside_for = true;
	if (p->tok.kind == v__token__Kind_lcbr) {
		p->inside_for = false;
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		v__parser__Parser_close_scope(p);
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__ForStmt[]) {(v__ast__ForStmt){
			.stmts = stmts,
			.pos = pos,
			.is_inf = true,
			.cond = {0},
		}}, sizeof(v__ast__ForStmt)), .typ = 151 /* v.ast.ForStmt */};
	} else if (p->tok.kind == v__token__Kind_key_mut) {
		v__parser__Parser_error(p, tos3("`mut` is not needed in for loops"));
	} else if ((p->peek_tok.kind == v__token__Kind_decl_assign || p->peek_tok.kind == v__token__Kind_assign || p->peek_tok.kind == v__token__Kind_semicolon) || p->tok.kind == v__token__Kind_semicolon) {
		v__ast__Stmt init = (v__ast__Stmt){
		0};
		v__ast__Expr cond = v__parser__Parser_new_true_expr(p);
		v__ast__Expr inc = (v__ast__Expr){
		0};
		bool has_init = false;
		bool has_cond = false;
		bool has_inc = false;
		if ((p->peek_tok.kind == v__token__Kind_assign || p->peek_tok.kind == v__token__Kind_decl_assign)) {
			init = v__parser__Parser_assign_stmt(p);
			has_init = true;
		} else if (p->tok.kind != v__token__Kind_semicolon) {
		}
		v__parser__Parser_check(p, v__token__Kind_semicolon);
		if (p->tok.kind != v__token__Kind_semicolon) {
			cond = v__parser__Parser_expr(p, 0);
			has_cond = true;
		}
		v__parser__Parser_check(p, v__token__Kind_semicolon);
		if (p->tok.kind != v__token__Kind_lcbr) {
			inc = v__parser__Parser_expr(p, 0);
			has_inc = true;
		}
		p->inside_for = false;
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		v__parser__Parser_close_scope(p);
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__ForCStmt[]) {(v__ast__ForCStmt){
			.stmts = stmts,
			.has_init = has_init,
			.has_cond = has_cond,
			.has_inc = has_inc,
			.init = init,
			.cond = cond,
			.inc = inc,
			.pos = pos,
		}}, sizeof(v__ast__ForCStmt)), .typ = 152 /* v.ast.ForCStmt */};
	} else if ((p->peek_tok.kind == v__token__Kind_key_in || p->peek_tok.kind == v__token__Kind_comma)) {
		v__token__Position val_var_pos = v__token__Token_position(&p->tok);
		string key_var_name = tos3("");
		string val_var_name = v__parser__Parser_check_name(p);
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
			v__token__Position key_var_pos = val_var_pos;
			val_var_pos = v__token__Token_position(&p->tok);
			key_var_name = val_var_name;
			val_var_name = v__parser__Parser_check_name(p);
			if (v__ast__Scope_known_var(p->scope, key_var_name)) {
				v__parser__Parser_error(p, _STR("redefinition of key iteration variable `%.*s\000`", 2, key_var_name));
			}
			if (v__ast__Scope_known_var(p->scope, val_var_name)) {
				v__parser__Parser_error(p, _STR("redefinition of value iteration variable `%.*s\000`", 2, val_var_name));
			}
			v__ast__Scope_register(p->scope, key_var_name, /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
				.name = key_var_name,
				.typ = _const_v__table__int_type,
				.pos = key_var_pos,
				.expr = {0},
				.is_mut = 0,
				.is_arg = 0,
				.is_used = 0,
			}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
		} else if (v__ast__Scope_known_var(p->scope, val_var_name)) {
			v__parser__Parser_error(p, _STR("redefinition of value iteration variable `%.*s\000`", 2, val_var_name));
		}
		v__parser__Parser_check(p, v__token__Kind_key_in);
		if (p->tok.kind == v__token__Kind_name && (string_eq(p->tok.lit, key_var_name) || string_eq(p->tok.lit, val_var_name))) {
			v__parser__Parser_error(p, _STR("in a `for x in array` loop, the key or value iteration variable `%.*s\000` can not be the same as the array variable", 2, p->tok.lit));
		}
		v__ast__Expr cond = v__parser__Parser_expr(p, 0);
		v__ast__Expr high_expr = (v__ast__Expr){
		0};
		bool is_range = false;
		if (p->tok.kind == v__token__Kind_dotdot) {
			is_range = true;
			v__parser__Parser_next(p);
			high_expr = v__parser__Parser_expr(p, 0);
			v__ast__Scope_register(p->scope, val_var_name, /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
				.name = val_var_name,
				.typ = _const_v__table__int_type,
				.pos = val_var_pos,
				.expr = {0},
				.is_mut = 0,
				.is_arg = 0,
				.is_used = 0,
			}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
		} else {
			v__ast__Scope_register(p->scope, val_var_name, /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
				.name = val_var_name,
				.pos = val_var_pos,
				.expr = {0},
				.is_mut = 0,
				.is_arg = 0,
				.typ = {0},
				.is_used = 0,
			}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
		}
		p->inside_for = false;
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		v__parser__Parser_close_scope(p);
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__ForInStmt[]) {(v__ast__ForInStmt){
			.stmts = stmts,
			.cond = cond,
			.key_var = key_var_name,
			.val_var = val_var_name,
			.high = high_expr,
			.is_range = is_range,
			.pos = pos,
			.key_type = {0},
			.val_type = {0},
			.cond_type = {0},
			.kind = {0},
		}}, sizeof(v__ast__ForInStmt)), .typ = 153 /* v.ast.ForInStmt */};
	}
	v__ast__Expr cond = v__parser__Parser_expr(p, 0);
	p->inside_for = false;
	array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
	v__parser__Parser_close_scope(p);
	return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__ForStmt[]) {(v__ast__ForStmt){
		.cond = cond,
		.stmts = stmts,
		.pos = pos,
		.is_inf = 0,
	}}, sizeof(v__ast__ForStmt)), .typ = 151 /* v.ast.ForStmt */};
}

static v__ast__IfExpr v__parser__Parser_if_expr(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	array_v__ast__IfBranch branches = __new_array(0, 0, sizeof(v__ast__IfBranch));
	bool has_else = false;
	while ((p->tok.kind == v__token__Kind_key_if || p->tok.kind == v__token__Kind_key_else)) {
		p->inside_if = true;
		v__token__Position start_pos = v__token__Token_position(&p->tok);
		v__ast__Comment comment = (v__ast__Comment){
			.text = (string){.str=""},
			.is_multi = 0,
			.line_nr = 0,
			.pos = {0},
		};
		if (p->tok.kind == v__token__Kind_key_if) {
			v__parser__Parser_next(p);
		} else {
			v__parser__Parser_check(p, v__token__Kind_key_else);
			if (p->tok.kind == v__token__Kind_key_if) {
				v__parser__Parser_next(p);
			} else {
				has_else = true;
				p->inside_if = false;
				v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
				array_push(&branches, &(v__ast__IfBranch[]){ (v__ast__IfBranch){
					.stmts = v__parser__Parser_parse_block(p),
					.pos = v__token__Position_extend(start_pos, end_pos),
					.comment = comment,
					.cond = {0},
				} });
				break;
			}
		}
		v__ast__Expr cond = (v__ast__Expr){
		0};
		bool is_or = false;
		if (p->peek_tok.kind == v__token__Kind_decl_assign) {
			is_or = true;
			v__parser__Parser_open_scope(p);
			v__token__Position var_pos = v__token__Token_position(&p->tok);
			string var_name = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind_decl_assign);
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			v__ast__Scope_register(p->scope, var_name, /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
				.name = var_name,
				.expr = expr,
				.pos = var_pos,
				.is_mut = 0,
				.is_arg = 0,
				.typ = {0},
				.is_used = 0,
			}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
			cond = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__IfGuardExpr[]) {(v__ast__IfGuardExpr){
				.var_name = var_name,
				.expr = expr,
				.expr_type = {0},
			}}, sizeof(v__ast__IfGuardExpr)), .typ = 158 /* v.ast.IfGuardExpr */};
		} else {
			cond = v__parser__Parser_expr(p, 0);
		}
		v__token__Position end_pos = v__token__Token_position(&p->prev_tok);
		p->inside_if = false;
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		if (is_or) {
			v__parser__Parser_close_scope(p);
		}
		array_push(&branches, &(v__ast__IfBranch[]){ (v__ast__IfBranch){
			.cond = cond,
			.stmts = stmts,
			.pos = v__token__Position_extend(start_pos, end_pos),
			.comment = (v__ast__Comment){
			.text = (string){.str=""},
			.is_multi = 0,
			.line_nr = 0,
			.pos = {0},
		},
		} });
		if (p->tok.kind != v__token__Kind_key_else) {
			break;
		}
	}
	return (v__ast__IfExpr){
		.branches = branches,
		.pos = pos,
		.has_else = has_else,
		.tok_kind = {0},
		.left = {0},
		.is_expr = 0,
		.typ = {0},
	};
}

static v__ast__MatchExpr v__parser__Parser_match_expr(v__parser__Parser* p) {
	v__token__Position match_first_pos = v__token__Token_position(&p->tok);
	p->inside_match = true;
	v__parser__Parser_check(p, v__token__Kind_key_match);
	bool is_mut = p->tok.kind == v__token__Kind_key_mut;
	bool is_sum_type = false;
	if (is_mut) {
		v__parser__Parser_next(p);
	}
	v__token__Position cond_pos = v__token__Token_position(&p->tok);
	v__ast__Expr cond = v__parser__Parser_expr(p, 0);
	p->inside_match = false;
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	array_v__ast__MatchBranch branches = __new_array(0, 0, sizeof(v__ast__MatchBranch));
	while (1) {
		v__token__Position branch_first_pos = v__token__Token_position(&p->tok);
		v__ast__Comment comment = v__parser__Parser_check_comment(p);
		array_v__ast__Expr exprs = __new_array(0, 0, sizeof(v__ast__Expr));
		v__parser__Parser_open_scope(p);
		bool is_else = false;
		if (p->tok.kind == v__token__Kind_key_else) {
			is_else = true;
			v__parser__Parser_next(p);
		} else if (p->tok.kind == v__token__Kind_name && !(string_eq(p->tok.lit, tos3("C")) && p->peek_tok.kind == v__token__Kind_dot) && (_IN(string, p->tok.lit, _const_v__table__builtin_type_names) || (byte_is_capital(string_at(p->tok.lit, 0)) && !string_is_upper(p->tok.lit)) || p->peek_tok.kind == v__token__Kind_dot)) {
			v__table__Type typ = v__parser__Parser_parse_type(p);
			array_push(&exprs, &(v__ast__Expr[]){ /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__Type[]) {(v__ast__Type){
				.typ = typ,
				.pos = {0},
			}}, sizeof(v__ast__Type)), .typ = 162 /* v.ast.Type */} });
			v__ast__Scope_register(p->scope, tos3("it"), /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
				.name = tos3("it"),
				.typ = v__table__Type_to_ptr(typ),
				.pos = cond_pos,
				.is_used = true,
				.is_mut = is_mut,
				.expr = {0},
				.is_arg = 0,
			}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
			if (p->tok.kind == v__token__Kind_comma) {
				v__parser__Parser_next(p);
				v__parser__Parser_parse_type(p);
			}
			is_sum_type = true;
			string var_name = tos3("");
			if (cond.typ == 136 /* v.ast.Ident */) {
				v__ast__Ident* it = (v__ast__Ident*)cond.obj; // ST it
				var_name = it->name;
			}else {
			};
			if (string_ne(var_name, tos3(""))) {
			}
		} else {
			while (1) {
				p->inside_match_case = true;
				v__ast__Expr expr = v__parser__Parser_expr(p, 0);
				p->inside_match_case = false;
				array_push(&exprs, &(v__ast__Expr[]){ expr });
				if (p->tok.kind != v__token__Kind_comma) {
					break;
				}
				v__parser__Parser_check(p, v__token__Kind_comma);
			}
		}
		v__token__Position branch_last_pos = v__token__Token_position(&p->tok);
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		v__token__Position pos = (v__token__Position){
			.line_nr = branch_first_pos.line_nr,
			.pos = branch_first_pos.pos,
			.len = branch_last_pos.pos - branch_first_pos.pos + branch_last_pos.len,
		};
		array_push(&branches, &(v__ast__MatchBranch[]){ (v__ast__MatchBranch){
			.exprs = exprs,
			.stmts = stmts,
			.pos = pos,
			.comment = comment,
			.is_else = is_else,
		} });
		v__parser__Parser_close_scope(p);
		if (p->tok.kind == v__token__Kind_rcbr) {
			break;
		}
	}
	v__token__Position match_last_pos = v__token__Token_position(&p->tok);
	v__token__Position pos = (v__token__Position){
		.line_nr = match_first_pos.line_nr,
		.pos = match_first_pos.pos,
		.len = match_last_pos.pos - match_first_pos.pos + match_last_pos.len,
	};
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	return (v__ast__MatchExpr){
		.branches = branches,
		.cond = cond,
		.is_sum_type = is_sum_type,
		.pos = pos,
		.is_mut = is_mut,
		.tok_kind = {0},
		.is_expr = 0,
		.return_type = {0},
		.cond_type = {0},
		.expected_type = {0},
	};
}

bool v__parser__Parser_known_import(v__parser__Parser* p, string mod) {
	return _IN_MAP(mod, p->imports);
}

static string v__parser__Parser_prepend_mod(v__parser__Parser* p, string name) {
	if (string_ne(p->expr_mod, tos3(""))) {
		return string_add(string_add(p->expr_mod, tos3(".")), name);
	}
	if (p->builtin_mod || string_eq(p->mod, tos3("main"))) {
		return name;
	}
	return _STR("%.*s\000.%.*s", 2, p->mod, name);
}

v__table__Type v__parser__Parser_parse_array_type(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_lsbr);
	if (p->tok.kind == v__token__Kind_number) {
		int size = string_int(p->tok.lit);
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		v__table__Type elem_type = v__parser__Parser_parse_type(p);
		int idx = v__table__Table_find_or_register_array_fixed(p->table, elem_type, size, 1);
		return v__table__new_type(idx);
	}
	v__parser__Parser_check(p, v__token__Kind_rsbr);
	v__table__Type elem_type = v__parser__Parser_parse_type(p);
	int nr_dims = 1;
	while (p->tok.kind == v__token__Kind_lsbr) {
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		nr_dims++;
	}
	int idx = v__table__Table_find_or_register_array(p->table, elem_type, nr_dims);
	return v__table__new_type(idx);
}

v__table__Type v__parser__Parser_parse_map_type(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	if (p->tok.kind != v__token__Kind_lsbr) {
		return _const_v__table__map_type;
	}
	v__parser__Parser_check(p, v__token__Kind_lsbr);
	v__table__Type key_type = v__parser__Parser_parse_type(p);
	if (v__table__Type_idx(key_type) != _const_v__table__string_type_idx) {
		v__parser__Parser_error(p, tos3("maps can only have string keys for now"));
	}
	v__parser__Parser_check(p, v__token__Kind_rsbr);
	v__table__Type value_type = v__parser__Parser_parse_type(p);
	int idx = v__table__Table_find_or_register_map(p->table, key_type, value_type);
	return v__table__new_type(idx);
}

v__table__Type v__parser__Parser_parse_multi_return_type(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_lpar);
	array_v__table__Type mr_types = __new_array(0, 0, sizeof(v__table__Type));
	while (1) {
		v__table__Type mr_type = v__parser__Parser_parse_type(p);
		array_push(&mr_types, &(v__table__Type[]){ mr_type });
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		} else {
			break;
		}
	}
	v__parser__Parser_check(p, v__token__Kind_rpar);
	int idx = v__table__Table_find_or_register_multi_return(p->table, mr_types);
	return v__table__new_type(idx);
}

v__table__Type v__parser__Parser_parse_fn_type(v__parser__Parser* p, string name) {
	v__parser__Parser_check(p, v__token__Kind_key_fn);
	int line_nr = p->tok.line_nr;
	multi_return_array_v__table__Arg_bool mr_1759 = v__parser__Parser_fn_args(p);
	array_v__table__Arg args = mr_1759.arg0;
	bool is_variadic = mr_1759.arg1;
	v__table__Type return_type = _const_v__table__void_type;
	if (p->tok.line_nr == line_nr && v__token__Kind_is_start_of_type(p->tok.kind)) {
		return_type = v__parser__Parser_parse_type(p);
	}
	v__table__Fn func = (v__table__Fn){
		.name = name,
		.args = args,
		.is_variadic = is_variadic,
		.return_type = return_type,
		.is_c = 0,
		.is_js = 0,
		.is_generic = 0,
		.is_pub = 0,
		.mod = (string){.str=""},
		.ctdefine = (string){.str=""},
	};
	int idx = v__table__Table_find_or_register_fn_type(p->table, func, false, false);
	return v__table__new_type(idx);
}

v__table__Type v__parser__Parser_parse_type_with_mut(v__parser__Parser* p, bool is_mut) {
	v__table__Type typ = v__parser__Parser_parse_type(p);
	if (is_mut) {
		return v__table__Type_set_nr_muls(typ, 1);
	}
	return typ;
}

v__table__Type v__parser__Parser_parse_type(v__parser__Parser* p) {
	bool is_optional = false;
	if (p->tok.kind == v__token__Kind_question) {
		v__parser__Parser_next(p);
		is_optional = true;
	}
	int nr_muls = 0;
	if (p->tok.kind == v__token__Kind_key_mut) {
		nr_muls++;
		v__parser__Parser_next(p);
	}
	while ((p->tok.kind == v__token__Kind_and || p->tok.kind == v__token__Kind_amp)) {
		if (p->tok.kind == v__token__Kind_and) {
			nr_muls += 2;
		} else {
			nr_muls++;
		}
		v__parser__Parser_next(p);
	}
	bool is_c = string_eq(p->tok.lit, tos3("C"));
	bool is_js = string_eq(p->tok.lit, tos3("JS"));
	if (is_c || is_js) {
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_dot);
	}
	v__table__Type typ = v__parser__Parser_parse_any_type(p, is_c, is_js, nr_muls > 0);
	if (is_optional) {
		typ = v__table__Type_set_flag(typ, v__table__TypeFlag_optional);
	}
	if (nr_muls > 0) {
		typ = v__table__Type_set_nr_muls(typ, nr_muls);
	}
	return typ;
}

v__table__Type v__parser__Parser_parse_any_type(v__parser__Parser* p, bool is_c, bool is_js, bool is_ptr) {
	string name = p->tok.lit;
	if (is_c) {
		name = _STR("C.%.*s", 1, name);
	} else if (is_js) {
		name = _STR("JS.%.*s", 1, name);
	} else if (p->peek_tok.kind == v__token__Kind_dot) {
		if (!v__parser__Parser_known_import(p, name)) {
			println(array_string_str(p->table->imports));
			v__parser__Parser_error(p, _STR("unknown module `%.*s\000`", 2, p->tok.lit));
		}
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_dot);
		name = _STR("%.*s\000.%.*s", 2, (*(string*)map_get3(p->imports, name, &(string[]){ (string){.str=""} })), p->tok.lit);
	} else if (string_ne(p->expr_mod, tos3(""))) {
		name = string_add(string_add(p->expr_mod, tos3(".")), name);
	} else if (!(string_eq(p->mod, tos3("builtin")) || string_eq(p->mod, tos3("main"))) && !_IN(string, name, _const_v__table__builtin_type_names)) {
		name = string_add(string_add(p->mod, tos3(".")), name);
	}
	if (p->tok.kind == v__token__Kind_key_fn) {
		return v__parser__Parser_parse_fn_type(p, tos3(""));
	}else if (p->tok.kind == v__token__Kind_lsbr) {
		return v__parser__Parser_parse_array_type(p);
	}else if (p->tok.kind == v__token__Kind_lpar) {
		if (is_ptr) {
			v__parser__Parser_error(p, tos3("parse_type: unexpected `&` before multiple returns"));
		}
		return v__parser__Parser_parse_multi_return_type(p);
	}else {
		if (string_eq(name, tos3("map"))) {
			return v__parser__Parser_parse_map_type(p);
		}
		if (string_eq(name, tos3("voidptr"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__voidptr_type;
		}else if (string_eq(name, tos3("byteptr"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__byteptr_type;
		}else if (string_eq(name, tos3("charptr"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__charptr_type;
		}else if (string_eq(name, tos3("i8"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__i8_type;
		}else if (string_eq(name, tos3("i16"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__i16_type;
		}else if (string_eq(name, tos3("int"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__int_type;
		}else if (string_eq(name, tos3("i64"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__i64_type;
		}else if (string_eq(name, tos3("byte"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__byte_type;
		}else if (string_eq(name, tos3("u16"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__u16_type;
		}else if (string_eq(name, tos3("u32"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__u32_type;
		}else if (string_eq(name, tos3("u64"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__u64_type;
		}else if (string_eq(name, tos3("f32"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__f32_type;
		}else if (string_eq(name, tos3("f64"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__f64_type;
		}else if (string_eq(name, tos3("string"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__string_type;
		}else if (string_eq(name, tos3("char"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__char_type;
		}else if (string_eq(name, tos3("bool"))) {
			// defer
				v__parser__Parser_next(p);
			return _const_v__table__bool_type;
		}else {
			int idx = v__table__Table_find_type_idx(p->table, name);
			if (idx > 0) {
				// defer
					v__parser__Parser_next(p);
				return v__table__new_type(idx);
			}
			idx = v__table__Table_add_placeholder_type(p->table, name);
			// defer
				v__parser__Parser_next(p);
			return v__table__new_type(idx);
		};
	};
// defer
	v__parser__Parser_next(p);
}

v__ast__Stmt v__parser__parse_stmt(string text, v__table__Table* table, v__ast__Scope* scope) {
	v__scanner__Scanner* s = v__scanner__new_scanner(text, v__scanner__CommentsMode_skip_comments);
	v__parser__Parser p = (v__parser__Parser){
		.scanner = s,
		.table = table,
		.pref = (v__pref__Preferences*)memdup(&(v__pref__Preferences){	.os = {0},
		.backend = {0},
		.build_mode = {0},
		.is_verbose = 0,
		.is_test = 0,
		.is_script = 0,
		.is_livemain = 0,
		.is_liveshared = 0,
		.is_shared = 0,
		.is_prof = 0,
		.profile_file = (string){.str=""},
		.translated = 0,
		.is_prod = 0,
		.obfuscate = 0,
		.is_repl = 0,
		.is_run = 0,
		.sanitize = 0,
		.is_debug = 0,
		.is_vlines = 0,
		.keep_c = 0,
		.show_cc = 0,
		.use_cache = 0,
		.is_stats = 0,
		.no_auto_free = 0,
		.cflags = (string){.str=""},
		.ccompiler = (string){.str=""},
		.third_party_option = (string){.str=""},
		.building_v = 0,
		.autofree = 0,
		.compress = 0,
		.fast = 0,
		.enable_globals = 0,
		.is_fmt = 0,
		.is_bare = 0,
		.lookup_path = __new_array(0, 1, sizeof(string)),
		.output_cross_c = 0,
		.prealloc = 0,
		.vroot = (string){.str=""},
		.out_name = (string){.str=""},
		.path = (string){.str=""},
		.compile_defines = __new_array(0, 1, sizeof(string)),
		.compile_defines_all = __new_array(0, 1, sizeof(string)),
		.mod = (string){.str=""},
		.run_args = __new_array(0, 1, sizeof(string)),
		.printfn_list = __new_array(0, 1, sizeof(string)),
		.print_v_files = 0,
	}, sizeof(v__pref__Preferences)),
		.scope = scope,
		.global_scope = (v__ast__Scope*)memdup(&(v__ast__Scope){	.start_pos = 0,
		.parent = 0,
		.children = __new_array(0, 1, sizeof(v__ast__Scope)),
		.end_pos = 0,
		.objects = new_map_1(sizeof(v__ast__ScopeObject)),
	}, sizeof(v__ast__Scope)),
		.file_name = (string){.str=""},
		.file_name_dir = (string){.str=""},
		.tok = {0},
		.prev_tok = {0},
		.peek_tok = {0},
		.peek_tok2 = {0},
		.is_c = 0,
		.is_js = 0,
		.inside_if = 0,
		.inside_for = 0,
		.inside_fn = 0,
		.builtin_mod = 0,
		.mod = (string){.str=""},
		.attr = (string){.str=""},
		.attr_ctdefine = (string){.str=""},
		.expr_mod = (string){.str=""},
		.imports = new_map_1(sizeof(string)),
		.ast_imports = __new_array(0, 1, sizeof(v__ast__Import)),
		.is_amp = 0,
		.returns = 0,
		.inside_match = 0,
		.inside_match_case = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
	};
	v__parser__Parser_init_parse_fns(&p);
	v__parser__Parser_read_first_token(&p);
	return v__parser__Parser_stmt(&p);
}

v__ast__File v__parser__parse_file(string path, v__table__Table* b_table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref, v__ast__Scope* global_scope) {
	array_v__ast__Stmt stmts = __new_array(0, 0, sizeof(v__ast__Stmt));
	v__parser__Parser p = (v__parser__Parser){
		.scanner = v__scanner__new_scanner_file(path, comments_mode),
		.table = b_table,
		.file_name = path,
		.file_name_dir = os__dir(path),
		.pref = pref,
		.scope = (v__ast__Scope*)memdup(&(v__ast__Scope){	.start_pos = 0,
		.parent = 0,
		.children = __new_array(0, 1, sizeof(v__ast__Scope)),
		.end_pos = 0,
		.objects = new_map_1(sizeof(v__ast__ScopeObject)),
	}, sizeof(v__ast__Scope)),
		.global_scope = global_scope,
		.tok = {0},
		.prev_tok = {0},
		.peek_tok = {0},
		.peek_tok2 = {0},
		.is_c = 0,
		.is_js = 0,
		.inside_if = 0,
		.inside_for = 0,
		.inside_fn = 0,
		.builtin_mod = 0,
		.mod = (string){.str=""},
		.attr = (string){.str=""},
		.attr_ctdefine = (string){.str=""},
		.expr_mod = (string){.str=""},
		.imports = new_map_1(sizeof(string)),
		.ast_imports = __new_array(0, 1, sizeof(v__ast__Import)),
		.is_amp = 0,
		.returns = 0,
		.inside_match = 0,
		.inside_match_case = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
	};
	v__parser__Parser_read_first_token(&p);
	while (p.tok.kind == v__token__Kind_comment) {
		v__ast__Stmt stmt = (v__ast__Stmt){
		0};
		v__ast__Comment com = v__parser__Parser_comment(&p);
		stmt = /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__Comment[]) {com}, sizeof(v__ast__Comment)), .typ = 157 /* v.ast.Comment */};
		array_push(&stmts, &(v__ast__Stmt[]){ stmt });
	}
	v__ast__Stmt mstmt = (v__ast__Stmt){
	0};
	v__ast__Module module_decl = v__parser__Parser_module_decl(&p);
	mstmt = /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__Module[]) {module_decl}, sizeof(v__ast__Module)), .typ = 187 /* v.ast.Module */};
	array_push(&stmts, &(v__ast__Stmt[]){ mstmt });
	while (1) {
		if (p.tok.kind == v__token__Kind_eof) {
			if (p.pref->is_script && !p.pref->is_test && string_eq(p.mod, tos3("main")) && !v__parser__have_fn_main(stmts)) {
				array_push(&stmts, &(v__ast__Stmt[]){ /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__FnDecl[]) {(v__ast__FnDecl){
					.name = tos3("main"),
					.file = p.file_name,
					.return_type = _const_v__table__void_type,
					.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),
					.args = __new_array(0, 1, sizeof(v__table__Arg)),
					.is_deprecated = 0,
					.is_pub = 0,
					.is_variadic = 0,
					.is_anon = 0,
					.receiver = {0},
					.receiver_pos = {0},
					.is_method = 0,
					.rec_mut = 0,
					.is_c = 0,
					.is_js = 0,
					.no_body = 0,
					.is_builtin = 0,
					.ctdefine = (string){.str=""},
					.pos = {0},
					.body_pos = {0},
				}}, sizeof(v__ast__FnDecl)), .typ = 111 /* v.ast.FnDecl */} });
			}
			break;
		}
		array_push(&stmts, &(v__ast__Stmt[]){ v__parser__Parser_top_stmt(&p) });
	}
	p.scope->end_pos = p.tok.pos;
	return (v__ast__File){
		.path = path,
		.mod = module_decl,
		.imports = p.ast_imports,
		.stmts = stmts,
		.scope = p.scope,
		.global_scope = p.global_scope,
	};
}

array_v__ast__File v__parser__parse_files(array_string paths, v__table__Table* table, v__pref__Preferences* pref, v__ast__Scope* global_scope) {
	array_v__ast__File files = __new_array(0, 0, sizeof(v__ast__File));
	// FOR IN array
	array tmp1 = paths;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string path = ((string*)tmp1.data)[tmp2];
		array_push(&files, &(v__ast__File[]){ v__parser__parse_file(path, table, v__scanner__CommentsMode_skip_comments, pref, global_scope) });
	}
	return files;
}

void v__parser__Parser_init_parse_fns(v__parser__Parser* p) {
	println(tos3(""));
}

void v__parser__Parser_read_first_token(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	v__parser__Parser_next(p);
	v__parser__Parser_next(p);
}

void v__parser__Parser_open_scope(v__parser__Parser* p) {
	p->scope = (v__ast__Scope*)memdup(&(v__ast__Scope){	.parent = p->scope,
		.start_pos = p->tok.pos,
		.children = __new_array(0, 1, sizeof(v__ast__Scope)),
		.end_pos = 0,
		.objects = new_map_1(sizeof(v__ast__ScopeObject)),
	}, sizeof(v__ast__Scope));
}

void v__parser__Parser_close_scope(v__parser__Parser* p) {
	if (!p->pref->is_repl && !p->scanner->is_fmt) {
		// FOR IN map
		array_string keys_tmp2 = map_keys(&p->scope->objects);
		for (int tmp3 = 0; tmp3 < keys_tmp2.len; tmp3++) {
			string tmp4 = ((string*)keys_tmp2.data)[tmp3];
			v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)map_get3(p->scope->objects, tmp4, &(v__ast__ScopeObject[]){ {0} }));
			if (obj.typ == 131 /* v.ast.Var */) {
				v__ast__Var* it = (v__ast__Var*)obj.obj; // ST it
				if (!it->is_used && !string_starts_with(it->name, tos3("__"))) {
					if (p->pref->is_prod) {
						v__parser__Parser_error_with_pos(p, _STR("unused variable: `%.*s\000`", 2, it->name), it->pos);
					} else {
						v__parser__Parser_warn_with_pos(p, _STR("unused variable: `%.*s\000`", 2, it->name), it->pos);
					}
				}
			}else {
			};
		}
	}
	p->scope->end_pos = p->tok.pos;
	array_push(&p->scope->parent->children, &(v__ast__Scope*[]){ p->scope });
	p->scope = p->scope->parent;
}

array_v__ast__Stmt v__parser__Parser_parse_block(v__parser__Parser* p) {
	v__parser__Parser_open_scope(p);
	array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p);
	v__parser__Parser_close_scope(p);
	return stmts;
}

array_v__ast__Stmt v__parser__Parser_parse_block_no_scope(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	array_v__ast__Stmt stmts = __new_array(0, 0, sizeof(v__ast__Stmt));
	if (p->tok.kind != v__token__Kind_rcbr) {
		while (1) {
			array_push(&stmts, &(v__ast__Stmt[]){ v__parser__Parser_stmt(p) });
			if ((p->tok.kind == v__token__Kind_eof || p->tok.kind == v__token__Kind_rcbr)) {
				break;
			}
		}
	}
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	return stmts;
}

static void v__parser__Parser_next(v__parser__Parser* p) {
	p->prev_tok = p->tok;
	p->tok = p->peek_tok;
	p->peek_tok = p->peek_tok2;
	p->peek_tok2 = v__scanner__Scanner_scan(p->scanner);
}

static void v__parser__Parser_check(v__parser__Parser* p, v__token__Kind expected) {
	if (p->tok.kind != expected) {
		v__parser__Parser_error(p, _STR("unexpected `%.*s\000`, expecting `%.*s\000`", 3, v__token__Kind_str(p->tok.kind), v__token__Kind_str(expected)));
	}
	v__parser__Parser_next(p);
}

static string v__parser__Parser_check_name(v__parser__Parser* p) {
	string name = p->tok.lit;
	v__parser__Parser_check(p, v__token__Kind_name);
	return name;
}

v__ast__Stmt v__parser__Parser_top_stmt(v__parser__Parser* p) {
	if (p->tok.kind == v__token__Kind_key_pub) {
		if (p->peek_tok.kind == v__token__Kind_key_const) {
			return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__ConstDecl[]) {v__parser__Parser_const_decl(p)}, sizeof(v__ast__ConstDecl)), .typ = 188 /* v.ast.ConstDecl */};
		}else if (p->peek_tok.kind == v__token__Kind_key_fn) {
			return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__FnDecl[]) {v__parser__Parser_fn_decl(p)}, sizeof(v__ast__FnDecl)), .typ = 111 /* v.ast.FnDecl */};
		}else if (p->peek_tok.kind == v__token__Kind_key_struct || p->peek_tok.kind == v__token__Kind_key_union) {
			return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__StructDecl[]) {v__parser__Parser_struct_decl(p)}, sizeof(v__ast__StructDecl)), .typ = 211 /* v.ast.StructDecl */};
		}else if (p->peek_tok.kind == v__token__Kind_key_interface) {
			return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__InterfaceDecl[]) {v__parser__Parser_interface_decl(p)}, sizeof(v__ast__InterfaceDecl)), .typ = 217 /* v.ast.InterfaceDecl */};
		}else if (p->peek_tok.kind == v__token__Kind_key_enum) {
			return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__EnumDecl[]) {v__parser__Parser_enum_decl(p)}, sizeof(v__ast__EnumDecl)), .typ = 193 /* v.ast.EnumDecl */};
		}else if (p->peek_tok.kind == v__token__Kind_key_type) {
			return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__TypeDecl[]) {v__parser__Parser_type_decl(p)}, sizeof(v__ast__TypeDecl)), .typ = 196 /* v.ast.TypeDecl */};
		}else {
			v__parser__Parser_error(p, tos3("wrong pub keyword usage"));
			return (v__ast__Stmt){
			0};
		};
	}else if (p->tok.kind == v__token__Kind_lsbr) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__Attr[]) {v__parser__Parser_attribute(p)}, sizeof(v__ast__Attr)), .typ = 178 /* v.ast.Attr */};
	}else if (p->tok.kind == v__token__Kind_key_interface) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__InterfaceDecl[]) {v__parser__Parser_interface_decl(p)}, sizeof(v__ast__InterfaceDecl)), .typ = 217 /* v.ast.InterfaceDecl */};
	}else if (p->tok.kind == v__token__Kind_key_import) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__Import[]) {v__parser__Parser_import_stmt(p)}, sizeof(v__ast__Import)), .typ = 165 /* v.ast.Import */};
	}else if (p->tok.kind == v__token__Kind_key_global) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__GlobalDecl[]) {v__parser__Parser_global_decl(p)}, sizeof(v__ast__GlobalDecl)), .typ = 192 /* v.ast.GlobalDecl */};
	}else if (p->tok.kind == v__token__Kind_key_const) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__ConstDecl[]) {v__parser__Parser_const_decl(p)}, sizeof(v__ast__ConstDecl)), .typ = 188 /* v.ast.ConstDecl */};
	}else if (p->tok.kind == v__token__Kind_key_fn) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__FnDecl[]) {v__parser__Parser_fn_decl(p)}, sizeof(v__ast__FnDecl)), .typ = 111 /* v.ast.FnDecl */};
	}else if (p->tok.kind == v__token__Kind_key_struct) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__StructDecl[]) {v__parser__Parser_struct_decl(p)}, sizeof(v__ast__StructDecl)), .typ = 211 /* v.ast.StructDecl */};
	}else if (p->tok.kind == v__token__Kind_dollar) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__CompIf[]) {v__parser__Parser_comp_if(p)}, sizeof(v__ast__CompIf)), .typ = 141 /* v.ast.CompIf */};
	}else if (p->tok.kind == v__token__Kind_hash) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__HashStmt[]) {v__parser__Parser_hash(p)}, sizeof(v__ast__HashStmt)), .typ = 140 /* v.ast.HashStmt */};
	}else if (p->tok.kind == v__token__Kind_key_type) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__TypeDecl[]) {v__parser__Parser_type_decl(p)}, sizeof(v__ast__TypeDecl)), .typ = 196 /* v.ast.TypeDecl */};
	}else if (p->tok.kind == v__token__Kind_key_enum) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__EnumDecl[]) {v__parser__Parser_enum_decl(p)}, sizeof(v__ast__EnumDecl)), .typ = 193 /* v.ast.EnumDecl */};
	}else if (p->tok.kind == v__token__Kind_key_union) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__StructDecl[]) {v__parser__Parser_struct_decl(p)}, sizeof(v__ast__StructDecl)), .typ = 211 /* v.ast.StructDecl */};
	}else if (p->tok.kind == v__token__Kind_comment) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__Comment[]) {v__parser__Parser_comment(p)}, sizeof(v__ast__Comment)), .typ = 157 /* v.ast.Comment */};
	}else {
		if (p->pref->is_script && !p->pref->is_test) {
			v__scanner__Scanner_add_fn_main_and_rescan(p->scanner, p->tok.pos - 1);
			v__parser__Parser_read_first_token(p);
			return v__parser__Parser_top_stmt(p);
		} else {
			v__parser__Parser_error(p, string_add(tos3("bad top level statement "), v__token__Token_str(p->tok)));
			return (v__ast__Stmt){
			0};
		}
	};
}

v__ast__Comment v__parser__Parser_check_comment(v__parser__Parser* p) {
	if (p->tok.kind == v__token__Kind_comment) {
		return v__parser__Parser_comment(p);
	}
	return (v__ast__Comment){
		.text = (string){.str=""},
		.is_multi = 0,
		.line_nr = 0,
		.pos = {0},
	};
}

v__ast__Comment v__parser__Parser_comment(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	string text = p->tok.lit;
	v__parser__Parser_next(p);
	return (v__ast__Comment){
		.text = text,
		.pos = pos,
		.is_multi = 0,
		.line_nr = 0,
	};
}

v__ast__Stmt v__parser__Parser_stmt(v__parser__Parser* p) {
	p->is_stmt_ident = p->tok.kind == v__token__Kind_name;
	if (p->tok.kind == v__token__Kind_lcbr) {
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__Block[]) {(v__ast__Block){
			.stmts = stmts,
		}}, sizeof(v__ast__Block)), .typ = 169 /* v.ast.Block */};
	}else if (p->tok.kind == v__token__Kind_key_assert) {
		v__parser__Parser_next(p);
		v__token__Position assert_pos = v__token__Token_position(&p->tok);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__AssertStmt[]) {(v__ast__AssertStmt){
			.expr = expr,
			.pos = assert_pos,
		}}, sizeof(v__ast__AssertStmt)), .typ = 170 /* v.ast.AssertStmt */};
	}else if (p->tok.kind == v__token__Kind_key_mut || p->tok.kind == v__token__Kind_key_static) {
		return v__parser__Parser_assign_stmt(p);
	}else if (p->tok.kind == v__token__Kind_key_for) {
		return v__parser__Parser_for_stmt(p);
	}else if (p->tok.kind == v__token__Kind_comment) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__Comment[]) {v__parser__Parser_comment(p)}, sizeof(v__ast__Comment)), .typ = 157 /* v.ast.Comment */};
	}else if (p->tok.kind == v__token__Kind_key_return) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__Return[]) {v__parser__Parser_return_stmt(p)}, sizeof(v__ast__Return)), .typ = 191 /* v.ast.Return */};
	}else if (p->tok.kind == v__token__Kind_dollar) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__CompIf[]) {v__parser__Parser_comp_if(p)}, sizeof(v__ast__CompIf)), .typ = 141 /* v.ast.CompIf */};
	}else if (p->tok.kind == v__token__Kind_key_continue || p->tok.kind == v__token__Kind_key_break) {
		v__token__Token tok = p->tok;
		v__parser__Parser_next(p);
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__BranchStmt[]) {(v__ast__BranchStmt){
			.tok = tok,
		}}, sizeof(v__ast__BranchStmt)), .typ = 171 /* v.ast.BranchStmt */};
	}else if (p->tok.kind == v__token__Kind_key_unsafe) {
		v__parser__Parser_next(p);
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__UnsafeStmt[]) {(v__ast__UnsafeStmt){
			.stmts = stmts,
		}}, sizeof(v__ast__UnsafeStmt)), .typ = 172 /* v.ast.UnsafeStmt */};
	}else if (p->tok.kind == v__token__Kind_hash) {
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__HashStmt[]) {v__parser__Parser_hash(p)}, sizeof(v__ast__HashStmt)), .typ = 140 /* v.ast.HashStmt */};
	}else if (p->tok.kind == v__token__Kind_key_defer) {
		v__parser__Parser_next(p);
		array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__DeferStmt[]) {(v__ast__DeferStmt){
			.stmts = stmts,
			.ifdef = (string){.str=""},
		}}, sizeof(v__ast__DeferStmt)), .typ = 173 /* v.ast.DeferStmt */};
	}else if (p->tok.kind == v__token__Kind_key_go) {
		v__parser__Parser_next(p);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		if (expr.typ == 144 /* v.ast.CallExpr */) {
			v__ast__CallExpr* it = (v__ast__CallExpr*)expr.obj; // ST it
		}else {
		};
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__GoStmt[]) {(v__ast__GoStmt){
			.call_expr = expr,
		}}, sizeof(v__ast__GoStmt)), .typ = 174 /* v.ast.GoStmt */};
	}else if (p->tok.kind == v__token__Kind_key_goto) {
		v__parser__Parser_next(p);
		string name = v__parser__Parser_check_name(p);
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__GotoStmt[]) {(v__ast__GotoStmt){
			.name = name,
		}}, sizeof(v__ast__GotoStmt)), .typ = 175 /* v.ast.GotoStmt */};
	}else {
		if (p->tok.kind == v__token__Kind_name && (p->peek_tok.kind == v__token__Kind_decl_assign || p->peek_tok.kind == v__token__Kind_comma)) {
			return v__parser__Parser_assign_stmt(p);
		} else if (p->tok.kind == v__token__Kind_name && p->peek_tok.kind == v__token__Kind_colon) {
			string name = v__parser__Parser_check_name(p);
			v__parser__Parser_next(p);
			return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__GotoLabel[]) {(v__ast__GotoLabel){
				.name = name,
			}}, sizeof(v__ast__GotoLabel)), .typ = 176 /* v.ast.GotoLabel */};
		} else if (p->tok.kind == v__token__Kind_name && p->peek_tok.kind == v__token__Kind_name) {
			v__parser__Parser_error_with_pos(p, _STR("unexpected name `%.*s\000`", 2, p->peek_tok.lit), v__token__Token_position(&p->peek_tok));
		}
		v__token__Position epos = v__token__Token_position(&p->tok);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		return /* sum type cast */ (v__ast__Stmt) {.obj = memdup(&(v__ast__ExprStmt[]) {(v__ast__ExprStmt){
			.expr = expr,
			.pos = epos,
			.typ = {0},
		}}, sizeof(v__ast__ExprStmt)), .typ = 177 /* v.ast.ExprStmt */};
	};
}

static v__ast__Attr v__parser__Parser_attribute(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_lsbr);
	bool is_if_attr = false;
	if (p->tok.kind == v__token__Kind_key_if) {
		v__parser__Parser_next(p);
		is_if_attr = true;
	}
	string name = v__parser__Parser_check_name(p);
	if (p->tok.kind == v__token__Kind_colon) {
		name = string_add(name, tos3(":"));
		v__parser__Parser_next(p);
		if (p->tok.kind == v__token__Kind_name) {
			name = string_add(name, v__parser__Parser_check_name(p));
		} else if (p->tok.kind == v__token__Kind_string) {
			name = string_add(name, p->tok.lit);
			v__parser__Parser_next(p);
		}
	}
	v__parser__Parser_check(p, v__token__Kind_rsbr);
	p->attr = name;
	if (is_if_attr) {
		p->attr_ctdefine = name;
	}
	return (v__ast__Attr){
		.name = name,
	};
}

void v__parser__Parser_error(v__parser__Parser* p, string s) {
	v__parser__Parser_error_with_pos(p, s, v__token__Token_position(&p->tok));
}

void v__parser__Parser_warn(v__parser__Parser* p, string s) {
	v__parser__Parser_warn_with_pos(p, s, v__token__Token_position(&p->tok));
}

void v__parser__Parser_error_with_pos(v__parser__Parser* p, string s, v__token__Position pos) {
	string kind = tos3("error:");
	if (p->pref->is_verbose) {
		print_backtrace();
		kind = tos3("parser error:");
	}
	string ferror = v__util__formatted_error(kind, s, p->file_name, pos);
	eprintln(ferror);
	v_exit(1);
}

void v__parser__Parser_warn_with_pos(v__parser__Parser* p, string s, v__token__Position pos) {
	string ferror = v__util__formatted_error(tos3("warning:"), s, p->file_name, pos);
	eprintln(ferror);
}

v__ast__Ident v__parser__Parser_parse_ident(v__parser__Parser* p, bool is_c, bool is_js) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	string name = v__parser__Parser_check_name(p);
	if (string_eq(name, tos3("_"))) {
		return (v__ast__Ident){
			.name = tos3("_"),
			.kind = v__ast__IdentKind_blank_ident,
			.pos = pos,
			.value = (string){.str=""},
			.is_c = 0,
			.is_js = 0,
			.tok_kind = {0},
			.mod = (string){.str=""},
			.info = {0},
			.is_mut = 0,
		};
	}
	if (p->expr_mod.len > 0) {
		name = _STR("%.*s\000.%.*s", 2, p->expr_mod, name);
	}
	return (v__ast__Ident){
		.kind = v__ast__IdentKind_unresolved,
		.name = name,
		.is_c = is_c,
		.is_js = is_js,
		.mod = p->mod,
		.pos = pos,
		.value = (string){.str=""},
		.tok_kind = {0},
		.info = {0},
		.is_mut = 0,
	};
}

v__ast__Expr v__parser__Parser_name_expr(v__parser__Parser* p) {
	v__ast__Expr node = (v__ast__Expr){
	0};
	if (p->expecting_type) {
		p->expecting_type = false;
		v__token__Position type_pos = v__token__Token_position(&p->tok);
		v__table__Type typ = v__parser__Parser_parse_type(p);
		return /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__Type[]) {(v__ast__Type){
			.typ = typ,
			.pos = type_pos,
		}}, sizeof(v__ast__Type)), .typ = 162 /* v.ast.Type */};
	}
	bool is_c = string_eq(p->tok.lit, tos3("C"));
	bool is_js = string_eq(p->tok.lit, tos3("JS"));
	string mod = tos3("");
	p->expr_mod = tos3("");
	if (string_eq(p->tok.lit, tos3("map")) && p->peek_tok.kind == v__token__Kind_lsbr) {
		v__table__Type map_type = v__parser__Parser_parse_map_type(p);
		if (p->tok.kind == v__token__Kind_lcbr && p->peek_tok.kind == v__token__Kind_rcbr) {
			v__parser__Parser_next(p);
			v__parser__Parser_next(p);
		}
		return /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__MapInit[]) {(v__ast__MapInit){
			.typ = map_type,
			.pos = {0},
			.keys = __new_array(0, 1, sizeof(v__ast__Expr)),
			.vals = __new_array(0, 1, sizeof(v__ast__Expr)),
			.key_type = {0},
			.value_type = {0},
		}}, sizeof(v__ast__MapInit)), .typ = 143 /* v.ast.MapInit */};
	}
	if ((string_eq(p->tok.lit, tos3("r")) || string_eq(p->tok.lit, tos3("c")) || string_eq(p->tok.lit, tos3("js"))) && p->peek_tok.kind == v__token__Kind_string && p->prev_tok.kind != v__token__Kind_str_dollar) {
		return v__parser__Parser_string_expr(p);
	}
	bool known_var = false;
	bool tmp5;
	{ /* if guard */ Option_v__ast__ScopeObject obj = v__ast__Scope_find(p->scope, p->tok.lit);
	if ((tmp5 = obj.ok)) {
		if (/*opt*/(*(v__ast__ScopeObject*)obj.data).typ == 131 /* v.ast.Var */) {
			v__ast__Var* it = (v__ast__Var*)/*opt*/(*(v__ast__ScopeObject*)obj.data).obj; // ST it
			known_var = true;
			it->is_used = true;
		}else {
		};
	}}
	if (p->peek_tok.kind == v__token__Kind_dot && !known_var && (is_c || is_js || v__parser__Parser_known_import(p, p->tok.lit) || string_eq(string_all_after(p->mod, tos3(".")), p->tok.lit))) {
		if (is_c) {
			mod = tos3("C");
		} else if (is_js) {
			mod = tos3("JS");
		} else {
			mod = (*(string*)map_get3(p->imports, p->tok.lit, &(string[]){ (string){.str=""} }));
		}
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_dot);
		p->expr_mod = mod;
	}
	if (p->peek_tok.kind == v__token__Kind_lpar) {
		string name = p->tok.lit;
		if (mod.len > 0) {
			name = _STR("%.*s\000.%.*s", 2, mod, name);
		}
		string name_w_mod = v__parser__Parser_prepend_mod(p, name);
		if (!known_var && (_IN_MAP(name, p->table->type_idxs) || _IN_MAP(name_w_mod, p->table->type_idxs)) && !(string_eq(name, tos3("C.stat")) || string_eq(name, tos3("C.sigaction")))) {
			v__table__Type to_typ = v__parser__Parser_parse_type(p);
			if (p->is_amp) {
				to_typ = v__table__Type_to_ptr(to_typ);
			}
			v__parser__Parser_check(p, v__token__Kind_lpar);
			v__ast__Expr expr = (v__ast__Expr){
			0};
			v__ast__Expr arg = (v__ast__Expr){
			0};
			bool has_arg = false;
			expr = v__parser__Parser_expr(p, 0);
			if (p->tok.kind == v__token__Kind_comma && v__table__Type_idx(to_typ) == _const_v__table__string_type_idx) {
				v__parser__Parser_next(p);
				arg = v__parser__Parser_expr(p, 0);
				has_arg = true;
			}
			v__parser__Parser_check(p, v__token__Kind_rpar);
			node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__CastExpr[]) {(v__ast__CastExpr){
				.typ = to_typ,
				.expr = expr,
				.arg = arg,
				.has_arg = has_arg,
				.pos = v__ast__Expr_position(expr),
				.typname = (string){.str=""},
				.expr_type = {0},
			}}, sizeof(v__ast__CastExpr)), .typ = 179 /* v.ast.CastExpr */};
			p->expr_mod = tos3("");
			return node;
		} else {
			v__ast__CallExpr x = v__parser__Parser_call_expr(p, is_c, is_js, mod);
			node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__CallExpr[]) {x}, sizeof(v__ast__CallExpr)), .typ = 144 /* v.ast.CallExpr */};
		}
	} else if (p->peek_tok.kind == v__token__Kind_lcbr && !p->inside_match && !p->inside_match_case && !p->inside_if && !p->inside_for) {
		return /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__StructInit[]) {v__parser__Parser_struct_init(p, false)}, sizeof(v__ast__StructInit)), .typ = 214 /* v.ast.StructInit */};
	} else if (p->peek_tok.kind == v__token__Kind_dot && (byte_is_capital(string_at(p->tok.lit, 0)) && !known_var)) {
		string enum_name = v__parser__Parser_check_name(p);
		if (string_ne(mod, tos3(""))) {
			enum_name = string_add(string_add(mod, tos3(".")), enum_name);
		} else {
			enum_name = v__parser__Parser_prepend_mod(p, enum_name);
		}
		v__parser__Parser_check(p, v__token__Kind_dot);
		string val = v__parser__Parser_check_name(p);
		p->expr_mod = tos3("");
		return /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__EnumVal[]) {(v__ast__EnumVal){
			.enum_name = enum_name,
			.val = val,
			.pos = v__token__Token_position(&p->tok),
			.mod = mod,
			.typ = {0},
		}}, sizeof(v__ast__EnumVal)), .typ = 180 /* v.ast.EnumVal */};
	} else if (p->peek_tok.kind == v__token__Kind_colon && p->prev_tok.kind != v__token__Kind_str_dollar) {
		return /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__StructInit[]) {v__parser__Parser_struct_init(p, true)}, sizeof(v__ast__StructInit)), .typ = 214 /* v.ast.StructInit */};
	} else {
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__Ident[]) {v__parser__Parser_parse_ident(p, is_c, is_js)}, sizeof(v__ast__Ident)), .typ = 136 /* v.ast.Ident */};
	}
	p->expr_mod = tos3("");
	return node;
}

static v__ast__IndexExpr v__parser__Parser_index_expr(v__parser__Parser* p, v__ast__Expr left) {
	v__parser__Parser_next(p);
	bool has_low = true;
	if (p->tok.kind == v__token__Kind_dotdot) {
		has_low = false;
		v__parser__Parser_next(p);
		v__ast__Expr high = v__parser__Parser_expr(p, 0);
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		return (v__ast__IndexExpr){
			.left = left,
			.pos = v__token__Token_position(&p->tok),
			.index = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__RangeExpr[]) {(v__ast__RangeExpr){
			.low = (v__ast__Expr){
		0},
			.high = high,
			.has_high = true,
			.has_low = 0,
		}}, sizeof(v__ast__RangeExpr)), .typ = 181 /* v.ast.RangeExpr */},
			.left_type = {0},
			.is_setter = 0,
		};
	}
	v__ast__Expr expr = v__parser__Parser_expr(p, 0);
	bool has_high = false;
	if (p->tok.kind == v__token__Kind_dotdot) {
		v__parser__Parser_next(p);
		v__ast__Expr high = (v__ast__Expr){
		0};
		if (p->tok.kind != v__token__Kind_rsbr) {
			has_high = true;
			high = v__parser__Parser_expr(p, 0);
		}
		v__parser__Parser_check(p, v__token__Kind_rsbr);
		return (v__ast__IndexExpr){
			.left = left,
			.pos = v__token__Token_position(&p->tok),
			.index = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__RangeExpr[]) {(v__ast__RangeExpr){
			.low = expr,
			.high = high,
			.has_high = has_high,
			.has_low = has_low,
		}}, sizeof(v__ast__RangeExpr)), .typ = 181 /* v.ast.RangeExpr */},
			.left_type = {0},
			.is_setter = 0,
		};
	}
	v__parser__Parser_check(p, v__token__Kind_rsbr);
	return (v__ast__IndexExpr){
		.left = left,
		.index = expr,
		.pos = v__token__Token_position(&p->tok),
		.left_type = {0},
		.is_setter = 0,
	};
}

static void v__parser__Parser_scope_register_it(v__parser__Parser* p) {
	v__ast__Scope_register(p->scope, tos3("it"), /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
		.name = tos3("it"),
		.pos = v__token__Token_position(&p->tok),
		.is_used = true,
		.expr = {0},
		.is_mut = 0,
		.is_arg = 0,
		.typ = {0},
	}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
}

static v__ast__Expr v__parser__Parser_dot_expr(v__parser__Parser* p, v__ast__Expr left) {
	v__parser__Parser_next(p);
	v__token__Position name_pos = v__token__Token_position(&p->tok);
	string field_name = v__parser__Parser_check_name(p);
	bool is_filter = (string_eq(field_name, tos3("filter")) || string_eq(field_name, tos3("map")));
	if (is_filter) {
		v__parser__Parser_open_scope(p);
		name_pos = v__token__Token_position(&p->tok);
		v__parser__Parser_scope_register_it(p);
	}
	if (p->tok.kind == v__token__Kind_lpar) {
		v__parser__Parser_next(p);
		array_v__ast__CallArg args = v__parser__Parser_call_args(p);
		if (is_filter && args.len != 1) {
			v__parser__Parser_error(p, tos3("needs exactly 1 argument"));
		}
		v__parser__Parser_check(p, v__token__Kind_rpar);
		array_v__ast__Stmt or_stmts = __new_array(0, 0, sizeof(v__ast__Stmt));
		bool is_or_block_used = false;
		if (p->tok.kind == v__token__Kind_key_orelse) {
			v__parser__Parser_next(p);
			v__parser__Parser_open_scope(p);
			v__ast__Scope_register(p->scope, tos3("errcode"), /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
				.name = tos3("errcode"),
				.typ = _const_v__table__int_type,
				.pos = v__token__Token_position(&p->tok),
				.is_used = true,
				.expr = {0},
				.is_mut = 0,
				.is_arg = 0,
			}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
			v__ast__Scope_register(p->scope, tos3("err"), /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__Var[]) {(v__ast__Var){
				.name = tos3("err"),
				.typ = _const_v__table__string_type,
				.pos = v__token__Token_position(&p->tok),
				.is_used = true,
				.expr = {0},
				.is_mut = 0,
				.is_arg = 0,
			}}, sizeof(v__ast__Var)), .typ = 131 /* v.ast.Var */});
			is_or_block_used = true;
			or_stmts = v__parser__Parser_parse_block_no_scope(p);
			v__parser__Parser_close_scope(p);
		}
		v__token__Position end_pos = v__token__Token_position(&p->tok);
		v__token__Position pos = (v__token__Position){
			.line_nr = name_pos.line_nr,
			.pos = name_pos.pos,
			.len = end_pos.pos - name_pos.pos,
		};
		v__ast__CallExpr mcall_expr = (v__ast__CallExpr){
			.left = left,
			.name = field_name,
			.args = args,
			.pos = pos,
			.is_method = true,
			.or_block = (v__ast__OrExpr){
			.stmts = or_stmts,
			.is_used = is_or_block_used,
		},
			.mod = (string){.str=""},
			.expected_arg_types = __new_array(0, 1, sizeof(v__table__Type)),
			.is_c = 0,
			.is_js = 0,
			.left_type = {0},
			.receiver_type = {0},
			.return_type = {0},
			.should_be_skipped = 0,
		};
		v__ast__Expr node = (v__ast__Expr){
		0};
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__CallExpr[]) {mcall_expr}, sizeof(v__ast__CallExpr)), .typ = 144 /* v.ast.CallExpr */};
		if (is_filter) {
			v__parser__Parser_close_scope(p);
		}
		return node;
	}
	v__ast__SelectorExpr sel_expr = (v__ast__SelectorExpr){
		.expr = left,
		.field = field_name,
		.pos = name_pos,
		.expr_type = {0},
	};
	v__ast__Expr node = (v__ast__Expr){
	0};
	node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__SelectorExpr[]) {sel_expr}, sizeof(v__ast__SelectorExpr)), .typ = 182 /* v.ast.SelectorExpr */};
	if (is_filter) {
		v__parser__Parser_close_scope(p);
	}
	return node;
}

static v__ast__EnumVal v__parser__Parser_enum_val(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_dot);
	string val = v__parser__Parser_check_name(p);
	return (v__ast__EnumVal){
		.val = val,
		.pos = v__token__Token_position(&p->tok),
		.enum_name = (string){.str=""},
		.mod = (string){.str=""},
		.typ = {0},
	};
}

static v__ast__Expr v__parser__Parser_string_expr(v__parser__Parser* p) {
	bool is_raw = p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos3("r"));
	bool is_cstr = p->tok.kind == v__token__Kind_name && string_eq(p->tok.lit, tos3("c"));
	if (is_raw || is_cstr) {
		v__parser__Parser_next(p);
	}
	v__ast__Expr node = (v__ast__Expr){
	0};
	string val = p->tok.lit;
	v__token__Position pos = v__token__Token_position(&p->tok);
	if (p->peek_tok.kind != v__token__Kind_str_dollar) {
		v__parser__Parser_next(p);
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__StringLiteral[]) {(v__ast__StringLiteral){
			.val = val,
			.is_raw = is_raw,
			.is_c = is_cstr,
			.pos = pos,
			.is_js = 0,
		}}, sizeof(v__ast__StringLiteral)), .typ = 183 /* v.ast.StringLiteral */};
		return node;
	}
	array_v__ast__Expr exprs = __new_array(0, 0, sizeof(v__ast__Expr));
	array_string vals = __new_array(0, 0, sizeof(string));
	array_string efmts = __new_array(0, 0, sizeof(string));
	while (p->tok.kind == v__token__Kind_string) {
		array_push(&vals, &(string[]){ p->tok.lit });
		v__parser__Parser_next(p);
		if (p->tok.kind != v__token__Kind_str_dollar) {
			continue;
		}
		v__parser__Parser_next(p);
		array_push(&exprs, &(v__ast__Expr[]){ v__parser__Parser_expr(p, 0) });
		array_string efmt = __new_array(0, 0, sizeof(string));
		if (p->tok.kind == v__token__Kind_colon) {
			array_push(&efmt, &(string[]){ tos3(":") });
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind_minus) {
				array_push(&efmt, &(string[]){ tos3("-") });
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind_number) {
				array_push(&efmt, &(string[]){ p->tok.lit });
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind_name && p->tok.lit.len == 1) {
				array_push(&efmt, &(string[]){ p->tok.lit });
				v__parser__Parser_next(p);
			}
		}
		array_push(&efmts, &(string[]){ array_string_join(efmt, tos3("")) });
	}
	node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__StringInterLiteral[]) {(v__ast__StringInterLiteral){
		.vals = vals,
		.exprs = exprs,
		.expr_fmts = efmts,
		.pos = pos,
		.expr_types = __new_array(0, 1, sizeof(v__table__Type)),
	}}, sizeof(v__ast__StringInterLiteral)), .typ = 184 /* v.ast.StringInterLiteral */};
	return node;
}

static v__ast__Expr v__parser__Parser_parse_number_literal(v__parser__Parser* p) {
	string lit = p->tok.lit;
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__ast__Expr node = (v__ast__Expr){
	0};
	if (string_index_any(lit, tos3(".eE")) >= 0 && !(string_eq(string_substr(lit, 0, 2), tos3("0x")) || string_eq(string_substr(lit, 0, 2), tos3("0X")) || string_eq(string_substr(lit, 0, 2), tos3("0o")) || string_eq(string_substr(lit, 0, 2), tos3("0O")) || string_eq(string_substr(lit, 0, 2), tos3("0b")) || string_eq(string_substr(lit, 0, 2), tos3("0B")))) {
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__FloatLiteral[]) {(v__ast__FloatLiteral){
			.val = lit,
			.pos = pos,
		}}, sizeof(v__ast__FloatLiteral)), .typ = 185 /* v.ast.FloatLiteral */};
	} else {
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__IntegerLiteral[]) {(v__ast__IntegerLiteral){
			.val = lit,
			.pos = pos,
		}}, sizeof(v__ast__IntegerLiteral)), .typ = 186 /* v.ast.IntegerLiteral */};
	}
	v__parser__Parser_next(p);
	return node;
}

static v__ast__Module v__parser__Parser_module_decl(v__parser__Parser* p) {
	string name = tos3("main");
	bool is_skipped = p->tok.kind != v__token__Kind_key_module;
	if (!is_skipped) {
		v__parser__Parser_next(p);
		name = v__parser__Parser_check_name(p);
	}
	string full_mod = v__table__Table_qualify_module(p->table, name, p->file_name);
	p->mod = full_mod;
	p->builtin_mod = string_eq(p->mod, tos3("builtin"));
	return (v__ast__Module){
		.name = full_mod,
		.is_skipped = is_skipped,
		.path = (string){.str=""},
		.expr = {0},
	};
}

static v__ast__Import v__parser__Parser_import_stmt(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind_key_import);
	v__token__Position pos = v__token__Token_position(&p->tok);
	if (p->tok.kind == v__token__Kind_lpar) {
		v__parser__Parser_error_with_pos(p, tos3("`import()` has been deprecated, use `import x` instead"), pos);
	}
	string mod_name = v__parser__Parser_check_name(p);
	string mod_alias = mod_name;
	while (p->tok.kind == v__token__Kind_dot) {
		v__parser__Parser_next(p);
		string submod_name = v__parser__Parser_check_name(p);
		mod_name = string_add(mod_name, string_add(tos3("."), submod_name));
		mod_alias = submod_name;
	}
	if (p->tok.kind == v__token__Kind_key_as) {
		v__parser__Parser_next(p);
		mod_alias = v__parser__Parser_check_name(p);
	}
	map_set(&p->imports, mod_alias, &(string[]) { mod_name });
	array_push(&p->table->imports, &(string[]){ mod_name });
	v__ast__Import node = (v__ast__Import){
		.mod = mod_name,
		.alias = mod_alias,
		.pos = pos,
	};
	array_push(&p->ast_imports, &(v__ast__Import[]){ node });
	return node;
}

static v__ast__ConstDecl v__parser__Parser_const_decl(v__parser__Parser* p) {
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_check(p, v__token__Kind_key_const);
	if (p->tok.kind != v__token__Kind_lpar) {
		v__parser__Parser_error(p, tos3("consts must be grouped, e.g.\nconst (\n\ta = 1\n)"));
	}
	v__parser__Parser_next(p);
	array_v__ast__ConstField fields = __new_array(0, 0, sizeof(v__ast__ConstField));
	while (p->tok.kind != v__token__Kind_rpar) {
		if (p->tok.kind == v__token__Kind_comment) {
			v__parser__Parser_comment(p);
		}
		v__token__Position pos = v__token__Token_position(&p->tok);
		string name = v__parser__Parser_prepend_mod(p, v__parser__Parser_check_name(p));
		v__parser__Parser_check(p, v__token__Kind_assign);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		v__ast__ConstField field = (v__ast__ConstField){
			.name = name,
			.expr = expr,
			.pos = pos,
			.is_pub = 0,
			.typ = {0},
		};
		array_push(&fields, &(v__ast__ConstField[]){ field });
		v__ast__Scope_register(p->global_scope, field.name, /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__ConstField[]) {field}, sizeof(v__ast__ConstField)), .typ = 189 /* v.ast.ConstField */});
	}
	v__parser__Parser_check(p, v__token__Kind_rpar);
	return (v__ast__ConstDecl){
		.pos = v__token__Position_extend(start_pos, end_pos),
		.fields = fields,
		.is_pub = is_pub,
	};
}

static v__ast__Return v__parser__Parser_return_stmt(v__parser__Parser* p) {
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	array_v__ast__Expr exprs = __new_array(0, 0, sizeof(v__ast__Expr));
	if (p->tok.kind == v__token__Kind_rcbr) {
		return (v__ast__Return){
			.pos = first_pos,
			.exprs = __new_array(0, 1, sizeof(v__ast__Expr)),
			.types = __new_array(0, 1, sizeof(v__table__Type)),
		};
	}
	while (1) {
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		array_push(&exprs, &(v__ast__Expr[]){ expr });
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		} else {
			break;
		}
	}
	v__token__Position end_pos = v__ast__Expr_position(*(v__ast__Expr*)array_last(exprs));
	return (v__ast__Return){
		.exprs = exprs,
		.pos = v__token__Position_extend(first_pos, end_pos),
		.types = __new_array(0, 1, sizeof(v__table__Type)),
	};
}

static v__ast__GlobalDecl v__parser__Parser_global_decl(v__parser__Parser* p) {
	if (!p->pref->translated && !p->pref->is_livemain && !p->builtin_mod && !p->pref->building_v && string_ne(p->mod, tos3("ui")) && string_ne(p->mod, tos3("gg2")) && string_ne(p->mod, tos3("uiold")) && !string_contains(os__getwd(), tos3("/volt")) && !p->pref->enable_globals) {
		v__parser__Parser_error(p, tos3("use `v --enable-globals ...` to enable globals"));
	}
	v__parser__Parser_next(p);
	string name = v__parser__Parser_check_name(p);
	v__table__Type typ = v__parser__Parser_parse_type(p);
	v__ast__Expr expr = (v__ast__Expr){
	0};
	bool has_expr = p->tok.kind == v__token__Kind_assign;
	if (has_expr) {
		v__parser__Parser_next(p);
		expr = v__parser__Parser_expr(p, 0);
	}
	v__ast__GlobalDecl glob = (v__ast__GlobalDecl){
		.name = name,
		.typ = typ,
		.has_expr = has_expr,
		.expr = expr,
	};
	v__ast__Scope_register(p->global_scope, name, /* sum type cast */ (v__ast__ScopeObject) {.obj = memdup(&(v__ast__GlobalDecl[]) {glob}, sizeof(v__ast__GlobalDecl)), .typ = 192 /* v.ast.GlobalDecl */});
	return glob;
}

static v__ast__EnumDecl v__parser__Parser_enum_decl(v__parser__Parser* p) {
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind_key_enum);
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	string enum_name = v__parser__Parser_check_name(p);
	if (enum_name.len > 0 && !byte_is_capital(string_at(enum_name, 0))) {
		v__parser__verror(_STR("enum name `%.*s\000` must begin with a capital letter", 2, enum_name));
	}
	string name = v__parser__Parser_prepend_mod(p, enum_name);
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	array_string vals = __new_array(0, 0, sizeof(string));
	array_v__ast__EnumField fields = __new_array(0, 0, sizeof(v__ast__EnumField));
	while (p->tok.kind != v__token__Kind_eof && p->tok.kind != v__token__Kind_rcbr) {
		v__token__Position pos = v__token__Token_position(&p->tok);
		string val = v__parser__Parser_check_name(p);
		array_push(&vals, &(string[]){ val });
		v__ast__Expr expr = (v__ast__Expr){
		0};
		bool has_expr = false;
		if (p->tok.kind == v__token__Kind_assign) {
			v__parser__Parser_next(p);
			expr = v__parser__Parser_expr(p, 0);
			has_expr = true;
		}
		array_push(&fields, &(v__ast__EnumField[]){ (v__ast__EnumField){
			.name = val,
			.pos = pos,
			.expr = expr,
			.has_expr = has_expr,
		} });
	}
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	v__table__Table_register_type_symbol(p->table, (v__table__TypeSymbol){
		.kind = v__table__Kind_enum_,
		.name = name,
		.info = /* sum type cast */ (v__table__TypeInfo) {.obj = memdup(&(v__table__Enum[]) {(v__table__Enum){
		.vals = vals,
	}}, sizeof(v__table__Enum)), .typ = 82 /* v.table.Enum */},
		.parent_idx = 0,
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	});
	return (v__ast__EnumDecl){
		.name = name,
		.is_pub = is_pub,
		.fields = fields,
		.pos = v__token__Position_extend(start_pos, end_pos),
	};
}

static v__ast__TypeDecl v__parser__Parser_type_decl(v__parser__Parser* p) {
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind_key_type);
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	v__token__Position decl_pos = v__token__Position_extend(start_pos, end_pos);
	string name = v__parser__Parser_check_name(p);
	array_v__table__Type sum_variants = __new_array(0, 0, sizeof(v__table__Type));
	if (p->tok.kind == v__token__Kind_assign) {
		v__parser__Parser_next(p);
	}
	if (p->tok.kind == v__token__Kind_key_fn) {
		string fn_name = v__parser__Parser_prepend_mod(p, name);
		v__table__Type fn_type = v__parser__Parser_parse_fn_type(p, fn_name);
		return /* sum type cast */ (v__ast__TypeDecl) {.obj = memdup(&(v__ast__FnTypeDecl[]) {(v__ast__FnTypeDecl){
			.name = fn_name,
			.is_pub = is_pub,
			.typ = fn_type,
			.pos = decl_pos,
		}}, sizeof(v__ast__FnTypeDecl)), .typ = 197 /* v.ast.FnTypeDecl */};
	}
	v__table__Type first_type = v__parser__Parser_parse_type(p);
	if (p->tok.kind == v__token__Kind_pipe) {
		v__parser__Parser_next(p);
		array_push(&sum_variants, &(v__table__Type[]){ first_type });
		while (1) {
			v__table__Type variant_type = v__parser__Parser_parse_type(p);
			array_push(&sum_variants, &(v__table__Type[]){ variant_type });
			if (p->tok.kind != v__token__Kind_pipe) {
				break;
			}
			v__parser__Parser_check(p, v__token__Kind_pipe);
		}
		v__table__Table_register_type_symbol(p->table, (v__table__TypeSymbol){
			.kind = v__table__Kind_sum_type,
			.name = v__parser__Parser_prepend_mod(p, name),
			.info = /* sum type cast */ (v__table__TypeInfo) {.obj = memdup(&(v__table__SumType[]) {(v__table__SumType){
			.variants = sum_variants,
		}}, sizeof(v__table__SumType)), .typ = 88 /* v.table.SumType */},
			.is_public = is_pub,
			.parent_idx = 0,
			.methods = __new_array(0, 1, sizeof(v__table__Fn)),
			.mod = (string){.str=""},
		});
		return /* sum type cast */ (v__ast__TypeDecl) {.obj = memdup(&(v__ast__SumTypeDecl[]) {(v__ast__SumTypeDecl){
			.name = name,
			.is_pub = is_pub,
			.sub_types = sum_variants,
			.pos = decl_pos,
		}}, sizeof(v__ast__SumTypeDecl)), .typ = 198 /* v.ast.SumTypeDecl */};
	}
	v__table__Type parent_type = first_type;
	int pid = v__table__Type_idx(parent_type);
	v__table__Table_register_type_symbol(p->table, (v__table__TypeSymbol){
		.kind = v__table__Kind_alias,
		.name = v__parser__Parser_prepend_mod(p, name),
		.parent_idx = pid,
		.info = /* sum type cast */ (v__table__TypeInfo) {.obj = memdup(&(v__table__Alias[]) {(v__table__Alias){
		.foo = tos3(""),
	}}, sizeof(v__table__Alias)), .typ = 79 /* v.table.Alias */},
		.is_public = is_pub,
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
	});
	return /* sum type cast */ (v__ast__TypeDecl) {.obj = memdup(&(v__ast__AliasTypeDecl[]) {(v__ast__AliasTypeDecl){
		.name = name,
		.is_pub = is_pub,
		.parent_type = parent_type,
		.pos = decl_pos,
	}}, sizeof(v__ast__AliasTypeDecl)), .typ = 199 /* v.ast.AliasTypeDecl */};
}

static v__ast__Assoc v__parser__Parser_assoc(v__parser__Parser* p) {
	string var_name = v__parser__Parser_check_name(p);
	v__token__Position pos = v__token__Token_position(&p->tok);
	Option_v__ast__Var_ptr v = v__ast__Scope_find_var(p->scope, var_name);
	if (!v.ok) {
		string err = v.v_error;
		int errcode = v.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		v__parser__Parser_error(p, _STR("unknown variable `%.*s\000`", 2, var_name));
		return (v__ast__Assoc){
			.var_name = (string){.str=""},
			.fields = __new_array(0, 1, sizeof(string)),
			.exprs = __new_array(0, 1, sizeof(v__ast__Expr)),
			.pos = {0},
			.typ = {0},
		};
	};
	/*opt*/(*(v__ast__Var**)v.data)->is_used = true;
	array_string fields = __new_array(0, 0, sizeof(string));
	array_v__ast__Expr vals = __new_array(0, 0, sizeof(v__ast__Expr));
	v__parser__Parser_check(p, v__token__Kind_pipe);
	while (1) {
		array_push(&fields, &(string[]){ v__parser__Parser_check_name(p) });
		v__parser__Parser_check(p, v__token__Kind_colon);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		array_push(&vals, &(v__ast__Expr[]){ expr });
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		}
		if (p->tok.kind == v__token__Kind_rcbr) {
			break;
		}
	}
	return (v__ast__Assoc){
		.var_name = var_name,
		.fields = fields,
		.exprs = vals,
		.pos = pos,
		.typ = {0},
	};
}

static v__ast__Expr v__parser__Parser_new_true_expr(v__parser__Parser* p) {
	return /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__BoolLiteral[]) {(v__ast__BoolLiteral){
		.val = true,
		.pos = v__token__Token_position(&p->tok),
	}}, sizeof(v__ast__BoolLiteral)), .typ = 201 /* v.ast.BoolLiteral */};
}

static void v__parser__verror(string s) {
	v__util__verror(tos3("parser error"), s);
}

v__ast__Expr v__parser__Parser_expr(v__parser__Parser* p, int precedence) {
	v__table__Type typ = _const_v__table__void_type;
	v__ast__Expr node = (v__ast__Expr){
	0};
	bool is_stmt_ident = p->is_stmt_ident;
	p->is_stmt_ident = false;
	if (p->tok.kind == v__token__Kind_name) {
		node = v__parser__Parser_name_expr(p);
		p->is_stmt_ident = is_stmt_ident;
	}else if (p->tok.kind == v__token__Kind_string) {
		node = v__parser__Parser_string_expr(p);
	}else if (p->tok.kind == v__token__Kind_dot) {
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__EnumVal[]) {v__parser__Parser_enum_val(p)}, sizeof(v__ast__EnumVal)), .typ = 180 /* v.ast.EnumVal */};
	}else if (p->tok.kind == v__token__Kind_chartoken) {
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__CharLiteral[]) {(v__ast__CharLiteral){
			.val = p->tok.lit,
			.pos = v__token__Token_position(&p->tok),
		}}, sizeof(v__ast__CharLiteral)), .typ = 202 /* v.ast.CharLiteral */};
		v__parser__Parser_next(p);
	}else if (p->tok.kind == v__token__Kind_minus || p->tok.kind == v__token__Kind_amp || p->tok.kind == v__token__Kind_mul || p->tok.kind == v__token__Kind_not || p->tok.kind == v__token__Kind_bit_not) {
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__PrefixExpr[]) {v__parser__Parser_prefix_expr(p)}, sizeof(v__ast__PrefixExpr)), .typ = 210 /* v.ast.PrefixExpr */};
	}else if (p->tok.kind == v__token__Kind_key_true || p->tok.kind == v__token__Kind_key_false) {
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__BoolLiteral[]) {(v__ast__BoolLiteral){
			.val = p->tok.kind == v__token__Kind_key_true,
			.pos = v__token__Token_position(&p->tok),
		}}, sizeof(v__ast__BoolLiteral)), .typ = 201 /* v.ast.BoolLiteral */};
		v__parser__Parser_next(p);
	}else if (p->tok.kind == v__token__Kind_key_match) {
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__MatchExpr[]) {v__parser__Parser_match_expr(p)}, sizeof(v__ast__MatchExpr)), .typ = 159 /* v.ast.MatchExpr */};
	}else if (p->tok.kind == v__token__Kind_number) {
		node = v__parser__Parser_parse_number_literal(p);
	}else if (p->tok.kind == v__token__Kind_lpar) {
		v__parser__Parser_check(p, v__token__Kind_lpar);
		node = v__parser__Parser_expr(p, 0);
		v__parser__Parser_check(p, v__token__Kind_rpar);
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__ParExpr[]) {(v__ast__ParExpr){
			.expr = node,
		}}, sizeof(v__ast__ParExpr)), .typ = 203 /* v.ast.ParExpr */};
	}else if (p->tok.kind == v__token__Kind_key_if) {
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__IfExpr[]) {v__parser__Parser_if_expr(p)}, sizeof(v__ast__IfExpr)), .typ = 154 /* v.ast.IfExpr */};
	}else if (p->tok.kind == v__token__Kind_lsbr) {
		if (p->expecting_type) {
			node = v__parser__Parser_name_expr(p);
		} else {
			node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__ArrayInit[]) {v__parser__Parser_array_init(p)}, sizeof(v__ast__ArrayInit)), .typ = 142 /* v.ast.ArrayInit */};
		}
	}else if (p->tok.kind == v__token__Kind_key_none) {
		v__parser__Parser_next(p);
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__None[]) {(v__ast__None){
			.foo = 0,
		}}, sizeof(v__ast__None)), .typ = 204 /* v.ast.None */};
	}else if (p->tok.kind == v__token__Kind_key_sizeof) {
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_lpar);
		if (string_eq(p->tok.lit, tos3("C"))) {
			v__parser__Parser_next(p);
			v__parser__Parser_check(p, v__token__Kind_dot);
			node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__SizeOf[]) {(v__ast__SizeOf){
				.type_name = v__parser__Parser_check_name(p),
				.typ = {0},
			}}, sizeof(v__ast__SizeOf)), .typ = 205 /* v.ast.SizeOf */};
		} else {
			v__table__Type sizeof_type = v__parser__Parser_parse_type(p);
			node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__SizeOf[]) {(v__ast__SizeOf){
				.typ = sizeof_type,
				.type_name = (string){.str=""},
			}}, sizeof(v__ast__SizeOf)), .typ = 205 /* v.ast.SizeOf */};
		}
		v__parser__Parser_check(p, v__token__Kind_rpar);
	}else if (p->tok.kind == v__token__Kind_key_typeof) {
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind_lpar);
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		v__parser__Parser_check(p, v__token__Kind_rpar);
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__TypeOf[]) {(v__ast__TypeOf){
			.expr = expr,
			.expr_type = {0},
		}}, sizeof(v__ast__TypeOf)), .typ = 206 /* v.ast.TypeOf */};
	}else if (p->tok.kind == v__token__Kind_lcbr) {
		v__parser__Parser_next(p);
		if (p->tok.kind == v__token__Kind_string) {
			node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__MapInit[]) {v__parser__Parser_map_init(p)}, sizeof(v__ast__MapInit)), .typ = 143 /* v.ast.MapInit */};
		} else {
			if (p->peek_tok.kind == v__token__Kind_pipe) {
				node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__Assoc[]) {v__parser__Parser_assoc(p)}, sizeof(v__ast__Assoc)), .typ = 200 /* v.ast.Assoc */};
			} else if (p->peek_tok.kind == v__token__Kind_colon || p->tok.kind == v__token__Kind_rcbr) {
				node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__StructInit[]) {v__parser__Parser_struct_init(p, true)}, sizeof(v__ast__StructInit)), .typ = 214 /* v.ast.StructInit */};
			} else if (p->tok.kind == v__token__Kind_name) {
				v__parser__Parser_next(p);
				string lit = (string_ne(p->tok.lit, tos3("")) ?  ( p->tok.lit )  :  ( v__token__Kind_str(p->tok.kind) ) );
				v__parser__Parser_error(p, _STR("unexpected `%.*s\000`, expecting `:`", 2, lit));
			} else {
				v__parser__Parser_error(p, _STR("unexpected `%.*s\000`, expecting struct key", 2, p->tok.lit));
			}
		}
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}else if (p->tok.kind == v__token__Kind_key_fn) {
		node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__AnonFn[]) {v__parser__Parser_anon_fn(p)}, sizeof(v__ast__AnonFn)), .typ = 149 /* v.ast.AnonFn */};
		return node;
	}else {
		if (p->tok.kind == v__token__Kind_comment) {
			println(p->tok.lit);
		}
		v__parser__Parser_error(p, _STR("expr(): bad token `%.*s\000`", 2, v__token__Kind_str(p->tok.kind)));
	};
	while (precedence < v__token__Token_precedence(p->tok)) {
		if (v__token__Kind_is_assign(p->tok.kind)) {
			node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__AssignExpr[]) {v__parser__Parser_assign_expr(p, node)}, sizeof(v__ast__AssignExpr)), .typ = 134 /* v.ast.AssignExpr */};
		} else if (p->tok.kind == v__token__Kind_dot) {
			node = v__parser__Parser_dot_expr(p, node);
			p->is_stmt_ident = is_stmt_ident;
		} else if (p->tok.kind == v__token__Kind_lsbr) {
			node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__IndexExpr[]) {v__parser__Parser_index_expr(p, node)}, sizeof(v__ast__IndexExpr)), .typ = 135 /* v.ast.IndexExpr */};
		} else if (p->tok.kind == v__token__Kind_key_as) {
			v__token__Position pos = v__token__Token_position(&p->tok);
			v__parser__Parser_next(p);
			typ = v__parser__Parser_parse_type(p);
			node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__AsCast[]) {(v__ast__AsCast){
				.expr = node,
				.typ = typ,
				.pos = pos,
				.expr_type = {0},
			}}, sizeof(v__ast__AsCast)), .typ = 207 /* v.ast.AsCast */};
		} else if (p->tok.kind == v__token__Kind_left_shift && p->is_stmt_ident) {
			v__token__Token tok = p->tok;
			v__token__Position pos = v__token__Token_position(&tok);
			v__parser__Parser_next(p);
			v__ast__Expr right = v__parser__Parser_expr(p, precedence - 1);
			node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__InfixExpr[]) {(v__ast__InfixExpr){
				.left = node,
				.right = right,
				.op = tok.kind,
				.pos = pos,
				.left_type = {0},
				.right_type = {0},
			}}, sizeof(v__ast__InfixExpr)), .typ = 208 /* v.ast.InfixExpr */};
		} else if (v__token__Kind_is_infix(p->tok.kind)) {
			if (p->tok.kind == v__token__Kind_mul && p->tok.line_nr != p->prev_tok.line_nr && p->peek_tok2.kind == v__token__Kind_assign) {
				return node;
			}
			node = v__parser__Parser_infix_expr(p, node);
		} else if ((p->tok.kind == v__token__Kind_inc || p->tok.kind == v__token__Kind_dec)) {
			node = /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__PostfixExpr[]) {(v__ast__PostfixExpr){
				.op = p->tok.kind,
				.expr = node,
				.pos = v__token__Token_position(&p->tok),
			}}, sizeof(v__ast__PostfixExpr)), .typ = 209 /* v.ast.PostfixExpr */};
			v__parser__Parser_next(p);
		} else {
			return node;
		}
	}
	return node;
}

static v__ast__Expr v__parser__Parser_infix_expr(v__parser__Parser* p, v__ast__Expr left) {
	v__token__Kind op = p->tok.kind;
	int precedence = v__token__Token_precedence(p->tok);
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__parser__Parser_next(p);
	v__ast__Expr right = (v__ast__Expr){
	0};
	if (op == v__token__Kind_key_is) {
		p->expecting_type = true;
	}
	right = v__parser__Parser_expr(p, precedence);
	return /* sum type cast */ (v__ast__Expr) {.obj = memdup(&(v__ast__InfixExpr[]) {(v__ast__InfixExpr){
		.left = left,
		.right = right,
		.op = op,
		.pos = pos,
		.left_type = {0},
		.right_type = {0},
	}}, sizeof(v__ast__InfixExpr)), .typ = 208 /* v.ast.InfixExpr */};
}

static v__ast__PrefixExpr v__parser__Parser_prefix_expr(v__parser__Parser* p) {
	v__token__Position pos = v__token__Token_position(&p->tok);
	v__token__Kind op = p->tok.kind;
	if (op == v__token__Kind_amp) {
		p->is_amp = true;
	}
	v__parser__Parser_next(p);
	v__ast__Expr right = v__parser__Parser_expr(p, v__token__Precedence_prefix);
	p->is_amp = false;
	return (v__ast__PrefixExpr){
		.op = op,
		.right = right,
		.pos = pos,
	};
}

static v__ast__StructDecl v__parser__Parser_struct_decl(v__parser__Parser* p) {
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	bool is_union = p->tok.kind == v__token__Kind_key_union;
	if (p->tok.kind == v__token__Kind_key_struct) {
		v__parser__Parser_next(p);
	} else {
		v__parser__Parser_check(p, v__token__Kind_key_union);
	}
	bool is_c = string_eq(p->tok.lit, tos3("C")) && p->peek_tok.kind == v__token__Kind_dot;
	bool is_js = string_eq(p->tok.lit, tos3("JS")) && p->peek_tok.kind == v__token__Kind_dot;
	if (is_c) {
		v__parser__Parser_next(p);
		v__parser__Parser_next(p);
	}
	bool is_typedef = string_eq(p->attr, tos3("typedef"));
	bool no_body = p->peek_tok.kind != v__token__Kind_lcbr;
	if (!is_c && !is_js && no_body) {
		v__parser__Parser_error(p, _STR("`%.*s\000` lacks body", 2, p->tok.lit));
	}
	v__token__Position end_pos = v__token__Token_position(&p->tok);
	string name = v__parser__Parser_check_name(p);
	array_v__ast__StructField ast_fields = __new_array(0, 0, sizeof(v__ast__StructField));
	array_v__table__Field fields = __new_array(0, 0, sizeof(v__table__Field));
	int mut_pos = -1;
	int pub_pos = -1;
	int pub_mut_pos = -1;
	int global_pos = -1;
	bool is_field_mut = false;
	bool is_field_pub = false;
	bool is_field_global = false;
	if (!no_body) {
		v__parser__Parser_check(p, v__token__Kind_lcbr);
		while (p->tok.kind != v__token__Kind_rcbr) {
			v__ast__Comment comment = (v__ast__Comment){
				.text = (string){.str=""},
				.is_multi = 0,
				.line_nr = 0,
				.pos = {0},
			};
			if (p->tok.kind == v__token__Kind_comment) {
				comment = v__parser__Parser_comment(p);
			}
			if (p->tok.kind == v__token__Kind_key_pub) {
				v__parser__Parser_next(p);
				if (p->tok.kind == v__token__Kind_key_mut) {
					if (pub_mut_pos != -1) {
						v__parser__Parser_error(p, tos3("redefinition of `pub mut` section"));
					}
					v__parser__Parser_next(p);
					pub_mut_pos = fields.len;
					is_field_pub = true;
					is_field_mut = true;
					is_field_global = false;
				} else {
					if (pub_pos != -1) {
						v__parser__Parser_error(p, tos3("redefinition of `pub` section"));
					}
					pub_pos = fields.len;
					is_field_pub = true;
					is_field_mut = false;
					is_field_global = false;
				}
				v__parser__Parser_check(p, v__token__Kind_colon);
			} else if (p->tok.kind == v__token__Kind_key_mut) {
				if (mut_pos != -1) {
					v__parser__Parser_error(p, tos3("redefinition of `mut` section"));
				}
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind_colon);
				mut_pos = fields.len;
				is_field_pub = false;
				is_field_mut = true;
				is_field_global = false;
			} else if (p->tok.kind == v__token__Kind_key_global) {
				if (global_pos != -1) {
					v__parser__Parser_error(p, tos3("redefinition of `global` section"));
				}
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind_colon);
				global_pos = fields.len;
				is_field_pub = true;
				is_field_mut = true;
				is_field_global = true;
			}
			string field_name = v__parser__Parser_check_name(p);
			v__token__Position field_pos = v__token__Token_position(&p->tok);
			v__table__Type typ = v__parser__Parser_parse_type(p);
			v__ast__Expr default_expr = (v__ast__Expr){
			0};
			bool has_default_expr = false;
			if (p->tok.kind == v__token__Kind_assign) {
				v__parser__Parser_next(p);
				default_expr = v__parser__Parser_expr(p, 0);
				if (default_expr.typ == 180 /* v.ast.EnumVal */) {
					v__ast__EnumVal* it = (v__ast__EnumVal*)default_expr.obj; // ST it
					it->typ = typ;
				}else {
				};
				has_default_expr = true;
			}
			v__ast__Attr attr = (v__ast__Attr){
				.name = (string){.str=""},
			};
			if (p->tok.kind == v__token__Kind_lsbr) {
				attr = v__parser__Parser_attribute(p);
			}
			if (p->tok.kind == v__token__Kind_comment) {
				comment = v__parser__Parser_comment(p);
			}
			array_push(&ast_fields, &(v__ast__StructField[]){ (v__ast__StructField){
				.name = field_name,
				.pos = field_pos,
				.typ = typ,
				.comment = comment,
				.default_expr = default_expr,
				.has_default_expr = has_default_expr,
				.attr = attr.name,
			} });
			array_push(&fields, &(v__table__Field[]){ (v__table__Field){
				.name = field_name,
				.typ = typ,
				.default_expr = v__ast__ex2fe(default_expr),
				.has_default_expr = has_default_expr,
				.is_pub = is_field_pub,
				.is_mut = is_field_mut,
				.is_global = is_field_global,
				.attr = attr.name,
				.default_val = (string){.str=""},
			} });
		}
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	if (is_c) {
		name = _STR("C.%.*s", 1, name);
	} else if (is_js) {
		name = _STR("JS.%.*s", 1, name);
	} else {
		name = v__parser__Parser_prepend_mod(p, name);
	}
	v__table__TypeSymbol t = (v__table__TypeSymbol){
		.kind = v__table__Kind_struct_,
		.name = name,
		.info = /* sum type cast */ (v__table__TypeInfo) {.obj = memdup(&(v__table__Struct[]) {(v__table__Struct){
		.fields = fields,
		.is_typedef = is_typedef,
		.is_union = is_union,
	}}, sizeof(v__table__Struct)), .typ = 87 /* v.table.Struct */},
		.mod = p->mod,
		.is_public = is_pub,
		.parent_idx = 0,
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
	};
	int ret = 0;
	if (p->builtin_mod && _IN(string, t.name, _const_v__table__builtin_type_names)) {
		ret = v__table__Table_register_builtin_type_symbol(p->table, t);
	} else {
		ret = v__table__Table_register_type_symbol(p->table, t);
	}
	if (ret == -1) {
		v__parser__Parser_error(p, _STR("cannot register type `%.*s\000`, another type with this name exists", 2, name));
	}
	p->expr_mod = tos3("");
	return (v__ast__StructDecl){
		.name = name,
		.is_pub = is_pub,
		.fields = ast_fields,
		.pos = v__token__Position_extend(start_pos, end_pos),
		.mut_pos = mut_pos,
		.pub_pos = pub_pos,
		.pub_mut_pos = pub_mut_pos,
		.is_c = is_c,
		.is_js = is_js,
		.is_union = is_union,
	};
}

static v__ast__StructInit v__parser__Parser_struct_init(v__parser__Parser* p, bool short_syntax) {
	v__token__Position first_pos = v__token__Token_position(&p->tok);
	v__table__Type typ = (short_syntax ?  ( _const_v__table__void_type )  :  ( v__parser__Parser_parse_type(p) ) );
	p->expr_mod = tos3("");
	if (!short_syntax) {
		v__parser__Parser_check(p, v__token__Kind_lcbr);
	}
	array_v__ast__StructInitField fields = __new_array(0, 0, sizeof(v__ast__StructInitField));
	int i = 0;
	bool no_keys = p->peek_tok.kind != v__token__Kind_colon && p->tok.kind != v__token__Kind_rcbr;
	while (p->tok.kind != v__token__Kind_rcbr && p->tok.kind != v__token__Kind_rpar) {
		v__parser__Parser_check_comment(p);
		string field_name = tos3("");
		if (no_keys) {
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			array_push(&fields, &(v__ast__StructInitField[]){ (v__ast__StructInitField){
				.expr = expr,
				.pos = v__ast__Expr_position(expr),
				.name = (string){.str=""},
				.typ = {0},
				.expected_type = {0},
			} });
		} else {
			v__token__Position first_field_pos = v__token__Token_position(&p->tok);
			field_name = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind_colon);
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			v__token__Position last_field_pos = v__ast__Expr_position(expr);
			v__token__Position field_pos = (v__token__Position){
				.line_nr = first_field_pos.line_nr,
				.pos = first_field_pos.pos,
				.len = last_field_pos.pos - first_field_pos.pos + last_field_pos.len,
			};
			array_push(&fields, &(v__ast__StructInitField[]){ (v__ast__StructInitField){
				.name = field_name,
				.expr = expr,
				.pos = field_pos,
				.typ = {0},
				.expected_type = {0},
			} });
		}
		i++;
		if (p->tok.kind == v__token__Kind_comma) {
			v__parser__Parser_next(p);
		}
		v__parser__Parser_check_comment(p);
	}
	v__token__Position last_pos = v__token__Token_position(&p->tok);
	if (!short_syntax) {
		v__parser__Parser_check(p, v__token__Kind_rcbr);
	}
	v__ast__StructInit node = (v__ast__StructInit){
		.typ = typ,
		.fields = fields,
		.pos = (v__token__Position){
		.line_nr = first_pos.line_nr,
		.pos = first_pos.pos,
		.len = last_pos.pos - first_pos.pos + last_pos.len,
	},
		.is_short = no_keys,
	};
	return node;
}

static v__ast__InterfaceDecl v__parser__Parser_interface_decl(v__parser__Parser* p) {
	v__token__Position start_pos = v__token__Token_position(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind_key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_next(p);
	string interface_name = v__parser__Parser_prepend_mod(p, v__parser__Parser_check_name(p));
	v__parser__Parser_check(p, v__token__Kind_lcbr);
	v__table__TypeSymbol t = (v__table__TypeSymbol){
		.kind = v__table__Kind_interface_,
		.name = interface_name,
		.info = /* sum type cast */ (v__table__TypeInfo) {.obj = memdup(&(v__table__Interface[]) {(v__table__Interface){
		.types = __new_array(0, 0, sizeof(v__table__Type)),
	}}, sizeof(v__table__Interface)), .typ = 84 /* v.table.Interface */},
		.parent_idx = 0,
		.methods = __new_array(0, 1, sizeof(v__table__Fn)),
		.mod = (string){.str=""},
		.is_public = 0,
	};
	v__table__Type typ = v__table__new_type(v__table__Table_register_type_symbol(p->table, t));
	v__table__TypeSymbol* ts = v__table__Table_get_type_symbol(p->table, typ);
	array_v__ast__FnDecl methods = __new_array(0, 0, sizeof(v__ast__FnDecl));
	while (p->tok.kind != v__token__Kind_rcbr && p->tok.kind != v__token__Kind_eof) {
		int line_nr = p->tok.line_nr;
		string name = v__parser__Parser_check_name(p);
		if (v__util__contains_capital(name)) {
			v__parser__Parser_error(p, tos3("interface methods cannot contain uppercase letters, use snake_case instead"));
		}
		multi_return_array_v__table__Arg_bool mr_6866 = v__parser__Parser_fn_args(p);
		array_v__table__Arg args2 = mr_6866.arg0;
		array_v__table__Arg args = new_array_from_c_array(1, 1, sizeof(v__table__Arg), (v__table__Arg[1]){
		(v__table__Arg){
			.name = tos3("x"),
			.typ = typ,
			.is_hidden = true,
			.is_mut = 0,
		}, 
});
		_PUSH_MANY(&args, (args2), tmp3, array_v__table__Arg);
		v__ast__FnDecl method = (v__ast__FnDecl){
			.name = name,
			.args = args,
			.file = p->file_name,
			.return_type = _const_v__table__void_type,
			.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),
			.is_deprecated = 0,
			.is_pub = 0,
			.is_variadic = 0,
			.is_anon = 0,
			.receiver = {0},
			.receiver_pos = {0},
			.is_method = 0,
			.rec_mut = 0,
			.is_c = 0,
			.is_js = 0,
			.no_body = 0,
			.is_builtin = 0,
			.ctdefine = (string){.str=""},
			.pos = {0},
			.body_pos = {0},
		};
		if (v__token__Kind_is_start_of_type(p->tok.kind) && p->tok.line_nr == line_nr) {
			method.return_type = v__parser__Parser_parse_type(p);
		}
		array_push(&methods, &(v__ast__FnDecl[]){ method });
		v__table__TypeSymbol_register_method(ts, (v__table__Fn){
			.name = name,
			.args = args,
			.return_type = method.return_type,
			.is_variadic = 0,
			.is_c = 0,
			.is_js = 0,
			.is_generic = 0,
			.is_pub = 0,
			.mod = (string){.str=""},
			.ctdefine = (string){.str=""},
		});
	}
	v__parser__Parser_check(p, v__token__Kind_rcbr);
	return (v__ast__InterfaceDecl){
		.name = interface_name,
		.methods = methods,
		.pos = start_pos,
		.field_names = __new_array(0, 1, sizeof(string)),
	};
}

// TypeDecl
string v__doc__doc(string mod, v__table__Table* table, v__pref__Preferences* prefs) {
	v__doc__Doc d = (v__doc__Doc){
		.out = strings__new_builder(1000),
		.table = table,
		.mod = mod,
		.stmts = __new_array(0, 1, sizeof(v__ast__Stmt)),
	};
	string vlib_path = string_add(os__dir(v__pref__vexe_path()), tos3("/vlib"));
	string mod_path = string_replace(mod, tos3("."), _const_os__path_separator);
	string path = os__join_path(vlib_path, (varg_string){.len=1,.args={mod_path}});
	if (!os__exists(path)) {
		println(_STR("module \"%.*s\000\" not found", 2, mod));
		println(path);
		return tos3("");
	}
	Option_array_string files = os__ls(path);
	if (!files.ok) {
		string err = files.v_error;
		int errcode = files.ecode;
		 // typeof it_expr_type: v.ast.CallExpr
		// last_type: v.ast.ExprStmt
		// last_expr_result_type: void
		v_panic(err);
	};
	array_string filtered_files = v__pref__Preferences_should_compile_filtered_files(prefs, path, /*opt*/(*(array_string*)files.data));
	// FOR IN array
	array tmp2 = filtered_files;
	for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
		string file = ((string*)tmp2.data)[tmp3];
		v__ast__Scope* fscope = (v__ast__Scope*)memdup(&(v__ast__Scope){	.parent = 0,
			.children = __new_array(0, 1, sizeof(v__ast__Scope)),
			.start_pos = 0,
			.end_pos = 0,
			.objects = new_map_1(sizeof(v__ast__ScopeObject)),
		}, sizeof(v__ast__Scope));
		v__ast__File file_ast = v__parser__parse_file(file, table, v__scanner__CommentsMode_skip_comments, prefs, fscope);
		_PUSH_MANY(&d.stmts, (file_ast.stmts), tmp4, array_v__ast__Stmt);
	}
	if (d.stmts.len == 0) {
		println(tos3("nothing here"));
		v_exit(1);
	}
	v__doc__Doc_print_structs(&d);
	v__doc__Doc_print_enums(&d);
	v__doc__Doc_print_fns(&d);
	strings__Builder_writeln(&d.out, tos3(""));
	v__doc__Doc_print_methods(&d);
	return string_trim_space(strings__Builder_str(&d.out));
}

static string v__doc__Doc_get_fn_node(v__doc__Doc* d, v__ast__FnDecl f) {
	return string_replace_each(v__ast__FnDecl_str(&f, d->table), new_array_from_c_array(4, 4, sizeof(string), (string[4]){
		string_add(d->mod, tos3(".")), tos3(""), tos3("pub "), tos3(""), 
}));
}

static void v__doc__Doc_print_fns(v__doc__Doc* d) {
	array_string fn_signatures = v__doc__Doc_get_fn_signatures(/*rec*/*d, v__doc__is_pub_function);
	v__doc__Doc_write_fn_signatures(d, fn_signatures);
}

static void v__doc__Doc_print_methods(v__doc__Doc* d) {
	array_string fn_signatures = v__doc__Doc_get_fn_signatures(/*rec*/*d, v__doc__is_pub_method);
	v__doc__Doc_write_fn_signatures(d, fn_signatures);
}

// Attr: [inline]
inline static void v__doc__Doc_write_fn_signatures(v__doc__Doc* d, array_string fn_signatures) {
	// FOR IN array
	array tmp1 = fn_signatures;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		string s = ((string*)tmp1.data)[tmp2];
		strings__Builder_writeln(&d->out, s);
	}
}

static array_string v__doc__Doc_get_fn_signatures(v__doc__Doc d, v__doc__FilterFn filter_fn) {
	array_string fn_signatures = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp1 = d.stmts;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)tmp1.data)[tmp2];
		if (stmt.typ == 111 /* v.ast.FnDecl */) {
			v__ast__FnDecl* it = (v__ast__FnDecl*)stmt.obj; // ST it
			if (filter_fn(*/*d*/it)) {
				array_push(&fn_signatures, &(string[]){ v__doc__Doc_get_fn_node(&d, */*d*/it) });
			}
		}else {
		};
	}
	array_string_sort(&fn_signatures);
	return fn_signatures;
}

static bool v__doc__is_pub_method(v__ast__FnDecl node) {
	return node.is_pub && node.is_method && !node.is_deprecated;
}

static bool v__doc__is_pub_function(v__ast__FnDecl node) {
	return node.is_pub && !node.is_method && !node.is_deprecated;
}

static void v__doc__Doc_print_enums(v__doc__Doc* d) {
	// FOR IN array
	array tmp1 = d->table->types;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__TypeSymbol typ = ((v__table__TypeSymbol*)tmp1.data)[tmp2];
		if (typ.kind != v__table__Kind_enum_) {
			continue;
		}
		strings__Builder_writeln(&d->out, _STR("enum %.*s\000 {", 2, typ.name));
		v__table__Enum* info = /* as */ (v__table__Enum*)__as_cast(typ.info.obj, typ.info.typ, /*expected:*/82);
		// FOR IN array
		array tmp4 = info->vals;
		for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
			string val = ((string*)tmp4.data)[tmp5];
			strings__Builder_writeln(&d->out, _STR("\t%.*s", 1, val));
		}
		strings__Builder_writeln(&d->out, tos3("}"));
	}
}

static void v__doc__Doc_print_structs(v__doc__Doc* d) {
	// FOR IN array
	array tmp1 = d->table->types;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__table__TypeSymbol typ = ((v__table__TypeSymbol*)tmp1.data)[tmp2];
		if (typ.kind != v__table__Kind_struct_ || !string_starts_with(typ.name, string_add(d->mod, tos3(".")))) {
			continue;
		}
		string name = string_after(typ.name, tos3("."));
		strings__Builder_writeln(&d->out, _STR("struct %.*s\000 {", 2, name));
		v__table__Struct* info = /* as */ (v__table__Struct*)__as_cast(typ.info.obj, typ.info.typ, /*expected:*/87);
		// FOR IN array
		array tmp4 = info->fields;
		for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
			v__table__Field field = ((v__table__Field*)tmp4.data)[tmp5];
			v__table__TypeSymbol* sym = v__table__Table_get_type_symbol(d->table, field.typ);
			strings__Builder_writeln(&d->out, _STR("\t%.*s\000 %.*s", 2, field.name, sym->name));
		}
		strings__Builder_writeln(&d->out, tos3("}\n"));
	}
}

v__builder__Builder v__builder__new_builder(v__pref__Preferences* pref) {
	string rdir = os__real_path(pref->path);
	string compiled_dir = (os__is_dir(rdir) ?  ( rdir )  :  ( os__dir(rdir) ) );
	v__table__Table* table = v__table__new_table();
	return (v__builder__Builder){
		.pref = pref,
		.table = table,
		.checker = v__checker__new_checker(table, pref),
		.global_scope = (v__ast__Scope*)memdup(&(v__ast__Scope){	.parent = 0,
		.children = __new_array(0, 1, sizeof(v__ast__Scope)),
		.start_pos = 0,
		.end_pos = 0,
		.objects = new_map_1(sizeof(v__ast__ScopeObject)),
	}, sizeof(v__ast__Scope)),
		.compiled_dir = compiled_dir,
		.module_path = (string){.str=""},
		.module_search_paths = __new_array(0, 1, sizeof(string)),
		.parsed_files = __new_array(0, 1, sizeof(v__ast__File)),
		.out_name_c = (string){.str=""},
		.out_name_js = (string){.str=""},
	};
}

void v__builder__Builder_parse_imports(v__builder__Builder* b) {
	array_string done_imports = __new_array(0, 0, sizeof(string));
	for (int i = 0;
	i < b->parsed_files.len; i++) {
		v__ast__File ast_file = (*(v__ast__File*)array_get(b->parsed_files, i));
		// FOR IN array
		array tmp1 = ast_file.imports;
		for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
			v__ast__Import imp = ((v__ast__Import*)tmp1.data)[tmp2];
			string mod = imp.mod;
			if (_IN(string, mod, done_imports)) {
				continue;
			}
			Option_string import_path = v__builder__Builder_find_module_path(/*rec*/*b, mod, ast_file.path);
			if (!import_path.ok) {
				string err = import_path.v_error;
				int errcode = import_path.ecode;
				 // typeof it_expr_type: v.ast.CallExpr
				// last_type: v.ast.ExprStmt
				// last_expr_result_type: void
				v_panic(_STR("cannot import module \"%.*s\000\" (not found)", 2, mod));
			};
			array_string v_files = v__builder__Builder_v_files_from_dir(/*rec*/*b, /*opt*/(*(string*)import_path.data));
			if (v_files.len == 0) {
				v_panic(_STR("cannot import module \"%.*s\000\" (no .v files in \"%.*s\000\")", 3, mod, /*opt*/(*(string*)import_path.data)));
			}
			array_v__ast__File parsed_files = v__parser__parse_files(v_files, b->table, b->pref, b->global_scope);
			// FOR IN array
			array tmp5 = parsed_files;
			for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
				v__ast__File file = ((v__ast__File*)tmp5.data)[tmp6];
				if (string_ne(file.mod.name, mod)) {
					v__builder__verror(_STR("bad module definition: %.*s\000 imports module \"%.*s\000\" but %.*s\000 is defined as module `%.*s\000`", 5, ast_file.path, mod, file.path, file.mod.name));
				}
			}
			_PUSH_MANY(&b->parsed_files, (parsed_files), tmp8, array_v__ast__File);
			array_push(&done_imports, &(string[]){ mod });
		}
	}
	v__builder__Builder_resolve_deps(b);
	if (b->pref->print_v_files) {
		// FOR IN array
		array tmp11 = b->parsed_files;
		for (int tmp12 = 0; tmp12 < tmp11.len; tmp12++) {
			v__ast__File p = ((v__ast__File*)tmp11.data)[tmp12];
			println(p.path);
		}
		v_exit(0);
	}
}

void v__builder__Builder_resolve_deps(v__builder__Builder* b) {
	v__depgraph__DepGraph* graph = v__builder__Builder_import_graph(b);
	v__depgraph__DepGraph* deps_resolved = v__depgraph__DepGraph_resolve(graph);
	if (!deps_resolved->acyclic) {
		eprintln(string_add(tos3("warning: import cycle detected between the following modules: \n"), v__depgraph__DepGraph_display_cycles(deps_resolved)));
		return ;
	}
	if (b->pref->is_verbose) {
		eprintln(tos3("------ resolved dependencies graph: ------"));
		eprintln(v__depgraph__DepGraph_display(deps_resolved));
		eprintln(tos3("------------------------------------------"));
	}
	array_string mods = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp3 = deps_resolved->nodes;
	for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
		v__depgraph__DepGraphNode node = ((v__depgraph__DepGraphNode*)tmp3.data)[tmp4];
		array_push(&mods, &(string[]){ node.name });
	}
	if (b->pref->is_verbose) {
		eprintln(tos3("------ imported modules: ------"));
		eprintln(array_string_str(mods));
		eprintln(tos3("-------------------------------"));
	}
	array_v__ast__File reordered_parsed_files = __new_array(0, 0, sizeof(v__ast__File));
	// FOR IN array
	array tmp7 = mods;
	for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
		string m = ((string*)tmp7.data)[tmp8];
		// FOR IN array
		array tmp9 = b->parsed_files;
		for (int tmp10 = 0; tmp10 < tmp9.len; tmp10++) {
			v__ast__File pf = ((v__ast__File*)tmp9.data)[tmp10];
			if (string_eq(m, pf.mod.name)) {
				array_push(&reordered_parsed_files, &(v__ast__File[]){ pf });
			}
		}
	}
	b->parsed_files = reordered_parsed_files;
}

v__depgraph__DepGraph* v__builder__Builder_import_graph(v__builder__Builder* b) {
	array_string builtins = _const_v__util__builtin_module_parts;
	array_push(&builtins, &(string[]){ tos3("builtin") });
	v__depgraph__DepGraph* graph = v__depgraph__new_dep_graph();
	// FOR IN array
	array tmp2 = b->parsed_files;
	for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
		v__ast__File p = ((v__ast__File*)tmp2.data)[tmp3];
		array_string deps = __new_array(0, 0, sizeof(string));
		if (!_IN(string, p.mod.name, builtins)) {
			array_push(&deps, &(string[]){ tos3("builtin") });
		}
		// FOR IN array
		array tmp6 = p.imports;
		for (int tmp7 = 0; tmp7 < tmp6.len; tmp7++) {
			v__ast__Import m = ((v__ast__Import*)tmp6.data)[tmp7];
			array_push(&deps, &(string[]){ m.mod });
		}
		v__depgraph__DepGraph_add(graph, p.mod.name, deps);
	}
	return graph;
}

array_string v__builder__Builder_v_files_from_dir(v__builder__Builder b, string dir) {
	if (!os__exists(dir)) {
		if (string_eq(dir, tos3("compiler")) && os__is_dir(tos3("vlib"))) {
			println(tos3("looks like you are trying to build V with an old command"));
			println(tos3("use `v -o v cmd/v` instead of `v -o v compiler`"));
		}
		v__builder__verror(_STR("%.*s\000 doesn't exist", 2, dir));
	} else if (!os__is_dir(dir)) {
		v__builder__verror(_STR("%.*s\000 isn't a directory!", 2, dir));
	}
	Option_array_string files = os__ls(dir);
	if (!files.ok) {
		string err = files.v_error;
		int errcode = files.ecode;
		 // typeof it_expr_type: v.ast.CallExpr
		// last_type: v.ast.ExprStmt
		// last_expr_result_type: void
		v_panic(err);
	};
	if (b.pref->is_verbose) {
		println(_STR("v_files_from_dir (\"%.*s\000\")", 2, dir));
	}
	return v__pref__Preferences_should_compile_filtered_files(b.pref, dir, /*opt*/(*(array_string*)files.data));
}

void v__builder__Builder_log(v__builder__Builder b, string s) {
	if (b.pref->is_verbose) {
		println(s);
	}
}

void v__builder__Builder_info(v__builder__Builder b, string s) {
	if (b.pref->is_verbose) {
		println(s);
	}
}

// Attr: [inline]
inline static string v__builder__module_path(string mod) {
	return string_replace(mod, tos3("."), _const_os__path_separator);
}

Option_string v__builder__Builder_find_module_path(v__builder__Builder b, string mod, string fpath) {
	v__vmod__ModFileAndFolder vmod_file_location = v__vmod__ModFileCacher_get(_const_v__vmod__mod_file_cacher, fpath);
	string mod_path = v__builder__module_path(mod);
	array_string module_lookup_paths = __new_array(0, 0, sizeof(string));
	if (vmod_file_location.vmod_file.len != 0 && !_IN(string, vmod_file_location.vmod_folder, b.module_search_paths)) {
		array_push(&module_lookup_paths, &(string[]){ vmod_file_location.vmod_folder });
	}
	_PUSH_MANY(&module_lookup_paths, (b.module_search_paths), tmp3, array_string);
	// FOR IN array
	array tmp4 = module_lookup_paths;
	for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
		string search_path = ((string*)tmp4.data)[tmp5];
		string try_path = os__join_path(search_path, (varg_string){.len=1,.args={mod_path}});
		if (b.pref->is_verbose) {
			println(_STR("  >> trying to find %.*s\000 in %.*s\000 ..", 3, mod, try_path));
		}
		if (os__is_dir(try_path)) {
			if (b.pref->is_verbose) {
				println(_STR("  << found %.*s\000 .", 2, try_path));
			}
			return /*:)string*/opt_ok(&(string[]) { try_path }, sizeof(string));
		}
	}
	string smodule_lookup_paths = array_string_join(module_lookup_paths, tos3(", "));
	return v_error(_STR("module \"%.*s\000\" not found in:\n%.*s", 2, mod, smodule_lookup_paths));}

static void v__builder__Builder_print_warnings_and_errors(v__builder__Builder* b) {
	if (b->checker.nr_warnings > 0) {
		// FOR IN array
		array tmp2 = b->checker.warnings;
		for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
			v__errors__Warning err = ((v__errors__Warning*)tmp2.data)[tmp3];
			string kind = (b->pref->is_verbose ?  ( _STR("%.*s\000 warning #%"PRId32"\000:", 3, v__errors__Reporter_str(err.reporter), b->checker.nr_warnings) )  :  ( tos3("warning:") ) );
			string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
			eprintln(ferror);
		}
	}
	if (b->checker.nr_errors > 0) {
		// FOR IN array
		array tmp6 = b->checker.errors;
		for (int tmp7 = 0; tmp7 < tmp6.len; tmp7++) {
			v__errors__Error err = ((v__errors__Error*)tmp6.data)[tmp7];
			string kind = (b->pref->is_verbose ?  ( _STR("%.*s\000 error #%"PRId32"\000:", 3, v__errors__Reporter_str(err.reporter), b->checker.nr_errors) )  :  ( tos3("error:") ) );
			string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
			eprintln(ferror);
		}
		v_exit(1);
	}
}

static void v__builder__verror(string s) {
	v__util__verror(tos3("builder error"), s);
}

string v__builder__Builder_gen_c(v__builder__Builder* b, array_string v_files) {
	i64 t0 = time__ticks();
	b->parsed_files = v__parser__parse_files(v_files, b->table, b->pref, b->global_scope);
	v__builder__Builder_parse_imports(b);
	i64 t1 = time__ticks();
	i64 parse_time = t1 - t0;
	v__builder__Builder_info(/*rec*/*b, _STR("PARSE: %"PRId64"\000ms", 2, parse_time));
	v__checker__Checker_check_files(&b->checker, b->parsed_files);
	i64 t2 = time__ticks();
	i64 check_time = t2 - t1;
	v__builder__Builder_info(/*rec*/*b, _STR("CHECK: %"PRId64"\000ms", 2, check_time));
	v__builder__Builder_print_warnings_and_errors(b);
	string res = v__gen__cgen(b->parsed_files, b->table, b->pref);
	i64 t3 = time__ticks();
	i64 gen_time = t3 - t2;
	v__builder__Builder_info(/*rec*/*b, _STR("C GEN: %"PRId64"\000ms", 2, gen_time));
	return res;
}

void v__builder__Builder_build_c(v__builder__Builder* b, array_string v_files, string out_file) {
	b->out_name_c = out_file;
	v__builder__Builder_info(/*rec*/*b, _STR("build_c(%.*s\000)", 2, out_file));
	string output2 = v__builder__Builder_gen_c(b, v_files);
	Option_os__File f = os__create(out_file);
	if (!f.ok) {
		string err = f.v_error;
		int errcode = f.ecode;
		 // typeof it_expr_type: v.ast.CallExpr
		// last_type: v.ast.ExprStmt
		// last_expr_result_type: void
		v_panic(err);
	};
	os__File_writeln(&/*opt*/(*(os__File*)f.data), output2);
	os__File_close(&/*opt*/(*(os__File*)f.data));
}

void v__builder__Builder_compile_c(v__builder__Builder* b) {
	if (string_ne(os__user_os(), tos3("windows")) && string_eq(b->pref->ccompiler, tos3("msvc"))) {
		v__builder__verror(_STR("Cannot build with msvc on %.*s", 1, os__user_os()));
	}
	if (b->pref->is_verbose) {
		println(tos3("all .v files before:"));
	}
	array_string files = v__builder__Builder_get_builtin_files(/*rec*/*b);
	_PUSH_MANY(&files, (v__builder__Builder_get_user_files(/*rec*/*b)), tmp3, array_string);
	v__builder__Builder_set_module_lookup_paths(b);
	if (b->pref->is_verbose) {
		println(tos3("all .v files:"));
		println(array_string_str(files));
	}
	string out_name_c = v__builder__get_vtmp_filename(b->pref->out_name, tos3(".tmp.c"));
	if (b->pref->is_shared) {
		out_name_c = v__builder__get_vtmp_filename(b->pref->out_name, tos3(".tmp.so.c"));
	}
	v__builder__Builder_build_c(b, files, out_name_c);
	v__builder__Builder_cc(b);
}

static void v__builder__todo() {
}

static bool v__builder__Builder_no_cc_installed(v__builder__Builder* v) {
	
// $if  windows {
#ifdef _WIN32
		Option_os__Result tmp1 = os__exec(_STR("%.*s\000 -v", 2, v->pref->ccompiler));
		if (!tmp1.ok) {
			string err = tmp1.v_error;
			int errcode = tmp1.ecode;
			// last_type: v.ast.Return
			// last_expr_result_type: 
			if (v->pref->is_verbose) {
				println(tos3("C compiler not found, trying to build with msvc..."));
			}
			return true;
		};
	
// } windows
#endif

	return false;
}

static void v__builder__Builder_cc(v__builder__Builder* v) {
	if (string_contains(os__executable(), tos3("vfmt"))) {
		return ;
	}
	if (v->pref->is_verbose) {
		println(_STR("builder.cc() pref.out_name=\"%.*s\000\"", 2, v->pref->out_name));
	}
	v__builder__Builder_build_thirdparty_obj_files(v);
	string vexe = v__pref__vexe_path();
	string vdir = os__dir(vexe);
	bool ends_with_c = string_ends_with(v->pref->out_name, tos3(".c"));
	bool ends_with_js = string_ends_with(v->pref->out_name, tos3(".js"));
	if (ends_with_c || ends_with_js) {
		
// $if !js {
#ifndef _VJS
			if (ends_with_js) {
				string vjs_path = string_add(vexe, tos3("js"));
				if (!os__exists(vjs_path)) {
					println(tos3("V.js compiler not found, building..."));
					int ret = os__system(_STR("%.*s\000 -o %.*s\000 -os js %.*s\000/cmd/v", 4, vexe, vjs_path, vdir));
					if (ret == 0) {
						println(tos3("Done."));
					} else {
						println(tos3("Failed."));
						v_exit(1);
					}
				}
				int ret = os__system(_STR("%.*s\000 -o %.*s\000 %.*s", 3, vjs_path, v->pref->out_name, v->pref->path));
				if (ret == 0) {
					println(_STR("Done. Run it with `node %.*s\000`", 2, v->pref->out_name));
					println(tos3("JS backend is at a very early stage."));
				}
			}
		
// } js
#endif

		Option_bool tmp8 = os__mv_by_cp(v->out_name_c, v->pref->out_name);
		if (!tmp8.ok) {
			string err = tmp8.v_error;
			int errcode = tmp8.ecode;
			 // typeof it_expr_type: v.ast.CallExpr
			// last_type: v.ast.ExprStmt
			// last_expr_result_type: void
			v_panic(err);
		};
		v_exit(0);
	}
	if (v->pref->os == v__pref__OS_windows) {
		
// $if !windows {
#ifndef _WIN32
			v__builder__Builder_cc_windows_cross(v);
			return ;
		
// } windows
#endif

	}
	
// $if  windows {
#ifdef _WIN32
		if (string_eq(v->pref->ccompiler, tos3("msvc")) || v__builder__Builder_no_cc_installed(v)) {
			v__builder__Builder_cc_msvc(v);
			return ;
		}
	
// } windows
#endif

	array_string a = new_array_from_c_array(10, 10, sizeof(string), (string[10]){
		v->pref->cflags, tos3("-std=gnu11"), tos3("-Wall"), tos3("-Wextra"), tos3("-Wno-unused-variable"), tos3("-Wno-unused-parameter"), tos3("-Wno-unused-result"), tos3("-Wno-unused-function"), tos3("-Wno-missing-braces"), tos3("-Wno-unused-label"), 
});
	array_string linker_flags = __new_array(0, 0, sizeof(string));
	if (v->pref->fast) {
		
// $if  linux {
#ifdef __linux__
			
// $if !android {
#ifndef __ANDROID__
				string tcc_3rd = _STR("%.*s\000/thirdparty/tcc/bin/tcc", 2, vdir);
				string tcc_path = tos3("/var/tmp/tcc/bin/tcc");
				if (os__exists(tcc_3rd) && !os__exists(tcc_path)) {
					os__system(_STR("mv %.*s\000/thirdparty/tcc /var/tmp/", 2, vdir));
				}
				if (string_eq(v->pref->ccompiler, tos3("cc")) && os__exists(tcc_path)) {
					v->pref->ccompiler = tcc_path;
					array_push(&a, &(string[]){ tos3("-m64") });
				}
			
// } android
#endif

		
#else
			v__builder__verror(tos3("-fast is only supported on Linux right now"));
		
// } linux
#endif

	}
	if (!v->pref->is_shared && v->pref->build_mode != v__pref__BuildMode_build_module && string_eq(os__user_os(), tos3("windows")) && !string_ends_with(v->pref->out_name, tos3(".exe"))) {
		v->pref->out_name = string_add(v->pref->out_name, tos3(".exe"));
	}
	v__builder__Builder_log(/*rec*/*v, _STR("cc() isprod=%.*s\000 outname=%.*s", 2, v->pref->is_prod ? _SLIT("true") : _SLIT("false"), v->pref->out_name));
	if (v->pref->is_shared) {
		array_push(&linker_flags, &(string[]){ tos3("-shared") });
		array_push(&a, &(string[]){ tos3("-fPIC") });
		v->pref->out_name = string_add(v->pref->out_name, tos3(".so"));
	}
	if (v->pref->is_bare) {
		array_push(&a, &(string[]){ tos3("-fno-stack-protector") });
		array_push(&a, &(string[]){ tos3("-ffreestanding") });
		array_push(&linker_flags, &(string[]){ tos3("-static") });
		array_push(&linker_flags, &(string[]){ tos3("-nostdlib") });
	}
	if (v->pref->build_mode == v__pref__BuildMode_build_module) {
		string out_dir = (string_starts_with(v->pref->path, tos3("vlib")) ?  ( _STR("%.*s\000%.*s\000cache%.*s\000%.*s", 4, _const_v__pref__default_module_path, _const_os__path_separator, _const_os__path_separator, v->pref->path) )  :  ( _STR("%.*s\000%.*s\000%.*s", 3, _const_v__pref__default_module_path, _const_os__path_separator, v->pref->path) ) );
		string pdir = string_all_before_last(out_dir, _const_os__path_separator);
		if (!os__is_dir(pdir)) {
			os__mkdir_all(pdir);
		}
		v->pref->out_name = _STR("%.*s\000.o", 2, out_dir);
		println(_STR("Building %.*s\000...", 2, v->pref->out_name));
	}
	bool debug_mode = v->pref->is_debug;
	string debug_options = tos3("-g");
	string optimization_options = tos3("-O2");
	string guessed_compiler = v->pref->ccompiler;
	if (string_eq(guessed_compiler, tos3("cc")) && v->pref->is_prod) {
		bool tmp28;
		{ /* if guard */ Option_os__Result ccversion = os__exec(tos3("cc --version"));
		if ((tmp28 = ccversion.ok)) {
			if (/*opt*/(*(os__Result*)ccversion.data).exit_code == 0) {
				if (string_contains(/*opt*/(*(os__Result*)ccversion.data).output, tos3("This is free software;")) && string_contains(/*opt*/(*(os__Result*)ccversion.data).output, tos3("Free Software Foundation, Inc."))) {
					guessed_compiler = tos3("gcc");
				}
				if (string_contains(/*opt*/(*(os__Result*)ccversion.data).output, tos3("clang version "))) {
					guessed_compiler = tos3("clang");
				}
			}
		}}
	}
	bool is_cc_clang = string_contains(v->pref->ccompiler, tos3("clang")) || string_eq(guessed_compiler, tos3("clang"));
	bool is_cc_tcc = string_contains(v->pref->ccompiler, tos3("tcc")) || string_eq(guessed_compiler, tos3("tcc"));
	bool is_cc_gcc = string_contains(v->pref->ccompiler, tos3("gcc")) || string_eq(guessed_compiler, tos3("gcc"));
	if (is_cc_clang) {
		if (debug_mode) {
			debug_options = tos3("-g -O0 -no-pie");
		}
		optimization_options = tos3("-O3");
		bool have_flto = true;
		
// $if  openbsd {
#ifdef __OpenBSD__
			have_flto = false;
		
// } openbsd
#endif

		if (have_flto) {
			optimization_options = string_add(optimization_options, tos3(" -flto"));
		}
	}
	if (is_cc_gcc) {
		if (debug_mode) {
			debug_options = tos3("-g3 -no-pie");
		}
		optimization_options = tos3("-O3 -fno-strict-aliasing -flto");
	}
	if (debug_mode) {
		array_push(&a, &(string[]){ debug_options });
		
// $if  macos {
#ifdef __APPLE__
			array_push(&a, &(string[]){ tos3(" -ferror-limit=5000 ") });
		
// } macos
#endif

	}
	if (v->pref->is_prod) {
		array_push(&a, &(string[]){ optimization_options });
	}
	if (debug_mode && string_ne(os__user_os(), tos3("windows"))) {
		array_push(&linker_flags, &(string[]){ tos3(" -rdynamic ") });
	}
	if (string_ne(v->pref->ccompiler, tos3("msvc")) && v->pref->os != v__pref__OS_freebsd) {
		array_push(&a, &(string[]){ tos3("-Werror=implicit-function-declaration") });
	}
	if (v->pref->is_liveshared || v->pref->is_livemain) {
		if (v->pref->os == v__pref__OS_linux || string_eq(os__user_os(), tos3("linux"))) {
			array_push(&linker_flags, &(string[]){ tos3("-rdynamic") });
		}
		if (v->pref->os == v__pref__OS_mac || string_eq(os__user_os(), tos3("mac"))) {
			array_push(&a, &(string[]){ tos3("-flat_namespace") });
		}
	}
	string libs = tos3("");
	if (v->pref->build_mode == v__pref__BuildMode_build_module) {
		array_push(&a, &(string[]){ tos3("-c") });
	} else if (v->pref->use_cache) {
	}
	if (v->pref->sanitize) {
		array_push(&a, &(string[]){ tos3("-fsanitize=leak") });
	}
	array_push(&a, &(string[]){ _STR("-o \"%.*s\000\"", 2, v->pref->out_name) });
	if (os__is_dir(v->pref->out_name)) {
		v__builder__verror(_STR("'%.*s\000' is a directory", 2, v->pref->out_name));
	}
	if (v->pref->os == v__pref__OS_mac) {
		array_push(&a, &(string[]){ tos3("-x objective-c") });
	}
	array_push(&a, &(string[]){ _STR("\"%.*s\000\"", 2, v->out_name_c) });
	if (v->pref->os == v__pref__OS_mac) {
		array_push(&a, &(string[]){ tos3("-x none") });
	}
	if (v->pref->os == v__pref__OS_mac) {
		array_push(&a, &(string[]){ tos3("-mmacosx-version-min=10.7") });
	}
	if (v->pref->os == v__pref__OS_windows) {
		array_push(&a, &(string[]){ tos3("-municode") });
	}
	array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(v);
	array_push(&a, &(string[]){ array_v__cflag__CFlag_c_options_only_object_files(cflags) });
	array_push(&a, &(string[]){ array_v__cflag__CFlag_c_options_without_object_files(cflags) });
	array_push(&a, &(string[]){ libs });
	if (v->pref->use_cache) {
		array_string cached_modules = new_array_from_c_array(5, 5, sizeof(string), (string[5]){
		tos3("builtin"), tos3("os"), tos3("math"), tos3("strconv"), tos3("strings"), 
});
		// FOR IN array
		array tmp70 = cached_modules;
		for (int tmp71 = 0; tmp71 < tmp70.len; tmp71++) {
			string cfile = ((string*)tmp70.data)[tmp71];
			string ofile = os__join_path(_const_v__pref__default_module_path, (varg_string){.len=3,.args={tos3("cache"), tos3("vlib"), string_add(cfile, tos3(".o"))}});
			if (!os__exists(ofile)) {
				println(_STR("%.*s\000.o is missing. Building...", 2, cfile));
				println(_STR("%.*s\000 build-module vlib/%.*s", 2, vexe, cfile));
				os__system(_STR("%.*s\000 build-module vlib/%.*s", 2, vexe, cfile));
			}
			array_push(&a, &(string[]){ ofile });
		}
		if (!is_cc_tcc) {
			
// $if  linux {
#ifdef __linux__
				array_push(&linker_flags, &(string[]){ tos3("-Xlinker -z") });
				array_push(&linker_flags, &(string[]){ tos3("-Xlinker muldefs") });
			
// } linux
#endif

		}
	}
	if (!v->pref->is_bare && v->pref->build_mode != v__pref__BuildMode_build_module && (v->pref->os == v__pref__OS_linux || v->pref->os == v__pref__OS_freebsd || v->pref->os == v__pref__OS_openbsd || v->pref->os == v__pref__OS_netbsd || v->pref->os == v__pref__OS_dragonfly || v->pref->os == v__pref__OS_solaris || v->pref->os == v__pref__OS_haiku)) {
		array_push(&linker_flags, &(string[]){ tos3("-lm") });
		array_push(&linker_flags, &(string[]){ tos3("-lpthread") });
		if (v->pref->os == v__pref__OS_linux) {
			array_push(&linker_flags, &(string[]){ tos3("-ldl") });
		}
		if (v->pref->os == v__pref__OS_freebsd) {
			array_push(&linker_flags, &(string[]){ tos3("-lexecinfo") });
		}
	}
	if (!v->pref->is_bare && v->pref->os == v__pref__OS_js && string_eq(os__user_os(), tos3("linux"))) {
		array_push(&linker_flags, &(string[]){ tos3("-lm") });
	}
	string args = string_add(array_string_join(a, tos3(" ")), array_string_join(linker_flags, tos3(" ")));
	start:
	v__builder__todo();
	string cmd = _STR("%.*s\000 %.*s", 2, v->pref->ccompiler, args);
	if (v->pref->is_verbose || v->pref->show_cc) {
		println(tos3("\n=========="));
		println(cmd);
	}
	i64 ticks = time__ticks();
	Option_os__Result res = os__exec(cmd);
	if (!res.ok) {
		string err = res.v_error;
		int errcode = res.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		println(tos3("C compilation failed."));
		v__builder__verror(err);
		return ;
	};
	if (/*opt*/(*(os__Result*)res.data).exit_code != 0) {
		if (/*opt*/(*(os__Result*)res.data).exit_code == 127) {
			
// $if  linux {
#ifdef __linux__
				if (string_contains(v->pref->ccompiler, tos3("tcc"))) {
					v->pref->ccompiler = tos3("cc");
					goto start;
				}
			
// } linux
#endif

			v__builder__verror(string_add(string_add(string_add(string_add(string_add(string_add(tos3("C compiler error, while attempting to run: \n"), tos3("-----------------------------------------------------------\n")), _STR("%.*s\000\n", 2, cmd)), tos3("-----------------------------------------------------------\n")), tos3("Probably your C compiler is missing. \n")), tos3("Please reinstall it, or make it available in your PATH.\n\n")), v__builder__missing_compiler_info()));
		}
		if (v->pref->is_debug) {
			string eword = tos3("error:");
			string khighlight = (term__can_show_color_on_stdout() ?  ( term__red(eword) )  :  ( eword ) );
			println(string_replace(/*opt*/(*(os__Result*)res.data).output, eword, khighlight));
			v__builder__verror(_STR("\n==================\nC error. This should never happen.\n\nV compiler version: %.*s\000\nHost OS: %.*s\000\nTarget OS: %.*s\000\n\nIf you were not working with C interop and are not sure about what's happening,\nplease put the whole output in a pastebin and contact us through the following ways with a link to the pastebin:\n- Raise an issue on GitHub: https://github.com/vlang/v/issues/new/choose\n- Ask a question in #help on Discord: https://discord.gg/vlang", 4, v__util__full_v_version(), v__pref__OS_str(v__pref__get_host_os()), v__pref__OS_str(v->pref->os)));
		} else {
			if (/*opt*/(*(os__Result*)res.data).output.len < 30) {
				println(/*opt*/(*(os__Result*)res.data).output);
			} else {
				array_string elines = v__builder__error_context_lines(/*opt*/(*(os__Result*)res.data).output, tos3("error:"), 1, 12);
				println(tos3("=================="));
				// FOR IN array
				array tmp93 = elines;
				for (int tmp94 = 0; tmp94 < tmp93.len; tmp94++) {
					string eline = ((string*)tmp93.data)[tmp94];
					println(eline);
				}
				println(tos3("..."));
				println(tos3("=================="));
				println(tos3("(Use `v -cg` to print the entire error message)\n"));
			}
			v__builder__verror(tos3("C error.\n\nPlease make sure that:\n- You have all V dependencies installed.\n- You did not declare a C function that was not included. (Try commenting your code that involves C interop)\n- You are running the latest version of V. (Try running `v up` and rerunning your command)\n\nIf you're confident that all of the above is true, please try running V with the `-cg` option which enables more debugging capabilities.\n"));
		}
	}
	i64 diff = time__ticks() - ticks;
	if (v->pref->is_verbose) {
		println(_STR("%.*s\000 took %"PRId64"\000 ms", 3, v->pref->ccompiler, diff));
		println(tos3("=========\n"));
	}
	if (!v->pref->keep_c && string_ne(v->out_name_c, tos3("v.c"))) {
		os__rm(v->out_name_c);
	}
	if (v->pref->compress) {
		
// $if  windows {
#ifdef _WIN32
			println(tos3("-compress does not work on Windows for now"));
			return ;
		
// } windows
#endif

		int ret = os__system(_STR("strip %.*s", 1, v->pref->out_name));
		if (ret != 0) {
			println(tos3("strip failed"));
			return ;
		}
		int ret2 = os__system(_STR("upx --lzma -qqq %.*s", 1, v->pref->out_name));
		if (ret2 != 0) {
			ret2 = os__system(_STR("upx -qqq %.*s", 1, v->pref->out_name));
		}
		if (ret2 != 0) {
			println(tos3("upx failed"));
			
// $if  macos {
#ifdef __APPLE__
				println(tos3("install upx with `brew install upx`"));
			
// } macos
#endif

			
// $if  linux {
#ifdef __linux__
				println(string_add(tos3("install upx\n"), tos3("for example, on Debian/Ubuntu run `sudo apt install upx`")));
			
// } linux
#endif

			
// $if  windows {
#ifdef _WIN32
			
// } windows
#endif

		}
	}
}

static void v__builder__Builder_cc_windows_cross(v__builder__Builder* c) {
}

static void v__builder__Builder_build_thirdparty_obj_files(v__builder__Builder* c) {
	// FOR IN array
	array tmp1 = v__builder__Builder_get_os_cflags(c);
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)tmp1.data)[tmp2];
		if (string_ends_with(flag.value, tos3(".o"))) {
			array_v__cflag__CFlag rest_of_module_flags = v__builder__Builder_get_rest_of_module_cflags(c, &/*qq*/flag);
			if (string_eq(c->pref->ccompiler, tos3("msvc")) || v__builder__Builder_no_cc_installed(c)) {
				v__builder__build_thirdparty_obj_file_with_msvc(flag.value, rest_of_module_flags);
			} else {
				v__builder__Builder_build_thirdparty_obj_file(c, flag.value, rest_of_module_flags);
			}
		}
	}
}

static void v__builder__Builder_build_thirdparty_obj_file(v__builder__Builder* v, string path, array_v__cflag__CFlag moduleflags) {
	string obj_path = os__real_path(path);
	if (os__exists(obj_path)) {
		return ;
	}
	println(_STR("%.*s\000 not found, building it...", 2, obj_path));
	string parent = os__dir(obj_path);
	Option_array_string files = os__ls(parent);
	if (!files.ok) {
		string err = files.v_error;
		int errcode = files.ecode;
		 // typeof it_expr_type: v.ast.CallExpr
		// last_type: v.ast.ExprStmt
		// last_expr_result_type: void
		v_panic(err);
	};
	string cfiles = tos3("");
	// FOR IN array
	array tmp2 = /*opt*/(*(array_string*)files.data);
	for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
		string file = ((string*)tmp2.data)[tmp3];
		if (string_ends_with(file, tos3(".c"))) {
			cfiles = string_add(cfiles, string_add(string_add(tos3("\""), os__real_path(string_add(string_add(parent, _const_os__path_separator), file))), tos3("\" ")));
		}
	}
	string btarget = array_v__cflag__CFlag_c_options_before_target(moduleflags);
	string atarget = array_v__cflag__CFlag_c_options_after_target(moduleflags);
	string cmd = _STR("%.*s\000 %.*s\000 %.*s\000 -c -o \"%.*s\000\" %.*s\000 %.*s\000 ", 7, v->pref->ccompiler, v->pref->third_party_option, btarget, obj_path, cfiles, atarget);
	Option_os__Result res = os__exec(cmd);
	if (!res.ok) {
		string err = res.v_error;
		int errcode = res.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		println(_STR("failed thirdparty object build cmd: %.*s", 1, cmd));
		v__builder__verror(err);
		return ;
	};
	if (/*opt*/(*(os__Result*)res.data).exit_code != 0) {
		println(_STR("failed thirdparty object build cmd: %.*s", 1, cmd));
		v__builder__verror(/*opt*/(*(os__Result*)res.data).output);
		return ;
	}
	println(/*opt*/(*(os__Result*)res.data).output);
}

static string v__builder__missing_compiler_info() {
	
// $if  windows {
#ifdef _WIN32
		return tos3("https://github.com/vlang/v/wiki/Installing-a-C-compiler-on-Windows");
	
// } windows
#endif

	
// $if  linux {
#ifdef __linux__
		return tos3("On Debian/Ubuntu, run `sudo apt install build-essential`");
	
// } linux
#endif

	
// $if  macos {
#ifdef __APPLE__
		return tos3("Install command line XCode tools with `xcode-select --install`");
	
// } macos
#endif

	return tos3("");
}

static array_string v__builder__error_context_lines(string text, string keyword, int before, int after) {
	string khighlight = (term__can_show_color_on_stdout() ?  ( term__red(keyword) )  :  ( keyword ) );
	int eline_idx = 0;
	array_string lines = string_split_into_lines(text);
	// FOR IN array
	array tmp2 = lines;
	for (int idx = 0; idx < tmp2.len; idx++) {
		string eline = ((string*)tmp2.data)[idx];
		if (string_contains(eline, keyword)) {
			array_set(&lines, idx, &(string[]) { string_replace((*(string*)array_get(lines, idx)), keyword, khighlight) });
			if (eline_idx == 0) {
				eline_idx = idx;
			}
		}
	}
	int idx_s = (eline_idx - before >= 0 ?  ( eline_idx - before )  :  ( 0 ) );
	int idx_e = (idx_s + after < lines.len ?  ( idx_s + after )  :  ( lines.len ) );
	return array_slice(lines, idx_s, idx_e);
}

static array_v__cflag__CFlag v__builder__Builder_get_os_cflags(v__builder__Builder* v) {
	array_v__cflag__CFlag flags = __new_array(0, 0, sizeof(v__cflag__CFlag));
	array_string ctimedefines = __new_array(0, 0, sizeof(string));
	if (v->pref->compile_defines.len > 0) {
		_PUSH_MANY(&ctimedefines, (v->pref->compile_defines), tmp2, array_string);
	}
	// FOR IN array
	array tmp3 = v->table->cflags;
	for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)tmp3.data)[tmp4];
		if (string_eq(flag.os, tos3("")) || (string_eq(flag.os, tos3("linux")) && v->pref->os == v__pref__OS_linux) || (string_eq(flag.os, tos3("darwin")) && v->pref->os == v__pref__OS_mac) || (string_eq(flag.os, tos3("freebsd")) && v->pref->os == v__pref__OS_freebsd) || (string_eq(flag.os, tos3("windows")) && v->pref->os == v__pref__OS_windows) || (string_eq(flag.os, tos3("mingw")) && v->pref->os == v__pref__OS_windows && string_ne(v->pref->ccompiler, tos3("msvc"))) || (string_eq(flag.os, tos3("solaris")) && v->pref->os == v__pref__OS_solaris)) {
			array_push(&flags, &(v__cflag__CFlag[]){ flag });
		}
		if (_IN(string, flag.os, ctimedefines)) {
			array_push(&flags, &(v__cflag__CFlag[]){ flag });
		}
	}
	return flags;
}

static array_v__cflag__CFlag v__builder__Builder_get_rest_of_module_cflags(v__builder__Builder* v, v__cflag__CFlag* c) {
	array_v__cflag__CFlag flags = __new_array(0, 0, sizeof(v__cflag__CFlag));
	array_v__cflag__CFlag cflags = v__builder__Builder_get_os_cflags(v);
	// FOR IN array
	array tmp1 = cflags;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)tmp1.data)[tmp2];
		if (string_eq(c->mod, flag.mod)) {
			if (string_eq(c->name, flag.name) && string_eq(c->value, flag.value) && string_eq(c->os, flag.os)) {
				continue;
			}
			array_push(&flags, &(v__cflag__CFlag[]){ flag });
		}
	}
	return flags;
}

static string v__builder__get_vtmp_folder() {
	string vtmp = os__join_path(os__temp_dir(), (varg_string){.len=1,.args={tos3("v")}});
	if (!os__is_dir(vtmp)) {
		Option_bool tmp2 = os__mkdir(vtmp);
		if (!tmp2.ok) {
			string err = tmp2.v_error;
			int errcode = tmp2.ecode;
			 // typeof it_expr_type: v.ast.CallExpr
			// last_type: v.ast.ExprStmt
			// last_expr_result_type: void
			v_panic(err);
		};
	}
	return vtmp;
}

static string v__builder__get_vtmp_filename(string base_file_name, string postfix) {
	string vtmp = v__builder__get_vtmp_folder();
	return os__real_path(os__join_path(vtmp, (varg_string){.len=1,.args={string_add(os__file_name(os__real_path(base_file_name)), postfix)}}));
}

void v__builder__compile(string command, v__pref__Preferences* pref) {
	v__builder__Builder b = v__builder__new_builder(pref);
	if (pref->is_verbose) {
		println(tos3("builder.compile() pref:"));
	}
	time__StopWatch sw = time__new_stopwatch();
	if (pref->backend == v__pref__Backend_c) {
		v__builder__Builder_compile_c(&b);
	}else if (pref->backend == v__pref__Backend_js) {
		v__builder__Builder_compile_js(&b);
	}else if (pref->backend == v__pref__Backend_x64) {
		v__builder__Builder_compile_x64(&b);
	};
	if (pref->is_stats) {
		println(_STR("compilation took: %"PRId64"\000 ms", 2, time__Duration_milliseconds(time__StopWatch_elapsed(sw))));
	}
	if (pref->is_test || pref->is_run) {
		v__builder__Builder_run_compiled_executable_and_exit(&b);
	}
	v__builder__Builder_myfree(&b);
}

static void v__builder__Builder_myfree(v__builder__Builder* b) {
	array_free(&b->parsed_files);
}

static void v__builder__Builder_run_compiled_executable_and_exit(v__builder__Builder* b) {
	if (b->pref->is_verbose) {
		println(_STR("============ running %.*s\000 ============", 2, b->pref->out_name));
	}
	string cmd = _STR("\"%.*s\000\"", 2, b->pref->out_name);
	// FOR IN array
	array tmp2 = b->pref->run_args;
	for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
		string arg = ((string*)tmp2.data)[tmp3];
		if (string_index_byte(arg, ' ') > 0) {
			cmd = string_add(cmd, string_add(string_add(tos3(" \""), arg), tos3("\"")));
		} else {
			cmd = string_add(cmd, string_add(tos3(" "), arg));
		}
	}
	if (b->pref->is_verbose) {
		println(_STR("command to run executable: %.*s", 1, cmd));
	}
	if (b->pref->is_test) {
		int ret = os__system(cmd);
		if (ret != 0) {
			v_exit(1);
		}
	}
	if (b->pref->is_run) {
		int ret = os__system(cmd);
		v_exit(ret);
	}
	v_exit(0);
}

static void v__builder__Builder_set_module_lookup_paths(v__builder__Builder* v) {
	v->module_search_paths = __new_array(0, 0, sizeof(string));
	if (v->pref->is_test) {
		array_push(&v->module_search_paths, &(string[]){ os__base_dir(v->compiled_dir) });
	}
	array_push(&v->module_search_paths, &(string[]){ v->compiled_dir });
	string x = os__join_path(v->compiled_dir, (varg_string){.len=1,.args={tos3("modules")}});
	if (v->pref->is_verbose) {
		println(_STR("x: \"%.*s\000\"", 2, x));
	}
	array_push(&v->module_search_paths, &(string[]){ os__join_path(v->compiled_dir, (varg_string){.len=1,.args={tos3("modules")}}) });
	_PUSH_MANY(&v->module_search_paths, (v->pref->lookup_path), tmp6, array_string);
	if (v->pref->is_verbose) {
		v__builder__Builder_log(/*rec*/*v, tos3("v.module_search_paths:"));
		println(array_string_str(v->module_search_paths));
	}
}

array_string v__builder__Builder_get_builtin_files(v__builder__Builder v) {
	if (v.pref->build_mode == v__pref__BuildMode_build_module && string_eq(v.pref->path, tos3("vlib/builtin"))) {
		if (v.pref->is_verbose) {
			println(tos3("skipping builtin modules for builtin.o"));
		}
		return __new_array(0, 0, sizeof(string));
	}
	// FOR IN array
	array tmp3 = v.pref->lookup_path;
	for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
		string location = ((string*)tmp3.data)[tmp4];
		if (!os__exists(os__join_path(location, (varg_string){.len=1,.args={tos3("builtin")}}))) {
			continue;
		}
		if (v.pref->is_bare) {
			return v__builder__Builder_v_files_from_dir(v, os__join_path(location, (varg_string){.len=2,.args={tos3("builtin"), tos3("bare")}}));
		}
		
// $if  js {
#ifdef _VJS
			return v__builder__Builder_v_files_from_dir(v, os__join_path(location, (varg_string){.len=2,.args={tos3("builtin"), tos3("js")}}));
		
// } js
#endif

		return v__builder__Builder_v_files_from_dir(v, os__join_path(location, (varg_string){.len=1,.args={tos3("builtin")}}));
	}
	v__builder__verror(tos3("`builtin/` not included on module lookup path.\nDid you forget to add vlib to the path? (Use @vlib for default vlib)"));
	v_panic(tos3("Unreachable code reached."));
}

array_string v__builder__Builder_get_user_files(v__builder__Builder v) {
	string dir = v.pref->path;
	v__builder__Builder_log(v, _STR("get_v_files(%.*s\000)", 2, dir));
	array_string user_files = __new_array(0, 0, sizeof(string));
	string vroot = os__dir(v__pref__vexe_path());
	string preludes_path = os__join_path(vroot, (varg_string){.len=3,.args={tos3("cmd"), tos3("tools"), tos3("preludes")}});
	if (v.pref->is_livemain || v.pref->is_liveshared) {
		array_push(&user_files, &(string[]){ os__join_path(preludes_path, (varg_string){.len=1,.args={tos3("live.v")}}) });
	}
	if (v.pref->is_livemain) {
		array_push(&user_files, &(string[]){ os__join_path(preludes_path, (varg_string){.len=1,.args={tos3("live_main.v")}}) });
	}
	if (v.pref->is_liveshared) {
		array_push(&user_files, &(string[]){ os__join_path(preludes_path, (varg_string){.len=1,.args={tos3("live_shared.v")}}) });
	}
	if (v.pref->is_test) {
		array_push(&user_files, &(string[]){ os__join_path(preludes_path, (varg_string){.len=1,.args={tos3("tests_assertions.v")}}) });
	}
	if (v.pref->is_test && v.pref->is_stats) {
		array_push(&user_files, &(string[]){ os__join_path(preludes_path, (varg_string){.len=1,.args={tos3("tests_with_stats.v")}}) });
	}
	if (v.pref->is_prof) {
		array_push(&user_files, &(string[]){ os__join_path(preludes_path, (varg_string){.len=1,.args={tos3("profiled_program.v")}}) });
	}
	bool is_test = string_ends_with(dir, tos3("_test.v"));
	if (v.pref->is_run && is_test) {
		println(tos3("use `v x_test.v` instead of `v run x_test.v`"));
		v_exit(1);
	}
	bool is_internal_module_test = false;
	if (is_test) {
		Option_string tcontent = os__read_file(dir);
		if (!tcontent.ok) {
			string err = tcontent.v_error;
			int errcode = tcontent.ecode;
			 // typeof it_expr_type: v.ast.CallExpr
			// last_type: v.ast.ExprStmt
			// last_expr_result_type: void
			v_panic(_STR("%.*s\000 does not exist", 2, dir));
		};
		array_string slines = string_split_into_lines(string_trim_space(/*opt*/(*(string*)tcontent.data)));
		// FOR IN array
		array tmp15 = slines;
		for (int tmp16 = 0; tmp16 < tmp15.len; tmp16++) {
			string sline = ((string*)tmp15.data)[tmp16];
			string line = string_trim_space(sline);
			if (line.len > 2) {
				if (string_at(line, 0) == '/' && string_at(line, 1) == '/') {
					continue;
				}
				if (string_starts_with(line, tos3("module ")) && !string_starts_with(line, tos3("module main"))) {
					is_internal_module_test = true;
					break;
				}
			}
		}
	}
	if (is_internal_module_test) {
		string single_test_v_file = os__real_path(dir);
		if (v.pref->is_verbose) {
			v__builder__Builder_log(v, _STR("> Compiling an internal module _test.v file %.*s\000 .", 2, single_test_v_file));
			v__builder__Builder_log(v, tos3("> That brings in all other ordinary .v files in the same module too ."));
		}
		array_push(&user_files, &(string[]){ single_test_v_file });
		dir = os__base_dir(single_test_v_file);
	}
	bool is_real_file = os__exists(dir) && !os__is_dir(dir);
	if (is_real_file && (string_ends_with(dir, tos3(".v")) || string_ends_with(dir, tos3(".vsh")))) {
		string single_v_file = dir;
		array_push(&user_files, &(string[]){ single_v_file });
		if (v.pref->is_verbose) {
			v__builder__Builder_log(v, _STR("> just compile one file: \"%.*s\000\"", 2, single_v_file));
		}
	} else {
		if (v.pref->is_verbose) {
			v__builder__Builder_log(v, _STR("> add all .v files from directory \"%.*s\000\" ...", 2, dir));
		}
		_PUSH_MANY(&user_files, (v__builder__Builder_v_files_from_dir(v, dir)), tmp27, array_string);
	}
	if (user_files.len == 0) {
		println(tos3("No input .v files"));
		v_exit(1);
	}
	if (v.pref->is_verbose) {
		v__builder__Builder_log(v, _STR("user_files: %.*s", 1, array_string_str(user_files)));
	}
	return user_files;
}

string v__builder__Builder_gen_js(v__builder__Builder* b, array_string v_files) {
	i64 t0 = time__ticks();
	b->parsed_files = v__parser__parse_files(v_files, b->table, b->pref, b->global_scope);
	v__builder__Builder_parse_imports(b);
	i64 t1 = time__ticks();
	i64 parse_time = t1 - t0;
	v__builder__Builder_info(/*rec*/*b, _STR("PARSE: %"PRId64"\000ms", 2, parse_time));
	v__checker__Checker_check_files(&b->checker, b->parsed_files);
	i64 t2 = time__ticks();
	i64 check_time = t2 - t1;
	v__builder__Builder_info(/*rec*/*b, _STR("CHECK: %"PRId64"\000ms", 2, check_time));
	v__builder__Builder_print_warnings_and_errors(b);
	string res = v__gen__js__gen(b->parsed_files, b->table, b->pref);
	i64 t3 = time__ticks();
	i64 gen_time = t3 - t2;
	v__builder__Builder_info(/*rec*/*b, _STR("JS GEN: %"PRId64"\000ms", 2, gen_time));
	return res;
}

void v__builder__Builder_build_js(v__builder__Builder* b, array_string v_files, string out_file) {
	b->out_name_js = out_file;
	v__builder__Builder_info(/*rec*/*b, _STR("build_js(%.*s\000)", 2, out_file));
	string output = v__builder__Builder_gen_js(b, v_files);
	Option_os__File f = os__create(out_file);
	if (!f.ok) {
		string err = f.v_error;
		int errcode = f.ecode;
		 // typeof it_expr_type: v.ast.CallExpr
		// last_type: v.ast.ExprStmt
		// last_expr_result_type: void
		v_panic(err);
	};
	os__File_writeln(&/*opt*/(*(os__File*)f.data), output);
	os__File_close(&/*opt*/(*(os__File*)f.data));
}

void v__builder__Builder_compile_js(v__builder__Builder* b) {
	array_string files = v__builder__Builder_get_user_files(/*rec*/*b);
	v__builder__Builder_set_module_lookup_paths(b);
	if (b->pref->is_verbose) {
		println(tos3("all .v files:"));
		println(array_string_str(files));
	}
	v__builder__Builder_build_js(b, files, string_add(b->pref->out_name, tos3(".js")));
}

// TypeDecl
static Option_string v__builder__find_windows_kit_internal(v__builder__RegKey key, array_string versions) {
	
// $if  windows {
#ifdef _WIN32
			// FOR IN array
			array tmp1 = versions;
			for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
				string version = ((string*)tmp1.data)[tmp2];
				int required_bytes = 0;
				voidptr result = RegQueryValueEx(key, string_to_wide(version), 0, 0, 0, &required_bytes);
				int length = required_bytes / 2;
				if (result != 0) {
					continue;
				}
				int alloc_length = (required_bytes + 2);
				u16* value = ((u16*)(v_malloc(alloc_length)));
				if (isnil(value)) {
					continue;
				} else {
				}
				voidptr result2 = RegQueryValueEx(key, string_to_wide(version), 0, 0, value, &alloc_length);
				if (result2 != 0) {
					continue;
				}
				if (value[length - 1] != ((u16)(0))) {
					value[length] = ((u16)(0));
				}
				string res = string_from_wide(value);
				return /*:)string*/opt_ok(&(string[]) { res }, sizeof(string));
			}
	
// } windows
#endif

	return v_error(tos3("windows kit not found"));}

static Option_v__builder__WindowsKit v__builder__find_windows_kit_root(string host_arch) {
	
// $if  windows {
#ifdef _WIN32
		v__builder__RegKey root_key = ((v__builder__RegKey)(0));
		string path = tos3("SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots");
		voidptr rc = RegOpenKeyEx(_const_v__builder__HKEY_LOCAL_MACHINE, string_to_wide(path), 0, ((_const_v__builder__KEY_QUERY_VALUE | _const_v__builder__KEY_WOW64_32KEY) | _const_v__builder__KEY_ENUMERATE_SUB_KEYS), &root_key);
		if (rc != 0) {
			// defer
			
#ifdef _WIN32
				RegCloseKey(root_key);
			
			#endif
			return v_error(tos3("Unable to open root key"));}
		Option_string kit_root = v__builder__find_windows_kit_internal(root_key, new_array_from_c_array(2, 2, sizeof(string), (string[2]){
		tos3("KitsRoot10"), tos3("KitsRoot81"), 
}));
		if (!kit_root.ok) {
			string err = kit_root.v_error;
			int errcode = kit_root.ecode;
			// last_type: v.ast.Return
			// last_expr_result_type: 
			// defer
			
#ifdef _WIN32
				RegCloseKey(root_key);
			
			#endif
			return v_error(tos3("Unable to find a windows kit"));};
		string kit_lib = string_add(/*opt*/(*(string*)kit_root.data), tos3("Lib"));
		Option_array_string files = os__ls(kit_lib);
		if (!files.ok) {
			string err = files.v_error;
			int errcode = files.ecode;
			 // typeof it_expr_type: v.ast.CallExpr
			// last_type: v.ast.ExprStmt
			// last_expr_result_type: void
			v_panic(err);
		};
		string highest_path = tos3("");
		int highest_int = 0;
		// FOR IN array
		array tmp2 = /*opt*/(*(array_string*)files.data);
		for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
			string f = ((string*)tmp2.data)[tmp3];
			string no_dot = string_replace(f, tos3("."), tos3(""));
			int v_int = string_int(no_dot);
			if (v_int > highest_int) {
				highest_int = v_int;
				highest_path = f;
			}
		}
		string kit_lib_highest = string_add(kit_lib, _STR("\\%.*s", 1, highest_path));
		string kit_include_highest = string_replace(kit_lib_highest, tos3("Lib"), tos3("Include"));
		// defer
		
#ifdef _WIN32
			RegCloseKey(root_key);
		
		#endif
		return /*:)v.builder.WindowsKit*/opt_ok(&(v__builder__WindowsKit[]) { (v__builder__WindowsKit){
			.um_lib_path = string_add(kit_lib_highest, _STR("\\um\\%.*s", 1, host_arch)),
			.ucrt_lib_path = string_add(kit_lib_highest, _STR("\\ucrt\\%.*s", 1, host_arch)),
			.um_include_path = string_add(kit_include_highest, tos3("\\um")),
			.ucrt_include_path = string_add(kit_include_highest, tos3("\\ucrt")),
			.shared_include_path = string_add(kit_include_highest, tos3("\\shared")),
		} }, sizeof(v__builder__WindowsKit));
	
// } windows
#endif

	// defer
	
#ifdef _WIN32
		RegCloseKey(root_key);
	
	#endif
	return v_error(tos3("Host OS does not support funding a windows kit"));// defer

#ifdef _WIN32
	RegCloseKey(root_key);

#endif
}

static Option_v__builder__VsInstallation v__builder__find_vs(string vswhere_dir, string host_arch) {
	
// $if !windows {
#ifndef _WIN32
		return v_error(tos3("Host OS does not support finding a Vs installation"));
// } windows
#endif

	Option_os__Result res = os__exec(_STR("\"%.*s\000\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -latest -prerelease -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath", 2, vswhere_dir));
	if (!res.ok) {
		string err = res.v_error;
		int errcode = res.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		return v_error(err);};
	Option_string version = os__read_file(_STR("%.*s\000\\VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt", 2, /*opt*/(*(os__Result*)res.data).output));
	if (!version.ok) {
		string err = version.v_error;
		int errcode = version.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		println(tos3("Unable to find msvc version"));
		return v_error(tos3("Unable to find vs installation"));};
	string version2 = /*opt*/(*(string*)version.data);
	string v = (string_ends_with(/*opt*/(*(string*)version.data), tos3("\n")) ?  ( string_substr(version2, 0, /*opt*/(*(string*)version.data).len - 2) )  :  ( version2 ) );
	string lib_path = _STR("%.*s\000\\VC\\Tools\\MSVC\\%.*s\000\\lib\\%.*s", 3, /*opt*/(*(os__Result*)res.data).output, v, host_arch);
	string include_path = _STR("%.*s\000\\VC\\Tools\\MSVC\\%.*s\000\\include", 3, /*opt*/(*(os__Result*)res.data).output, v);
	if (os__exists(_STR("%.*s\000\\vcruntime.lib", 2, lib_path))) {
		string p = _STR("%.*s\000\\VC\\Tools\\MSVC\\%.*s\000\\bin\\Host%.*s\000\\%.*s", 4, /*opt*/(*(os__Result*)res.data).output, v, host_arch, host_arch);
		return /*:)v.builder.VsInstallation*/opt_ok(&(v__builder__VsInstallation[]) { (v__builder__VsInstallation){
			.exe_path = p,
			.lib_path = lib_path,
			.include_path = include_path,
		} }, sizeof(v__builder__VsInstallation));
	}
	println(_STR("Unable to find vs installation (attempted to use lib path \"%.*s\000\")", 2, lib_path));
	return v_error(tos3("Unable to find vs exe folder"));}

static Option_v__builder__MsvcResult v__builder__find_msvc() {
	
// $if  windows {
#ifdef _WIN32
		string processor_architecture = os__getenv(tos3("PROCESSOR_ARCHITECTURE"));
		string vswhere_dir = (string_eq(processor_architecture, tos3("x86")) ?  ( tos3("%ProgramFiles%") )  :  ( tos3("%ProgramFiles(x86)%") ) );
		string host_arch = (string_eq(processor_architecture, tos3("x86")) ?  ( tos3("X86") )  :  ( tos3("X64") ) );
		Option_v__builder__WindowsKit wk = v__builder__find_windows_kit_root(host_arch);
		if (!wk.ok) {
			string err = wk.v_error;
			int errcode = wk.ecode;
			// last_type: v.ast.Return
			// last_expr_result_type: 
			return v_error(tos3("Unable to find windows sdk"));};
		Option_v__builder__VsInstallation vs = v__builder__find_vs(vswhere_dir, host_arch);
		if (!vs.ok) {
			string err = vs.v_error;
			int errcode = vs.ecode;
			// last_type: v.ast.Return
			// last_expr_result_type: 
			return v_error(tos3("Unable to find visual studio"));};
		return /*:)v.builder.MsvcResult*/opt_ok(&(v__builder__MsvcResult[]) { (v__builder__MsvcResult){
			.full_cl_exe_path = os__real_path(string_add(string_add(/*opt*/(*(v__builder__VsInstallation*)vs.data).exe_path, _const_os__path_separator), tos3("cl.exe"))),
			.exe_path = /*opt*/(*(v__builder__VsInstallation*)vs.data).exe_path,
			.um_lib_path = /*opt*/(*(v__builder__WindowsKit*)wk.data).um_lib_path,
			.ucrt_lib_path = /*opt*/(*(v__builder__WindowsKit*)wk.data).ucrt_lib_path,
			.vs_lib_path = /*opt*/(*(v__builder__VsInstallation*)vs.data).lib_path,
			.um_include_path = /*opt*/(*(v__builder__WindowsKit*)wk.data).um_include_path,
			.ucrt_include_path = /*opt*/(*(v__builder__WindowsKit*)wk.data).ucrt_include_path,
			.vs_include_path = /*opt*/(*(v__builder__VsInstallation*)vs.data).include_path,
			.shared_include_path = /*opt*/(*(v__builder__WindowsKit*)wk.data).shared_include_path,
		} }, sizeof(v__builder__MsvcResult));
	
#else
		v__builder__verror(tos3("Cannot find msvc on this OS"));
		return v_error(tos3("msvc not found"));
// } windows
#endif

}

void v__builder__Builder_cc_msvc(v__builder__Builder* v) {
	Option_v__builder__MsvcResult r = v__builder__find_msvc();
	if (!r.ok) {
		string err = r.v_error;
		int errcode = r.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		if (!v->pref->keep_c && string_ne(v->out_name_c, tos3("v.c")) && string_ne(v->out_name_c, tos3("v_macos.c"))) {
			os__rm(v->out_name_c);
		}
		v__builder__verror(tos3("Cannot find MSVC on this OS"));
		return ;
	};
	string out_name_obj = os__real_path(string_add(v->out_name_c, tos3(".obj")));
	array_string a = new_array_from_c_array(4, 4, sizeof(string), (string[4]){
		tos3("-w"), tos3("/we4013"), tos3("/volatile:ms"), _STR("/Fo\"%.*s\000\"", 2, out_name_obj), 
});
	if (v->pref->is_prod) {
		array_push(&a, &(string[]){ tos3("/O2") });
		array_push(&a, &(string[]){ tos3("/MD") });
		array_push(&a, &(string[]){ tos3("/Zi") });
		array_push(&a, &(string[]){ tos3("/DNDEBUG") });
	} else {
		array_push(&a, &(string[]){ tos3("/Zi") });
		array_push(&a, &(string[]){ tos3("/MDd") });
	}
	if (v->pref->is_shared) {
		if (!string_ends_with(v->pref->out_name, tos3(".dll"))) {
			v->pref->out_name = string_add(v->pref->out_name, tos3(".dll"));
		}
		array_push(&a, &(string[]){ tos3("/LD") });
	} else if (!string_ends_with(v->pref->out_name, tos3(".exe"))) {
		v->pref->out_name = string_add(v->pref->out_name, tos3(".exe"));
	}
	v->pref->out_name = os__real_path(v->pref->out_name);
	if (v->pref->build_mode == v__pref__BuildMode_build_module) {
		array_push(&a, &(string[]){ tos3("/c") });
	} else if (v->pref->build_mode == v__pref__BuildMode_default_mode) {
	}
	if (v->pref->sanitize) {
		println(tos3("Sanitize not supported on msvc."));
	}
	array_push(&a, &(string[]){ string_add(string_add(tos3("\""), os__real_path(v->out_name_c)), tos3("\"")) });
	array_string real_libs = new_array_from_c_array(3, 3, sizeof(string), (string[3]){
		tos3("kernel32.lib"), tos3("user32.lib"), tos3("advapi32.lib"), 
});
	v__builder__MsvcStringFlags sflags = array_v__cflag__CFlag_msvc_string_flags(v__builder__Builder_get_os_cflags(v));
	_PUSH_MANY(&real_libs, (sflags.real_libs), tmp16, array_string);
	array_string inc_paths = sflags.inc_paths;
	array_string lib_paths = sflags.lib_paths;
	array_string other_flags = sflags.other_flags;
	array_push(&a, &(string[]){ _STR("-I \"%.*s\000\"", 2, /*opt*/(*(v__builder__MsvcResult*)r.data).ucrt_include_path) });
	array_push(&a, &(string[]){ _STR("-I \"%.*s\000\"", 2, /*opt*/(*(v__builder__MsvcResult*)r.data).vs_include_path) });
	array_push(&a, &(string[]){ _STR("-I \"%.*s\000\"", 2, /*opt*/(*(v__builder__MsvcResult*)r.data).um_include_path) });
	array_push(&a, &(string[]){ _STR("-I \"%.*s\000\"", 2, /*opt*/(*(v__builder__MsvcResult*)r.data).shared_include_path) });
	_PUSH_MANY(&a, (inc_paths), tmp21, array_string);
	_PUSH_MANY(&a, (other_flags), tmp22, array_string);
	array_push(&a, &(string[]){ array_string_join(real_libs, tos3(" ")) });
	array_push(&a, &(string[]){ tos3("/link") });
	array_push(&a, &(string[]){ tos3("/NOLOGO") });
	array_push(&a, &(string[]){ _STR("/OUT:\"%.*s\000\"", 2, v->pref->out_name) });
	array_push(&a, &(string[]){ _STR("/LIBPATH:\"%.*s\000\"", 2, /*opt*/(*(v__builder__MsvcResult*)r.data).ucrt_lib_path) });
	array_push(&a, &(string[]){ _STR("/LIBPATH:\"%.*s\000\"", 2, /*opt*/(*(v__builder__MsvcResult*)r.data).um_lib_path) });
	array_push(&a, &(string[]){ _STR("/LIBPATH:\"%.*s\000\"", 2, /*opt*/(*(v__builder__MsvcResult*)r.data).vs_lib_path) });
	array_push(&a, &(string[]){ tos3("/DEBUG:FULL") });
	if (v->pref->is_prod) {
		array_push(&a, &(string[]){ tos3("/INCREMENTAL:NO") });
		array_push(&a, &(string[]){ tos3("/OPT:REF") });
		array_push(&a, &(string[]){ tos3("/OPT:ICF") });
	}
	_PUSH_MANY(&a, (lib_paths), tmp35, array_string);
	string args = array_string_join(a, tos3(" "));
	string cmd = _STR("\"%.*s\000\" %.*s", 2, /*opt*/(*(v__builder__MsvcResult*)r.data).full_cl_exe_path, args);
	if (v->pref->is_verbose) {
		println(tos3("\n========== cl cmd line:"));
		println(cmd);
		println(tos3("==========\n"));
	}
	Option_os__Result res = os__exec(cmd);
	if (!res.ok) {
		string err = res.v_error;
		int errcode = res.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		println(err);
		v__builder__verror(tos3("msvc error"));
		return ;
	};
	if (/*opt*/(*(os__Result*)res.data).exit_code != 0) {
		v__builder__verror(/*opt*/(*(os__Result*)res.data).output);
	}
	if (!v->pref->keep_c && string_ne(v->out_name_c, tos3("v.c")) && string_ne(v->out_name_c, tos3("v_macos.c"))) {
		os__rm(v->out_name_c);
	}
	os__rm(out_name_obj);
}

static void v__builder__build_thirdparty_obj_file_with_msvc(string path, array_v__cflag__CFlag moduleflags) {
	Option_v__builder__MsvcResult msvc = v__builder__find_msvc();
	if (!msvc.ok) {
		string err = msvc.v_error;
		int errcode = msvc.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		println(tos3("Could not find visual studio"));
		return ;
	};
	string obj_path = _STR("%.*s\000bj", 2, path);
	obj_path = os__real_path(obj_path);
	if (os__exists(obj_path)) {
		println(_STR("%.*s\000 already built.", 2, obj_path));
		return ;
	}
	println(_STR("%.*s\000 not found, building it (with msvc)...", 2, obj_path));
	string parent = os__dir(obj_path);
	Option_array_string files = os__ls(parent);
	if (!files.ok) {
		string err = files.v_error;
		int errcode = files.ecode;
		 // typeof it_expr_type: v.ast.CallExpr
		// last_type: v.ast.ExprStmt
		// last_expr_result_type: void
		v_panic(err);
	};
	string cfiles = tos3("");
	// FOR IN array
	array tmp2 = /*opt*/(*(array_string*)files.data);
	for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
		string file = ((string*)tmp2.data)[tmp3];
		if (string_ends_with(file, tos3(".c"))) {
			cfiles = string_add(cfiles, string_add(string_add(tos3("\""), os__real_path(string_add(string_add(parent, _const_os__path_separator), file))), tos3("\" ")));
		}
	}
	string include_string = _STR("-I \"%.*s\000\" -I \"%.*s\000\" -I \"%.*s\000\" -I \"%.*s\000\"", 5, /*opt*/(*(v__builder__MsvcResult*)msvc.data).ucrt_include_path, /*opt*/(*(v__builder__MsvcResult*)msvc.data).vs_include_path, /*opt*/(*(v__builder__MsvcResult*)msvc.data).um_include_path, /*opt*/(*(v__builder__MsvcResult*)msvc.data).shared_include_path);
	string btarget = array_v__cflag__CFlag_c_options_before_target_msvc(moduleflags);
	string atarget = array_v__cflag__CFlag_c_options_after_target_msvc(moduleflags);
	string cmd = _STR("\"%.*s\000\" /volatile:ms /Zi /DNDEBUG %.*s\000 /c %.*s\000 %.*s\000 %.*s\000 /Fo\"%.*s\000\"", 7, /*opt*/(*(v__builder__MsvcResult*)msvc.data).full_cl_exe_path, include_string, btarget, cfiles, atarget, obj_path);
	println(_STR("thirdparty cmd line: %.*s", 1, cmd));
	Option_os__Result res = os__exec(cmd);
	if (!res.ok) {
		string err = res.v_error;
		int errcode = res.ecode;
		// last_type: v.ast.Return
		// last_expr_result_type: 
		println(_STR("msvc: failed thirdparty object build cmd: %.*s", 1, cmd));
		v__builder__verror(err);
		return ;
	};
	if (/*opt*/(*(os__Result*)res.data).exit_code != 0) {
		println(_STR("msvc: failed thirdparty object build cmd: %.*s", 1, cmd));
		v__builder__verror(/*opt*/(*(os__Result*)res.data).output);
		return ;
	}
	println(/*opt*/(*(os__Result*)res.data).output);
}

static v__builder__MsvcStringFlags array_v__cflag__CFlag_msvc_string_flags(array_v__cflag__CFlag cflags) {
	array_string real_libs = __new_array(0, 0, sizeof(string));
	array_string inc_paths = __new_array(0, 0, sizeof(string));
	array_string lib_paths = __new_array(0, 0, sizeof(string));
	array_string other_flags = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp1 = cflags;
	for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)tmp1.data)[tmp2];
		if (string_eq(flag.name, tos3("-l"))) {
			if (string_ends_with(flag.value, tos3(".dll"))) {
				v__builder__verror(_STR("MSVC cannot link against a dll (`#flag -l %.*s\000`)", 2, flag.value));
			}
			string lib_lib = string_add(flag.value, tos3(".lib"));
			array_push(&real_libs, &(string[]){ lib_lib });
		} else if (string_eq(flag.name, tos3("-I"))) {
			array_push(&inc_paths, &(string[]){ v__cflag__CFlag_format(&flag) });
		} else if (string_eq(flag.name, tos3("-L"))) {
			array_push(&lib_paths, &(string[]){ flag.value });
			array_push(&lib_paths, &(string[]){ string_add(string_add(flag.value, _const_os__path_separator), tos3("msvc")) });
		} else if (string_ends_with(flag.value, tos3(".o"))) {
			array_push(&other_flags, &(string[]){ _STR("\"%.*s\000bj\"", 2, flag.value) });
		} else {
			array_push(&other_flags, &(string[]){ flag.value });
		}
	}
	array_string lpaths = __new_array(0, 0, sizeof(string));
	// FOR IN array
	array tmp11 = lib_paths;
	for (int tmp12 = 0; tmp12 < tmp11.len; tmp12++) {
		string l = ((string*)tmp11.data)[tmp12];
		array_push(&lpaths, &(string[]){ string_add(string_add(tos3("/LIBPATH:\""), os__real_path(l)), tos3("\"")) });
	}
	return (v__builder__MsvcStringFlags){
		.real_libs = real_libs,
		.inc_paths = inc_paths,
		.lib_paths = lpaths,
		.other_flags = other_flags,
	};
}

void v__builder__Builder_build_x64(v__builder__Builder* b, array_string v_files, string out_file) {
	
// $if !linux {
#ifndef __linux__
		println(tos3("v -x64 can only generate Linux binaries for now"));
		println(string_add(tos3("You are not on a Linux system, so you will not "), tos3("be able to run the resulting executable")));
	
// } linux
#endif

	i64 t0 = time__ticks();
	b->parsed_files = v__parser__parse_files(v_files, b->table, b->pref, b->global_scope);
	v__builder__Builder_parse_imports(b);
	i64 t1 = time__ticks();
	i64 parse_time = t1 - t0;
	v__builder__Builder_info(/*rec*/*b, _STR("PARSE: %"PRId64"\000ms", 2, parse_time));
	v__checker__Checker_check_files(&b->checker, b->parsed_files);
	i64 t2 = time__ticks();
	i64 check_time = t2 - t1;
	v__builder__Builder_info(/*rec*/*b, _STR("CHECK: %"PRId64"\000ms", 2, check_time));
	v__gen__x64__gen(b->parsed_files, out_file);
	i64 t3 = time__ticks();
	i64 gen_time = t3 - t2;
	v__builder__Builder_info(/*rec*/*b, _STR("x64 GEN: %"PRId64"\000ms", 2, gen_time));
}

void v__builder__Builder_compile_x64(v__builder__Builder* b) {
	array_string files = new_array_from_c_array(1, 1, sizeof(string), (string[1]){
		b->pref->path, 
});
	v__builder__Builder_set_module_lookup_paths(b);
	v__builder__Builder_build_x64(b, files, b->pref->out_name);
}


static multi_return_v__pref__Preferences_string parse_args(array_string args) {
	v__pref__Preferences* res = (v__pref__Preferences*)memdup(&(v__pref__Preferences){	.os = {0},
		.backend = {0},
		.build_mode = {0},
		.is_verbose = 0,
		.is_test = 0,
		.is_script = 0,
		.is_livemain = 0,
		.is_liveshared = 0,
		.is_shared = 0,
		.is_prof = 0,
		.profile_file = (string){.str=""},
		.translated = 0,
		.is_prod = 0,
		.obfuscate = 0,
		.is_repl = 0,
		.is_run = 0,
		.sanitize = 0,
		.is_debug = 0,
		.is_vlines = 0,
		.keep_c = 0,
		.show_cc = 0,
		.use_cache = 0,
		.is_stats = 0,
		.no_auto_free = 0,
		.cflags = (string){.str=""},
		.ccompiler = (string){.str=""},
		.third_party_option = (string){.str=""},
		.building_v = 0,
		.autofree = 0,
		.compress = 0,
		.fast = 0,
		.enable_globals = 0,
		.is_fmt = 0,
		.is_bare = 0,
		.lookup_path = __new_array(0, 1, sizeof(string)),
		.output_cross_c = 0,
		.prealloc = 0,
		.vroot = (string){.str=""},
		.out_name = (string){.str=""},
		.path = (string){.str=""},
		.compile_defines = __new_array(0, 1, sizeof(string)),
		.compile_defines_all = __new_array(0, 1, sizeof(string)),
		.mod = (string){.str=""},
		.run_args = __new_array(0, 1, sizeof(string)),
		.printfn_list = __new_array(0, 1, sizeof(string)),
		.print_v_files = 0,
	}, sizeof(v__pref__Preferences));
	string command = tos3("");
	int command_pos = 0;
	for (int i = 0;
	i < args.len; i++) {
		string arg = (*(string*)array_get(args, i));
		array_string current_args = array_slice(args, i, args.len);
		if (string_eq(arg, tos3("-v"))) {
			res->is_verbose = true;
		}else if (string_eq(arg, tos3("-cg"))) {
			res->is_debug = true;
		}else if (string_eq(arg, tos3("-repl"))) {
			res->is_repl = true;
		}else if (string_eq(arg, tos3("-live"))) {
			res->is_livemain = true;
		}else if (string_eq(arg, tos3("-sharedlive"))) {
			res->is_liveshared = true;
			res->is_shared = true;
		}else if (string_eq(arg, tos3("-shared"))) {
			res->is_shared = true;
		}else if (string_eq(arg, tos3("-autofree"))) {
			res->autofree = true;
		}else if (string_eq(arg, tos3("-compress"))) {
			res->compress = true;
		}else if (string_eq(arg, tos3("-freestanding"))) {
			res->is_bare = true;
		}else if (string_eq(arg, tos3("-prof")) || string_eq(arg, tos3("-profile"))) {
			res->profile_file = os__cmdline__option(current_args, tos3("-profile"), tos3("-"));
			res->is_prof = true;
			i++;
		}else if (string_eq(arg, tos3("-prod"))) {
			res->is_prod = true;
		}else if (string_eq(arg, tos3("-stats"))) {
			res->is_stats = true;
		}else if (string_eq(arg, tos3("-obfuscate"))) {
			res->obfuscate = true;
		}else if (string_eq(arg, tos3("-translated"))) {
			res->translated = true;
		}else if (string_eq(arg, tos3("-showcc"))) {
			res->show_cc = true;
		}else if (string_eq(arg, tos3("-usecache"))) {
			res->use_cache = true;
		}else if (string_eq(arg, tos3("-keepc"))) {
			res->keep_c = true;
		}else if (string_eq(arg, tos3("-x64"))) {
			res->backend = v__pref__Backend_x64;
		}else if (string_eq(arg, tos3("-print_v_files"))) {
			res->print_v_files = true;
		}else if (string_eq(arg, tos3("-os"))) {
			string target_os = os__cmdline__option(current_args, tos3("-os"), tos3(""));
			i++;
			Option_v__pref__OS target_os_kind = v__pref__os_from_string(target_os);
			if (!target_os_kind.ok) {
				string err = target_os_kind.v_error;
				int errcode = target_os_kind.ecode;
				 // typeof it_expr_type: v.ast.CallExpr
				// last_type: v.ast.ExprStmt
				// last_expr_result_type: void
				if (string_eq(target_os, tos3("cross"))) {
					res->output_cross_c = true;
					continue;
				}
				println(_STR("unknown operating system target `%.*s\000`", 2, target_os));
				v_exit(1);
			};
			res->os = /*opt*/(*(v__pref__OS*)target_os_kind.data);
		}else if (string_eq(arg, tos3("-printfn"))) {
			array_push(&res->printfn_list, &(string[]){ os__cmdline__option(current_args, tos3("-printfn"), tos3("")) });
			i++;
		}else if (string_eq(arg, tos3("-cflags"))) {
			res->cflags = string_add(res->cflags, string_add(tos3(" "), os__cmdline__option(current_args, tos3("-cflags"), tos3(""))));
			i++;
		}else if (string_eq(arg, tos3("-define")) || string_eq(arg, tos3("-d"))) {
			if (current_args.len > 1) {
				string define = (*(string*)array_get(current_args, 1));
				parse_define(res, define);
			}
			i++;
		}else if (string_eq(arg, tos3("-cc"))) {
			res->ccompiler = os__cmdline__option(current_args, tos3("-cc"), tos3("cc"));
			i++;
		}else if (string_eq(arg, tos3("-o"))) {
			res->out_name = os__cmdline__option(current_args, tos3("-o"), tos3(""));
			i++;
		}else if (string_eq(arg, tos3("-b"))) {
			Option_v__pref__Backend b = v__pref__backend_from_string(os__cmdline__option(current_args, tos3("-b"), tos3("c")));
			if (!b.ok) {
				string err = b.v_error;
				int errcode = b.ecode;
				// last_type: v.ast.BranchStmt
				// last_expr_result_type: 
				continue;
			};
			res->backend = /*opt*/(*(v__pref__Backend*)b.data);
			i++;
		}else {
			bool should_continue = false;
			// FOR IN array
			array tmp5 = _const_list_of_flags_with_param;
			for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
				string flag_with_param = ((string*)tmp5.data)[tmp6];
				if (string_eq(_STR("-%.*s", 1, flag_with_param), arg)) {
					should_continue = true;
					i++;
					break;
				}
			}
			if (should_continue) {
				continue;
			}
			if (!string_starts_with(arg, tos3("-")) && string_eq(command, tos3(""))) {
				command = arg;
				command_pos = i;
			}
		};
	}
	if (string_ends_with(command, tos3(".v")) || os__exists(command)) {
		res->path = command;
	} else if (string_eq(command, tos3("run"))) {
		res->is_run = true;
		if (command_pos > args.len) {
			eprintln(tos3("v run: no v files listed"));
			v_exit(1);
		}
		res->path = (*(string*)array_get(args, command_pos + 1));
		res->run_args = array_slice(args, command_pos + 2, args.len);
	}
	if (string_eq(command, tos3("build-module"))) {
		res->build_mode = v__pref__BuildMode_build_module;
		res->path = (*(string*)array_get(args, command_pos + 1));
	}
	if (res->is_verbose) {
		println(_STR("setting pref.path to \"%.*s\000\"", 2, res->path));
	}
	v__pref__Preferences_fill_with_defaults(res);
	return (multi_return_v__pref__Preferences_string){.arg0=res,.arg1=command};
}

static void invoke_help_and_exit(array_string remaining) {
	if (remaining.len == 0 || remaining.len == 1) {
		help__print_and_exit(tos3("default"));
	}else if (remaining.len == 2) {
		help__print_and_exit((*(string*)array_get(remaining, 1)));
	}else {
	};
	println(tos3("V Error: Expected only one help topic to be provided."));
	println(tos3("For usage information, use `v help`."));
	v_exit(1);
}

static void create_symlink() {
	
// $if  windows {
#ifdef _WIN32
		return ;
	
// } windows
#endif

	string vexe = v__pref__vexe_path();
	string link_path = tos3("/usr/local/bin/v");
	Option_os__Result ret = os__exec(_STR("ln -sf %.*s\000 %.*s", 2, vexe, link_path));
	if (!ret.ok) {
		string err = ret.v_error;
		int errcode = ret.ecode;
		 // typeof it_expr_type: v.ast.CallExpr
		// last_type: v.ast.ExprStmt
		// last_expr_result_type: void
		v_panic(err);
	};
	if (/*opt*/(*(os__Result*)ret.data).exit_code == 0) {
		println(_STR("Symlink \"%.*s\000\" has been created", 2, link_path));
	} else if (os__system(tos3("uname -o | grep -q \'[A/a]ndroid\'")) == 0) {
		println(_STR("Failed to create symlink \"%.*s\000\". Trying again with Termux path for Android.", 2, link_path));
		link_path = tos3("/data/data/com.termux/files/usr/bin/v");
		Option_os__Result tmp2 =ret = os__exec(_STR("ln -sf %.*s\000 %.*s", 2, vexe, link_path));
		if (!tmp2.ok) {
			string err = tmp2.v_error;
			int errcode = tmp2.ecode;
			 // typeof it_expr_type: v.ast.CallExpr
			// last_type: v.ast.ExprStmt
			// last_expr_result_type: void
			v_panic(err);
		};
		if (/*opt*/(*(os__Result*)ret.data).exit_code == 0) {
			println(_STR("Symlink \"%.*s\000\" has been created", 2, link_path));
		} else {
			println(_STR("Failed to create symlink \"%.*s\000\". Try again with sudo.", 2, link_path));
		}
	} else {
		println(_STR("Failed to create symlink \"%.*s\000\". Try again with sudo.", 2, link_path));
	}
}

static void parse_define(v__pref__Preferences* prefs, string define) {
	array_string define_parts = string_split(define, tos3("="));
	if (define_parts.len == 1) {
		array_push(&prefs->compile_defines, &(string[]){ define });
		array_push(&prefs->compile_defines_all, &(string[]){ define });
		return ;
	}
	if (define_parts.len == 2) {
		array_push(&prefs->compile_defines_all, &(string[]){ (*(string*)array_get(define_parts, 0)) });
		if (string_eq((*(string*)array_get(define_parts, 1)), tos3("0"))) {
		}else if (string_eq((*(string*)array_get(define_parts, 1)), tos3("1"))) {
			array_push(&prefs->compile_defines, &(string[]){ (*(string*)array_get(define_parts, 0)) });
		}else {
			println(string_add(_STR("V error: Unknown define argument value `%.*s\000` for %.*s\000.", 3, (*(string*)array_get(define_parts, 1)), (*(string*)array_get(define_parts, 0))), tos3("Expected `0` or `1`.")));
			v_exit(1);
		};
		return ;
	}
	println(_STR("V error: Unknown define argument: %.*s\000. Expected at most one `=`.", 2, define));
	v_exit(1);
}

void _vinit() {
	builtin_init();
	vinit_string_literals();
	_const_hash__wyhash__wyp0 = ((u64)(0xa0761d6478bd642f));
	_const_hash__wyhash__wyp1 = ((u64)(0xe7037ed1a0b428db));
	_const_hash__wyhash__wyp2 = ((u64)(0x8ebc6af09c88c6e3));
	_const_hash__wyhash__wyp3 = ((u64)(0x589965cc75374cc3));
	_const_hash__wyhash__wyp4 = ((u64)(0x1d8e4e27c47d124f));
	_const_math__bits__de_bruijn32 = ((u32)(0x077CB531));
	_const_math__bits__de_bruijn32tab = new_array_from_c_array(32, 32, sizeof(byte), (byte[32]){
		((byte)(0)), 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9, 
});
	_const_math__bits__de_bruijn64 = ((u64)(0x03f79d71b4ca8b09));
	_const_math__bits__de_bruijn64tab = new_array_from_c_array(64, 64, sizeof(byte), (byte[64]){
		((byte)(0)), 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6, 
});
	_const_math__bits__m0 = ((u64)(0x5555555555555555));
	_const_math__bits__m1 = ((u64)(0x3333333333333333));
	_const_math__bits__m2 = ((u64)(0x0f0f0f0f0f0f0f0f));
	_const_math__bits__m3 = ((u64)(0x00ff00ff00ff00ff));
	_const_math__bits__m4 = ((u64)(0x0000ffff0000ffff));
	_const_math__bits__max_u32 = ((u32)(4294967295));
	_const_math__bits__max_u64 = ((u64)(18446744073709551615));
	_const_math__bits__two32 = ((u64)(0x100000000));
	_const_math__bits__mask32 = _const_math__bits__two32 - 1;
	_const_math__bits__ntz_8_tab = new_array_from_c_array(256, 256, sizeof(byte), (byte[256]){
		((byte)(0x08)), 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x07, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
});
	_const_math__bits__pop_8_tab = new_array_from_c_array(256, 256, sizeof(byte), (byte[256]){
		((byte)(0x00)), 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08, 
});
	_const_math__bits__rev_8_tab = new_array_from_c_array(256, 256, sizeof(byte), (byte[256]){
		((byte)(0x00)), 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff, 
});
	_const_math__bits__len_8_tab = new_array_from_c_array(256, 256, sizeof(byte), (byte[256]){
		((byte)(0x00)), 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
});
	_const_strconv__ftoa__ten_pow_table_32 = new_array_from_c_array(12, 12, sizeof(u32), (u32[12]){
		((u32)(1)), ((u32)(10)), ((u32)(100)), ((u32)(1000)), ((u32)(10000)), ((u32)(100000)), ((u32)(1000000)), ((u32)(10000000)), ((u32)(100000000)), ((u32)(1000000000)), ((u32)(10000000000)), ((u32)(100000000000)), 
});
	_const_strconv__ftoa__mantbits32 = ((u32)(23));
	_const_strconv__ftoa__expbits32 = ((u32)(8));
	_const_strconv__ftoa__bias32 = ((u32)(127));
	_const_strconv__ftoa__ten_pow_table_64 = new_array_from_c_array(20, 20, sizeof(u64), (u64[20]){
		((u64)(1)), ((u64)(10)), ((u64)(100)), ((u64)(1000)), ((u64)(10000)), ((u64)(100000)), ((u64)(1000000)), ((u64)(10000000)), ((u64)(100000000)), ((u64)(1000000000)), ((u64)(10000000000)), ((u64)(100000000000)), ((u64)(1000000000000)), ((u64)(10000000000000)), ((u64)(100000000000000)), ((u64)(1000000000000000)), ((u64)(10000000000000000)), ((u64)(100000000000000000)), ((u64)(1000000000000000000)), ((u64)(10000000000000000000)), 
});
	_const_strconv__ftoa__mantbits64 = ((u32)(52));
	_const_strconv__ftoa__expbits64 = ((u32)(11));
	_const_strconv__ftoa__bias64 = ((u32)(1023));
	_const_strconv__ftoa__powers_of_10 = new_array_from_c_array(18, 18, sizeof(u64), (u64[18]){
		((u64)(1e0)), ((u64)(1e1)), ((u64)(1e2)), ((u64)(1e3)), ((u64)(1e4)), ((u64)(1e5)), ((u64)(1e6)), ((u64)(1e7)), ((u64)(1e8)), ((u64)(1e9)), ((u64)(1e10)), ((u64)(1e11)), ((u64)(1e12)), ((u64)(1e13)), ((u64)(1e14)), ((u64)(1e15)), ((u64)(1e16)), ((u64)(1e17)), 
});
	_const_strconv__ftoa__pow5_split_32 = new_array_from_c_array(47, 47, sizeof(u64), (u64[47]){
		((u64)(1152921504606846976)), ((u64)(1441151880758558720)), ((u64)(1801439850948198400)), ((u64)(2251799813685248000)), ((u64)(1407374883553280000)), ((u64)(1759218604441600000)), ((u64)(2199023255552000000)), ((u64)(1374389534720000000)), ((u64)(1717986918400000000)), ((u64)(2147483648000000000)), ((u64)(1342177280000000000)), ((u64)(1677721600000000000)), ((u64)(2097152000000000000)), ((u64)(1310720000000000000)), ((u64)(1638400000000000000)), ((u64)(2048000000000000000)), ((u64)(1280000000000000000)), ((u64)(1600000000000000000)), ((u64)(2000000000000000000)), ((u64)(1250000000000000000)), ((u64)(1562500000000000000)), ((u64)(1953125000000000000)), ((u64)(1220703125000000000)), ((u64)(1525878906250000000)), ((u64)(1907348632812500000)), ((u64)(1192092895507812500)), ((u64)(1490116119384765625)), ((u64)(1862645149230957031)), ((u64)(1164153218269348144)), ((u64)(1455191522836685180)), ((u64)(1818989403545856475)), ((u64)(2273736754432320594)), ((u64)(1421085471520200371)), ((u64)(1776356839400250464)), ((u64)(2220446049250313080)), ((u64)(1387778780781445675)), ((u64)(1734723475976807094)), ((u64)(2168404344971008868)), ((u64)(1355252715606880542)), ((u64)(1694065894508600678)), ((u64)(2117582368135750847)), ((u64)(1323488980084844279)), ((u64)(1654361225106055349)), ((u64)(2067951531382569187)), ((u64)(1292469707114105741)), ((u64)(1615587133892632177)), ((u64)(2019483917365790221)), 
});
	_const_strconv__ftoa__pow5_inv_split_32 = new_array_from_c_array(31, 31, sizeof(u64), (u64[31]){
		((u64)(576460752303423489)), ((u64)(461168601842738791)), ((u64)(368934881474191033)), ((u64)(295147905179352826)), ((u64)(472236648286964522)), ((u64)(377789318629571618)), ((u64)(302231454903657294)), ((u64)(483570327845851670)), ((u64)(386856262276681336)), ((u64)(309485009821345069)), ((u64)(495176015714152110)), ((u64)(396140812571321688)), ((u64)(316912650057057351)), ((u64)(507060240091291761)), ((u64)(405648192073033409)), ((u64)(324518553658426727)), ((u64)(519229685853482763)), ((u64)(415383748682786211)), ((u64)(332306998946228969)), ((u64)(531691198313966350)), ((u64)(425352958651173080)), ((u64)(340282366920938464)), ((u64)(544451787073501542)), ((u64)(435561429658801234)), ((u64)(348449143727040987)), ((u64)(557518629963265579)), ((u64)(446014903970612463)), ((u64)(356811923176489971)), ((u64)(570899077082383953)), ((u64)(456719261665907162)), ((u64)(365375409332725730)), 
});
	_const_strconv__ftoa__pow5_split_64 = new_array_from_c_array(326, 326, sizeof(strconv__ftoa__Uint128), (strconv__ftoa__Uint128[326]){
		(strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0100000000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0140000000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0190000000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01f4000000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0138800000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0186a00000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01e8480000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01312d0000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x017d784000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01dcd65000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x012a05f200000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0174876e80000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01d1a94a20000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x012309ce54000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x016bcc41e9000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01c6bf5263400000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x011c37937e080000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x016345785d8a0000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01bc16d674ec8000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01158e460913d000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x015af1d78b58c400)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01b1ae4d6e2ef500)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x010f0cf064dd5920)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x0152d02c7e14af68)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000000)),
	.hi = ((u64)(0x01a784379d99db42)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4000000000000000)),
	.hi = ((u64)(0x0108b2a2c2802909)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9000000000000000)),
	.hi = ((u64)(0x014adf4b7320334b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7400000000000000)),
	.hi = ((u64)(0x019d971e4fe8401e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0880000000000000)),
	.hi = ((u64)(0x01027e72f1f12813)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcaa0000000000000)),
	.hi = ((u64)(0x01431e0fae6d7217)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbd48000000000000)),
	.hi = ((u64)(0x0193e5939a08ce9d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2c9a000000000000)),
	.hi = ((u64)(0x01f8def8808b0245)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3be0400000000000)),
	.hi = ((u64)(0x013b8b5b5056e16b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0ad8500000000000)),
	.hi = ((u64)(0x018a6e32246c99c6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8d8e640000000000)),
	.hi = ((u64)(0x01ed09bead87c037)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb878fe8000000000)),
	.hi = ((u64)(0x013426172c74d822)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x66973e2000000000)),
	.hi = ((u64)(0x01812f9cf7920e2b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x403d0da800000000)),
	.hi = ((u64)(0x01e17b84357691b6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe826288900000000)),
	.hi = ((u64)(0x012ced32a16a1b11)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x622fb2ab40000000)),
	.hi = ((u64)(0x0178287f49c4a1d6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfabb9f5610000000)),
	.hi = ((u64)(0x01d6329f1c35ca4b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7cb54395ca000000)),
	.hi = ((u64)(0x0125dfa371a19e6f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5be2947b3c800000)),
	.hi = ((u64)(0x016f578c4e0a060b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x32db399a0ba00000)),
	.hi = ((u64)(0x01cb2d6f618c878e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdfc9040047440000)),
	.hi = ((u64)(0x011efc659cf7d4b8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x17bb450059150000)),
	.hi = ((u64)(0x0166bb7f0435c9e7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xddaa16406f5a4000)),
	.hi = ((u64)(0x01c06a5ec5433c60)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8a8a4de845986800)),
	.hi = ((u64)(0x0118427b3b4a05bc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xad2ce16256fe8200)),
	.hi = ((u64)(0x015e531a0a1c872b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x987819baecbe2280)),
	.hi = ((u64)(0x01b5e7e08ca3a8f6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1f4b1014d3f6d590)),
	.hi = ((u64)(0x0111b0ec57e6499a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa71dd41a08f48af4)),
	.hi = ((u64)(0x01561d276ddfdc00)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd0e549208b31adb1)),
	.hi = ((u64)(0x01aba4714957d300)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x828f4db456ff0c8e)),
	.hi = ((u64)(0x010b46c6cdd6e3e0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa33321216cbecfb2)),
	.hi = ((u64)(0x014e1878814c9cd8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcbffe969c7ee839e)),
	.hi = ((u64)(0x01a19e96a19fc40e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3f7ff1e21cf51243)),
	.hi = ((u64)(0x0105031e2503da89)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8f5fee5aa43256d4)),
	.hi = ((u64)(0x014643e5ae44d12b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7337e9f14d3eec89)),
	.hi = ((u64)(0x0197d4df19d60576)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1005e46da08ea7ab)),
	.hi = ((u64)(0x01fdca16e04b86d4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8a03aec4845928cb)),
	.hi = ((u64)(0x013e9e4e4c2f3444)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xac849a75a56f72fd)),
	.hi = ((u64)(0x018e45e1df3b0155)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x17a5c1130ecb4fbd)),
	.hi = ((u64)(0x01f1d75a5709c1ab)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xeec798abe93f11d6)),
	.hi = ((u64)(0x013726987666190a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaa797ed6e38ed64b)),
	.hi = ((u64)(0x0184f03e93ff9f4d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1517de8c9c728bde)),
	.hi = ((u64)(0x01e62c4e38ff8721)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xad2eeb17e1c7976b)),
	.hi = ((u64)(0x012fdbb0e39fb474)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd87aa5ddda397d46)),
	.hi = ((u64)(0x017bd29d1c87a191)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4e994f5550c7dc97)),
	.hi = ((u64)(0x01dac74463a989f6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf11fd195527ce9de)),
	.hi = ((u64)(0x0128bc8abe49f639)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6d67c5faa71c2456)),
	.hi = ((u64)(0x0172ebad6ddc73c8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x88c1b77950e32d6c)),
	.hi = ((u64)(0x01cfa698c95390ba)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x957912abd28dfc63)),
	.hi = ((u64)(0x0121c81f7dd43a74)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbad75756c7317b7c)),
	.hi = ((u64)(0x016a3a275d494911)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x298d2d2c78fdda5b)),
	.hi = ((u64)(0x01c4c8b1349b9b56)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd9f83c3bcb9ea879)),
	.hi = ((u64)(0x011afd6ec0e14115)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x50764b4abe865297)),
	.hi = ((u64)(0x0161bcca7119915b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2493de1d6e27e73d)),
	.hi = ((u64)(0x01ba2bfd0d5ff5b2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x56dc6ad264d8f086)),
	.hi = ((u64)(0x01145b7e285bf98f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2c938586fe0f2ca8)),
	.hi = ((u64)(0x0159725db272f7f3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf7b866e8bd92f7d2)),
	.hi = ((u64)(0x01afcef51f0fb5ef)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfad34051767bdae3)),
	.hi = ((u64)(0x010de1593369d1b5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x79881065d41ad19c)),
	.hi = ((u64)(0x015159af80444623)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x57ea147f49218603)),
	.hi = ((u64)(0x01a5b01b605557ac)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb6f24ccf8db4f3c1)),
	.hi = ((u64)(0x01078e111c3556cb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa4aee003712230b2)),
	.hi = ((u64)(0x014971956342ac7e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4dda98044d6abcdf)),
	.hi = ((u64)(0x019bcdfabc13579e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf0a89f02b062b60b)),
	.hi = ((u64)(0x010160bcb58c16c2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xacd2c6c35c7b638e)),
	.hi = ((u64)(0x0141b8ebe2ef1c73)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x98077874339a3c71)),
	.hi = ((u64)(0x01922726dbaae390)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbe0956914080cb8e)),
	.hi = ((u64)(0x01f6b0f092959c74)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf6c5d61ac8507f38)),
	.hi = ((u64)(0x013a2e965b9d81c8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x34774ba17a649f07)),
	.hi = ((u64)(0x0188ba3bf284e23b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x01951e89d8fdc6c8)),
	.hi = ((u64)(0x01eae8caef261aca)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x40fd3316279e9c3d)),
	.hi = ((u64)(0x0132d17ed577d0be)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd13c7fdbb186434c)),
	.hi = ((u64)(0x017f85de8ad5c4ed)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x458b9fd29de7d420)),
	.hi = ((u64)(0x01df67562d8b3629)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcb7743e3a2b0e494)),
	.hi = ((u64)(0x012ba095dc7701d9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3e5514dc8b5d1db9)),
	.hi = ((u64)(0x017688bb5394c250)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4dea5a13ae346527)),
	.hi = ((u64)(0x01d42aea2879f2e4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb0b2784c4ce0bf38)),
	.hi = ((u64)(0x01249ad2594c37ce)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5cdf165f6018ef06)),
	.hi = ((u64)(0x016dc186ef9f45c2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf416dbf7381f2ac8)),
	.hi = ((u64)(0x01c931e8ab871732)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd88e497a83137abd)),
	.hi = ((u64)(0x011dbf316b346e7f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xceb1dbd923d8596c)),
	.hi = ((u64)(0x01652efdc6018a1f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc25e52cf6cce6fc7)),
	.hi = ((u64)(0x01be7abd3781eca7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd97af3c1a40105dc)),
	.hi = ((u64)(0x01170cb642b133e8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0fd9b0b20d014754)),
	.hi = ((u64)(0x015ccfe3d35d80e3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd3d01cde90419929)),
	.hi = ((u64)(0x01b403dcc834e11b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6462120b1a28ffb9)),
	.hi = ((u64)(0x01108269fd210cb1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbd7a968de0b33fa8)),
	.hi = ((u64)(0x0154a3047c694fdd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2cd93c3158e00f92)),
	.hi = ((u64)(0x01a9cbc59b83a3d5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3c07c59ed78c09bb)),
	.hi = ((u64)(0x010a1f5b81324665)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8b09b7068d6f0c2a)),
	.hi = ((u64)(0x014ca732617ed7fe)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2dcc24c830cacf34)),
	.hi = ((u64)(0x019fd0fef9de8dfe)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdc9f96fd1e7ec180)),
	.hi = ((u64)(0x0103e29f5c2b18be)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x93c77cbc661e71e1)),
	.hi = ((u64)(0x0144db473335deee)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x38b95beb7fa60e59)),
	.hi = ((u64)(0x01961219000356aa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc6e7b2e65f8f91ef)),
	.hi = ((u64)(0x01fb969f40042c54)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfc50cfcffbb9bb35)),
	.hi = ((u64)(0x013d3e2388029bb4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3b6503c3faa82a03)),
	.hi = ((u64)(0x018c8dac6a0342a2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xca3e44b4f9523484)),
	.hi = ((u64)(0x01efb1178484134a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbe66eaf11bd360d2)),
	.hi = ((u64)(0x0135ceaeb2d28c0e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6e00a5ad62c83907)),
	.hi = ((u64)(0x0183425a5f872f12)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0980cf18bb7a4749)),
	.hi = ((u64)(0x01e412f0f768fad7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x65f0816f752c6c8d)),
	.hi = ((u64)(0x012e8bd69aa19cc6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xff6ca1cb527787b1)),
	.hi = ((u64)(0x017a2ecc414a03f7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xff47ca3e2715699d)),
	.hi = ((u64)(0x01d8ba7f519c84f5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbf8cde66d86d6202)),
	.hi = ((u64)(0x0127748f9301d319)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2f7016008e88ba83)),
	.hi = ((u64)(0x017151b377c247e0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3b4c1b80b22ae923)),
	.hi = ((u64)(0x01cda62055b2d9d8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x250f91306f5ad1b6)),
	.hi = ((u64)(0x012087d4358fc827)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xee53757c8b318623)),
	.hi = ((u64)(0x0168a9c942f3ba30)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x29e852dbadfde7ac)),
	.hi = ((u64)(0x01c2d43b93b0a8bd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3a3133c94cbeb0cc)),
	.hi = ((u64)(0x0119c4a53c4e6976)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc8bd80bb9fee5cff)),
	.hi = ((u64)(0x016035ce8b6203d3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbaece0ea87e9f43e)),
	.hi = ((u64)(0x01b843422e3a84c8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x74d40c9294f238a7)),
	.hi = ((u64)(0x01132a095ce492fd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd2090fb73a2ec6d1)),
	.hi = ((u64)(0x0157f48bb41db7bc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x068b53a508ba7885)),
	.hi = ((u64)(0x01adf1aea12525ac)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8417144725748b53)),
	.hi = ((u64)(0x010cb70d24b7378b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x651cd958eed1ae28)),
	.hi = ((u64)(0x014fe4d06de5056e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfe640faf2a8619b2)),
	.hi = ((u64)(0x01a3de04895e46c9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3efe89cd7a93d00f)),
	.hi = ((u64)(0x01066ac2d5daec3e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcebe2c40d938c413)),
	.hi = ((u64)(0x014805738b51a74d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x426db7510f86f518)),
	.hi = ((u64)(0x019a06d06e261121)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc9849292a9b4592f)),
	.hi = ((u64)(0x0100444244d7cab4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfbe5b73754216f7a)),
	.hi = ((u64)(0x01405552d60dbd61)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7adf25052929cb59)),
	.hi = ((u64)(0x01906aa78b912cba)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1996ee4673743e2f)),
	.hi = ((u64)(0x01f485516e7577e9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaffe54ec0828a6dd)),
	.hi = ((u64)(0x0138d352e5096af1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1bfdea270a32d095)),
	.hi = ((u64)(0x018708279e4bc5ae)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa2fd64b0ccbf84ba)),
	.hi = ((u64)(0x01e8ca3185deb719)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x05de5eee7ff7b2f4)),
	.hi = ((u64)(0x01317e5ef3ab3270)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0755f6aa1ff59fb1)),
	.hi = ((u64)(0x017dddf6b095ff0c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x092b7454a7f3079e)),
	.hi = ((u64)(0x01dd55745cbb7ecf)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x65bb28b4e8f7e4c3)),
	.hi = ((u64)(0x012a5568b9f52f41)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbf29f2e22335ddf3)),
	.hi = ((u64)(0x0174eac2e8727b11)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2ef46f9aac035570)),
	.hi = ((u64)(0x01d22573a28f19d6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdd58c5c0ab821566)),
	.hi = ((u64)(0x0123576845997025)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x54aef730d6629ac0)),
	.hi = ((u64)(0x016c2d4256ffcc2f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x29dab4fd0bfb4170)),
	.hi = ((u64)(0x01c73892ecbfbf3b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfa28b11e277d08e6)),
	.hi = ((u64)(0x011c835bd3f7d784)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x38b2dd65b15c4b1f)),
	.hi = ((u64)(0x0163a432c8f5cd66)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc6df94bf1db35de7)),
	.hi = ((u64)(0x01bc8d3f7b3340bf)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdc4bbcf772901ab0)),
	.hi = ((u64)(0x0115d847ad000877)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd35eac354f34215c)),
	.hi = ((u64)(0x015b4e5998400a95)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x48365742a30129b4)),
	.hi = ((u64)(0x01b221effe500d3b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0d21f689a5e0ba10)),
	.hi = ((u64)(0x010f5535fef20845)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x506a742c0f58e894)),
	.hi = ((u64)(0x01532a837eae8a56)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe4851137132f22b9)),
	.hi = ((u64)(0x01a7f5245e5a2ceb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6ed32ac26bfd75b4)),
	.hi = ((u64)(0x0108f936baf85c13)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4a87f57306fcd321)),
	.hi = ((u64)(0x014b378469b67318)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5d29f2cfc8bc07e9)),
	.hi = ((u64)(0x019e056584240fde)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfa3a37c1dd7584f1)),
	.hi = ((u64)(0x0102c35f729689ea)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb8c8c5b254d2e62e)),
	.hi = ((u64)(0x014374374f3c2c65)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x26faf71eea079fb9)),
	.hi = ((u64)(0x01945145230b377f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf0b9b4e6a48987a8)),
	.hi = ((u64)(0x01f965966bce055e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5674111026d5f4c9)),
	.hi = ((u64)(0x013bdf7e0360c35b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2c111554308b71fb)),
	.hi = ((u64)(0x018ad75d8438f432)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb7155aa93cae4e7a)),
	.hi = ((u64)(0x01ed8d34e547313e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x326d58a9c5ecf10c)),
	.hi = ((u64)(0x013478410f4c7ec7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xff08aed437682d4f)),
	.hi = ((u64)(0x01819651531f9e78)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3ecada89454238a3)),
	.hi = ((u64)(0x01e1fbe5a7e78617)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x873ec895cb496366)),
	.hi = ((u64)(0x012d3d6f88f0b3ce)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x290e7abb3e1bbc3f)),
	.hi = ((u64)(0x01788ccb6b2ce0c2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb352196a0da2ab4f)),
	.hi = ((u64)(0x01d6affe45f818f2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb0134fe24885ab11)),
	.hi = ((u64)(0x01262dfeebbb0f97)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9c1823dadaa715d6)),
	.hi = ((u64)(0x016fb97ea6a9d37d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x031e2cd19150db4b)),
	.hi = ((u64)(0x01cba7de5054485d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x21f2dc02fad2890f)),
	.hi = ((u64)(0x011f48eaf234ad3a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaa6f9303b9872b53)),
	.hi = ((u64)(0x01671b25aec1d888)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd50b77c4a7e8f628)),
	.hi = ((u64)(0x01c0e1ef1a724eaa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc5272adae8f199d9)),
	.hi = ((u64)(0x01188d357087712a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7670f591a32e004f)),
	.hi = ((u64)(0x015eb082cca94d75)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd40d32f60bf98063)),
	.hi = ((u64)(0x01b65ca37fd3a0d2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc4883fd9c77bf03e)),
	.hi = ((u64)(0x0111f9e62fe44483)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb5aa4fd0395aec4d)),
	.hi = ((u64)(0x0156785fbbdd55a4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe314e3c447b1a760)),
	.hi = ((u64)(0x01ac1677aad4ab0d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaded0e5aaccf089c)),
	.hi = ((u64)(0x010b8e0acac4eae8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd96851f15802cac3)),
	.hi = ((u64)(0x014e718d7d7625a2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8fc2666dae037d74)),
	.hi = ((u64)(0x01a20df0dcd3af0b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x39d980048cc22e68)),
	.hi = ((u64)(0x010548b68a044d67)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x084fe005aff2ba03)),
	.hi = ((u64)(0x01469ae42c8560c1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4a63d8071bef6883)),
	.hi = ((u64)(0x0198419d37a6b8f1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9cfcce08e2eb42a4)),
	.hi = ((u64)(0x01fe52048590672d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x821e00c58dd309a7)),
	.hi = ((u64)(0x013ef342d37a407c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa2a580f6f147cc10)),
	.hi = ((u64)(0x018eb0138858d09b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8b4ee134ad99bf15)),
	.hi = ((u64)(0x01f25c186a6f04c2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x97114cc0ec80176d)),
	.hi = ((u64)(0x0137798f428562f9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfcd59ff127a01d48)),
	.hi = ((u64)(0x018557f31326bbb7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfc0b07ed7188249a)),
	.hi = ((u64)(0x01e6adefd7f06aa5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbd86e4f466f516e0)),
	.hi = ((u64)(0x01302cb5e6f642a7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xace89e3180b25c98)),
	.hi = ((u64)(0x017c37e360b3d351)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1822c5bde0def3be)),
	.hi = ((u64)(0x01db45dc38e0c826)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcf15bb96ac8b5857)),
	.hi = ((u64)(0x01290ba9a38c7d17)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc2db2a7c57ae2e6d)),
	.hi = ((u64)(0x01734e940c6f9c5d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3391f51b6d99ba08)),
	.hi = ((u64)(0x01d022390f8b8375)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x403b393124801445)),
	.hi = ((u64)(0x01221563a9b73229)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x904a077d6da01956)),
	.hi = ((u64)(0x016a9abc9424feb3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x745c895cc9081fac)),
	.hi = ((u64)(0x01c5416bb92e3e60)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x48b9d5d9fda513cb)),
	.hi = ((u64)(0x011b48e353bce6fc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5ae84b507d0e58be)),
	.hi = ((u64)(0x01621b1c28ac20bb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x31a25e249c51eeee)),
	.hi = ((u64)(0x01baa1e332d728ea)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5f057ad6e1b33554)),
	.hi = ((u64)(0x0114a52dffc67992)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf6c6d98c9a2002aa)),
	.hi = ((u64)(0x0159ce797fb817f6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb4788fefc0a80354)),
	.hi = ((u64)(0x01b04217dfa61df4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf0cb59f5d8690214)),
	.hi = ((u64)(0x010e294eebc7d2b8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2cfe30734e83429a)),
	.hi = ((u64)(0x0151b3a2a6b9c767)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf83dbc9022241340)),
	.hi = ((u64)(0x01a6208b50683940)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9b2695da15568c08)),
	.hi = ((u64)(0x0107d457124123c8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc1f03b509aac2f0a)),
	.hi = ((u64)(0x0149c96cd6d16cba)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x726c4a24c1573acd)),
	.hi = ((u64)(0x019c3bc80c85c7e9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe783ae56f8d684c0)),
	.hi = ((u64)(0x0101a55d07d39cf1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x616499ecb70c25f0)),
	.hi = ((u64)(0x01420eb449c8842e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf9bdc067e4cf2f6c)),
	.hi = ((u64)(0x019292615c3aa539)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x782d3081de02fb47)),
	.hi = ((u64)(0x01f736f9b3494e88)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4b1c3e512ac1dd0c)),
	.hi = ((u64)(0x013a825c100dd115)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9de34de57572544f)),
	.hi = ((u64)(0x018922f31411455a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x455c215ed2cee963)),
	.hi = ((u64)(0x01eb6bafd91596b1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcb5994db43c151de)),
	.hi = ((u64)(0x0133234de7ad7e2e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7e2ffa1214b1a655)),
	.hi = ((u64)(0x017fec216198ddba)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1dbbf89699de0feb)),
	.hi = ((u64)(0x01dfe729b9ff1529)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb2957b5e202ac9f3)),
	.hi = ((u64)(0x012bf07a143f6d39)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1f3ada35a8357c6f)),
	.hi = ((u64)(0x0176ec98994f4888)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x270990c31242db8b)),
	.hi = ((u64)(0x01d4a7bebfa31aaa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5865fa79eb69c937)),
	.hi = ((u64)(0x0124e8d737c5f0aa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xee7f791866443b85)),
	.hi = ((u64)(0x016e230d05b76cd4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2a1f575e7fd54a66)),
	.hi = ((u64)(0x01c9abd04725480a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5a53969b0fe54e80)),
	.hi = ((u64)(0x011e0b622c774d06)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf0e87c41d3dea220)),
	.hi = ((u64)(0x01658e3ab7952047)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xed229b5248d64aa8)),
	.hi = ((u64)(0x01bef1c9657a6859)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3435a1136d85eea9)),
	.hi = ((u64)(0x0117571ddf6c8138)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4143095848e76a53)),
	.hi = ((u64)(0x015d2ce55747a186)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd193cbae5b2144e8)),
	.hi = ((u64)(0x01b4781ead1989e7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe2fc5f4cf8f4cb11)),
	.hi = ((u64)(0x0110cb132c2ff630)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1bbb77203731fdd5)),
	.hi = ((u64)(0x0154fdd7f73bf3bd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x62aa54e844fe7d4a)),
	.hi = ((u64)(0x01aa3d4df50af0ac)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbdaa75112b1f0e4e)),
	.hi = ((u64)(0x010a6650b926d66b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xad15125575e6d1e2)),
	.hi = ((u64)(0x014cffe4e7708c06)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x585a56ead360865b)),
	.hi = ((u64)(0x01a03fde214caf08)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x37387652c41c53f8)),
	.hi = ((u64)(0x010427ead4cfed65)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x850693e7752368f7)),
	.hi = ((u64)(0x014531e58a03e8be)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x264838e1526c4334)),
	.hi = ((u64)(0x01967e5eec84e2ee)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xafda4719a7075402)),
	.hi = ((u64)(0x01fc1df6a7a61ba9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0de86c7008649481)),
	.hi = ((u64)(0x013d92ba28c7d14a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9162878c0a7db9a1)),
	.hi = ((u64)(0x018cf768b2f9c59c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb5bb296f0d1d280a)),
	.hi = ((u64)(0x01f03542dfb83703)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5194f9e568323906)),
	.hi = ((u64)(0x01362149cbd32262)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe5fa385ec23ec747)),
	.hi = ((u64)(0x0183a99c3ec7eafa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9f78c67672ce7919)),
	.hi = ((u64)(0x01e494034e79e5b9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x03ab7c0a07c10bb0)),
	.hi = ((u64)(0x012edc82110c2f94)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x04965b0c89b14e9c)),
	.hi = ((u64)(0x017a93a2954f3b79)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x45bbf1cfac1da243)),
	.hi = ((u64)(0x01d9388b3aa30a57)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8b957721cb92856a)),
	.hi = ((u64)(0x0127c35704a5e676)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2e7ad4ea3e7726c4)),
	.hi = ((u64)(0x0171b42cc5cf6014)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3a198a24ce14f075)),
	.hi = ((u64)(0x01ce2137f7433819)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc44ff65700cd1649)),
	.hi = ((u64)(0x0120d4c2fa8a030f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb563f3ecc1005bdb)),
	.hi = ((u64)(0x016909f3b92c83d3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa2bcf0e7f14072d2)),
	.hi = ((u64)(0x01c34c70a777a4c8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x65b61690f6c847c3)),
	.hi = ((u64)(0x011a0fc668aac6fd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbf239c35347a59b4)),
	.hi = ((u64)(0x016093b802d578bc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xeeec83428198f021)),
	.hi = ((u64)(0x01b8b8a6038ad6eb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7553d20990ff9615)),
	.hi = ((u64)(0x01137367c236c653)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x52a8c68bf53f7b9a)),
	.hi = ((u64)(0x01585041b2c477e8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6752f82ef28f5a81)),
	.hi = ((u64)(0x01ae64521f7595e2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8093db1d57999890)),
	.hi = ((u64)(0x010cfeb353a97dad)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe0b8d1e4ad7ffeb4)),
	.hi = ((u64)(0x01503e602893dd18)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x18e7065dd8dffe62)),
	.hi = ((u64)(0x01a44df832b8d45f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6f9063faa78bfefd)),
	.hi = ((u64)(0x0106b0bb1fb384bb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4b747cf9516efebc)),
	.hi = ((u64)(0x01485ce9e7a065ea)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xde519c37a5cabe6b)),
	.hi = ((u64)(0x019a742461887f64)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0af301a2c79eb703)),
	.hi = ((u64)(0x01008896bcf54f9f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcdafc20b798664c4)),
	.hi = ((u64)(0x0140aabc6c32a386)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x811bb28e57e7fdf5)),
	.hi = ((u64)(0x0190d56b873f4c68)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa1629f31ede1fd72)),
	.hi = ((u64)(0x01f50ac6690f1f82)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa4dda37f34ad3e67)),
	.hi = ((u64)(0x013926bc01a973b1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0e150c5f01d88e01)),
	.hi = ((u64)(0x0187706b0213d09e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x919a4f76c24eb181)),
	.hi = ((u64)(0x01e94c85c298c4c5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7b0071aa39712ef1)),
	.hi = ((u64)(0x0131cfd3999f7afb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x59c08e14c7cd7aad)),
	.hi = ((u64)(0x017e43c8800759ba)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf030b199f9c0d958)),
	.hi = ((u64)(0x01ddd4baa0093028)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x961e6f003c1887d7)),
	.hi = ((u64)(0x012aa4f4a405be19)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfba60ac04b1ea9cd)),
	.hi = ((u64)(0x01754e31cd072d9f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfa8f8d705de65440)),
	.hi = ((u64)(0x01d2a1be4048f907)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfc99b8663aaff4a8)),
	.hi = ((u64)(0x0123a516e82d9ba4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3bc0267fc95bf1d2)),
	.hi = ((u64)(0x016c8e5ca239028e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcab0301fbbb2ee47)),
	.hi = ((u64)(0x01c7b1f3cac74331)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1eae1e13d54fd4ec)),
	.hi = ((u64)(0x011ccf385ebc89ff)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe659a598caa3ca27)),
	.hi = ((u64)(0x01640306766bac7e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9ff00efefd4cbcb1)),
	.hi = ((u64)(0x01bd03c81406979e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x23f6095f5e4ff5ef)),
	.hi = ((u64)(0x0116225d0c841ec3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xecf38bb735e3f36a)),
	.hi = ((u64)(0x015baaf44fa52673)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe8306ea5035cf045)),
	.hi = ((u64)(0x01b295b1638e7010)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x911e4527221a162b)),
	.hi = ((u64)(0x010f9d8ede39060a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3565d670eaa09bb6)),
	.hi = ((u64)(0x015384f295c7478d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x82bf4c0d2548c2a3)),
	.hi = ((u64)(0x01a8662f3b391970)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x51b78f88374d79a6)),
	.hi = ((u64)(0x01093fdd8503afe6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe625736a4520d810)),
	.hi = ((u64)(0x014b8fd4e6449bdf)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdfaed044d6690e14)),
	.hi = ((u64)(0x019e73ca1fd5c2d7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xebcd422b0601a8cc)),
	.hi = ((u64)(0x0103085e53e599c6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa6c092b5c78212ff)),
	.hi = ((u64)(0x0143ca75e8df0038)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd070b763396297bf)),
	.hi = ((u64)(0x0194bd136316c046)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x848ce53c07bb3daf)),
	.hi = ((u64)(0x01f9ec583bdc7058)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x52d80f4584d5068d)),
	.hi = ((u64)(0x013c33b72569c637)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x278e1316e60a4831)),
	.hi = ((u64)(0x018b40a4eec437c5)),
}, 
});
	_const_strconv__ftoa__pow5_inv_split_64 = new_array_from_c_array(292, 292, sizeof(strconv__ftoa__Uint128), (strconv__ftoa__Uint128[292]){
		(strconv__ftoa__Uint128){
	.lo = ((u64)(0x0000000000000001)),
	.hi = ((u64)(0x0400000000000000)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3333333333333334)),
	.hi = ((u64)(0x0333333333333333)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x28f5c28f5c28f5c3)),
	.hi = ((u64)(0x028f5c28f5c28f5c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xed916872b020c49c)),
	.hi = ((u64)(0x020c49ba5e353f7c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaf4f0d844d013a93)),
	.hi = ((u64)(0x0346dc5d63886594)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8c3f3e0370cdc876)),
	.hi = ((u64)(0x029f16b11c6d1e10)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd698fe69270b06c5)),
	.hi = ((u64)(0x0218def416bdb1a6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf0f4ca41d811a46e)),
	.hi = ((u64)(0x035afe535795e90a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf3f70834acdae9f1)),
	.hi = ((u64)(0x02af31dc4611873b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5cc5a02a23e254c1)),
	.hi = ((u64)(0x0225c17d04dad296)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfad5cd10396a2135)),
	.hi = ((u64)(0x036f9bfb3af7b756)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfbde3da69454e75e)),
	.hi = ((u64)(0x02bfaffc2f2c92ab)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2fe4fe1edd10b918)),
	.hi = ((u64)(0x0232f33025bd4223)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4ca19697c81ac1bf)),
	.hi = ((u64)(0x0384b84d092ed038)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3d4e1213067bce33)),
	.hi = ((u64)(0x02d09370d4257360)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x643e74dc052fd829)),
	.hi = ((u64)(0x024075f3dceac2b3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6d30baf9a1e626a7)),
	.hi = ((u64)(0x039a5652fb113785)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2426fbfae7eb5220)),
	.hi = ((u64)(0x02e1dea8c8da92d1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1cebfcc8b9890e80)),
	.hi = ((u64)(0x024e4bba3a487574)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x94acc7a78f41b0cc)),
	.hi = ((u64)(0x03b07929f6da5586)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaa23d2ec729af3d7)),
	.hi = ((u64)(0x02f394219248446b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbb4fdbf05baf2979)),
	.hi = ((u64)(0x025c768141d369ef)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc54c931a2c4b758d)),
	.hi = ((u64)(0x03c7240202ebdcb2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9dd6dc14f03c5e0b)),
	.hi = ((u64)(0x0305b66802564a28)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4b1249aa59c9e4d6)),
	.hi = ((u64)(0x026af8533511d4ed)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x44ea0f76f60fd489)),
	.hi = ((u64)(0x03de5a1ebb4fbb15)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6a54d92bf80caa07)),
	.hi = ((u64)(0x0318481895d96277)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x21dd7a89933d54d2)),
	.hi = ((u64)(0x0279d346de4781f9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x362f2a75b8622150)),
	.hi = ((u64)(0x03f61ed7ca0c0328)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf825bb91604e810d)),
	.hi = ((u64)(0x032b4bdfd4d668ec)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc684960de6a5340b)),
	.hi = ((u64)(0x0289097fdd7853f0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd203ab3e521dc33c)),
	.hi = ((u64)(0x02073accb12d0ff3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe99f7863b696052c)),
	.hi = ((u64)(0x033ec47ab514e652)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x87b2c6b62bab3757)),
	.hi = ((u64)(0x02989d2ef743eb75)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd2f56bc4efbc2c45)),
	.hi = ((u64)(0x0213b0f25f69892a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1e55793b192d13a2)),
	.hi = ((u64)(0x0352b4b6ff0f41de)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4b77942f475742e8)),
	.hi = ((u64)(0x02a8909265a5ce4b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd5f9435905df68ba)),
	.hi = ((u64)(0x022073a8515171d5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x565b9ef4d6324129)),
	.hi = ((u64)(0x03671f73b54f1c89)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdeafb25d78283421)),
	.hi = ((u64)(0x02b8e5f62aa5b06d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x188c8eb12cecf681)),
	.hi = ((u64)(0x022d84c4eeeaf38b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8dadb11b7b14bd9b)),
	.hi = ((u64)(0x037c07a17e44b8de)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7157c0e2c8dd647c)),
	.hi = ((u64)(0x02c99fb46503c718)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8ddfcd823a4ab6ca)),
	.hi = ((u64)(0x023ae629ea696c13)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1632e269f6ddf142)),
	.hi = ((u64)(0x0391704310a8acec)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x44f581ee5f17f435)),
	.hi = ((u64)(0x02dac035a6ed5723)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x372ace584c1329c4)),
	.hi = ((u64)(0x024899c4858aac1c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbeaae3c079b842d3)),
	.hi = ((u64)(0x03a75c6da27779c6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6555830061603576)),
	.hi = ((u64)(0x02ec49f14ec5fb05)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb7779c004de6912b)),
	.hi = ((u64)(0x0256a18dd89e626a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf258f99a163db512)),
	.hi = ((u64)(0x03bdcf495a9703dd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5b7a614811caf741)),
	.hi = ((u64)(0x02fe3f6de212697e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaf951aa00e3bf901)),
	.hi = ((u64)(0x0264ff8b1b41edfe)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7f54f7667d2cc19b)),
	.hi = ((u64)(0x03d4cc11c5364997)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x32aa5f8530f09ae3)),
	.hi = ((u64)(0x0310a3416a91d479)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf55519375a5a1582)),
	.hi = ((u64)(0x0273b5cdeedb1060)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbbbb5b8bc3c3559d)),
	.hi = ((u64)(0x03ec56164af81a34)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2fc916096969114a)),
	.hi = ((u64)(0x03237811d593482a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x596dab3ababa743c)),
	.hi = ((u64)(0x0282c674aadc39bb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x478aef622efb9030)),
	.hi = ((u64)(0x0202385d557cfafc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd8de4bd04b2c19e6)),
	.hi = ((u64)(0x0336c0955594c4c6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xad7ea30d08f014b8)),
	.hi = ((u64)(0x029233aaaadd6a38)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x24654f3da0c01093)),
	.hi = ((u64)(0x020e8fbbbbe454fa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3a3bb1fc346680eb)),
	.hi = ((u64)(0x034a7f92c63a2190)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x94fc8e635d1ecd89)),
	.hi = ((u64)(0x02a1ffa89e94e7a6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaa63a51c4a7f0ad4)),
	.hi = ((u64)(0x021b32ed4baa52eb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdd6c3b607731aaed)),
	.hi = ((u64)(0x035eb7e212aa1e45)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1789c919f8f488bd)),
	.hi = ((u64)(0x02b22cb4dbbb4b6b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xac6e3a7b2d906d64)),
	.hi = ((u64)(0x022823c3e2fc3c55)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x13e390c515b3e23a)),
	.hi = ((u64)(0x03736c6c9e606089)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdcb60d6a77c31b62)),
	.hi = ((u64)(0x02c2bd23b1e6b3a0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7d5e7121f968e2b5)),
	.hi = ((u64)(0x0235641c8e52294d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc8971b698f0e3787)),
	.hi = ((u64)(0x0388a02db0837548)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa078e2bad8d82c6c)),
	.hi = ((u64)(0x02d3b357c0692aa0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe6c71bc8ad79bd24)),
	.hi = ((u64)(0x0242f5dfcd20eee6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0ad82c7448c2c839)),
	.hi = ((u64)(0x039e5632e1ce4b0b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3be023903a356cfa)),
	.hi = ((u64)(0x02e511c24e3ea26f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2fe682d9c82abd95)),
	.hi = ((u64)(0x0250db01d8321b8c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4ca4048fa6aac8ee)),
	.hi = ((u64)(0x03b4919c8d1cf8e0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3d5003a61eef0725)),
	.hi = ((u64)(0x02f6dae3a4172d80)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9773361e7f259f51)),
	.hi = ((u64)(0x025f1582e9ac2466)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8beb89ca6508fee8)),
	.hi = ((u64)(0x03cb559e42ad070a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6fefa16eb73a6586)),
	.hi = ((u64)(0x0309114b688a6c08)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf3261abef8fb846b)),
	.hi = ((u64)(0x026da76f86d52339)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x51d691318e5f3a45)),
	.hi = ((u64)(0x03e2a57f3e21d1f6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0e4540f471e5c837)),
	.hi = ((u64)(0x031bb798fe8174c5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd8376729f4b7d360)),
	.hi = ((u64)(0x027c92e0cb9ac3d0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf38bd84321261eff)),
	.hi = ((u64)(0x03fa849adf5e061a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x293cad0280eb4bff)),
	.hi = ((u64)(0x032ed07be5e4d1af)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xedca240200bc3ccc)),
	.hi = ((u64)(0x028bd9fcb7ea4158)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbe3b50019a3030a4)),
	.hi = ((u64)(0x02097b309321cde0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc9f88002904d1a9f)),
	.hi = ((u64)(0x03425eb41e9c7c9a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3b2d3335403daee6)),
	.hi = ((u64)(0x029b7ef67ee396e2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x95bdc291003158b8)),
	.hi = ((u64)(0x0215ff2b98b6124e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x892f9db4cd1bc126)),
	.hi = ((u64)(0x035665128df01d4a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x07594af70a7c9a85)),
	.hi = ((u64)(0x02ab840ed7f34aa2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6c476f2c0863aed1)),
	.hi = ((u64)(0x0222d00bdff5d54e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x13a57eacda3917b4)),
	.hi = ((u64)(0x036ae67966562217)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0fb7988a482dac90)),
	.hi = ((u64)(0x02bbeb9451de81ac)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd95fad3b6cf156da)),
	.hi = ((u64)(0x022fefa9db1867bc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf565e1f8ae4ef15c)),
	.hi = ((u64)(0x037fe5dc91c0a5fa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x911e4e608b725ab0)),
	.hi = ((u64)(0x02ccb7e3a7cd5195)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xda7ea51a0928488d)),
	.hi = ((u64)(0x023d5fe9530aa7aa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf7310829a8407415)),
	.hi = ((u64)(0x039566421e7772aa)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2c2739baed005cde)),
	.hi = ((u64)(0x02ddeb68185f8eef)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbcec2e2f24004a4b)),
	.hi = ((u64)(0x024b22b9ad193f25)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x94ad16b1d333aa11)),
	.hi = ((u64)(0x03ab6ac2ae8ecb6f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaa241227dc2954db)),
	.hi = ((u64)(0x02ef889bbed8a2bf)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x54e9a81fe35443e2)),
	.hi = ((u64)(0x02593a163246e899)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2175d9cc9eed396a)),
	.hi = ((u64)(0x03c1f689ea0b0dc2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe7917b0a18bdc788)),
	.hi = ((u64)(0x03019207ee6f3e34)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb9412f3b46fe393a)),
	.hi = ((u64)(0x0267a8065858fe90)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf535185ed7fd285c)),
	.hi = ((u64)(0x03d90cd6f3c1974d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc42a79e57997537d)),
	.hi = ((u64)(0x03140a458fce12a4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x03552e512e12a931)),
	.hi = ((u64)(0x02766e9e0ca4dbb7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9eeeb081e3510eb4)),
	.hi = ((u64)(0x03f0b0fce107c5f1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4bf226ce4f740bc3)),
	.hi = ((u64)(0x0326f3fd80d304c1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa3281f0b72c33c9c)),
	.hi = ((u64)(0x02858ffe00a8d09a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1c2018d5f568fd4a)),
	.hi = ((u64)(0x020473319a20a6e2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf9ccf48988a7fba9)),
	.hi = ((u64)(0x033a51e8f69aa49c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfb0a5d3ad3b99621)),
	.hi = ((u64)(0x02950e53f87bb6e3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2f3b7dc8a96144e7)),
	.hi = ((u64)(0x0210d8432d2fc583)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe52bfc7442353b0c)),
	.hi = ((u64)(0x034e26d1e1e608d1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb756639034f76270)),
	.hi = ((u64)(0x02a4ebdb1b1e6d74)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2c451c735d92b526)),
	.hi = ((u64)(0x021d897c15b1f12a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x13a1c71efc1deea3)),
	.hi = ((u64)(0x0362759355e981dd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x761b05b2634b2550)),
	.hi = ((u64)(0x02b52adc44bace4a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x91af37c1e908eaa6)),
	.hi = ((u64)(0x022a88b036fbd83b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x82b1f2cfdb417770)),
	.hi = ((u64)(0x03774119f192f392)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcef4c23fe29ac5f3)),
	.hi = ((u64)(0x02c5cdae5adbf60e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3f2a34ffe87bd190)),
	.hi = ((u64)(0x0237d7beaf165e72)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x984387ffda5fb5b2)),
	.hi = ((u64)(0x038c8c644b56fd83)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe0360666484c915b)),
	.hi = ((u64)(0x02d6d6b6a2abfe02)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x802b3851d3707449)),
	.hi = ((u64)(0x024578921bbccb35)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x99dec082ebe72075)),
	.hi = ((u64)(0x03a25a835f947855)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xae4bcd358985b391)),
	.hi = ((u64)(0x02e8486919439377)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbea30a913ad15c74)),
	.hi = ((u64)(0x02536d20e102dc5f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfdd1aa81f7b560b9)),
	.hi = ((u64)(0x03b8ae9b019e2d65)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x97daeece5fc44d61)),
	.hi = ((u64)(0x02fa2548ce182451)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdfe258a51969d781)),
	.hi = ((u64)(0x0261b76d71ace9da)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x996a276e8f0fbf34)),
	.hi = ((u64)(0x03cf8be24f7b0fc4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe121b9253f3fcc2a)),
	.hi = ((u64)(0x030c6fe83f95a636)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb41afa8432997022)),
	.hi = ((u64)(0x02705986994484f8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xecf7f739ea8f19cf)),
	.hi = ((u64)(0x03e6f5a4286da18d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x23f99294bba5ae40)),
	.hi = ((u64)(0x031f2ae9b9f14e0b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4ffadbaa2fb7be99)),
	.hi = ((u64)(0x027f5587c7f43e6f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7ff7c5dd1925fdc2)),
	.hi = ((u64)(0x03feef3fa6539718)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xccc637e4141e649b)),
	.hi = ((u64)(0x033258ffb842df46)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd704f983434b83af)),
	.hi = ((u64)(0x028ead9960357f6b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x126a6135cf6f9c8c)),
	.hi = ((u64)(0x020bbe144cf79923)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x83dd685618b29414)),
	.hi = ((u64)(0x0345fced47f28e9e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9cb12044e08edcdd)),
	.hi = ((u64)(0x029e63f1065ba54b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x16f419d0b3a57d7d)),
	.hi = ((u64)(0x02184ff405161dd6)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8b20294dec3bfbfb)),
	.hi = ((u64)(0x035a19866e89c956)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3c19baa4bcfcc996)),
	.hi = ((u64)(0x02ae7ad1f207d445)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc9ae2eea30ca3adf)),
	.hi = ((u64)(0x02252f0e5b39769d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0f7d17dd1add2afd)),
	.hi = ((u64)(0x036eb1b091f58a96)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3f97464a7be42264)),
	.hi = ((u64)(0x02bef48d41913bab)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xcc790508631ce850)),
	.hi = ((u64)(0x02325d3dce0dc955)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe0c1a1a704fb0d4d)),
	.hi = ((u64)(0x0383c862e3494222)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4d67b4859d95a43e)),
	.hi = ((u64)(0x02cfd3824f6dce82)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x711fc39e17aae9cb)),
	.hi = ((u64)(0x023fdc683f8b0b9b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe832d2968c44a945)),
	.hi = ((u64)(0x039960a6cc11ac2b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xecf575453d03ba9e)),
	.hi = ((u64)(0x02e11a1f09a7bcef)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x572ac4376402fbb1)),
	.hi = ((u64)(0x024dae7f3aec9726)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x58446d256cd192b5)),
	.hi = ((u64)(0x03af7d985e47583d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x79d0575123dadbc4)),
	.hi = ((u64)(0x02f2cae04b6c4697)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x94a6ac40e97be303)),
	.hi = ((u64)(0x025bd5803c569edf)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8771139b0f2c9e6c)),
	.hi = ((u64)(0x03c62266c6f0fe32)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9f8da948d8f07ebd)),
	.hi = ((u64)(0x0304e85238c0cb5b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe60aedd3e0c06564)),
	.hi = ((u64)(0x026a5374fa33d5e2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa344afb9679a3bd2)),
	.hi = ((u64)(0x03dd5254c3862304)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe903bfc78614fca8)),
	.hi = ((u64)(0x031775109c6b4f36)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xba6966393810ca20)),
	.hi = ((u64)(0x02792a73b055d8f8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2a423d2859b4769a)),
	.hi = ((u64)(0x03f510b91a22f4c1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xee9b642047c39215)),
	.hi = ((u64)(0x032a73c7481bf700)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbee2b680396941aa)),
	.hi = ((u64)(0x02885c9f6ce32c00)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xff1bc53361210155)),
	.hi = ((u64)(0x0206b07f8a4f5666)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x31c6085235019bbb)),
	.hi = ((u64)(0x033de73276e5570b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x27d1a041c4014963)),
	.hi = ((u64)(0x0297ec285f1ddf3c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xeca7b367d0010782)),
	.hi = ((u64)(0x021323537f4b18fc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xadd91f0c8001a59d)),
	.hi = ((u64)(0x0351d21f3211c194)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf17a7f3d3334847e)),
	.hi = ((u64)(0x02a7db4c280e3476)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x279532975c2a0398)),
	.hi = ((u64)(0x021fe2a3533e905f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd8eeb75893766c26)),
	.hi = ((u64)(0x0366376bb8641a31)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7a5892ad42c52352)),
	.hi = ((u64)(0x02b82c562d1ce1c1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xfb7a0ef102374f75)),
	.hi = ((u64)(0x022cf044f0e3e7cd)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc59017e8038bb254)),
	.hi = ((u64)(0x037b1a07e7d30c7c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x37a67986693c8eaa)),
	.hi = ((u64)(0x02c8e19feca8d6ca)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf951fad1edca0bbb)),
	.hi = ((u64)(0x023a4e198a20abd4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x28832ae97c76792b)),
	.hi = ((u64)(0x03907cf5a9cddfbb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2068ef21305ec756)),
	.hi = ((u64)(0x02d9fd9154a4b2fc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x19ed8c1a8d189f78)),
	.hi = ((u64)(0x0247fe0ddd508f30)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5caf4690e1c0ff26)),
	.hi = ((u64)(0x03a66349621a7eb3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4a25d20d81673285)),
	.hi = ((u64)(0x02eb82a11b48655c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3b5174d79ab8f537)),
	.hi = ((u64)(0x0256021a7c39eab0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x921bee25c45b21f1)),
	.hi = ((u64)(0x03bcd02a605caab3)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdb498b5169e2818e)),
	.hi = ((u64)(0x02fd735519e3bbc2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x15d46f7454b53472)),
	.hi = ((u64)(0x02645c4414b62fcf)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xefba4bed545520b6)),
	.hi = ((u64)(0x03d3c6d35456b2e4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf2fb6ff110441a2b)),
	.hi = ((u64)(0x030fd242a9def583)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8f2f8cc0d9d014ef)),
	.hi = ((u64)(0x02730e9bbb18c469)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb1e5ae015c80217f)),
	.hi = ((u64)(0x03eb4a92c4f46d75)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc1848b344a001acc)),
	.hi = ((u64)(0x0322a20f03f6bdf7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xce03a2903b3348a3)),
	.hi = ((u64)(0x02821b3f365efe5f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd802e873628f6d4f)),
	.hi = ((u64)(0x0201af65c518cb7f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x599e40b89db2487f)),
	.hi = ((u64)(0x0335e56fa1c14599)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe14b66fa17c1d399)),
	.hi = ((u64)(0x029184594e3437ad)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x81091f2e7967dc7a)),
	.hi = ((u64)(0x020e037aa4f692f1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9b41cb7d8f0c93f6)),
	.hi = ((u64)(0x03499f2aa18a84b5)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xaf67d5fe0c0a0ff8)),
	.hi = ((u64)(0x02a14c221ad536f7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf2b977fe70080cc7)),
	.hi = ((u64)(0x021aa34e7bddc592)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1df58cca4cd9ae0b)),
	.hi = ((u64)(0x035dd2172c9608eb)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe4c470a1d7148b3c)),
	.hi = ((u64)(0x02b174df56de6d88)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x83d05a1b1276d5ca)),
	.hi = ((u64)(0x022790b2abe5246d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9fb3c35e83f1560f)),
	.hi = ((u64)(0x0372811ddfd50715)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb2f635e5365aab3f)),
	.hi = ((u64)(0x02c200e4b310d277)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf591c4b75eaeef66)),
	.hi = ((u64)(0x0234cd83c273db92)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xef4fa125644b18a3)),
	.hi = ((u64)(0x0387af39371fc5b7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8c3fb41de9d5ad4f)),
	.hi = ((u64)(0x02d2f2942c196af9)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3cffc34b2177bdd9)),
	.hi = ((u64)(0x02425ba9bce12261)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x94cc6bab68bf9628)),
	.hi = ((u64)(0x039d5f75fb01d09b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x10a38955ed6611b9)),
	.hi = ((u64)(0x02e44c5e6267da16)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xda1c6dde5784dafb)),
	.hi = ((u64)(0x02503d184eb97b44)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf693e2fd58d49191)),
	.hi = ((u64)(0x03b394f3b128c53a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc5431bfde0aa0e0e)),
	.hi = ((u64)(0x02f610c2f4209dc8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x6a9c1664b3bb3e72)),
	.hi = ((u64)(0x025e73cf29b3b16d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x10f9bd6dec5eca4f)),
	.hi = ((u64)(0x03ca52e50f85e8af)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xda616457f04bd50c)),
	.hi = ((u64)(0x03084250d937ed58)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe1e783798d09773d)),
	.hi = ((u64)(0x026d01da475ff113)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x030c058f480f252e)),
	.hi = ((u64)(0x03e19c9072331b53)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x68d66ad906728425)),
	.hi = ((u64)(0x031ae3a6c1c27c42)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8711ef14052869b7)),
	.hi = ((u64)(0x027be952349b969b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0b4fe4ecd50d75f2)),
	.hi = ((u64)(0x03f97550542c242c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa2a650bd773df7f5)),
	.hi = ((u64)(0x032df7737689b689)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb551da312c31932a)),
	.hi = ((u64)(0x028b2c5c5ed49207)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5ddb14f4235adc22)),
	.hi = ((u64)(0x0208f049e576db39)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2fc4ee536bc49369)),
	.hi = ((u64)(0x034180763bf15ec2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xbfd0bea92303a921)),
	.hi = ((u64)(0x029acd2b63277f01)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9973cbba8269541a)),
	.hi = ((u64)(0x021570ef8285ff34)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5bec792a6a42202a)),
	.hi = ((u64)(0x0355817f373ccb87)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe3239421ee9b4cef)),
	.hi = ((u64)(0x02aacdff5f63d605)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb5b6101b25490a59)),
	.hi = ((u64)(0x02223e65e5e97804)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x22bce691d541aa27)),
	.hi = ((u64)(0x0369fd6fd64259a1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb563eba7ddce21b9)),
	.hi = ((u64)(0x02bb31264501e14d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf78322ecb171b494)),
	.hi = ((u64)(0x022f5a850401810a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x259e9e47824f8753)),
	.hi = ((u64)(0x037ef73b399c01ab)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1e187e9f9b72d2a9)),
	.hi = ((u64)(0x02cbf8fc2e1667bc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4b46cbb2e2c24221)),
	.hi = ((u64)(0x023cc73024deb963)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x120adf849e039d01)),
	.hi = ((u64)(0x039471e6a1645bd2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdb3be603b19c7d9a)),
	.hi = ((u64)(0x02dd27ebb4504974)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x7c2feb3627b0647c)),
	.hi = ((u64)(0x024a865629d9d45d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2d197856a5e7072c)),
	.hi = ((u64)(0x03aa7089dc8fba2f)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8a7ac6abb7ec05bd)),
	.hi = ((u64)(0x02eec06e4a0c94f2)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd52f05562cbcd164)),
	.hi = ((u64)(0x025899f1d4d6dd8e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x21e4d556adfae8a0)),
	.hi = ((u64)(0x03c0f64fbaf1627e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe7ea444557fbed4d)),
	.hi = ((u64)(0x0300c50c958de864)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xecbb69d1132ff10a)),
	.hi = ((u64)(0x0267040a113e5383)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xadf8a94e851981aa)),
	.hi = ((u64)(0x03d8067681fd526c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8b2d543ed0e13488)),
	.hi = ((u64)(0x0313385ece6441f0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd5bddcff0d80f6d3)),
	.hi = ((u64)(0x0275c6b23eb69b26)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x892fc7fe7c018aeb)),
	.hi = ((u64)(0x03efa45064575ea4)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3a8c9ffec99ad589)),
	.hi = ((u64)(0x03261d0d1d12b21d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc8707fff07af113b)),
	.hi = ((u64)(0x0284e40a7da88e7d)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x39f39998d2f2742f)),
	.hi = ((u64)(0x0203e9a1fe2071fe)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x8fec28f484b7204b)),
	.hi = ((u64)(0x033975cffd00b663)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xd989ba5d36f8e6a2)),
	.hi = ((u64)(0x02945e3ffd9a2b82)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x47a161e42bfa521c)),
	.hi = ((u64)(0x02104b66647b5602)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0c35696d132a1cf9)),
	.hi = ((u64)(0x034d4570a0c5566a)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x09c454574288172d)),
	.hi = ((u64)(0x02a4378d4d6aab88)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xa169dd129ba0128b)),
	.hi = ((u64)(0x021cf93dd7888939)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x0242fb50f9001dab)),
	.hi = ((u64)(0x03618ec958da7529)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x9b68c90d940017bc)),
	.hi = ((u64)(0x02b4723aad7b90ed)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x4920a0d7a999ac96)),
	.hi = ((u64)(0x0229f4fbbdfc73f1)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x750101590f5c4757)),
	.hi = ((u64)(0x037654c5fcc71fe8)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2a6734473f7d05df)),
	.hi = ((u64)(0x02c5109e63d27fed)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xeeb8f69f65fd9e4c)),
	.hi = ((u64)(0x0237407eb641fff0)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe45b24323cc8fd46)),
	.hi = ((u64)(0x038b9a6456cfffe7)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xb6af502830a0ca9f)),
	.hi = ((u64)(0x02d6151d123fffec)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xf88c402026e7087f)),
	.hi = ((u64)(0x0244ddb0db666656)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x2746cd003e3e73fe)),
	.hi = ((u64)(0x03a162b4923d708b)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x1f6bd73364fec332)),
	.hi = ((u64)(0x02e7822a0e978d3c)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xe5efdf5c50cbcf5b)),
	.hi = ((u64)(0x0252ce880bac70fc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x3cb2fefa1adfb22b)),
	.hi = ((u64)(0x03b7b0d9ac471b2e)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x308f3261af195b56)),
	.hi = ((u64)(0x02f95a47bd05af58)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x5a0c284e25ade2ab)),
	.hi = ((u64)(0x0261150630d15913)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x29ad0d49d5e30445)),
	.hi = ((u64)(0x03ce8809e7b55b52)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x548a7107de4f369d)),
	.hi = ((u64)(0x030ba007ec9115db)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xdd3b8d9fe50c2bb1)),
	.hi = ((u64)(0x026fb3398a0dab15)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x952c15cca1ad12b5)),
	.hi = ((u64)(0x03e5eb8f434911bc)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0x775677d6e7bda891)),
	.hi = ((u64)(0x031e560c35d40e30)),
}, (strconv__ftoa__Uint128){
	.lo = ((u64)(0xc5dec645863153a7)),
	.hi = ((u64)(0x027eab3cf7dcd826)),
}, 
});
	_const_strconv__DOUBLE_PLUS_ZERO = ((u64)(0x0000000000000000));
	_const_strconv__DOUBLE_MINUS_ZERO = ((u64)(0x8000000000000000));
	_const_strconv__DOUBLE_PLUS_INFINITY = ((u64)(0x7FF0000000000000));
	_const_strconv__DOUBLE_MINUS_INFINITY = ((u64)(0xFFF0000000000000));
	_const_strconv__TEN = ((u32)(10));
	_const_strconv__max_u64 = ((u64)(UINT64_MAX));
	_const_strconv__dec_round = new_array_from_c_array(20, 20, sizeof(f64), (f64[20]){
		((f64)(0.44)), 0.044, 0.0044, 0.00044, 0.000044, 0.0000044, 0.00000044, 0.000000044, 0.0000000044, 0.00000000044, 0.000000000044, 0.0000000000044, 0.00000000000044, 0.000000000000044, 0.0000000000000044, 0.00000000000000044, 0.000000000000000044, 0.0000000000000000044, 0.00000000000000000044, 0.000000000000000000044, 
});
	_const_init_capicity = 1 << _const_init_log_capicity;
	_const_init_cap = _const_init_capicity - 2;
	_const_hash_mask = ((u32)(0x00FFFFFF));
	_const_probe_inc = ((u32)(0x01000000));
	_const_mid_index = _const_degree - 1;
	_const_max_size = 2 * _const_degree - 1;
	_const_children_bytes = sizeof(voidptr) * (_const_max_size + 1);
	_const_os__STD_INPUT_HANDLE = -10;
	_const_os__STD_OUTPUT_HANDLE = -11;
	_const_os__STD_ERROR_HANDLE = -12;
	_const_os__args = __new_array(0, 0, sizeof(string));
	_const_os__wd_at_startup = os__getwd();
	_const_v__token__assign_tokens = new_array_from_c_array(11, 11, sizeof(v__token__Kind), (v__token__Kind[11]){
		v__token__Kind_assign, v__token__Kind_plus_assign, v__token__Kind_minus_assign, v__token__Kind_mult_assign, v__token__Kind_div_assign, v__token__Kind_xor_assign, v__token__Kind_mod_assign, v__token__Kind_or_assign, v__token__Kind_and_assign, v__token__Kind_right_shift_assign, v__token__Kind_left_shift_assign, 
});
	_const_v__token__nr_tokens = ((int)(v__token__Kind__end_));
	_const_v__token__token_str = v__token__build_token_str();
	_const_v__token__keywords = v__token__build_keys();
	_const_v__token__precedences = v__token__build_precedences();
	_const_time__month_days = new_array_from_c_array(12, 12, sizeof(int), (int[12]){
		31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 
});
	_const_time__absolute_zero_year = ((i64)(-292277022399));
	_const_time__seconds_per_hour = 60 * _const_time__seconds_per_minute;
	_const_time__seconds_per_day = 24 * _const_time__seconds_per_hour;
	_const_time__seconds_per_week = 7 * _const_time__seconds_per_day;
	_const_time__days_per_400_years = 365 * 400 + 97;
	_const_time__days_per_100_years = 365 * 100 + 24;
	_const_time__days_per_4_years = 365 * 4 + 1;
	_const_time__days_before = new_array_from_c_array(13, 13, sizeof(int), (int[13]){
		0, 31, 31 + 28, 31 + 28 + 31, 31 + 28 + 31 + 30, 31 + 28 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31, 
});
	_const_time__nanosecond = ((time__Duration)(1));
	_const_time__microsecond = ((time__Duration)(1000)) * _const_time__nanosecond;
	_const_time__millisecond = ((time__Duration)(1000)) * _const_time__microsecond;
	_const_time__second = ((time__Duration)(1000)) * _const_time__millisecond;
	_const_time__minute = ((time__Duration)(60)) * _const_time__second;
	_const_time__hour = ((time__Duration)(60)) * _const_time__minute;
	_const_v__vmod__MOD_FILE_STOP_PATHS = new_array_from_c_array(4, 4, sizeof(string), (string[4]){
		tos3(".git"), tos3(".hg"), tos3(".svn"), tos3(".v.mod.stop"), 
});
	_const_v__vmod__mod_file_cacher = v__vmod__new_mod_file_cacher();
	_const_v__table__integer_type_idxs = new_array_from_c_array(8, 8, sizeof(int), (int[8]){
		_const_v__table__i8_type_idx, _const_v__table__i16_type_idx, _const_v__table__int_type_idx, _const_v__table__i64_type_idx, _const_v__table__byte_type_idx, _const_v__table__u16_type_idx, _const_v__table__u32_type_idx, _const_v__table__u64_type_idx, 
});
	_const_v__table__signed_integer_type_idxs = new_array_from_c_array(4, 4, sizeof(int), (int[4]){
		_const_v__table__i8_type_idx, _const_v__table__i16_type_idx, _const_v__table__int_type_idx, _const_v__table__i64_type_idx, 
});
	_const_v__table__unsigned_integer_type_idxs = new_array_from_c_array(4, 4, sizeof(int), (int[4]){
		_const_v__table__byte_type_idx, _const_v__table__u16_type_idx, _const_v__table__u32_type_idx, _const_v__table__u64_type_idx, 
});
	_const_v__table__float_type_idxs = new_array_from_c_array(2, 2, sizeof(int), (int[2]){
		_const_v__table__f32_type_idx, _const_v__table__f64_type_idx, 
});
	_const_v__table__number_type_idxs = new_array_from_c_array(10, 10, sizeof(int), (int[10]){
		_const_v__table__i8_type_idx, _const_v__table__i16_type_idx, _const_v__table__int_type_idx, _const_v__table__i64_type_idx, _const_v__table__byte_type_idx, _const_v__table__u16_type_idx, _const_v__table__u32_type_idx, _const_v__table__u64_type_idx, _const_v__table__f32_type_idx, _const_v__table__f64_type_idx, 
});
	_const_v__table__pointer_type_idxs = new_array_from_c_array(3, 3, sizeof(int), (int[3]){
		_const_v__table__voidptr_type_idx, _const_v__table__byteptr_type_idx, _const_v__table__charptr_type_idx, 
});
	_const_v__table__string_type_idxs = new_array_from_c_array(2, 2, sizeof(int), (int[2]){
		_const_v__table__string_type_idx, _const_v__table__ustring_type_idx, 
});
	_const_v__table__void_type = v__table__new_type(_const_v__table__void_type_idx);
	_const_v__table__voidptr_type = v__table__new_type(_const_v__table__voidptr_type_idx);
	_const_v__table__byteptr_type = v__table__new_type(_const_v__table__byteptr_type_idx);
	_const_v__table__charptr_type = v__table__new_type(_const_v__table__charptr_type_idx);
	_const_v__table__i8_type = v__table__new_type(_const_v__table__i8_type_idx);
	_const_v__table__int_type = v__table__new_type(_const_v__table__int_type_idx);
	_const_v__table__i16_type = v__table__new_type(_const_v__table__i16_type_idx);
	_const_v__table__i64_type = v__table__new_type(_const_v__table__i64_type_idx);
	_const_v__table__byte_type = v__table__new_type(_const_v__table__byte_type_idx);
	_const_v__table__u16_type = v__table__new_type(_const_v__table__u16_type_idx);
	_const_v__table__u32_type = v__table__new_type(_const_v__table__u32_type_idx);
	_const_v__table__u64_type = v__table__new_type(_const_v__table__u64_type_idx);
	_const_v__table__f32_type = v__table__new_type(_const_v__table__f32_type_idx);
	_const_v__table__f64_type = v__table__new_type(_const_v__table__f64_type_idx);
	_const_v__table__char_type = v__table__new_type(_const_v__table__char_type_idx);
	_const_v__table__bool_type = v__table__new_type(_const_v__table__bool_type_idx);
	_const_v__table__none_type = v__table__new_type(_const_v__table__none_type_idx);
	_const_v__table__string_type = v__table__new_type(_const_v__table__string_type_idx);
	_const_v__table__ustring_type = v__table__new_type(_const_v__table__ustring_type_idx);
	_const_v__table__array_type = v__table__new_type(_const_v__table__array_type_idx);
	_const_v__table__map_type = v__table__new_type(_const_v__table__map_type_idx);
	_const_v__table__any_type = v__table__new_type(_const_v__table__any_type_idx);
	_const_v__table__builtin_type_names = new_array_from_c_array(26, 26, sizeof(string), (string[26]){
		tos3("void"), tos3("voidptr"), tos3("charptr"), tos3("byteptr"), tos3("i8"), tos3("i16"), tos3("int"), tos3("i64"), tos3("u16"), tos3("u32"), tos3("u64"), tos3("f32"), tos3("f64"), tos3("string"), tos3("ustring"), tos3("char"), tos3("byte"), tos3("bool"), tos3("none"), tos3("array"), tos3("array_fixed"), tos3("map"), tos3("any"), tos3("struct"), tos3("mapnode"), tos3("size_t"), 
});
	_const_v__pref__default_module_path = v__pref__mpath();
	_const_v__util__emanager = v__util__new_error_manager();
	_const_v__util__builtin_module_parts = new_array_from_c_array(5, 5, sizeof(string), (string[5]){
		tos3("math.bits"), tos3("strconv"), tos3("strconv.ftoa"), tos3("hash.wyhash"), tos3("strings"), 
});
	_const_v__gen__c_reserved = new_array_from_c_array(32, 32, sizeof(string), (string[32]){
		tos3("delete"), tos3("exit"), tos3("unix"), tos3("error"), tos3("calloc"), tos3("malloc"), tos3("free"), tos3("panic"), tos3("auto"), tos3("char"), tos3("default"), tos3("do"), tos3("double"), tos3("extern"), tos3("float"), tos3("inline"), tos3("int"), tos3("long"), tos3("register"), tos3("restrict"), tos3("short"), tos3("signed"), tos3("sizeof"), tos3("static"), tos3("switch"), tos3("typedef"), tos3("union"), tos3("unsigned"), tos3("void"), tos3("volatile"), tos3("while"), tos3("new"), 
});
	_const_v__gen__tabs = new_array_from_c_array(9, 9, sizeof(string), (string[9]){
		tos3(""), tos3("\t"), tos3("\t\t"), tos3("\t\t\t"), tos3("\t\t\t\t"), tos3("\t\t\t\t\t"), tos3("\t\t\t\t\t\t"), tos3("\t\t\t\t\t\t\t"), tos3("\t\t\t\t\t\t\t\t"), 
});
	_const_v__gen__builtins = new_array_from_c_array(6, 6, sizeof(string), (string[6]){
		tos3("string"), tos3("array"), tos3("KeyValue"), tos3("DenseArray"), tos3("map"), tos3("Option"), 
});
	_const_v__gen__c_headers = _STR("\n\n// c_headers\n#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually\n#include <stdlib.h>\n\n//#include \"fns.h\"\n#include <signal.h>\n#include <stdarg.h> // for va_list\n#include <string.h> // memcpy\n\n#if INTPTR_MAX == INT32_MAX\n    #define TARGET_IS_32BIT 1\n#elif INTPTR_MAX == INT64_MAX\n    #define TARGET_IS_64BIT 1\n#else\n    #error \"The environment is not 32 or 64-bit.\"\n#endif\n\n#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)\n    #define TARGET_ORDER_IS_BIG\n#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_X64) || defined(_M_IX86)\n    #define TARGET_ORDER_IS_LITTLE\n#else\n    #error \"Unknown architecture endianness\"\n#endif\n\n#ifndef _WIN32\n#include <ctype.h>\n#include <locale.h> // tolower\n#include <sys/time.h>\n#include <unistd.h> // sleep\nextern char **environ;\n#endif\n\n#if defined(__CYGWIN__) && !defined(_WIN32)\n#error Cygwin is not supported, please use MinGW or Visual Studio.\n#endif\n\n\n#ifdef __linux__\n#include <sys/types.h>\n#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __FreeBSD__\n#include <sys/types.h>\n#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __DragonFly__\n#include <sys/types.h>\n#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __OpenBSD__\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __NetBSD__\n#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef __sun\n#include <sys/types.h>\n#include <sys/wait.h> // os__wait uses wait on nix\n#endif\n\n%.*s\000\n\n#ifdef _WIN32\n#define WINVER 0x0600\n#ifdef _WIN32_WINNT\n#undef _WIN32_WINNT\n#endif\n#define _WIN32_WINNT 0x0600\n#define WIN32_LEAN_AND_MEAN\n#define _UNICODE\n#define UNICODE\n#include <windows.h>\n\n#include <io.h> // _waccess\n#include <direct.h> // _wgetcwd\n//#include <WinSock2.h>\n#ifdef _MSC_VER\n\n// On MSVC these are the same (as long as /volatile:ms is passed)\n#define _Atomic volatile\n\n// MSVC cannot parse some things properly\n#undef EMPTY_STRUCT_DECLARATION\n#undef OPTION_CAST\n\n#define EMPTY_STRUCT_DECLARATION int ____dummy_variable\n#define OPTION_CAST(x)\n\n#include <dbghelp.h>\n#pragma comment(lib, \"Dbghelp.lib\")\n\nextern wchar_t **_wenviron;\n\n#endif\n\n#else\n#include <pthread.h>\n#endif\n\n// g_live_info is used by live.info()\nvoid* g_live_info = NULL;\n\n//============================== HELPER C MACROS =============================*/\n//#define tos4(s, slen) ((string){.str=(s), .len=(slen)})\n#define _SLIT(s) ((string){.str=(s), .len=(strlen(s))})\n#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}\n#define _IN(typ, val, arr) array_##typ##_contains(arr, val)\n#define _IN_MAP(val, m) map_exists(m, val)\n#define DEFAULT_EQUAL(a, b) (a == b)\n#define DEFAULT_NOT_EQUAL(a, b) (a != b)\n#define DEFAULT_LT(a, b) (a < b)\n#define DEFAULT_LE(a, b) (a <= b)\n#define DEFAULT_GT(a, b) (a > b)\n#define DEFAULT_GE(a, b) (a >= b)\n\n// NB: macro_fXX_eq and macro_fXX_ne are NOT used\n// in the generated C code. They are here just for\n// completeness/testing.\n\n#define macro_f64_eq(a, b) (a == b)\n#define macro_f64_ne(a, b) (a != b)\n#define macro_f64_lt(a, b) (a <  b)\n#define macro_f64_le(a, b) (a <= b)\n#define macro_f64_gt(a, b) (a >  b)\n#define macro_f64_ge(a, b) (a >= b)\n\n#define macro_f32_eq(a, b) (a == b)\n#define macro_f32_ne(a, b) (a != b)\n#define macro_f32_lt(a, b) (a <  b)\n#define macro_f32_le(a, b) (a <= b)\n#define macro_f32_gt(a, b) (a >  b)\n#define macro_f32_ge(a, b) (a >= b)\n\n#if defined(__MINGW32__) || defined(__MINGW64__)\n#undef PRId64\n#undef PRIi64\n#undef PRIo64\n#undef PRIu64\n#undef PRIx64\n#undef PRIX64\n#define PRId64 \"lld\"\n#define PRIi64 \"lli\"\n#define PRIo64 \"llo\"\n#define PRIu64 \"llu\"\n#define PRIx64 \"llx\"\n#define PRIX64 \"llX\"\n#endif\n\n//================================== GLOBALS =================================*/\nbyte g_str_buf[1024];\nint load_so(byteptr);\nvoid reload_so();\nvoid _vinit();\nvoid _vcleanup();\n#define sigaction_size sizeof(sigaction);\n#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )\n\n// ============== wyhash ==============\n//Author: Wang Yi\n#ifndef wyhash_version_gamma\n#define wyhash_version_gamma\n#define WYHASH_CONDOM 0\n#include <stdint.h>\n#include <string.h>\n#if defined(_MSC_VER) && defined(_M_X64)\n#include <intrin.h>\n#pragma intrinsic(_umul128)\n#endif\n\n//const uint64_t _wyp0=0xa0761d6478bd642full, _wyp1=0xe7037ed1a0b428dbull;\n#define _wyp0 ((uint64_t)0xa0761d6478bd642full)\n#define _wyp1 ((uint64_t)0xe7037ed1a0b428dbull)\n\n\n#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__) || defined(__TINYC__)\n#define _likely_(x) __builtin_expect(x, 1)\n#else\n#define _likely_(x) (x)\n#endif\n\n#if defined(TARGET_ORDER_IS_LITTLE)\n#define WYHASH_LITTLE_ENDIAN 1\n#elif defined(TARGET_ORDER_IS_BIG)\n#define WYHASH_LITTLE_ENDIAN 0\n#endif\n\n#if (WYHASH_LITTLE_ENDIAN)\n  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}\n  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return v;}\n#else\n#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)\n  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}\n  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return __builtin_bswap32(v);}\n#elif defined(_MSC_VER)\n  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}\n  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return _byteswap_ulong(v);}\n#elif defined(__TINYC__)\n  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return bswap_64(v);}\n  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return bswap_32(v);}\n#endif\n#endif\n\nstatic inline uint64_t _wyr3(const uint8_t *p, unsigned k) { return (((uint64_t)p[0]) << 16) | (((uint64_t)p[k >> 1]) << 8) | p[k - 1];}\nstatic inline uint64_t _wyrotr(uint64_t v, unsigned k) { return (v >> k) | (v << (64 - k));}\nstatic inline void _wymix128(uint64_t A, uint64_t B, uint64_t *C, uint64_t *D){\n	A^=*C;	B^=*D;\n#ifdef UNOFFICIAL_WYHASH_32BIT\n	uint64_t hh=(A>>32)*(B>>32), hl=(A>>32)*(unsigned)B, lh=(unsigned)A*(B>>32), ll=(uint64_t)(unsigned)A*(unsigned)B;\n	*C=_wyrotr(hl,32)^hh; *D=_wyrotr(lh,32)^ll;\n#else\n#ifdef __SIZEOF_INT128__\n	__uint128_t r=A; r*=B; *C=(uint64_t)r; *D=(uint64_t)(r>>64);\n#elif defined(_MSC_VER) && defined(_M_X64)\n	A=_umul128(A,B,&B); *C=A; *D=B;\n#else\n	uint64_t ha=A>>32, hb=B>>32, la=(uint32_t)A, lb=(uint32_t)B, hi, lo;\n	uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;\n	lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;\n	*C=lo;	*D=hi;\n#endif\n#endif\n}\nstatic inline uint64_t wyhash(const void *key, uint64_t len, uint64_t seed){\n	const uint8_t *p=(const uint8_t *)key;\n	uint64_t i=len, see1=seed;\n	start:\n	if(_likely_(i<=16)){\n	#ifndef	WYHASH_CONDOM\n		uint64_t shift=(i<8)*((8-i)<<3);\n		//WARNING: intended reading outside buffer, trading for speed.\n		_wymix128((_wyr8(p)<<shift)^_wyp0,(_wyr8(p+i-8)>>shift)^_wyp1, &seed, &see1);\n	#else\n		if(_likely_(i<=8)){\n			if(_likely_(i>=4))	_wymix128(_wyr4(p)^_wyp0,_wyr4(p+i-4)^_wyp1, &seed, &see1);\n			else if (_likely_(i))	_wymix128(_wyr3(p,i)^_wyp0,_wyp1, &seed, &see1);\n			else	_wymix128(_wyp0,_wyp1, &seed, &see1);\n		}\n  		else	_wymix128(_wyr8(p)^_wyp0,_wyr8(p+i-8)^_wyp1, &seed, &see1);\n	#endif\n		_wymix128(len,_wyp0, &seed, &see1);\n		return	seed^see1;\n	}\n	_wymix128(_wyr8(p)^_wyp0,_wyr8(p+8)^_wyp1, &seed, &see1);\n	i-=16;	p+=16;	goto start;\n}\nstatic inline uint64_t wyhash64(uint64_t A, uint64_t B){\n	_wymix128(_wyp0,_wyp1,&A,&B);\n	_wymix128(0,0,&A,&B);\n	return	A^B;\n}\nstatic inline uint64_t wyrand(uint64_t *seed){\n	*seed+=_wyp0;\n	uint64_t	a=0, b=0;\n	_wymix128(*seed,*seed^_wyp1,&a,&b);\n	return	a^b;\n}\nstatic inline double wy2u01(uint64_t r) {\n	const double _wynorm=1.0/(1ull<<52);\n	return (r>>12)*_wynorm;\n}\nstatic inline double wy2gau(uint64_t r) {\n	const double _wynorm=1.0/(1ull<<20);\n	return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;\n}\n#endif\n\n", 2, _const_v__gen__c_common_macros);
	_const_v__gen__bare_c_headers = _STR("\n\n%.*s\000\n\n#ifndef exit\n#define exit(rc) sys_exit(rc)\nvoid sys_exit (int);\n#endif\n\n", 2, _const_v__gen__c_common_macros);
	_const_v__gen__js__js_reserved = new_array_from_c_array(14, 14, sizeof(string), (string[14]){
		tos3("delete"), tos3("const"), tos3("let"), tos3("var"), tos3("function"), tos3("continue"), tos3("break"), tos3("switch"), tos3("for"), tos3("in"), tos3("of"), tos3("instanceof"), tos3("typeof"), tos3("do"), 
});
	_const_v__gen__js__tabs = new_array_from_c_array(9, 9, sizeof(string), (string[9]){
		tos3(""), tos3("\t"), tos3("\t\t"), tos3("\t\t\t"), tos3("\t\t\t\t"), tos3("\t\t\t\t\t"), tos3("\t\t\t\t\t\t"), tos3("\t\t\t\t\t\t\t"), tos3("\t\t\t\t\t\t\t\t"), 
});
	_const_v__gen__x64__mag0 = ((byte)(0x7f));
	_const_v__gen__x64__fn_arg_registers = new_array_from_c_array(6, 6, sizeof(v__gen__x64__Register), (v__gen__x64__Register[6]){
		v__gen__x64__Register_rdi, v__gen__x64__Register_rsi, v__gen__x64__Register_rdx, v__gen__x64__Register_rcx, v__gen__x64__Register_r8, v__gen__x64__Register_r9, 
});
	_const_v__parser__supported_platforms = new_array_from_c_array(14, 14, sizeof(string), (string[14]){
		tos3("windows"), tos3("mac"), tos3("macos"), tos3("darwin"), tos3("linux"), tos3("freebsd"), tos3("openbsd"), tos3("netbsd"), tos3("dragonfly"), tos3("android"), tos3("js"), tos3("solaris"), tos3("haiku"), tos3("linux_or_macos"), 
});
	_const_v__parser__todo_delete_me = v__pref__OS_linux;
	_const_v__builder__HKEY_LOCAL_MACHINE = ((v__builder__RegKey)(0x80000002));
	_const_v__builder__KEY_QUERY_VALUE = (0x0001);
	_const_v__builder__KEY_WOW64_32KEY = (0x0200);
	_const_v__builder__KEY_ENUMERATE_SUB_KEYS = (0x0008);
	_const_simple_cmd = new_array_from_c_array(13, 13, sizeof(string), (string[13]){
		tos3("fmt"), tos3("up"), tos3("self"), tos3("test"), tos3("test-fmt"), tos3("test-compiler"), tos3("test-fixed"), tos3("bin2v"), tos3("repl"), tos3("build-tools"), tos3("build-examples"), tos3("build-vbinaries"), tos3("setup-freetype"), 
});
	_const_list_of_flags_that_allow_duplicates = new_array_from_c_array(5, 5, sizeof(string), (string[5]){
		tos3("cc"), tos3("d"), tos3("define"), tos3("cf"), tos3("cflags"), 
});
	_const_list_of_flags_with_param = new_array_from_c_array(14, 14, sizeof(string), (string[14]){
		tos3("o"), tos3("output"), tos3("d"), tos3("define"), tos3("b"), tos3("backend"), tos3("cc"), tos3("os"), tos3("target-os"), tos3("arch"), tos3("csource"), tos3("cf"), tos3("cflags"), tos3("path"), 
});

}

int main(int ___argc, char** ___argv){
	_vinit();
	_const_os__args = os__init_os_args(___argc, (byteptr*)___argv);
array_string args = array_slice(_const_os__args, 1, _const_os__args.len);
if (args.len == 0 || (string_eq((*(string*)array_get(args, 0)), tos3("-")) || string_eq((*(string*)array_get(args, 0)), tos3("repl")))) {
	if (args.len == 0) {
		println(tos3("For usage information, quit V REPL using `exit` and use `v help`"));
	}
	v__util__launch_tool(false, tos3("vrepl"));
	return 0;
}
if (args.len > 0 && ((string_eq((*(string*)array_get(args, 0)), tos3("version")) || string_eq((*(string*)array_get(args, 0)), tos3("-V")) || string_eq((*(string*)array_get(args, 0)), tos3("-version")) || string_eq((*(string*)array_get(args, 0)), tos3("--version"))) || (string_eq((*(string*)array_get(args, 0)), tos3("-v")) && args.len == 1))) {
	println(v__util__full_v_version());
	return 0;
}
array_string args_and_flags = array_slice(v__util__join_env_vflags_and_os_args(), 1, v__util__join_env_vflags_and_os_args().len);
multi_return_v__pref__Preferences_string mr_1376 = parse_args(args_and_flags);
v__pref__Preferences* prefs = mr_1376.arg0;
string command = mr_1376.arg1;
if (prefs->is_verbose) {
	println(_STR("command = \"%.*s\000\"", 2, command));
	println(v__util__full_v_version());
}
if (prefs->is_verbose) {
}
if (_IN(string, command, _const_simple_cmd)) {
	v__util__launch_tool(prefs->is_verbose, string_add(tos3("v"), command));
	return 0;
}
if (string_eq(command, tos3("help"))) {
	invoke_help_and_exit(args);
}else if (string_eq(command, tos3("new")) || string_eq(command, tos3("init"))) {
	v__util__launch_tool(prefs->is_verbose, tos3("vcreate"));
	return 0;
}else if (string_eq(command, tos3("translate"))) {
	println(tos3("Translating C to V will be available in V 0.3"));
	return 0;
}else if (string_eq(command, tos3("search")) || string_eq(command, tos3("install")) || string_eq(command, tos3("update")) || string_eq(command, tos3("remove"))) {
	v__util__launch_tool(prefs->is_verbose, tos3("vpm"));
	return 0;
}else if (string_eq(command, tos3("get"))) {
	println(tos3("V Error: Use `v install` to install modules from vpm.vlang.io"));
	v_exit(1);
}else if (string_eq(command, tos3("symlink"))) {
	create_symlink();
	return 0;
}else if (string_eq(command, tos3("doc"))) {
	if (args.len == 1) {
		println(tos3("v doc [module]"));
		v_exit(1);
	}
	v__table__Table* table = v__table__new_table();
	println(v__doc__doc((*(string*)array_get(args, 1)), table, prefs));
	return 0;
}else {
};
if ((string_eq(command, tos3("run")) || string_eq(command, tos3("build-module"))) || string_ends_with(command, tos3(".v")) || os__exists(command)) {
	v__builder__compile(command, prefs);
	return 0;
}
eprintln(_STR("v %.*s\000: unknown command\nRun \"v help\" for usage.", 2, command));
v_exit(1);
	return 0;
}


// THE END.

