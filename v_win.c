#define V_COMMIT_HASH "0f16070"
#ifndef V_COMMIT_HASH
#define V_COMMIT_HASH "c947e6e"
#endif
#include <inttypes.h>

//#include <inttypes.h>  // int64_t etc
//#include <stdint.h>  // int64_t etc

//================================== 1TYPEDEFS
//================================*/

typedef int64_t i64;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t byte;
typedef uint32_t rune;
typedef float f32;
typedef double f64;
typedef unsigned char *byteptr;
typedef int *intptr;
typedef void *voidptr;
typedef char *charptr;
typedef struct array array;
typedef struct map map;
typedef array array_string;
typedef array array_int;
typedef array array_byte;
typedef array array_f32;
typedef array array_f64;
typedef array array_u16;
typedef array array_u32;
typedef array array_u64;
typedef map map_int;
typedef map map_string;
#ifndef bool
typedef int bool;
#define true 1
#define false 0
#endif

//#include <inttypes.h>  // int64_t etc
#include <stdio.h> // TODO remove all these includes, define all function signatures and types manually
#include <stdlib.h>

//#include "fns.h"
#include <signal.h>
#include <stdarg.h> // for va_list
#include <string.h> // memcpy

#if INTPTR_MAX == INT32_MAX
#define TARGET_IS_32BIT 1
#elif INTPTR_MAX == INT64_MAX
#define TARGET_IS_64BIT 1
#else
#error "The environment is not 32 or 64-bit."
#endif

#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ ||       \
    defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN ||                   \
    defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) ||   \
    defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) ||         \
    defined(__MIBSEB__)
#define TARGET_ORDER_IS_BIG
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ ||  \
    defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN ||                \
    defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) ||                        \
    defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) ||      \
    defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) ||           \
    defined(_M_X64) || defined(_M_IX86)
#define TARGET_ORDER_IS_LITTLE
#else
#error "Unknown architecture endianness"
#endif

#ifndef _WIN32
#include <ctype.h>
#include <locale.h> // tolower
#include <sys/time.h>
#include <unistd.h> // sleep
extern char **environ;
#endif

#if defined(__CYGWIN__) && !defined(_WIN32)
#error Cygwin is not supported, please use MinGW or Visual Studio.
#endif

#ifdef __linux__
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __FreeBSD__
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __DragonFly__
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __OpenBSD__
#include <sys/resource.h>
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __NetBSD__
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#define EMPTY_STRUCT_DECLARATION
#define EMPTY_STRUCT_INITIALIZATION 0
// Due to a tcc bug, the length of an array needs to be specified, but GCC
// crashes if it is...
#define EMPTY_ARRAY_OF_ELEMS(x, n) (x[])
#define TCCSKIP(x) x

#ifdef __TINYC__
#undef EMPTY_STRUCT_DECLARATION
#undef EMPTY_STRUCT_INITIALIZATION
#define EMPTY_STRUCT_DECLARATION char _dummy
#define EMPTY_STRUCT_INITIALIZATION 0
#undef EMPTY_ARRAY_OF_ELEMS
#define EMPTY_ARRAY_OF_ELEMS(x, n) (x[n])
#undef TCCSKIP
#define TCCSKIP(x)
#endif

// for __offset_of
#ifndef __offsetof
#define __offsetof(s, memb) ((size_t)((char *)&((s *)0)->memb - (char *)0))
#endif

#define OPTION_CAST(x) (x)

#ifndef V64_PRINTFORMAT
#ifdef PRIx64
#define V64_PRINTFORMAT "0x%" PRIx64
#elif defined(__WIN32__)
#define V64_PRINTFORMAT "0x%I64x"
#elif defined(__LINUX__) && defined(__LP64__)
#define V64_PRINTFORMAT "0x%lx"
#else
#define V64_PRINTFORMAT "0x%llx"
#endif
#endif

#ifdef _WIN32
#define WINVER 0x0600
#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif
#define _WIN32_WINNT 0x0600
#define WIN32_LEAN_AND_MEAN
#define _UNICODE
#define UNICODE
#include <windows.h>

#include <direct.h> // _wgetcwd
#include <io.h>     // _waccess
//#include <WinSock2.h>
#ifdef _MSC_VER

// On MSVC these are the same (as long as /volatile:ms is passed)
#define _Atomic volatile

// MSVC cannot parse some things properly
#undef EMPTY_STRUCT_DECLARATION
#undef OPTION_CAST

#define EMPTY_STRUCT_DECLARATION int ____dummy_variable
#define OPTION_CAST(x)

#include <dbghelp.h>
#pragma comment(lib, "Dbghelp.lib")

extern wchar_t **_wenviron;

#endif

#else
#include <pthread.h>
#endif

//============================== HELPER C MACROS =============================*/
#define _PUSH(arr, val, tmp, tmp_typ)                                          \
  {                                                                            \
    tmp_typ tmp = (val);                                                       \
    array_push(arr, &tmp);                                                     \
  }
#define _PUSH_MANY(arr, val, tmp, tmp_typ)                                     \
  {                                                                            \
    tmp_typ tmp = (val);                                                       \
    array_push_many(arr, tmp.data, tmp.len);                                   \
  }
#define _IN(typ, val, arr) array_##typ##_contains(arr, val)
#define _IN_MAP(val, m) map_exists(m, val)
#define DEFAULT_EQUAL(a, b) (a == b)
#define DEFAULT_NOT_EQUAL(a, b) (a != b)
#define DEFAULT_LT(a, b) (a < b)
#define DEFAULT_LE(a, b) (a <= b)
#define DEFAULT_GT(a, b) (a > b)
#define DEFAULT_GE(a, b) (a >= b)

// NB: macro_fXX_eq and macro_fXX_ne are NOT used
// in the generated C code. They are here just for
// completeness/testing.

#define macro_f64_eq(a, b) (a == b)
#define macro_f64_ne(a, b) (a != b)
#define macro_f64_lt(a, b) (a < b)
#define macro_f64_le(a, b) (a <= b)
#define macro_f64_gt(a, b) (a > b)
#define macro_f64_ge(a, b) (a >= b)

#define macro_f32_eq(a, b) (a == b)
#define macro_f32_ne(a, b) (a != b)
#define macro_f32_lt(a, b) (a < b)
#define macro_f32_le(a, b) (a <= b)
#define macro_f32_gt(a, b) (a > b)
#define macro_f32_ge(a, b) (a >= b)

//================================== GLOBALS =================================*/
byte g_str_buf[1024];
int load_so(byteptr);
void reload_so();

// ============== wyhash ==============
//	Author: Wang Yi <godspeed_china@yeah.net>
#ifndef wyhash_version_4
#define wyhash_version_4
#include <stdint.h>
#include <string.h>
#if defined(_MSC_VER) && defined(_M_X64)
#include <intrin.h>
#pragma intrinsic(_umul128)
#endif
const uint64_t _wyp0 = 0xa0761d6478bd642full, _wyp1 = 0xe7037ed1a0b428dbull,
               _wyp2 = 0x8ebc6af09c88c6e3ull, _wyp3 = 0x589965cc75374cc3ull,
               _wyp4 = 0x1d8e4e27c47d124full;
static inline uint64_t _wyrotr(uint64_t v, unsigned k) {
  return (v >> k) | (v << (64 - k));
}
static inline uint64_t _wymum(uint64_t A, uint64_t B) {
#ifdef WYHASH32
  uint64_t hh = (A >> 32) * (B >> 32), hl = (A >> 32) * (unsigned)B,
           lh = (unsigned)A * (B >> 32),
           ll = (uint64_t)(unsigned)A * (unsigned)B;
  return _wyrotr(hl, 32) ^ _wyrotr(lh, 32) ^ hh ^ ll;
#else
#ifdef __SIZEOF_INT128__
  __uint128_t r = A;
  r *= B;
  return (r >> 64) ^ r;
#elif defined(_MSC_VER) && defined(_M_X64)
  A = _umul128(A, B, &B);
  return A ^ B;
#else
  uint64_t ha = A >> 32, hb = B >> 32, la = (uint32_t)A, lb = (uint32_t)B, hi,
           lo;
  uint64_t rh = ha * hb, rm0 = ha * lb, rm1 = hb * la, rl = la * lb,
           t = rl + (rm0 << 32), c = t < rl;
  lo = t + (rm1 << 32);
  c += lo < t;
  hi = rh + (rm0 >> 32) + (rm1 >> 32) + c;
  return hi ^ lo;
#endif
#endif
}
#ifndef WYHASH_LITTLE_ENDIAN
#if defined(_WIN32) || defined(__LITTLE_ENDIAN__) ||                           \
    (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
#define WYHASH_LITTLE_ENDIAN 1
#elif defined(__BIG_ENDIAN__) ||                                               \
    (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
#define WYHASH_LITTLE_ENDIAN 0
#endif
#endif
#if (WYHASH_LITTLE_ENDIAN) || defined(__TINYC__)
static inline uint64_t _wyr8(const uint8_t *p) {
  uint64_t v;
  memcpy(&v, p, 8);
  return v;
}
static inline uint64_t _wyr4(const uint8_t *p) {
  unsigned v;
  memcpy(&v, p, 4);
  return v;
}
#else
#if defined(__GNUC__) || defined(__INTEL_COMPILER)
static inline uint64_t _wyr8(const uint8_t *p) {
  uint64_t v;
  memcpy(&v, p, 8);
  return __builtin_bswap64(v);
}
static inline uint64_t _wyr4(const uint8_t *p) {
  unsigned v;
  memcpy(&v, p, 4);
  return __builtin_bswap32(v);
}
#elif defined(_MSC_VER)
static inline uint64_t _wyr8(const uint8_t *p) {
  uint64_t v;
  memcpy(&v, p, 8);
  return _byteswap_uint64(v);
}
static inline uint64_t _wyr4(const uint8_t *p) {
  unsigned v;
  memcpy(&v, p, 4);
  return _byteswap_ulong(v);
}
#endif
#endif
static inline uint64_t _wyr3(const uint8_t *p, unsigned k) {
  return (((uint64_t)p[0]) << 16) | (((uint64_t)p[k >> 1]) << 8) | p[k - 1];
}
static inline uint64_t wyhash(const void *key, uint64_t len, uint64_t seed) {
  const uint8_t *p = (const uint8_t *)key;
  uint64_t i = len & 63;
#if defined(__GNUC__) || defined(__INTEL_COMPILER)
#define _like_(x) __builtin_expect(x, 1)
#define _unlike_(x) __builtin_expect(x, 0)
#else
#define _like_(x) (x)
#define _unlike_(x) (x)
#endif
  if (_unlike_(!i)) {
  } else if (_unlike_(i < 4))
    seed = _wymum(_wyr3(p, i) ^ seed ^ _wyp0, seed ^ _wyp1);
  else if (_like_(i <= 8))
    seed = _wymum(_wyr4(p) ^ seed ^ _wyp0, _wyr4(p + i - 4) ^ seed ^ _wyp1);
  else if (_like_(i <= 16))
    seed = _wymum(_wyr8(p) ^ seed ^ _wyp0, _wyr8(p + i - 8) ^ seed ^ _wyp1);
  else if (_like_(i <= 24))
    seed = _wymum(_wyr8(p) ^ seed ^ _wyp0, _wyr8(p + 8) ^ seed ^ _wyp1) ^
           _wymum(_wyr8(p + i - 8) ^ seed ^ _wyp2, seed ^ _wyp3);
  else if (_like_(i <= 32))
    seed =
        _wymum(_wyr8(p) ^ seed ^ _wyp0, _wyr8(p + 8) ^ seed ^ _wyp1) ^
        _wymum(_wyr8(p + 16) ^ seed ^ _wyp2, _wyr8(p + i - 8) ^ seed ^ _wyp3);
  else {
    seed = _wymum(_wyr8(p) ^ seed ^ _wyp0, _wyr8(p + 8) ^ seed ^ _wyp1) ^
           _wymum(_wyr8(p + 16) ^ seed ^ _wyp2, _wyr8(p + 24) ^ seed ^ _wyp3) ^
           _wymum(_wyr8(p + i - 32) ^ seed ^ _wyp1,
                  _wyr8(p + i - 24) ^ seed ^ _wyp2) ^
           _wymum(_wyr8(p + i - 16) ^ seed ^ _wyp3,
                  _wyr8(p + i - 8) ^ seed ^ _wyp0);
  }
  if (_like_(i == len))
    return _wymum(seed, len ^ _wyp4);
  uint64_t see1 = seed, see2 = seed, see3 = seed;
  for (p += i, i = len - i; _like_(i >= 64); i -= 64, p += 64) {
    seed = _wymum(_wyr8(p) ^ seed ^ _wyp0, _wyr8(p + 8) ^ seed ^ _wyp1);
    see1 = _wymum(_wyr8(p + 16) ^ see1 ^ _wyp2, _wyr8(p + 24) ^ see1 ^ _wyp3);
    see2 = _wymum(_wyr8(p + 32) ^ see2 ^ _wyp1, _wyr8(p + 40) ^ see2 ^ _wyp2);
    see3 = _wymum(_wyr8(p + 48) ^ see3 ^ _wyp3, _wyr8(p + 56) ^ see3 ^ _wyp0);
  }
  return _wymum(seed ^ see1 ^ see2, see3 ^ len ^ _wyp4);
}
static inline uint64_t wyhash64(uint64_t A, uint64_t B) {
  return _wymum(_wymum(A ^ _wyp0, B ^ _wyp1), _wyp2);
}
static inline uint64_t wyrand(uint64_t *seed) {
  *seed += _wyp0;
  return _wymum(*seed ^ _wyp1, *seed);
}
static inline double wy2u01(uint64_t r) {
  const double _wynorm = 1.0 / (1ull << 52);
  return (r >> 11) * _wynorm;
}
static inline double wy2gau(uint64_t r) {
  const double _wynorm = 1.0 / (1ull << 20);
  return ((r & 0x1fffff) + ((r >> 21) & 0x1fffff) + ((r >> 42) & 0x1fffff)) *
             _wynorm -
         3.0;
}
static inline uint64_t fastest_hash(const void *key, size_t len,
                                    uint64_t seed) {
  const uint8_t *p = (const uint8_t *)key;
  return _like_(len >= 4)
             ? (_wyr4(p) + _wyr4(p + len - 4)) *
                   (_wyr4(p + (len >> 1) - 2) ^ seed)
             : (_like_(len) ? _wyr3(p, len) * (_wyp0 ^ seed) : seed);
}
#endif

int g_test_oks = 0;
int g_test_fails = 0;
#define builtin__hashbits 24
#define builtin__cached_hashbits 16
#define builtin__init_log_capicity 5
#define builtin__init_max_load_factor 0.8
#define builtin__min_load_factor 0.3
#define builtin__extra_metas_inc 4
#define builtin__degree 6
#define builtin__CP_UTF8 65001
#define strconv__DIGITS 18
#define strconv__fsm_a 0
#define strconv__fsm_b 1
#define strconv__fsm_c 2
#define strconv__fsm_d 3
#define strconv__fsm_e 4
#define strconv__fsm_f 5
#define strconv__fsm_g 6
#define strconv__fsm_h 7
#define strconv__fsm_i 8
#define strconv__FSM_STOP 9
#define strconv__parser_ok 0
#define strconv__parser_pzero 1
#define strconv__parser_mzero 2
#define strconv__parser_pinf 3
#define strconv__parser_minf 4
#define strconv__DPOINT '.'
#define strconv__PLUS '+'
#define strconv__MINUS '-'
#define strconv__ZERO '0'
#define strconv__NINE '9'
#define strconv__int_size 32
#define math__bias 1023
#define math__e 2.71828182845904523536028747135266249775724709369995957496696763
#define math__pi                                                               \
  3.14159265358979323846264338327950288419716939937510582097494459
#define math__phi                                                              \
  1.61803398874989484820458683436563811772030917980576286213544862
#define math__tau                                                              \
  6.28318530717958647692528676655900576839433879875021164194988918
#define math__sqrt2                                                            \
  1.41421356237309504880168872420969807856967187537694807317667974
#define math__sqrt_e                                                           \
  1.64872127070012814684865078781416357165377610071014801157507931
#define math__sqrt_pi                                                          \
  1.77245385090551602729816748334114518279754945612238712821380779
#define math__sqrt_tau                                                         \
  2.50662827463100050241576528481104525300698674060993831662992357
#define math__sqrt_phi                                                         \
  1.27201964951406896425242246173749149171560804184009624861664038
#define math__ln2                                                              \
  0.693147180559945309417232121458176568075500134360255254120680009
#define math__ln10                                                             \
  2.30258509299404568401799145468436420760110148862877297603332790
#define math__max_i8 127
#define math__max_i16 32767
#define math__max_i32 2147483647
#define math__max_i64 UINT64_C(9223372036854775807)
#define math__max_u8 255
#define math__max_u16 65535
#define math__max_u32 4294967295
#define math__max_u64 UINT64_C(18446744073709551615)
#define math_dot_bits__max_u32 4294967295
#define math_dot_bits__max_u64 UINT64_C(18446744073709551615)
#define time__seconds_per_minute 60
#define v_dot_token__nr_tokens 141
#define strconv_dot_ftoa__maxexp32 255
#define strconv_dot_ftoa__maxexp64 2047
#define strconv_dot_ftoa__pow5_num_bits_32 61
#define strconv_dot_ftoa__pow5_inv_num_bits_32 59
#define strconv_dot_ftoa__pow5_num_bits_64 121
#define strconv_dot_ftoa__pow5_inv_num_bits_64 122
#define os__SUCCESS 0
#define os__ERROR_INSUFFICIENT_BUFFER 130
#define os__FILE_SHARE_READ 1
#define os__FILE_SHARE_WRITE 2
#define os__FILE_SHARE_DELETE 4
#define os__FILE_NOTIFY_CHANGE_FILE_NAME 1
#define os__FILE_NOTIFY_CHANGE_DIR_NAME 2
#define os__FILE_NOTIFY_CHANGE_ATTRIBUTES 4
#define os__FILE_NOTIFY_CHANGE_SIZE 8
#define os__FILE_NOTIFY_CHANGE_LAST_WRITE 16
#define os__FILE_NOTIFY_CHANGE_LAST_ACCESS 32
#define os__FILE_NOTIFY_CHANGE_CREATION 64
#define os__FILE_NOTIFY_CHANGE_SECURITY 128
#define os__FILE_ACTION_ADDED 1
#define os__FILE_ACTION_REMOVED 2
#define os__FILE_ACTION_MODIFIED 3
#define os__FILE_ACTION_RENAMED_OLD_NAME 4
#define os__FILE_ACTION_RENAMED_NEW_NAME 5
#define os__O_RDONLY 0
#define os__O_WRONLY 1
#define os__O_RDWR 2
#define os__O_SYNC 0
#define os__O_NOCTTY 0
#define os__O_NONBLOCK 0
#define os__MAX_PATH 4096
#define os__F_OK 0
#define os__X_OK 1
#define os__W_OK 2
#define os__R_OK 4
#define os__MAX_ERROR_CODE 15841
#define v_dot_table__void_type_idx 1
#define v_dot_table__voidptr_type_idx 2
#define v_dot_table__byteptr_type_idx 3
#define v_dot_table__charptr_type_idx 4
#define v_dot_table__i8_type_idx 5
#define v_dot_table__i16_type_idx 6
#define v_dot_table__int_type_idx 7
#define v_dot_table__i64_type_idx 8
#define v_dot_table__byte_type_idx 9
#define v_dot_table__u16_type_idx 10
#define v_dot_table__u32_type_idx 11
#define v_dot_table__u64_type_idx 12
#define v_dot_table__f32_type_idx 13
#define v_dot_table__f64_type_idx 14
#define v_dot_table__char_type_idx 15
#define v_dot_table__bool_type_idx 16
#define v_dot_table__none_type_idx 17
#define v_dot_table__string_type_idx 18
#define v_dot_table__array_type_idx 19
#define v_dot_table__map_type_idx 20
#define term__default_columns_size 80
#define term__default_rows_size 25
#define vweb_dot_tmpl__STR_START tos3("sb.write(\'")
#define vweb_dot_tmpl__STR_END tos3("\' ) ")
#define v_dot_scanner__single_quote '\''
#define v_dot_scanner__double_quote '"'
#define v_dot_scanner__error_context_before 2
#define v_dot_scanner__error_context_after 2
#define v_dot_scanner__num_sep '_'
#define v_dot_checker__max_nr_errors 100
#define v_dot_gen_dot_x64__mag1 'E'
#define v_dot_gen_dot_x64__mag2 'L'
#define v_dot_gen_dot_x64__mag3 'F'
#define v_dot_gen_dot_x64__ei_class 4
#define v_dot_gen_dot_x64__elfclass64 2
#define v_dot_gen_dot_x64__elfdata2lsb 1
#define v_dot_gen_dot_x64__ev_current 1
#define v_dot_gen_dot_x64__elf_osabi 0
#define v_dot_gen_dot_x64__et_rel 1
#define v_dot_gen_dot_x64__et_exec 2
#define v_dot_gen_dot_x64__et_dyn 3
#define v_dot_gen_dot_x64__sht_null 0
#define compiler__max_module_depth 5
#define compiler__MaxLocalVars 50
#define compiler__single_quote '\''
#define compiler__double_quote '"'
#define compiler__error_context_before 2
#define compiler__error_context_after 2
#define compiler__num_sep '_'
#define compiler__NrTokens 141
#ifdef _WIN32
#include <dbghelp.h>
#endif
#include <errno.h>
#include <float.h>
#include <math.h>
#include <sys/stat.h> // #include <signal.h>
#include <time.h>
#ifdef _WIN32
#include <winsock2.h>
#endif
typedef struct array array;
typedef array array_string;
typedef array array_int;
typedef array array_bool;
typedef array array_byte;
typedef array array_char;
typedef array array_voidptr;
typedef struct SymbolInfo SymbolInfo;
typedef struct SymbolInfoContainer SymbolInfoContainer;
typedef struct Line64 Line64;
typedef struct KeyValue KeyValue;
typedef struct DenseArray DenseArray;
typedef struct map map;
typedef struct Option Option;
typedef struct SortedMap SortedMap;
typedef struct mapnode mapnode;
typedef struct string string;
typedef struct ustring ustring;
typedef struct RepIndex RepIndex;
typedef array array_RepIndex;
typedef Option Option_int;
typedef Option Option_int;
typedef struct varg_byte varg_byte;

typedef struct strings__Builder strings__Builder;
typedef union strconv__Float64u strconv__Float64u;
typedef struct _V_MulRet_u32_V_u32_V_u32 _V_MulRet_u32_V_u32_V_u32;
typedef struct strconv__PrepNumber strconv__PrepNumber;
typedef struct _V_MulRet_int_V_strconv__PrepNumber
    _V_MulRet_int_V_strconv__PrepNumber;
typedef struct _V_MulRet_u32_V_u32 _V_MulRet_u32_V_u32;
typedef struct _V_MulRet_u64_V_u64 _V_MulRet_u64_V_u64;
typedef Option Option_time__Time;
typedef Option Option_time__Time;
typedef struct time__Time time__Time;
typedef Option Option_int;
typedef struct _V_MulRet_int_V_int_V_int _V_MulRet_int_V_int_V_int;
typedef struct v_dot_token__Position v_dot_token__Position;
typedef struct v_dot_token__Token v_dot_token__Token;
typedef array array_v_dot_token__Kind;
typedef array array_v_dot_token__Precedence;
typedef struct v_dot_depgraph__DepGraphNode v_dot_depgraph__DepGraphNode;
typedef struct v_dot_depgraph__DepGraph v_dot_depgraph__DepGraph;
typedef array array_v_dot_depgraph__DepGraphNode;
typedef struct v_dot_depgraph__OrderedDepMap v_dot_depgraph__OrderedDepMap;
typedef map map_array_string;
typedef struct strconv_dot_ftoa__Dec32 strconv_dot_ftoa__Dec32;
typedef union strconv_dot_ftoa__Uf32 strconv_dot_ftoa__Uf32;
typedef struct _V_MulRet_strconv_dot_ftoa__Dec32_V_bool
    _V_MulRet_strconv_dot_ftoa__Dec32_V_bool;
typedef struct strconv_dot_ftoa__Uint128 strconv_dot_ftoa__Uint128;
typedef struct strconv_dot_ftoa__Dec64 strconv_dot_ftoa__Dec64;
typedef union strconv_dot_ftoa__Uf64 strconv_dot_ftoa__Uf64;
typedef struct _V_MulRet_strconv_dot_ftoa__Dec64_V_bool
    _V_MulRet_strconv_dot_ftoa__Dec64_V_bool;
typedef array array_u64;
typedef array array_strconv_dot_ftoa__Uint128;
typedef struct os__File os__File;
typedef struct os__FileInfo os__FileInfo;
typedef Option Option_array_byte;
typedef Option Option_string;
typedef Option Option_bool;
typedef Option Option_bool;
typedef Option Option_bool;
typedef Option Option_bool;
typedef Option Option_array_string;
typedef array array_ustring;
typedef Option Option_array_ustring;
typedef Option Option_os__File;
typedef struct varg_int varg_int;

typedef Option Option_os__File;
typedef struct _V_MulRet_int_V_bool _V_MulRet_int_V_bool;
typedef struct os__Result os__Result;
typedef Option Option_string;
typedef struct varg_string varg_string;

typedef void *os__HANDLE; // type alias name="os__HANDLE" parent=`void*`
typedef struct os__Filetime os__Filetime;
typedef struct os__Win32finddata os__Win32finddata;
typedef struct os__ProcessInformation os__ProcessInformation;
typedef struct os__StartupInfo os__StartupInfo;
typedef struct os__SecurityAttributes os__SecurityAttributes;
typedef Option Option_array_string;
typedef Option Option_os__File;
typedef Option Option_os__File;
typedef Option Option_bool;
typedef Option Option_string;
typedef Option Option_os__Result;
typedef Option Option_bool;
typedef Option Option_v_dot_pref__OS;
typedef struct v_dot_pref__Preferences v_dot_pref__Preferences;
typedef Option Option_v_dot_pref__Backend;
typedef int
    v_dot_table__Type; // type alias name="v_dot_table__Type" parent=`int`
typedef struct {
  void *obj;
  int typ;
} v_dot_table__TypeInfo;

typedef struct v_dot_table__TypeSymbol v_dot_table__TypeSymbol;
typedef array array_v_dot_table__Fn;
typedef array array_v_dot_table__Type;
typedef struct v_dot_table__MultiReturn v_dot_table__MultiReturn;
typedef array array_v_dot_table__Kind;
typedef struct v_dot_table__Struct v_dot_table__Struct;
typedef array array_v_dot_table__Field;
typedef struct v_dot_table__Enum v_dot_table__Enum;
typedef struct v_dot_table__Alias v_dot_table__Alias;
typedef struct v_dot_table__Field v_dot_table__Field;
typedef struct v_dot_table__Array v_dot_table__Array;
typedef struct v_dot_table__ArrayFixed v_dot_table__ArrayFixed;
typedef struct v_dot_table__Map v_dot_table__Map;
typedef struct v_dot_table__SumType v_dot_table__SumType;
typedef struct v_dot_table__Table v_dot_table__Table;
typedef array array_v_dot_table__TypeSymbol;
typedef map map_v_dot_table__Fn;
typedef map map_v_dot_table__Var;
typedef struct v_dot_table__Fn v_dot_table__Fn;
typedef array array_v_dot_table__Arg;
typedef struct v_dot_table__Arg v_dot_table__Arg;
typedef struct v_dot_table__Var v_dot_table__Var;
typedef Option Option_v_dot_table__Fn;
typedef Option Option_v_dot_table__Var;
typedef Option Option_v_dot_table__Fn;
typedef Option Option_v_dot_table__Field;
typedef Option Option_v_dot_table__Fn;
typedef Option Option_v_dot_table__Field;
typedef Option Option_v_dot_table__TypeSymbol;
typedef struct _V_MulRet_int_V_int _V_MulRet_int_V_int;
typedef struct v_dot_scanner__Scanner v_dot_scanner__Scanner;
typedef struct internal_dot_flag__Instance internal_dot_flag__Instance;
typedef map map_bool;
typedef Option Option_array_string;
typedef Option Option_string;
typedef Option Option_int;
typedef Option Option_f32;
typedef Option Option_f64;
typedef Option Option_i64;
typedef void (*internal_dot_flag__void_cb)(
    string, internal_dot_flag__Instance *,
    void * /*FFF*/); // type alias name="internal_dot_flag__void_cb" parent=`fn
                     // (string,internal_dot_flag__Instance*,void*)`
typedef Option Option_array_string;
typedef struct internal_dot_flag__MainCmdPreferences
    internal_dot_flag__MainCmdPreferences;
typedef Option Option_array_string;
typedef struct benchmark__Benchmark benchmark__Benchmark;
typedef struct {
  void *obj;
  int typ;
} v_dot_ast__TypeDecl;

typedef struct {
  void *obj;
  int typ;
} v_dot_ast__Expr;

typedef struct {
  void *obj;
  int typ;
} v_dot_ast__Stmt;

typedef struct v_dot_ast__Type v_dot_ast__Type;
typedef struct v_dot_ast__ExprStmt v_dot_ast__ExprStmt;
typedef struct v_dot_ast__IntegerLiteral v_dot_ast__IntegerLiteral;
typedef struct v_dot_ast__FloatLiteral v_dot_ast__FloatLiteral;
typedef struct v_dot_ast__StringLiteral v_dot_ast__StringLiteral;
typedef struct v_dot_ast__CharLiteral v_dot_ast__CharLiteral;
typedef struct v_dot_ast__BoolLiteral v_dot_ast__BoolLiteral;
typedef struct v_dot_ast__SelectorExpr v_dot_ast__SelectorExpr;
typedef struct v_dot_ast__Module v_dot_ast__Module;
typedef struct v_dot_ast__Field v_dot_ast__Field;
typedef struct v_dot_ast__ConstDecl v_dot_ast__ConstDecl;
typedef array array_v_dot_ast__Field;
typedef array array_v_dot_ast__Expr;
typedef struct v_dot_ast__StructDecl v_dot_ast__StructDecl;
typedef struct v_dot_ast__StructInit v_dot_ast__StructInit;
typedef struct v_dot_ast__Import v_dot_ast__Import;
typedef struct v_dot_ast__FnDecl v_dot_ast__FnDecl;
typedef array array_v_dot_ast__Stmt;
typedef struct v_dot_ast__BranchStmt v_dot_ast__BranchStmt;
typedef struct v_dot_ast__CallExpr v_dot_ast__CallExpr;
typedef array array_v_dot_ast__CallArg;
typedef struct v_dot_ast__MethodCallExpr v_dot_ast__MethodCallExpr;
typedef struct v_dot_ast__CallArg v_dot_ast__CallArg;
typedef struct v_dot_ast__Return v_dot_ast__Return;
typedef struct v_dot_ast__Var v_dot_ast__Var;
typedef struct v_dot_ast__GlobalDecl v_dot_ast__GlobalDecl;
typedef struct v_dot_ast__File v_dot_ast__File;
typedef array array_v_dot_ast__Import;
typedef struct v_dot_ast__IdentFn v_dot_ast__IdentFn;
typedef struct v_dot_ast__IdentVar v_dot_ast__IdentVar;
typedef struct {
  void *obj;
  int typ;
} v_dot_ast__IdentInfo;

typedef struct v_dot_ast__Ident v_dot_ast__Ident;
typedef struct v_dot_ast__InfixExpr v_dot_ast__InfixExpr;
typedef struct v_dot_ast__PostfixExpr v_dot_ast__PostfixExpr;
typedef struct v_dot_ast__PrefixExpr v_dot_ast__PrefixExpr;
typedef struct v_dot_ast__IndexExpr v_dot_ast__IndexExpr;
typedef struct v_dot_ast__IfExpr v_dot_ast__IfExpr;
typedef struct v_dot_ast__MatchExpr v_dot_ast__MatchExpr;
typedef array array_v_dot_ast__MatchBranch;
typedef struct v_dot_ast__MatchBranch v_dot_ast__MatchBranch;
typedef struct v_dot_ast__CompIf v_dot_ast__CompIf;
typedef struct v_dot_ast__ForStmt v_dot_ast__ForStmt;
typedef struct v_dot_ast__ForInStmt v_dot_ast__ForInStmt;
typedef struct v_dot_ast__ForCStmt v_dot_ast__ForCStmt;
typedef struct v_dot_ast__ReturnStmt v_dot_ast__ReturnStmt;
typedef struct v_dot_ast__HashStmt v_dot_ast__HashStmt;
typedef struct v_dot_ast__Lambda v_dot_ast__Lambda;
typedef struct v_dot_ast__AssignStmt v_dot_ast__AssignStmt;
typedef array array_v_dot_ast__Ident;
typedef struct v_dot_ast__AsCast v_dot_ast__AsCast;
typedef struct v_dot_ast__Attr v_dot_ast__Attr;
typedef struct v_dot_ast__EnumVal v_dot_ast__EnumVal;
typedef struct v_dot_ast__EnumDecl v_dot_ast__EnumDecl;
typedef struct v_dot_ast__AliasTypeDecl v_dot_ast__AliasTypeDecl;
typedef struct v_dot_ast__SumTypeDecl v_dot_ast__SumTypeDecl;
typedef struct v_dot_ast__FnTypeDecl v_dot_ast__FnTypeDecl;
typedef struct v_dot_ast__DeferStmt v_dot_ast__DeferStmt;
typedef struct v_dot_ast__UnsafeStmt v_dot_ast__UnsafeStmt;
typedef struct v_dot_ast__ParExpr v_dot_ast__ParExpr;
typedef struct v_dot_ast__AssignExpr v_dot_ast__AssignExpr;
typedef struct v_dot_ast__GoStmt v_dot_ast__GoStmt;
typedef struct v_dot_ast__GotoLabel v_dot_ast__GotoLabel;
typedef struct v_dot_ast__GotoStmt v_dot_ast__GotoStmt;
typedef struct v_dot_ast__ArrayInit v_dot_ast__ArrayInit;
typedef struct v_dot_ast__MapInit v_dot_ast__MapInit;
typedef struct v_dot_ast__RangeExpr v_dot_ast__RangeExpr;
typedef struct v_dot_ast__CastExpr v_dot_ast__CastExpr;
typedef struct v_dot_ast__AssertStmt v_dot_ast__AssertStmt;
typedef struct v_dot_ast__IfGuardExpr v_dot_ast__IfGuardExpr;
typedef struct v_dot_ast__OrExpr v_dot_ast__OrExpr;
typedef struct v_dot_ast__Assoc v_dot_ast__Assoc;
typedef struct v_dot_ast__SizeOf v_dot_ast__SizeOf;
typedef struct v_dot_ast__LineComment v_dot_ast__LineComment;
typedef struct v_dot_ast__MultiLineComment v_dot_ast__MultiLineComment;
typedef struct v_dot_ast__ConcatExpr v_dot_ast__ConcatExpr;
typedef struct v_dot_ast__None v_dot_ast__None;
typedef struct v_dot_ast__Scope v_dot_ast__Scope;
typedef array array_ptr_v_dot_ast__Scope;
typedef map map_v_dot_ast__Var;
typedef struct _V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var
    _V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var;
typedef Option Option__V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var;
typedef Option Option_v_dot_ast__Var;
typedef struct sync__PoolProcessor sync__PoolProcessor;
typedef void *(*sync__ThreadCB)(
    sync__PoolProcessor *p, int idx,
    int task_id /*FFF*/); // type alias name="sync__ThreadCB" parent=`fn
                          // (sync__PoolProcessor*,int,int) void*`
typedef struct sync__PoolProcessorConfig sync__PoolProcessorConfig;
typedef array array_T;
typedef void *sync__MHANDLE; // type alias name="sync__MHANDLE" parent=`void*`
typedef struct sync__Mutex sync__Mutex;
typedef struct sync__WaitGroup sync__WaitGroup;
typedef struct _V_MulRet_array_v_dot_table__Arg_V_bool
    _V_MulRet_array_v_dot_table__Arg_V_bool;
typedef struct v_dot_parser__Parser v_dot_parser__Parser;
typedef struct v_dot_parser__Queue v_dot_parser__Queue;
typedef array array_v_dot_ast__File;
typedef struct v_dot_checker__Checker v_dot_checker__Checker;
typedef struct v_dot_gen__Gen v_dot_gen__Gen;
typedef struct v_dot_gen__JsGen v_dot_gen__JsGen;
typedef struct v_dot_gen_dot_x64__SectionConfig
    v_dot_gen_dot_x64__SectionConfig;
typedef struct v_dot_gen_dot_x64__Gen v_dot_gen_dot_x64__Gen;
typedef array array_i64;
typedef map map_i64;
typedef struct v_dot_doc__Doc v_dot_doc__Doc;
typedef bool (*v_dot_doc__FilterFn)(
    v_dot_ast__FnDecl node /*FFF*/); // type alias name="v_dot_doc__FilterFn"
                                     // parent=`fn (v_dot_ast__FnDecl) bool`
typedef struct v_dot_builder__Builder v_dot_builder__Builder;
typedef Option Option_string;
typedef struct compiler__Parser compiler__Parser;
typedef array array_compiler__Token;
typedef array array_compiler__Var;
typedef struct compiler__ParserState compiler__ParserState;
typedef struct compiler__IndexConfig compiler__IndexConfig;
typedef struct _V_MulRet_bool_V_string _V_MulRet_bool_V_string;
typedef struct compiler__CFlag compiler__CFlag;
typedef array array_compiler__CFlag;
typedef Option Option_bool;
typedef struct compiler__CGen compiler__CGen;
typedef struct _V_MulRet_string_V_string _V_MulRet_string_V_string;
typedef array array_compiler__Type;
typedef struct compiler__ScannerPos compiler__ScannerPos;
typedef struct _V_MulRet_array_string_V_string _V_MulRet_array_string_V_string;
typedef struct compiler__DepGraphNode compiler__DepGraphNode;
typedef struct compiler__DepGraph compiler__DepGraph;
typedef array array_compiler__DepGraphNode;
typedef struct compiler__OrderedDepMap compiler__OrderedDepMap;
typedef struct compiler__Fn compiler__Fn;
typedef array array_compiler__TypeInst;
typedef struct compiler__TypeInst compiler__TypeInst;
typedef Option Option_compiler__Var;
typedef Option Option_compiler__Var;
typedef Option Option_compiler__Var;
typedef struct _V_MulRet_string_V_array_string _V_MulRet_string_V_array_string;
typedef array array_compiler__Fn;
typedef struct compiler__V compiler__V;
typedef array array_compiler__Parser;
typedef Option Option_int;
typedef struct compiler__VhGen compiler__VhGen;
typedef struct compiler__ImportTable compiler__ImportTable;
typedef Option Option_string;
typedef struct compiler__MsvcResult compiler__MsvcResult;
typedef void
    *compiler__RegKey; // type alias name="compiler__RegKey" parent=`void*`
typedef Option Option_string;
typedef struct compiler__WindowsKit compiler__WindowsKit;
typedef Option Option_compiler__WindowsKit;
typedef struct compiler__VsInstallation compiler__VsInstallation;
typedef Option Option_compiler__VsInstallation;
typedef Option Option_compiler__MsvcResult;
typedef struct compiler__MsvcStringFlags compiler__MsvcStringFlags;
typedef struct compiler__Scanner compiler__Scanner;
typedef struct compiler__ScanRes compiler__ScanRes;
typedef struct compiler__Table compiler__Table;
typedef map map_compiler__Type;
typedef map map_compiler__Fn;
typedef array array_compiler__VargAccess;
typedef struct compiler__VargAccess compiler__VargAccess;
typedef struct compiler__Name compiler__Name;
typedef array array_compiler__AccessMod;
typedef struct compiler__Var compiler__Var;
typedef struct compiler__Type compiler__Type;
typedef struct compiler__TypeNode compiler__TypeNode;
typedef Option Option_compiler__Fn;
typedef Option Option_compiler__Fn;
typedef Option Option_compiler__Var;
typedef Option Option_compiler__Var;
typedef Option Option_compiler__Fn;
typedef Option Option_compiler__Fn;
typedef Option Option_compiler__Var;
typedef struct compiler__Token compiler__Token;
typedef array array_compiler__TokenKind;
typedef struct compiler__ModFileAndFolder compiler__ModFileAndFolder;
typedef struct compiler__ModFileCacher compiler__ModFileCacher;
typedef map map_compiler__ModFileAndFolder;
typedef struct _V_MulRet_array_string_V_compiler__ModFileAndFolder
    _V_MulRet_array_string_V_compiler__ModFileAndFolder;
typedef struct _V_MulRet_v_dot_pref__Preferences_V_array_string
    _V_MulRet_v_dot_pref__Preferences_V_array_string;
typedef struct internal_dot_compile__Deprecated
    internal_dot_compile__Deprecated;
typedef array array_internal_dot_compile__Deprecated;
typedef array array_ptr_void;
typedef Option Option_int;
typedef Option Option_int;
typedef Option Option_time__Time;
typedef Option Option_time__Time;
typedef int time__FormatTime;
typedef int time__FormatDate;
typedef int time__FormatDelimiter;
typedef Option Option_int;
typedef int v_dot_token__Kind;
typedef int v_dot_token__Precedence;
typedef map map_v_dot_depgraph__DepGraphNode;
typedef Option Option_array_byte;
typedef Option Option_string;
typedef Option Option_bool;
typedef Option Option_bool;
typedef Option Option_bool;
typedef Option Option_bool;
typedef Option Option_array_string;
typedef Option Option_array_ustring;
typedef Option Option_os__File;
typedef Option Option_os__File;
typedef Option Option_string;
typedef Option Option_array_string;
typedef Option Option_os__File;
typedef Option Option_os__File;
typedef Option Option_bool;
typedef Option Option_string;
typedef Option Option_os__Result;
typedef Option Option_bool;
typedef int v_dot_pref__OS;
typedef Option Option_v_dot_pref__OS;
typedef int v_dot_pref__BuildMode;
typedef int v_dot_pref__Backend;
typedef int v_dot_pref__VerboseLevel;
typedef Option Option_v_dot_pref__Backend;
typedef int v_dot_table__TypeExtra;
typedef int v_dot_table__Kind;
typedef Option Option_v_dot_table__Fn;
typedef Option Option_v_dot_table__Var;
typedef Option Option_v_dot_table__Fn;
typedef Option Option_v_dot_table__Field;
typedef Option Option_v_dot_table__Fn;
typedef Option Option_v_dot_table__Field;
typedef Option Option_v_dot_table__TypeSymbol;
typedef int v_dot_scanner__CommentsMode;
typedef Option Option_array_string;
typedef Option Option_string;
typedef Option Option_int;
typedef Option Option_f32;
typedef Option Option_f64;
typedef Option Option_i64;
typedef Option Option_array_string;
typedef int internal_dot_flag__MainCmdAction;
typedef Option Option_array_string;
typedef int v_dot_ast__IdentKind;
typedef Option Option__V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var;
typedef Option Option_v_dot_ast__Var;
typedef int sync__MutexState;
typedef int v_dot_gen_dot_x64__SectionType;
typedef int v_dot_gen_dot_x64__Register;
typedef int v_dot_gen_dot_x64__Size;
typedef Option Option_string;
typedef int compiler__IndexType;
typedef Option Option_bool;
typedef map map_compiler__DepGraphNode;
typedef Option Option_compiler__Var;
typedef Option Option_compiler__Var;
typedef Option Option_compiler__Var;
typedef int compiler__Pass;
typedef Option Option_int;
typedef Option Option_string;
typedef Option Option_string;
typedef Option Option_compiler__WindowsKit;
typedef Option Option_compiler__VsInstallation;
typedef Option Option_compiler__MsvcResult;
typedef int compiler__NameCategory;
typedef int compiler__AccessMod;
typedef int compiler__TypeCategory;
typedef Option Option_compiler__Fn;
typedef Option Option_compiler__Fn;
typedef Option Option_compiler__Var;
typedef Option Option_compiler__Var;
typedef Option Option_compiler__Fn;
typedef Option Option_compiler__Fn;
typedef Option Option_compiler__Var;
typedef int compiler__TokenKind;
struct string {
  byte *str;
  int len;
};

struct array {
  void *data;
  int len;
  int cap;
  int element_size;
};

struct KeyValue {
  string key;
  void *value;
};

struct DenseArray {
  KeyValue *data;
  u32 cap;
  u32 size;
};

struct map {
  int value_bytes;
  u32 cap;
  byte window;
  byte shift;
  DenseArray key_values;
  u32 *metas;
  f32 max_load_factor;
  u32 extra_metas;
  int size;
};

struct Option {
  byte data[300];
  string error;
  int ecode;
  bool ok;
  bool is_none;
};

//----
struct v_dot_table__Alias {
  string foo;
};

struct v_dot_ast__FloatLiteral {
  string val;
};

struct v_dot_ast__StringLiteral {
  string val;
};

struct v_dot_ast__CharLiteral {
  string val;
};

struct v_dot_ast__HashStmt {
  string val;
};

struct v_dot_ast__Lambda {
  string name;
};

struct v_dot_ast__Attr {
  string name;
};

struct v_dot_ast__GotoLabel {
  string name;
};

struct v_dot_ast__GotoStmt {
  string name;
};

struct v_dot_ast__SizeOf {
  string type_name;
};

struct v_dot_ast__LineComment {
  string text;
};

struct v_dot_ast__MultiLineComment {
  string text;
};

struct compiler__CFlag {
  string mod;
  string os;
  string name;
  string value;
};

struct _V_MulRet_string_V_string {
  string var_0;
  string var_1;
};

struct compiler__MsvcResult {
  string full_cl_exe_path;
  string exe_path;
  string um_lib_path;
  string ucrt_lib_path;
  string vs_lib_path;
  string um_include_path;
  string ucrt_include_path;
  string vs_include_path;
  string shared_include_path;
};

struct compiler__WindowsKit {
  string um_lib_path;
  string ucrt_lib_path;
  string um_include_path;
  string ucrt_include_path;
  string shared_include_path;
};

struct compiler__VsInstallation {
  string include_path;
  string lib_path;
  string exe_path;
};

struct compiler__ModFileAndFolder {
  string vmod_file;
  string vmod_folder;
};

struct SymbolInfo {
  u32 f_size_of_struct;
  u32 f_type_index;
  u64 f_reserved[2];
  u32 f_index;
  u32 f_size;
  u64 f_mod_base;
  u32 f_flags;
  u64 f_value;
  u64 f_address;
  u32 f_register;
  u32 f_scope;
  u32 f_tag;
  u32 f_name_len;
  u32 f_max_name_len;
  byte f_name;
};

struct Line64 {
  u32 f_size_of_struct;
  void *f_key;
  u32 f_line_number;
  byte *f_file_name;
  u64 f_address;
};

struct SortedMap {
  int value_bytes;
  mapnode *root;
  int size;
};

struct mapnode {
  string keys[11];
  voidptr values[11];
  voidptr *children;
  int size;
};

struct ustring {
  string s;
  array_int runes;
  int len;
};

struct RepIndex {
  int idx;
  int val_idx;
};

struct varg_byte {
  int len;
  byte args[0];
};

struct strings__Builder {
  array_byte buf;
  int len;
  int initial_size;
};

union strconv__Float64u {
  f64 f;
  u64 u;
};

struct _V_MulRet_u32_V_u32_V_u32 {
  u32 var_0;
  u32 var_1;
  u32 var_2;
};

struct strconv__PrepNumber {
  bool negative;
  int exponent;
  u64 mantissa;
};

struct _V_MulRet_u32_V_u32 {
  u32 var_0;
  u32 var_1;
};

struct _V_MulRet_u64_V_u64 {
  u64 var_0;
  u64 var_1;
};

struct time__Time {
  int year;
  int month;
  int day;
  int hour;
  int minute;
  int second;
  int v_unix;
};

struct _V_MulRet_int_V_int_V_int {
  int var_0;
  int var_1;
  int var_2;
};

struct v_dot_token__Position {
  int line_nr;
  int pos;
};

struct v_dot_token__Token {
  v_dot_token__Kind kind;
  string lit;
  int line_nr;
  int pos;
};

struct v_dot_depgraph__DepGraphNode {
  string name;
  array_string deps;
};

struct v_dot_depgraph__DepGraph {
  bool acyclic;
  array_v_dot_depgraph__DepGraphNode nodes;
};

struct v_dot_depgraph__OrderedDepMap {
  array_string keys;
  map_array_string data;
};

struct strconv_dot_ftoa__Dec32 {
  u32 m;
  int e;
};

union strconv_dot_ftoa__Uf32 {
  f32 f;
  u32 u;
};

struct strconv_dot_ftoa__Uint128 {
  u64 lo;
  u64 hi;
};

struct strconv_dot_ftoa__Dec64 {
  u64 m;
  int e;
};

union strconv_dot_ftoa__Uf64 {
  f64 f;
  u64 u;
};

struct os__File {
  void *cfile;
  int fd;
  bool opened;
};

struct os__FileInfo {
  string name;
  int size;
};

struct varg_int {
  int len;
  int args[0];
};

struct _V_MulRet_int_V_bool {
  int var_0;
  bool var_1;
};

struct os__Result {
  int exit_code;
  string output;
};

struct varg_string {
  int len;
  string args[5];
};

struct os__Filetime {
  u32 dwLowDateTime;
  u32 dwHighDateTime;
};

struct os__ProcessInformation {
  void *hProcess;
  void *hThread;
  u32 dwProcessId;
  u32 dwThreadId;
};

struct os__StartupInfo {
  u32 cb;
  u16 *lpReserved;
  u16 *lpDesktop;
  u16 *lpTitle;
  u32 dwX;
  u32 dwY;
  u32 dwXSize;
  u32 dwYSize;
  u32 dwXCountChars;
  u32 dwYCountChars;
  u32 dwFillAttribute;
  u32 dwFlags;
  u16 wShowWindow;
  u16 cbReserved2;
  byte *lpReserved2;
  void *hStdInput;
  void *hStdOutput;
  void *hStdError;
};

struct os__SecurityAttributes {
  u32 nLength;
  void *lpSecurityDescriptor;
  bool bInheritHandle;
};

struct v_dot_pref__Preferences {
  v_dot_pref__OS os;
  v_dot_pref__Backend backend;
  v_dot_pref__BuildMode build_mode;
  v_dot_pref__VerboseLevel verbosity;
  bool is_test;
  bool is_script;
  bool is_live;
  bool is_solive;
  bool is_so;
  bool is_prof;
  bool translated;
  bool is_prod;
  bool obfuscate;
  bool is_repl;
  bool is_run;
  bool sanitize;
  bool is_debug;
  bool is_vlines;
  bool is_keep_c;
  bool is_pretty_c;
  bool is_cache;
  bool is_stats;
  bool no_auto_free;
  string cflags;
  string ccompiler;
  string third_party_option;
  bool building_v;
  bool autofree;
  bool compress;
  bool fast;
  bool enable_globals;
  bool is_bare;
  array_string lookup_path;
  bool output_cross_c;
  bool prealloc;
  string vroot;
  string out_name;
  string path;
  array_string compile_defines;
  array_string compile_defines_all;
  string mod;
};

struct v_dot_table__TypeSymbol {
  int parent_idx;
  v_dot_table__TypeInfo info;
  v_dot_table__Kind kind;
  string name;
  array_v_dot_table__Fn methods;
};

struct v_dot_table__MultiReturn {
  string name;
  array_v_dot_table__Type types;
};

struct v_dot_table__Table {
  array_v_dot_table__TypeSymbol types;
  map_int type_idxs;
  map_v_dot_table__Fn fns;
  map_v_dot_table__Var consts;
  array_string imports;
  array_string modules;
};

struct v_dot_table__Struct {
  array_v_dot_table__Field fields;
};

struct v_dot_table__Enum {
  array_string vals;
};

struct v_dot_table__Field {
  string name;
  v_dot_table__Type typ;
};

struct v_dot_table__Array {
  int nr_dims;
  v_dot_table__Type elem_type;
};

struct v_dot_table__ArrayFixed {
  int nr_dims;
  int size;
  v_dot_table__Type elem_type;
};

struct v_dot_table__Map {
  v_dot_table__Type key_type;
  v_dot_table__Type value_type;
};

struct v_dot_table__SumType {
  array_v_dot_table__Type variants;
};

struct v_dot_table__Fn {
  string name;
  array_v_dot_table__Arg args;
  v_dot_table__Type return_type;
  bool is_variadic;
  bool is_c;
};

struct v_dot_table__Arg {
  string name;
  bool is_mut;
  v_dot_table__Type typ;
};

struct v_dot_table__Var {
  string name;
  bool is_mut;
  bool is_const;
  bool is_global;
  v_dot_table__Type typ;
};

struct _V_MulRet_int_V_int {
  int var_0;
  int var_1;
};

struct v_dot_scanner__Scanner {
  string file_path;
  string text;
  int pos;
  int line_nr;
  int last_nl_pos;
  bool inside_string;
  bool inter_start;
  bool inter_end;
  bool debug;
  string line_comment;
  bool started;
  string fn_name;
  bool print_line_on_error;
  bool print_colored_error;
  bool print_rel_paths_on_error;
  byte quote;
  array_int line_ends;
  int nr_lines;
  bool is_vh;
  bool is_fmt;
  v_dot_scanner__CommentsMode comments_mode;
};

struct internal_dot_flag__Instance {
  array_string args;
  string current_flag;
  int current_pos;
  string equal_val;
  map_bool encountered;
};

struct internal_dot_flag__MainCmdPreferences {
  v_dot_pref__VerboseLevel verbosity;
  internal_dot_flag__MainCmdAction action;
  string unknown_flag;
};

struct benchmark__Benchmark {
  i64 bench_start_time;
  i64 bench_end_time;
  i64 step_start_time;
  i64 step_end_time;
  int ntotal;
  int nok;
  int nfail;
  bool verbose;
  int nexpected_steps;
  int cstep;
  string bok;
  string bfail;
};

struct v_dot_ast__Type {
  v_dot_table__Type typ;
};

struct v_dot_ast__ExprStmt {
  v_dot_ast__Expr expr;
  v_dot_table__Type typ;
};

struct v_dot_ast__IntegerLiteral {
  int val;
};

struct v_dot_ast__BoolLiteral {
  bool val;
};

struct v_dot_ast__Module {
  string name;
  string path;
  v_dot_ast__Expr expr;
};

struct v_dot_ast__Field {
  string name;
  v_dot_table__Type typ;
};

struct v_dot_ast__ConstDecl {
  array_v_dot_ast__Field fields;
  array_v_dot_ast__Expr exprs;
  bool is_pub;
};

struct v_dot_ast__CallArg {
  bool is_mut;
  v_dot_ast__Expr expr;
  v_dot_table__Type typ;
  v_dot_table__Type expected_type;
};

struct v_dot_ast__GlobalDecl {
  string name;
  v_dot_ast__Expr expr;
  v_dot_table__Type typ;
};

struct v_dot_ast__IdentFn {
  v_dot_table__Type typ;
};

struct v_dot_ast__IdentVar {
  v_dot_table__Type typ;
  bool is_mut;
  bool is_static;
  bool is_optional;
};

struct v_dot_ast__PrefixExpr {
  v_dot_token__Kind op;
  v_dot_ast__Expr right;
};

struct v_dot_ast__CompIf {
  v_dot_ast__Expr cond;
  array_v_dot_ast__Stmt stmts;
  array_v_dot_ast__Stmt else_stmts;
};

struct v_dot_ast__ForCStmt {
  v_dot_ast__Stmt init;
  bool has_init;
  v_dot_ast__Expr cond;
  v_dot_ast__Expr inc;
  array_v_dot_ast__Stmt stmts;
};

struct v_dot_ast__AsCast {
  v_dot_ast__Expr expr;
  v_dot_table__Type typ;
};

struct v_dot_ast__EnumDecl {
  string name;
  bool is_pub;
  array_string vals;
};

struct v_dot_ast__AliasTypeDecl {
  string name;
  bool is_pub;
  v_dot_table__Type parent_type;
};

struct v_dot_ast__SumTypeDecl {
  string name;
  bool is_pub;
  array_v_dot_table__Type sub_types;
};

struct v_dot_ast__FnTypeDecl {
  string name;
  bool is_pub;
  v_dot_table__Type typ;
};

struct v_dot_ast__DeferStmt {
  array_v_dot_ast__Stmt stmts;
};

struct v_dot_ast__UnsafeStmt {
  array_v_dot_ast__Stmt stmts;
};

struct v_dot_ast__ParExpr {
  v_dot_ast__Expr expr;
};

struct v_dot_ast__GoStmt {
  v_dot_ast__Expr expr;
};

struct v_dot_ast__RangeExpr {
  v_dot_ast__Expr low;
  v_dot_ast__Expr high;
  bool has_high;
  bool has_low;
};

struct v_dot_ast__CastExpr {
  v_dot_ast__Expr expr;
  v_dot_ast__Expr arg;
  v_dot_table__Type typ;
  v_dot_table__Type expr_type;
  bool has_arg;
};

struct v_dot_ast__AssertStmt {
  v_dot_ast__Expr expr;
};

struct v_dot_ast__IfGuardExpr {
  string var_name;
  v_dot_ast__Expr expr;
};

struct v_dot_ast__OrExpr {
  array_v_dot_ast__Stmt stmts;
};

struct v_dot_ast__ConcatExpr {
  array_v_dot_ast__Expr vals;
};

struct v_dot_ast__None {
  int foo;
};

struct v_dot_ast__Scope {
  v_dot_ast__Scope *parent;
  array_ptr_v_dot_ast__Scope children;
  int start_pos;
  int end_pos;
  map_v_dot_ast__Var vars;
};

struct sync__PoolProcessor {
  void *thread_cb;
  int njobs;
  array_voidptr items;
  array_voidptr results;
  int ntask;
  sync__Mutex *ntask_mtx;
  sync__WaitGroup *waitgroup;
  void *shared_context;
  array_voidptr thread_contexts;
};

struct sync__PoolProcessorConfig {
  int maxjobs;
  sync__ThreadCB callback;
};

struct sync__Mutex {
  sync__MHANDLE mx;
  sync__MutexState state;
  i64 cycle_wait;
  i64 cycle_woken;
  u32 reader_sem;
  u32 writer_sem;
};

struct sync__WaitGroup {
  sync__Mutex *mu;
  int active;
};

struct _V_MulRet_array_v_dot_table__Arg_V_bool {
  array_v_dot_table__Arg var_0;
  bool var_1;
};

struct v_dot_gen_dot_x64__Gen {
  string out_name;
  array_byte buf;
  int sect_header_name_pos;
  i64 offset;
  array_i64 str_pos;
  array_string strings;
  i64 file_size_pos;
  i64 main_fn_addr;
  i64 code_start_pos;
  map_i64 fn_addr;
};

struct v_dot_gen_dot_x64__SectionConfig {
  string name;
  v_dot_gen_dot_x64__SectionType typ;
  i64 flags;
  void *data;
  bool is_saa;
  i64 datalen;
  int link;
  int info;
  i64 align;
  i64 entsize;
};

struct compiler__ParserState {
  string scanner_file_path;
  int scanner_line_nr;
  string scanner_text;
  int scanner_pos;
  array_int scanner_line_ends;
  int scanner_nlines;
  array_string cgen_lines;
  string cgen_cur_line;
  string cgen_tmp_line;
  bool cgen_is_tmp;
  array_compiler__Token tokens;
  int token_idx;
  compiler__TokenKind tok;
  compiler__TokenKind prev_tok;
  compiler__TokenKind prev_tok2;
  string lit;
};

struct compiler__IndexConfig {
  bool is_map;
  bool is_str;
  bool is_ptr;
  bool is_arr;
  bool is_arr0;
  bool is_slice;
};

struct _V_MulRet_bool_V_string {
  bool var_0;
  string var_1;
};

struct compiler__Table {
  map_compiler__Type typesmap;
  array_compiler__Var consts;
  map_compiler__Fn fns;
  map_int obf_ids;
  array_string modules;
  array_string imports;
  array_compiler__CFlag cflags;
  int fn_cnt;
  bool obfuscate;
  array_compiler__VargAccess varg_access;
  map_int max_field_len;
  map_array_string generic_struct_params;
  map_array_string tuple_variants;
  map_array_string sum_types;
};

struct compiler__Scanner {
  string file_path;
  string text;
  int pos;
  int line_nr;
  int last_nl_pos;
  bool inside_string;
  bool inter_start;
  bool inter_end;
  bool debug;
  string line_comment;
  bool started;
  array_string fmt_lines;
  int fmt_indent;
  bool fmt_line_empty;
  compiler__TokenKind prev_tok;
  string fn_name;
  bool print_line_on_error;
  bool print_colored_error;
  bool print_rel_paths_on_error;
  byte quote;
  array_int line_ends;
  int nlines;
  bool is_vh;
  bool is_fmt;
};

struct compiler__ScannerPos {
  int pos;
  int line_nr;
  int last_nl_pos;
};

struct _V_MulRet_array_string_V_string {
  array_string var_0;
  string var_1;
};

struct compiler__DepGraphNode {
  string name;
  array_string deps;
};

struct compiler__DepGraph {
  bool acyclic;
  array_compiler__DepGraphNode nodes;
};

struct compiler__OrderedDepMap {
  array_string keys;
  map_array_string data;
};

struct compiler__Fn {
  string name;
  string mod;
  array_compiler__Var args;
  bool is_interface;
  int scope_level;
  string typ;
  string receiver_typ;
  bool is_c;
  bool is_public;
  bool is_method;
  bool is_decl;
  bool is_unsafe;
  bool is_deprecated;
  bool is_variadic;
  bool is_generic;
  bool returns_error;
  array_string defer_text;
  array_string type_pars;
  array_compiler__TypeInst type_inst;
  int generic_fn_idx;
  int parser_idx;
  int fn_name_token_idx;
  string comptime_define;
  bool is_used;
};

struct compiler__TypeInst {
  map_string inst;
  bool done;
};

struct _V_MulRet_string_V_array_string {
  string var_0;
  array_string var_1;
};

struct compiler__ImportTable {
  map_string imports;
  array_string used_imports;
  map_int import_tok_idx;
};

struct compiler__MsvcStringFlags {
  array_string real_libs;
  array_string inc_paths;
  array_string lib_paths;
  array_string other_flags;
};

struct compiler__ScanRes {
  compiler__TokenKind tok;
  string lit;
};

struct compiler__VargAccess {
  string fn_name;
  int tok_idx;
  int index;
};

struct compiler__Name {
  compiler__NameCategory cat;
  int idx;
};

struct compiler__Var {
  string typ;
  string name;
  int idx;
  bool is_arg;
  bool is_const;
  array_compiler__Var args;
  string attr;
  bool is_mut;
  bool is_alloc;
  bool is_returned;
  bool ptr;
  bool ref;
  string parent_fn;
  string mod;
  compiler__AccessMod access_mod;
  bool is_global;
  bool is_used;
  bool is_changed;
  int scope_level;
  bool is_c;
  bool is_moved;
  int line_nr;
  int token_idx;
  bool is_for_var;
  bool is_public;
};

struct compiler__Token {
  compiler__TokenKind tok;
  string lit;
  int line_nr;
  int name_idx;
  int pos;
};

struct compiler__ModFileCacher {
  map_compiler__ModFileAndFolder cache;
  map_array_string folder_files;
};

struct _V_MulRet_array_string_V_compiler__ModFileAndFolder {
  array_string var_0;
  compiler__ModFileAndFolder var_1;
};

struct internal_dot_compile__Deprecated {
  string old;
  string new;
  bool not_exactly;
};

struct SymbolInfoContainer {
  SymbolInfo syminfo;
  char f_name_rest[254];
};

struct _V_MulRet_int_V_strconv__PrepNumber {
  int var_0;
  strconv__PrepNumber var_1;
};

struct _V_MulRet_strconv_dot_ftoa__Dec32_V_bool {
  strconv_dot_ftoa__Dec32 var_0;
  bool var_1;
};

struct _V_MulRet_strconv_dot_ftoa__Dec64_V_bool {
  strconv_dot_ftoa__Dec64 var_0;
  bool var_1;
};

struct os__Win32finddata {
  u32 dwFileAttributes;
  os__Filetime ftCreationTime;
  os__Filetime ftLastAccessTime;
  os__Filetime ftLastWriteTime;
  u32 nFileSizeHigh;
  u32 nFileSizeLow;
  u32 dwReserved0;
  u32 dwReserved1;
  u16 cFileName[260];
  u16 cAlternateFileName[14];
  u32 dwFileType;
  u32 dwCreatorType;
  u16 wFinderFlags;
};

struct v_dot_ast__SelectorExpr {
  v_dot_token__Position pos;
  v_dot_ast__Expr expr;
  string field;
  v_dot_table__Type expr_type;
};

struct v_dot_ast__StructDecl {
  v_dot_token__Position pos;
  string name;
  array_v_dot_ast__Field fields;
  bool is_pub;
  int mut_pos;
  int pub_pos;
  int pub_mut_pos;
  bool is_c;
};

struct v_dot_ast__StructInit {
  v_dot_token__Position pos;
  v_dot_table__Type typ;
  array_string fields;
  array_v_dot_ast__Expr exprs;
};

struct v_dot_ast__Import {
  v_dot_token__Position pos;
  string mod;
  string alias;
};

struct v_dot_ast__FnDecl {
  string name;
  array_v_dot_ast__Stmt stmts;
  v_dot_table__Type return_type;
  array_v_dot_table__Arg args;
  bool is_deprecated;
  bool is_pub;
  bool is_variadic;
  v_dot_ast__Field receiver;
  bool is_method;
  bool rec_mut;
  bool is_c;
  bool no_body;
};

struct v_dot_ast__BranchStmt {
  v_dot_token__Token tok;
};

struct v_dot_ast__CallExpr {
  v_dot_token__Position pos;
  string name;
  array_v_dot_ast__CallArg args;
  bool is_c;
  array_bool muts;
  v_dot_ast__OrExpr or_block;
  v_dot_table__Type return_type;
};

struct v_dot_ast__MethodCallExpr {
  v_dot_token__Position pos;
  v_dot_ast__Expr expr;
  string name;
  array_v_dot_ast__CallArg args;
  v_dot_ast__OrExpr or_block;
  v_dot_table__Type expr_type;
  v_dot_table__Type receiver_type;
  v_dot_table__Type return_type;
};

struct v_dot_ast__Return {
  v_dot_token__Position pos;
  array_v_dot_ast__Expr exprs;
  array_v_dot_table__Type types;
};

struct v_dot_ast__Var {
  string name;
  v_dot_ast__Expr expr;
  bool is_mut;
  v_dot_table__Type typ;
  v_dot_token__Position pos;
};

struct v_dot_ast__File {
  string path;
  v_dot_ast__Module mod;
  array_v_dot_ast__Import imports;
  array_v_dot_ast__Stmt stmts;
  v_dot_ast__Scope *scope;
};

struct v_dot_ast__Ident {
  string value;
  bool is_c;
  v_dot_token__Kind tok_kind;
  v_dot_token__Position pos;
  string name;
  v_dot_ast__IdentKind kind;
  v_dot_ast__IdentInfo info;
};

struct v_dot_ast__InfixExpr {
  v_dot_token__Kind op;
  v_dot_token__Position pos;
  v_dot_ast__Expr left;
  v_dot_ast__Expr right;
  v_dot_table__Type left_type;
  v_dot_table__Type right_type;
};

struct v_dot_ast__PostfixExpr {
  v_dot_token__Kind op;
  v_dot_ast__Expr expr;
  v_dot_token__Position pos;
};

struct v_dot_ast__IndexExpr {
  v_dot_token__Position pos;
  v_dot_ast__Expr left;
  v_dot_ast__Expr index;
  v_dot_table__Type container_type;
};

struct v_dot_ast__IfExpr {
  v_dot_token__Kind tok_kind;
  v_dot_ast__Expr cond;
  array_v_dot_ast__Stmt stmts;
  array_v_dot_ast__Stmt else_stmts;
  v_dot_ast__Expr left;
  v_dot_token__Position pos;
  v_dot_table__Type typ;
  bool has_else;
};

struct v_dot_ast__MatchExpr {
  v_dot_token__Kind tok_kind;
  v_dot_ast__Expr cond;
  array_v_dot_ast__MatchBranch branches;
  v_dot_token__Position pos;
  v_dot_table__Type expr_type;
  bool is_sum_type;
};

struct v_dot_ast__MatchBranch {
  array_v_dot_ast__Expr exprs;
  array_v_dot_ast__Stmt stmts;
  v_dot_token__Position pos;
};

struct v_dot_ast__ForStmt {
  v_dot_ast__Expr cond;
  array_v_dot_ast__Stmt stmts;
  v_dot_token__Position pos;
  bool is_inf;
};

struct v_dot_ast__ForInStmt {
  string key_var;
  string val_var;
  v_dot_ast__Expr cond;
  bool is_range;
  v_dot_ast__Expr high;
  array_v_dot_ast__Stmt stmts;
  v_dot_token__Position pos;
};

struct v_dot_ast__ReturnStmt {
  v_dot_token__Kind tok_kind;
  v_dot_token__Position pos;
  array_v_dot_ast__Expr results;
};

struct v_dot_ast__AssignStmt {
  array_v_dot_ast__Ident left;
  array_v_dot_ast__Expr right;
  v_dot_token__Kind op;
  v_dot_token__Position pos;
  array_v_dot_table__Type left_types;
  array_v_dot_table__Type right_types;
};

struct v_dot_ast__EnumVal {
  string enum_name;
  string val;
  string mod;
  v_dot_token__Position pos;
  v_dot_table__Type typ;
};

struct v_dot_ast__AssignExpr {
  v_dot_token__Kind op;
  v_dot_token__Position pos;
  v_dot_ast__Expr left;
  v_dot_ast__Expr val;
  v_dot_table__Type left_type;
  v_dot_table__Type right_type;
};

struct v_dot_ast__ArrayInit {
  v_dot_token__Position pos;
  array_v_dot_ast__Expr exprs;
  v_dot_table__Type elem_type;
  v_dot_table__Type typ;
};

struct v_dot_ast__MapInit {
  v_dot_token__Position pos;
  array_v_dot_ast__Expr keys;
  array_v_dot_ast__Expr vals;
  v_dot_table__Type typ;
  v_dot_table__Type key_type;
  v_dot_table__Type value_type;
};

struct v_dot_ast__Assoc {
  string var_name;
  array_string fields;
  array_v_dot_ast__Expr exprs;
  v_dot_token__Position pos;
};

struct v_dot_parser__Parser {
  v_dot_scanner__Scanner *scanner;
  string file_name;
  v_dot_token__Token tok;
  v_dot_token__Token peek_tok;
  v_dot_table__Table *table;
  bool is_c;
  bool inside_if;
  v_dot_pref__Preferences *pref;
  bool builtin_mod;
  string mod;
  string attr;
  string expr_mod;
  v_dot_ast__Scope *scope;
  map_string imports;
  array_v_dot_ast__Import ast_imports;
  bool is_amp;
};

struct v_dot_parser__Queue {
  int idx;
  sync__Mutex mu;
  array_string paths;
  v_dot_table__Table *table;
  array_v_dot_ast__File parsed_ast_files;
};

struct v_dot_gen__Gen {
  strings__Builder out;
  strings__Builder typedefs;
  strings__Builder definitions;
  v_dot_table__Table *table;
  v_dot_ast__FnDecl *fn_decl;
  int tmp_count;
  map_int varaidic_args;
  bool is_c_call;
  bool is_assign_expr;
  bool is_array_set;
  bool is_amp;
  array_string optionals;
};

struct v_dot_gen__JsGen {
  strings__Builder out;
  v_dot_table__Table *table;
};

struct v_dot_doc__Doc {
  strings__Builder out;
  v_dot_table__Table *table;
  string mod;
  array_v_dot_ast__Stmt stmts;
};

struct compiler__Parser {
  string file_path;
  string file_path_dir;
  string file_name;
  string file_platform;
  string file_pcguard;
  compiler__V *v;
  v_dot_pref__Preferences *pref;
  compiler__Scanner *scanner;
  array_compiler__Token tokens;
  int token_idx;
  int prev_stuck_token_idx;
  compiler__TokenKind tok;
  compiler__TokenKind prev_tok;
  compiler__TokenKind prev_tok2;
  string lit;
  compiler__CGen *cgen;
  compiler__Table *table;
  compiler__ImportTable import_table;
  compiler__Pass pass;
  v_dot_pref__OS os;
  bool inside_const;
  compiler__Var expr_var;
  bool has_immutable_field;
  compiler__Var first_immutable_field;
  string assigned_type;
  string expected_type;
  int tmp_cnt;
  bool builtin_mod;
  bool inside_if_expr;
  bool inside_return_expr;
  bool inside_unsafe;
  bool is_struct_init;
  bool is_var_decl;
  int if_expr_cnt;
  int for_expr_cnt;
  bool ptr_cast;
  bool calling_c;
  compiler__Fn cur_fn;
  array_compiler__Var local_vars;
  array_compiler__Var global_vars;
  int var_idx;
  bool returns;
  string vroot;
  bool is_c_struct_init;
  bool is_empty_c_struct_init;
  bool is_c_fn_call;
  bool can_chash;
  string attr;
  bool v_script;
  string var_decl_name;
  bool is_alloc;
  bool is_const_literal;
  bool in_dispatch;
  bool is_vgen;
  bool is_sql;
  bool is_js;
  int sql_i;
  array_string sql_params;
  array_string sql_types;
  bool is_vh;
  compiler__TypeInst generic_dispatch;
  string mod;
};

struct compiler__V {
  compiler__ModFileCacher *mod_file_cacher;
  string out_name_c;
  array_string files;
  string compiled_dir;
  compiler__Table *table;
  compiler__CGen *cgen;
  v_dot_pref__Preferences *pref;
  array_compiler__Parser parsers;
  strings__Builder vgen_buf;
  map_int file_parser_idx;
  map_int gen_parser_idx;
  array_string cached_mods;
  array_string module_lookup_paths;
  bool v_fmt_all;
  string v_fmt_file;
  string v_fmt_file_result;
};

struct compiler__CGen {
  os__File out;
  string out_path;
  array_string thread_fns;
  bool is_user;
  array_string lines;
  array_string lines_extra;
  array_string typedefs;
  array_string type_aliases;
  array_string includes;
  array_string thread_args;
  array_string consts;
  array_string const_defines;
  array_string fns;
  array_string so_fns;
  array_string consts_init;
  compiler__Pass pass;
  bool nogen;
  array_string prev_tmps;
  string tmp_line;
  string cur_line;
  string prev_line;
  bool is_tmp;
  string fn_main;
  string stash;
  string file;
  int line;
  bool line_directives;
  int cut_pos;
};

struct compiler__VhGen {
  int i;
  strings__Builder consts;
  strings__Builder fns;
  strings__Builder types;
  array_compiler__Token tokens;
};

struct compiler__Type {
  string mod;
  string name;
  compiler__TypeCategory cat;
  bool is_public;
  array_compiler__Var fields;
  array_compiler__Fn methods;
  string parent;
  compiler__Fn func;
  bool is_c;
  array_string enum_vals;
  array_string gen_types;
  array_string default_vals;
  int parser_idx;
  int decl_tok_idx;
  bool is_placeholder;
  bool gen_str;
  bool is_flag;
  bool is_generic;
  array_string ctype_names;
};

struct _V_MulRet_v_dot_pref__Preferences_V_array_string {
  v_dot_pref__Preferences var_0;
  array_string var_1;
};

struct _V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var {
  v_dot_ast__Scope *var_0;
  v_dot_ast__Var var_1;
};

struct v_dot_checker__Checker {
  v_dot_table__Table *table;
  v_dot_ast__File file;
  int nr_errors;
  array_string errors;
  v_dot_table__Type expected_type;
  v_dot_table__Type fn_return_type;
  bool is_amp;
};

struct compiler__TypeNode {
  compiler__TypeNode *next;
  compiler__Type typ;
};

struct v_dot_builder__Builder {
  v_dot_pref__Preferences *pref;
  v_dot_table__Table *table;
  v_dot_checker__Checker checker;
  v_dot_pref__OS os;
  string compiled_dir;
  string module_path;
  array_string module_search_paths;
  array_v_dot_ast__File parsed_files;
};

string _STR(const char *, ...);

string _STR_TMP(const char *, ...);

array new_array(int mylen, int cap, int elm_size);
array make(int len, int cap, int elm_size);
array new_array_from_c_array(int len, int cap, int elm_size, void *c_array);
array new_array_from_c_array_no_alloc(int len, int cap, int elm_size,
                                      void *c_array);
void array_ensure_cap(array *a, int required);
array array_repeat(array a, int count);
void array_sort_with_compare(array *a, void *compare);
void array_insert(array *a, int i, void *val);
void array_prepend(array *a, void *val);
void v_array_delete(array *a, int i);
void array_clear(array *a);
void array_trim(array *a, int index);
void *array_get(array a, int i);
void *array_first(array a);
void *array_last(array a);
array array_slice(array a, int start, int _end);
array array_slice2(array a, int start, int _end, bool end_max);
array array_clone(array *a);
array array_slice_clone(array *a, int start, int _end);
void array_set(array *a, int i, void *val);
void array_push(array *a, void *val);
void array_push_many(array *a3, void *val, int size);
array array_reverse(array a);
void v_array_free(array a);
string array_string_str(array_string a);
string array_int_str(array_int a);
string array_bool_str(array_bool a);
string array_byte_hex(array_byte b);
int copy(array_byte dst, array_byte src);
int compare_ints(int *a, int *b);
void array_int_sort(array_int *a);
int array_string_index(array_string a, string v);
int array_int_index(array_int a, int v);
int array_byte_index(array_byte a, byte v);
int array_char_index(array_char a, char v);
int array_int_reduce(array_int a, int (*iter)(int accum, int curr /*FFF*/),
                     int accum_start);
bool array_string_eq(array_string a1, array_string a2);
int compare_i64(i64 *a, i64 *b);
int compare_f64(f64 *a, f64 *b);
int compare_f32(f32 *a, f32 *b);
array_voidptr array_pointers(array a);
void builtin__init();
void v_exit(int code);
bool isnil(void *v);
void print_backtrace_skipping_top_frames(int skipframes);
void print_backtrace();
void panic_debug(int line_no, string file, string mod, string fn_name,
                 string s);
void v_panic(string s);
void eprintln(string s);
void eprint(string s);
void print(string s);
void looo();
byte *v_malloc(int n);
byte *v_calloc(int n);
byte *vcalloc(int n);
void v_free(void *ptr);
void *memdup(void *src, int sz);
void v_ptr_free(void *ptr);
int is_atty(int fd);
bool print_backtrace_skipping_top_frames_msvc(int skipframes);
bool print_backtrace_skipping_top_frames_mingw(int skipframes);
bool print_backtrace_skipping_top_frames_nix(int skipframes);
void println(string s);
int backtrace(void *a, int b);
byteptr *backtrace_symbols(void *, int);
void backtrace_symbols_fd(void *, int, int);
int proc_pidpath(int, void *, int);
static inline string f64_str(f64 d);
static inline string f64_strsci(f64 x, int digit_num);
static inline string f64_strlong(f64 x);
static inline string f32_str(f32 d);
static inline string f32_strsci(f32 x, int digit_num);
static inline string f32_strlong(f32 x);
static inline f32 f32_abs(f32 a);
static inline f64 f64_abs(f64 a);
static inline bool f64_eq(f64 a, f64 b);
static inline bool f32_eq(f32 a, f32 b);
bool f64_eqbit(f64 a, f64 b);
bool f32_eqbit(f32 a, f32 b);
bool f64_ne(f64 a, f64 b);
bool f32_ne(f32 a, f32 b);
bool f64_nebit(f64 a, f64 b);
bool f32_nebit(f32 a, f32 b);
bool f64_lt(f64 a, f64 b);
bool f32_lt(f32 a, f32 b);
bool f64_ltbit(f64 a, f64 b);
bool f32_ltbit(f32 a, f32 b);
bool f64_le(f64 a, f64 b);
bool f32_le(f32 a, f32 b);
bool f64_lebit(f64 a, f64 b);
bool f32_lebit(f32 a, f32 b);
bool f64_gt(f64 a, f64 b);
bool f32_gt(f32 a, f32 b);
bool f64_gtbit(f64 a, f64 b);
bool f32_gtbit(f32 a, f32 b);
bool f64_ge(f64 a, f64 b);
bool f32_ge(f32 a, f32 b);
bool f64_gebit(f64 a, f64 b);
bool f32_gebit(f32 a, f32 b);
string ptr_str(void *ptr);
static inline string int_str_l(int nn, int max);
string i8_str(i8 n);
string i16_str(i16 n);
string u16_str(u16 n);
string int_str(int n);
string u32_str(u32 nn);
string i64_str(i64 nn);
string u64_str(u64 nn);
string bool_str(bool b);
string int_hex(int nn);
string u64_hex(u64 nn);
string i64_hex(i64 nn);
bool array_byte_contains(array_byte a, byte val);
string rune_str(rune c);
string byte_str(byte c);
bool byte_is_capital(byte c);
array_byte array_byte_clone(array_byte b);
static inline DenseArray new_dense_array();
static inline u32 DenseArray_push(DenseArray *d, KeyValue kv);
void DenseArray_zeros_to_end(DenseArray *d);
map new_map(int n, int value_bytes);
map new_map_init(int n, int value_bytes, string *keys, void *values);
void map_set(map *m, string key, void *value);
void map_expand(map *m);
void map_shrink(map *m);
void map_rehash(map *m);
void map_cached_rehash(map *m, u32 old_cap);
static inline bool map_get(map m, string key, void *out);
static inline bool map_exists(map m, string key);
void v_map_delete(map *m, string key);
array_string map_keys(map *m);
void v_map_free(map m);
void map_print(map m);
string map_string_str(map_string m);
Option opt_ok(void *data, int size);
Option opt_none();
Option v_error(string s);
Option error_with_code(string s, int code);
SortedMap new_sorted_map(int n, int value_bytes);
SortedMap new_sorted_map_init(int n, int value_bytes, string *keys,
                              void *values);
mapnode *new_node();
void SortedMap_set(SortedMap *m, string key, void *value);
void mapnode_split_child(mapnode *n, int child_index, mapnode *y);
bool SortedMap_get(SortedMap m, string key, void *out);
bool SortedMap_exists(SortedMap m, string key);
int mapnode_find_key(mapnode *n, string k);
bool mapnode_remove_key(mapnode *n, string k);
void mapnode_remove_from_leaf(mapnode *n, int idx);
void mapnode_remove_from_non_leaf(mapnode *n, int idx);
void mapnode_fill(mapnode *n, int idx);
void mapnode_borrow_from_prev(mapnode *n, int idx);
void mapnode_borrow_from_next(mapnode *n, int idx);
void mapnode_merge(mapnode *n, int idx);
void v_SortedMap_delete(SortedMap *m, string key);
int mapnode_subkeys(mapnode *n, array_string *keys, int at);
array_string SortedMap_keys(SortedMap *m);
void v_mapnode_free(mapnode *n);
void v_SortedMap_free(SortedMap *m);
void SortedMap_print(SortedMap m);
int vstrlen(byte *s);
string tos(byte *s, int len);
string tos_clone(byte *s);
string tos2(byte *s);
string tos3(charptr s);
string string_clone(string a);
string cstring_to_vstring(byte *cstr);
string string_replace_once(string s, string rep, string with);
string string_replace(string s, string rep, string with);
int compare_rep_index(RepIndex *a, RepIndex *b);
void array_RepIndex_sort(array_RepIndex *a);
string string_replace_each(string s, array_string vals);
bool string_bool(string s);
int v_string_int(string s);
i64 string_i64(string s);
i8 string_i8(string s);
i16 string_i16(string s);
f32 string_f32(string s);
f64 string_f64(string s);
u16 string_u16(string s);
u32 string_u32(string s);
u64 string_u64(string s);
bool string_eq(string s, string a);
bool string_ne(string s, string a);
bool string_lt(string s, string a);
bool string_le(string s, string a);
bool string_gt(string s, string a);
bool string_ge(string s, string a);
string string_add(string s, string a);
array_string string_split(string s, string delim);
array_string string_split_nth(string s, string delim, int nth);
array_string string_split_into_lines(string s);
string string_left(string s, int n);
string string_right(string s, int n);
string string_substr2(string s, int start, int _end, bool end_max);
string string_substr(string s, int start, int end);
int string_index_old(string s, string p);
Option_int string_index(string s, string p);
int string_index_kmp(string s, string p);
int string_index_any(string s, string chars);
Option_int string_last_index(string s, string p);
int string_index_after(string s, string p, int start);
int string_index_byte(string s, byte c);
int string_last_index_byte(string s, byte c);
int string_count(string s, string substr);
bool string_contains(string s, string p);
bool string_starts_with(string s, string p);
bool string_ends_with(string s, string p);
string string_to_lower(string s);
string string_to_upper(string s);
string string_capitalize(string s);
string string_title(string s);
string string_find_between(string s, string start, string end);
bool array_string_contains(array_string ar, string val);
bool array_int_contains(array_int ar, int val);
bool byte_is_space(byte c);
string string_trim_space(string s);
string string_trim(string s, string cutset);
string string_trim_left(string s, string cutset);
string string_trim_right(string s, string cutset);
int compare_strings(string *a, string *b);
int compare_strings_by_len(string *a, string *b);
int compare_lower_strings(string *a, string *b);
void array_string_sort(array_string *s);
void array_string_sort_ignore_case(array_string *s);
void array_string_sort_by_len(array_string *s);
ustring string_ustring(string s);
ustring string_ustring_tmp(string s);
bool ustring_eq(ustring u, ustring a);
bool ustring_ne(ustring u, ustring a);
bool ustring_lt(ustring u, ustring a);
bool ustring_le(ustring u, ustring a);
bool ustring_gt(ustring u, ustring a);
bool ustring_ge(ustring u, ustring a);
ustring ustring_add(ustring u, ustring a);
int ustring_index_after(ustring u, ustring p, int start);
int ustring_count(ustring u, ustring substr);
string ustring_substr(ustring u, int _start, int _end);
string ustring_left(ustring u, int pos);
string ustring_right(ustring u, int pos);
byte string_at(string s, int idx);
string ustring_at(ustring u, int idx);
void v_ustring_free(ustring u);
bool byte_is_digit(byte c);
bool byte_is_hex_digit(byte c);
bool byte_is_oct_digit(byte c);
bool byte_is_bin_digit(byte c);
bool byte_is_letter(byte c);
void v_string_free(string s);
string string_all_before(string s, string dot);
string string_all_before_last(string s, string dot);
string string_all_after(string s, string dot);
string string_after(string s, string dot);
string array_string_join(array_string a, string del);
string array_string_join_lines(array_string s);
string string_reverse(string s);
string string_limit(string s, int max);
bool byte_is_white(byte c);
int string_hash(string s);
array_byte string_bytes(string s);
string string_repeat(string s, int count);
string string_strip_margin(string s, varg_byte *del);
int utf8_char_len(byte b);
string utf32_to_str(u32 code);
string utf32_to_str_no_malloc(u32 code, void *buf);
int string_utf32_code(string _rune);
u16 *string_to_wide(string _str);
string string_from_wide(u16 *_wstr);
string string_from_wide2(u16 *_wstr, int len);
int utf8_len(byte c);
int utf8_getchar();
strings__Builder strings__new_builder(int initial_size);
void strings__Builder_write_bytes(strings__Builder *b, byte *bytes,
                                  int howmany);
void strings__Builder_write_b(strings__Builder *b, byte data);
void strings__Builder_write(strings__Builder *b, string s);
void strings__Builder_go_back(strings__Builder *b, int n);
void strings__Builder_writeln(strings__Builder *b, string s);
string strings__Builder_str(strings__Builder *b);
void strings__Builder_free(strings__Builder *b);
int strings__levenshtein_distance(string a, string b);
f32 strings__levenshtein_distance_percentage(string a, string b);
f32 strings__dice_coefficient(string s1, string s2);
string strings__repeat(byte c, int n);
string strings__repeat_string(string s, int n);
u64 hash_dot_wyhash__rand_u64(u64 *seed);
static inline u64 hash_dot_wyhash__wyhash_c(byte *key, u64 len, u64 seed);
static inline u64 hash_dot_wyhash__sum64_string(string key, u64 seed);
static inline u64 hash_dot_wyhash__sum64(array_byte key, u64 seed);
static inline u64 hash_dot_wyhash__wyhash64(byte *key, u64 len, u64 seed_);
static inline u64 hash_dot_wyhash__wyrotr(u64 v, u32 k);
static inline u64 hash_dot_wyhash__wymum(u64 a, u64 b);
static inline u64 hash_dot_wyhash__wyr3(byte *p, u64 k);
static inline u64 hash_dot_wyhash__wyr4(byte *p);
static inline u64 hash_dot_wyhash__wyr8(byte *p);
_V_MulRet_u32_V_u32_V_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0);
_V_MulRet_u32_V_u32_V_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0);
_V_MulRet_u32_V_u32_V_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1,
                                         u32 d0);
_V_MulRet_u32_V_u32_V_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1,
                                         u32 d0);
bool strconv__is_digit(byte x);
bool strconv__is_space(byte x);
bool strconv__is_exp(byte x);
_V_MulRet_int_V_strconv__PrepNumber strconv__parser(string s);
u64 strconv__converter(strconv__PrepNumber *pn);
f64 strconv__atof64(string s);
byte strconv__byte_to_lower(byte c);
u64 strconv__common_parse_uint(string s, int _base, int _bit_size,
                               bool error_on_non_digit,
                               bool error_on_high_digit);
u64 strconv__parse_uint(string s, int _base, int _bit_size);
i64 strconv__common_parse_int(string _s, int base, int _bit_size,
                              bool error_on_non_digit,
                              bool error_on_high_digit);
i64 strconv__parse_int(string _s, int base, int _bit_size);
int strconv__atoi(string s);
bool strconv__underscore_ok(string s);
f64 math__inf(int sign);
f64 math__nan();
bool math__is_nan(f64 f);
bool math__is_inf(f64 f, int sign);
f64 math__abs(f64 a);
f64 math__acos(f64 a);
f64 math__asin(f64 a);
f64 math__atan(f64 a);
f64 math__atan2(f64 a, f64 b);
f64 math__cbrt(f64 a);
f64 math__ceil(f64 a);
f64 math__cos(f64 a);
f32 math__cosf(f32 a);
f64 math__cosh(f64 a);
f64 math__degrees(f64 radians);
f64 math__exp(f64 a);
array_int math__digits(int _n, int base);
f64 math__erf(f64 a);
f64 math__erfc(f64 a);
f64 math__exp2(f64 a);
f64 math__floor(f64 a);
f64 math__fmod(f64 a, f64 b);
f64 math__gamma(f64 a);
i64 math__gcd(i64 a_, i64 b_);
f64 math__hypot(f64 a, f64 b);
i64 math__lcm(i64 a, i64 b);
f64 math__log(f64 a);
f64 math__log2(f64 a);
f64 math__log10(f64 a);
f64 math__log_gamma(f64 a);
f64 math__log_n(f64 a, f64 b);
f64 math__max(f64 a, f64 b);
f64 math__min(f64 a, f64 b);
f64 math__pow(f64 a, f64 b);
f32 math__powf(f32 a, f32 b);
f64 math__radians(f64 degrees);
f64 math__round(f64 f);
f64 math__sin(f64 a);
f32 math__sinf(f32 a);
f64 math__sinh(f64 a);
f64 math__sqrt(f64 a);
f32 math__sqrtf(f32 a);
f64 math__tan(f64 a);
f32 math__tanf(f32 a);
f64 math__tanh(f64 a);
f64 math__trunc(f64 a);
f64 math__aprox_sin(f64 a);
f64 math__aprox_cos(f64 a);
u32 math__f32_bits(f32 f);
f32 math__f32_from_bits(u32 b);
u64 math__f64_bits(f64 f);
f64 math__f64_from_bits(u64 b);
int math_dot_bits__leading_zeros_8(byte x);
int math_dot_bits__leading_zeros_16(u16 x);
int math_dot_bits__leading_zeros_32(u32 x);
int math_dot_bits__leading_zeros_64(u64 x);
int math_dot_bits__trailing_zeros_8(byte x);
int math_dot_bits__trailing_zeros_16(u16 x);
int math_dot_bits__trailing_zeros_32(u32 x);
int math_dot_bits__trailing_zeros_64(u64 x);
int math_dot_bits__ones_count_8(byte x);
int math_dot_bits__ones_count_16(u16 x);
int math_dot_bits__ones_count_32(u32 x);
int math_dot_bits__ones_count_64(u64 x);
static inline byte math_dot_bits__rotate_left_8(byte x, int k);
static inline u16 math_dot_bits__rotate_left_16(u16 x, int k);
static inline u32 math_dot_bits__rotate_left_32(u32 x, int k);
static inline u64 math_dot_bits__rotate_left_64(u64 x, int k);
static inline byte math_dot_bits__reverse_8(byte x);
static inline u16 math_dot_bits__reverse_16(u16 x);
static inline u32 math_dot_bits__reverse_32(u32 x);
static inline u64 math_dot_bits__reverse_64(u64 x);
static inline u16 math_dot_bits__reverse_bytes_16(u16 x);
static inline u32 math_dot_bits__reverse_bytes_32(u32 x);
static inline u64 math_dot_bits__reverse_bytes_64(u64 x);
int math_dot_bits__len_8(byte x);
int math_dot_bits__len_16(u16 x);
int math_dot_bits__len_32(u32 x);
int math_dot_bits__len_64(u64 x);
_V_MulRet_u32_V_u32 math_dot_bits__add_32(u32 x, u32 y, u32 carry);
_V_MulRet_u64_V_u64 math_dot_bits__add_64(u64 x, u64 y, u64 carry);
_V_MulRet_u32_V_u32 math_dot_bits__sub_32(u32 x, u32 y, u32 borrow);
_V_MulRet_u64_V_u64 math_dot_bits__sub_64(u64 x, u64 y, u64 borrow);
_V_MulRet_u32_V_u32 math_dot_bits__mul_32(u32 x, u32 y);
_V_MulRet_u64_V_u64 math_dot_bits__mul_64(u64 x, u64 y);
_V_MulRet_u32_V_u32 math_dot_bits__div_32(u32 hi, u32 lo, u32 y);
_V_MulRet_u64_V_u64 math_dot_bits__div_64(u64 hi, u64 lo, u64 y1);
u32 math_dot_bits__rem_32(u32 hi, u32 lo, u32 y);
u64 math_dot_bits__rem_64(u64 hi, u64 lo, u64 y);
string time__Time_format(time__Time t);
string time__Time_format_ss(time__Time t);
string time__Time_hhmm(time__Time t);
string time__Time_hhmmss(time__Time t);
string time__Time_hhmm12(time__Time t);
string time__Time_ymmdd(time__Time t);
string time__Time_ddmmy(time__Time t);
string time__Time_md(time__Time t);
string time__Time_clean(time__Time t);
string time__Time_clean12(time__Time t);
string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time);
string time__Time_get_fmt_date_str(time__Time t,
                                   time__FormatDelimiter fmt_dlmtr,
                                   time__FormatDate fmt_date);
string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr,
                              time__FormatTime fmt_time,
                              time__FormatDate fmt_date);
Option_time__Time time__parse(string s);
Option_time__Time time__parse_rfc2822(string s);
time__Time time__now();
string time__Time_smonth(time__Time t);
time__Time time__new_time(time__Time t);
int time__Time_calc_unix(time__Time *t);
time__Time time__Time_add_seconds(time__Time t, int seconds);
time__Time time__Time_add_days(time__Time t, int days);
int time__since(time__Time t);
string time__Time_relative(time__Time t);
int time__day_of_week(int y, int m, int d);
int time__Time_day_of_week(time__Time t);
string time__Time_weekday_str(time__Time t);
i64 time__ticks();
void time__sleep(int seconds);
void time__sleep_ms(int milliseconds);
void time__usleep(int microseconds);
bool time__is_leap_year(int year);
Option_int time__days_in_month(int month, int year);
string time__Time_str(time__Time t);
time__Time time__convert_ctime(struct /*TM*/ tm t);
int time__make_unix_time(struct /*TM*/ tm t);
time__Time time__unix(int abs);
static inline _V_MulRet_int_V_int_V_int
time__calculate_date_from_offset(int day_offset_);
static inline _V_MulRet_int_V_int_V_int
time__calculate_time_from_offset(int second_offset_);
array_string os_dot_cmdline__options(array_string args, string param);
string os_dot_cmdline__option(array_string args, string param, string def);
array_string os_dot_cmdline__options_before(array_string args,
                                            array_string what);
array_string os_dot_cmdline__options_after(array_string args,
                                           array_string what);
array_string os_dot_cmdline__only_non_options(array_string args);
array_string os_dot_cmdline__only_options(array_string args);
static inline v_dot_token__Position
v_dot_token__Token_position(v_dot_token__Token *tok);
map_int v_dot_token__build_keys();
array_string v_dot_token__build_token_str();
v_dot_token__Kind v_dot_token__key_to_token(string key);
bool v_dot_token__is_key(string key);
bool v_dot_token__is_decl(v_dot_token__Kind t);
bool v_dot_token__Kind_is_assign(v_dot_token__Kind t);
bool array_v_dot_token__Kind_contains(array_v_dot_token__Kind t,
                                      v_dot_token__Kind val);
string v_dot_token__Kind_str(v_dot_token__Kind t);
string v_dot_token__Token_str(v_dot_token__Token t);
array_v_dot_token__Precedence v_dot_token__build_precedences();
int v_dot_token__Token_precedence(v_dot_token__Token tok);
bool v_dot_token__Token_is_scalar(v_dot_token__Token tok);
bool v_dot_token__Token_is_unary(v_dot_token__Token tok);
bool v_dot_token__Kind_is_relational(v_dot_token__Kind tok);
bool v_dot_token__Kind_is_start_of_type(v_dot_token__Kind k);
bool v_dot_token__Kind_is_infix(v_dot_token__Kind kind);
void v_dot_depgraph__OrderedDepMap_set(v_dot_depgraph__OrderedDepMap *o,
                                       string name, array_string deps);
void v_dot_depgraph__OrderedDepMap_add(v_dot_depgraph__OrderedDepMap *o,
                                       string name, array_string deps);
array_string v_dot_depgraph__OrderedDepMap_get(v_dot_depgraph__OrderedDepMap *o,
                                               string name);
void v_dot_depgraph__OrderedDepMap_delete(v_dot_depgraph__OrderedDepMap *o,
                                          string name);
void v_dot_depgraph__OrderedDepMap_apply_diff(v_dot_depgraph__OrderedDepMap *o,
                                              string name, array_string deps);
int v_dot_depgraph__OrderedDepMap_size(v_dot_depgraph__OrderedDepMap *o);
v_dot_depgraph__DepGraph *v_dot_depgraph__new_dep_graph();
void v_dot_depgraph__DepGraph_add(v_dot_depgraph__DepGraph *graph, string mod,
                                  array_string deps);
v_dot_depgraph__DepGraph *
v_dot_depgraph__DepGraph_resolve(v_dot_depgraph__DepGraph *graph);
v_dot_depgraph__DepGraphNode
v_dot_depgraph__DepGraph_last_node(v_dot_depgraph__DepGraph *graph);
string v_dot_depgraph__DepGraph_display(v_dot_depgraph__DepGraph *graph);
string v_dot_depgraph__DepGraph_display_cycles(v_dot_depgraph__DepGraph *graph);
string strconv_dot_ftoa__Dec32_get_string_32(strconv_dot_ftoa__Dec32 d,
                                             bool neg, int n_digit);
_V_MulRet_strconv_dot_ftoa__Dec32_V_bool
strconv_dot_ftoa__f32_to_decimal_exact_int(u32 i_mant, u32 exp);
strconv_dot_ftoa__Dec32 strconv_dot_ftoa__f32_to_decimal(u32 mant, u32 exp);
string strconv_dot_ftoa__f32_to_str(f32 f, int n_digit);
string strconv_dot_ftoa__Dec64_get_string_64(strconv_dot_ftoa__Dec64 d,
                                             bool neg, int n_digit);
_V_MulRet_strconv_dot_ftoa__Dec64_V_bool
strconv_dot_ftoa__f64_to_decimal_exact_int(u64 i_mant, u64 exp);
strconv_dot_ftoa__Dec64 strconv_dot_ftoa__f64_to_decimal(u64 mant, u64 exp);
string strconv_dot_ftoa__f64_to_str(f64 f, int n_digit);
static inline string strconv_dot_ftoa__ftoa_64(f64 f);
static inline string strconv_dot_ftoa__ftoa_long_64(f64 f);
static inline string strconv_dot_ftoa__ftoa_32(f32 f);
static inline string strconv_dot_ftoa__ftoa_long_32(f32 f);
void strconv_dot_ftoa__assert1(bool t, string msg);
static inline int strconv_dot_ftoa__bool_to_int(bool b);
static inline u32 strconv_dot_ftoa__bool_to_u32(bool b);
static inline u64 strconv_dot_ftoa__bool_to_u64(bool b);
string strconv_dot_ftoa__get_string_special(bool neg, bool expZero,
                                            bool mantZero);
int strconv_dot_ftoa__decimal_len_32(u32 u);
u32 strconv_dot_ftoa__mul_shift_32(u32 m, u64 mul, int ishift);
u32 strconv_dot_ftoa__mul_pow5_invdiv_pow2(u32 m, u32 q, int j);
u32 strconv_dot_ftoa__mul_pow5_div_pow2(u32 m, u32 i, int j);
u32 strconv_dot_ftoa__pow5_factor_32(u32 i_v);
bool strconv_dot_ftoa__multiple_of_power_of_five_32(u32 v, u32 p);
bool strconv_dot_ftoa__multiple_of_power_of_two_32(u32 v, u32 p);
u32 strconv_dot_ftoa__log10_pow2(int e);
u32 strconv_dot_ftoa__log10_pow5(int e);
int strconv_dot_ftoa__pow5_bits(int e);
int strconv_dot_ftoa__decimal_len_64(u64 u);
u64 strconv_dot_ftoa__shift_right_128(strconv_dot_ftoa__Uint128 v, int shift);
u64 strconv_dot_ftoa__mul_shift_64(u64 m, strconv_dot_ftoa__Uint128 mul,
                                   int shift);
u32 strconv_dot_ftoa__pow5_factor_64(u64 v_i);
bool strconv_dot_ftoa__multiple_of_power_of_five_64(u64 v, u32 p);
bool strconv_dot_ftoa__multiple_of_power_of_two_64(u64 v, u32 p);
string strconv_dot_ftoa__f32_to_str_l(f64 f);
string strconv_dot_ftoa__f64_to_str_l(f64 f);
string os__getenv(string key);
int os__setenv(string name, string value, bool overwrite);
int os__unsetenv(string name);
map_string os__environ();
bool os__File_is_opened(os__File f);
array_byte os__File_read_bytes(os__File *f, int size);
array_byte os__File_read_bytes_at(os__File *f, int size, int pos);
Option_array_byte os__read_bytes(string path);
Option_string os__read_file(string path);
int os__file_size(string path);
void os__mv(string old, string new);
Option_bool os__cp(string old, string new);
Option_bool os__cp_r(string osource_path, string odest_path, bool overwrite);
Option_bool os__cp_all(string osource_path, string odest_path, bool overwrite);
Option_bool os__mv_by_cp(string source, string target);
FILE *os__vfopen(string path, string mode);
Option_array_string os__read_lines(string path);
Option_array_ustring os__read_ulines(string path);
Option_os__File os__open_append(string path);
Option_os__File os__open_file(string path, string mode, varg_int *options);
void os__File_write_bytes_at(os__File *f, void *data, int size, int pos);
void os__File_flush(os__File *f);
void *os__vpopen(string path);
_V_MulRet_int_V_bool os__posix_wait4_to_exit_status(int waitret);
string os__posix_get_error_msg(int code);
int os__vpclose(void *f);
int os__system(string cmd);
string os__sigint_to_signal_name(int si);
bool os__exists(string path);
bool os__is_executable(string path);
bool os__is_writable(string path);
bool os__is_readable(string path);
bool os__file_exists(string _path);
void os__rm(string path);
void os__rmdir(string path);
void os__rmdir_recursive(string path);
void os__rmdir_all(string path);
bool os__is_dir_empty(string path);
void os__print_c_errno();
string os__ext(string path);
string os__dir(string path);
string os__base_dir(string path);
string os__filename(string path);
string os__get_line();
string os__get_raw_line();
array_string os__get_lines();
string os__get_lines_joined();
string os__user_os();
string os__home_dir();
void os__write_file(string path, string text);
void os__clear();
void os__on_segfault(void *f);
string os__executable();
string os__executable_fallback();
Option_string os__find_abs_path_of_executable(string exepath);
bool os__dir_exists(string path);
bool os__is_dir(string path);
bool os__is_link(string path);
void os__chdir(string path);
string os__getwd();
string os__realpath(string fpath);
bool os__is_abs_path(string path);
string os__join_path(string base, varg_string *dirs);
array_string os__walk_ext(string path, string ext);
void os__walk(string path, void (*f)(string path /*FFF*/));
void os__signal(int signum, void *handler);
int os__fork();
int os__wait();
int os__file_last_mod_unix(string path);
void os__log(string s);
void os__flush_stdout();
void os__flush();
void os__mkdir_all(string path);
string os__cache_dir();
string os__temp_dir();
void os__chmod(string path, int mode);
string os__resource_abs_path(string path);
array_string os__init_os_args_wide(int argc, byteptr *argv);
Option_array_string os__ls(string path);
Option_os__File os__open(string path);
Option_os__File os__create(string path);
void os__File_write(os__File *f, string s);
void os__File_writeln(os__File *f, string s);
Option_bool os__mkdir(string path);
os__HANDLE os__get_file_handle(string path);
Option_string os__get_module_filename(os__HANDLE handle);
void *os__ptr_win_get_error_msg(u32 code);
string os__get_error_msg(int code);
Option_os__Result os__exec(string cmd);
Option_bool os__symlink(string origin, string target);
void os__File_write_bytes(os__File *f, void *data, int size);
void os__File_close(os__File *f);
void v_dot_pref__Preferences_fill_with_defaults(v_dot_pref__Preferences *p);
string v_dot_pref__default_c_compiler();
string v_dot_pref__vexe_path();
Option_v_dot_pref__OS v_dot_pref__os_from_string(string os_str);
string v_dot_pref__OS_str(v_dot_pref__OS o);
v_dot_pref__OS v_dot_pref__get_host_os();
Option_v_dot_pref__Backend v_dot_pref__backend_from_string(string s);
static inline bool
v_dot_pref__VerboseLevel_is_higher_or_equal(v_dot_pref__VerboseLevel v,
                                            v_dot_pref__VerboseLevel other);
bool array_v_dot_table__Type_contains(array_v_dot_table__Type types,
                                      v_dot_table__Type typ);
static inline int v_dot_table__type_idx(v_dot_table__Type t);
static inline int v_dot_table__type_nr_muls(v_dot_table__Type t);
static inline bool v_dot_table__type_is_ptr(v_dot_table__Type t);
static inline v_dot_table__Type
v_dot_table__type_set_nr_muls(v_dot_table__Type t, int nr_muls);
static inline v_dot_table__Type v_dot_table__type_to_ptr(v_dot_table__Type t);
static inline v_dot_table__Type v_dot_table__type_deref(v_dot_table__Type t);
static inline v_dot_table__Type
v_dot_table__type_clear_extra(v_dot_table__Type t);
static inline v_dot_table__TypeExtra
v_dot_table__type_extra(v_dot_table__Type t);
static inline v_dot_table__Type
v_dot_table__type_set_extra(v_dot_table__Type t, v_dot_table__TypeExtra extra);
static inline bool v_dot_table__type_is_optional(v_dot_table__Type t);
static inline v_dot_table__Type
v_dot_table__type_to_optional(v_dot_table__Type t);
static inline bool v_dot_table__type_is_variadic(v_dot_table__Type t);
static inline v_dot_table__Type
v_dot_table__type_to_variadic(v_dot_table__Type t);
static inline v_dot_table__Type v_dot_table__new_type(int idx);
static inline v_dot_table__Type v_dot_table__new_type_ptr(int idx, int nr_muls);
string v_dot_table__TypeSymbol_str(v_dot_table__TypeSymbol *t);
static inline v_dot_table__Enum
v_dot_table__TypeSymbol_enum_info(v_dot_table__TypeSymbol *t);
static inline v_dot_table__MultiReturn
v_dot_table__TypeSymbol_mr_info(v_dot_table__TypeSymbol *t);
static inline v_dot_table__Array
v_dot_table__TypeSymbol_array_info(v_dot_table__TypeSymbol *t);
static inline v_dot_table__ArrayFixed
v_dot_table__TypeSymbol_array_fixed_info(v_dot_table__TypeSymbol *t);
static inline v_dot_table__Map
v_dot_table__TypeSymbol_map_info(v_dot_table__TypeSymbol *t);
void v_dot_table__Table_register_builtin_type_symbols(v_dot_table__Table *t);
static inline bool v_dot_table__TypeSymbol_is_int(v_dot_table__TypeSymbol *t);
static inline bool v_dot_table__TypeSymbol_is_float(v_dot_table__TypeSymbol *t);
static inline bool
v_dot_table__TypeSymbol_is_number(v_dot_table__TypeSymbol *t);
string v_dot_table__Kind_str(v_dot_table__Kind k);
string array_v_dot_table__Kind_str(array_v_dot_table__Kind kinds);
string v_dot_table__Table_type_to_str(v_dot_table__Table *table,
                                      v_dot_table__Type t);
v_dot_table__Table *v_dot_table__new_table();
void v_dot_table__Table_register_const(v_dot_table__Table *t,
                                       v_dot_table__Var v);
void v_dot_table__Table_register_global(v_dot_table__Table *t, string name,
                                        v_dot_table__Type typ);
string v_dot_table__Fn_signature(v_dot_table__Fn *f);
Option_v_dot_table__Fn v_dot_table__Table_find_fn(v_dot_table__Table *t,
                                                  string name);
Option_v_dot_table__Var v_dot_table__Table_find_const(v_dot_table__Table *t,
                                                      string name);
void v_dot_table__Table_register_fn(v_dot_table__Table *t,
                                    v_dot_table__Fn new_fn);
void v_dot_table__TypeSymbol_register_method(v_dot_table__TypeSymbol *t,
                                             v_dot_table__Fn new_fn);
bool v_dot_table__TypeSymbol_has_method(v_dot_table__TypeSymbol *t,
                                        string name);
Option_v_dot_table__Fn
v_dot_table__TypeSymbol_find_method(v_dot_table__TypeSymbol *t, string name);
bool v_dot_table__TypeSymbol_has_field(v_dot_table__TypeSymbol *s, string name);
Option_v_dot_table__Field
v_dot_table__TypeSymbol_find_field(v_dot_table__TypeSymbol *s, string name);
bool v_dot_table__Table_type_has_method(v_dot_table__Table *t,
                                        v_dot_table__TypeSymbol *s,
                                        string name);
Option_v_dot_table__Fn
v_dot_table__Table_type_find_method(v_dot_table__Table *t,
                                    v_dot_table__TypeSymbol *s, string name);
bool v_dot_table__Table_struct_has_field(v_dot_table__Table *t,
                                         v_dot_table__TypeSymbol *s,
                                         string name);
Option_v_dot_table__Field
v_dot_table__Table_struct_find_field(v_dot_table__Table *t,
                                     v_dot_table__TypeSymbol *s, string name);
static inline int v_dot_table__Table_find_type_idx(v_dot_table__Table *t,
                                                   string name);
static inline Option_v_dot_table__TypeSymbol
v_dot_table__Table_find_type(v_dot_table__Table *t, string name);
static inline v_dot_table__TypeSymbol *
v_dot_table__Table_get_type_symbol(v_dot_table__Table *t,
                                   v_dot_table__Type typ);
static inline int
v_dot_table__Table_register_builtin_type_symbol(v_dot_table__Table *t,
                                                v_dot_table__TypeSymbol typ);
static inline int
v_dot_table__Table_register_type_symbol(v_dot_table__Table *t,
                                        v_dot_table__TypeSymbol typ);
bool v_dot_table__Table_known_type(v_dot_table__Table *t, string name);
static inline string v_dot_table__Table_array_name(v_dot_table__Table *t,
                                                   v_dot_table__Type elem_type,
                                                   int nr_dims);
static inline string v_dot_table__Table_array_fixed_name(
    v_dot_table__Table *t, v_dot_table__Type elem_type, int size, int nr_dims);
static inline string v_dot_table__Table_map_name(v_dot_table__Table *t,
                                                 v_dot_table__Type key_type,
                                                 v_dot_table__Type value_type);
int v_dot_table__Table_find_or_register_map(v_dot_table__Table *t,
                                            v_dot_table__Type key_type,
                                            v_dot_table__Type value_type);
int v_dot_table__Table_find_or_register_array(v_dot_table__Table *t,
                                              v_dot_table__Type elem_type,
                                              int nr_dims);
int v_dot_table__Table_find_or_register_array_fixed(v_dot_table__Table *t,
                                                    v_dot_table__Type elem_type,
                                                    int size, int nr_dims);
int v_dot_table__Table_find_or_register_multi_return(
    v_dot_table__Table *t, array_v_dot_table__Type mr_typs);
int v_dot_table__Table_find_or_register_fn_type(v_dot_table__Table *t,
                                                v_dot_table__Fn f);
int v_dot_table__Table_add_placeholder_type(v_dot_table__Table *t, string name);
bool v_dot_table__Table_check(v_dot_table__Table *t, v_dot_table__Type got,
                              v_dot_table__Type expected);
string v_dot_table__Table_qualify_module(v_dot_table__Table *table, string mod,
                                         string file_path);
string term__format(string msg, string open, string close);
string term__format_rgb(int r, int g, int b, string msg, string open,
                        string close);
string term__rgb(int r, int g, int b, string msg);
string term__bg_rgb(int r, int g, int b, string msg);
string term__hex(int hex, string msg);
string term__bg_hex(int hex, string msg);
string term__bg_black(string msg);
string term__bright_bg_black(string msg);
string term__bg_blue(string msg);
string term__bright_bg_blue(string msg);
string term__bg_cyan(string msg);
string term__bright_bg_cyan(string msg);
string term__bg_green(string msg);
string term__bright_bg_green(string msg);
string term__bg_magenta(string msg);
string term__bright_bg_magenta(string msg);
string term__bg_red(string msg);
string term__bright_bg_red(string msg);
string term__bg_white(string msg);
string term__bright_bg_white(string msg);
string term__bg_yellow(string msg);
string term__bright_bg_yellow(string msg);
string term__black(string msg);
string term__bright_black(string msg);
string term__blue(string msg);
string term__bright_blue(string msg);
string term__bold(string msg);
string term__cyan(string msg);
string term__bright_cyan(string msg);
string term__dim(string msg);
string term__green(string msg);
string term__bright_green(string msg);
string term__gray(string msg);
string term__hidden(string msg);
string term__italic(string msg);
string term__inverse(string msg);
string term__magenta(string msg);
string term__bright_magenta(string msg);
string term__reset(string msg);
string term__red(string msg);
string term__bright_red(string msg);
string term__strikethrough(string msg);
string term__underline(string msg);
string term__white(string msg);
string term__bright_white(string msg);
string term__yellow(string msg);
string term__bright_yellow(string msg);
void term__set_cursor_position(int x, int y);
void term__move(int n, string direction);
void term__cursor_up(int n);
void term__cursor_down(int n);
void term__cursor_forward(int n);
void term__cursor_back(int n);
void term__erase_display(string t);
void term__erase_toend();
void term__erase_tobeg();
void term__erase_clear();
void term__erase_del_clear();
void term__erase_line(string t);
void term__erase_line_toend();
void term__erase_line_tobeg();
void term__erase_line_clear();
void term__show_cursor();
void term__hide_cursor();
bool term__can_show_color_on_stdout();
bool term__can_show_color_on_stderr();
string term__ok_message(string s);
string term__fail_message(string s);
string term__h_divider(string divider);
string term__header(string text, string divider);
bool term__supports_escape_sequences(int fd);
_V_MulRet_int_V_int term__get_terminal_size();
string vweb_dot_tmpl__compile_template(string path);
v_dot_scanner__Scanner *
v_dot_scanner__new_scanner_file(string file_path,
                                v_dot_scanner__CommentsMode comments_mode);
v_dot_scanner__Scanner *
v_dot_scanner__new_scanner(string text,
                           v_dot_scanner__CommentsMode comments_mode);
v_dot_token__Token v_dot_scanner__Scanner_scan_res(v_dot_scanner__Scanner *s,
                                                   v_dot_token__Kind tok_kind,
                                                   string lit);
string v_dot_scanner__Scanner_ident_name(v_dot_scanner__Scanner *s);
string v_dot_scanner__filter_num_sep(byte *txt, int start, int end);
string v_dot_scanner__Scanner_ident_bin_number(v_dot_scanner__Scanner *s);
string v_dot_scanner__Scanner_ident_hex_number(v_dot_scanner__Scanner *s);
string v_dot_scanner__Scanner_ident_oct_number(v_dot_scanner__Scanner *s);
string v_dot_scanner__Scanner_ident_dec_number(v_dot_scanner__Scanner *s);
string v_dot_scanner__Scanner_ident_number(v_dot_scanner__Scanner *s);
void v_dot_scanner__Scanner_skip_whitespace(v_dot_scanner__Scanner *s);
v_dot_token__Token
v_dot_scanner__Scanner_end_of_file(v_dot_scanner__Scanner *s);
v_dot_token__Token v_dot_scanner__Scanner_scan(v_dot_scanner__Scanner *s);
int v_dot_scanner__Scanner_current_column(v_dot_scanner__Scanner *s);
int v_dot_scanner__Scanner_count_symbol_before(v_dot_scanner__Scanner s, int p,
                                               byte sym);
string v_dot_scanner__Scanner_ident_string(v_dot_scanner__Scanner *s);
string v_dot_scanner__Scanner_ident_char(v_dot_scanner__Scanner *s);
bool v_dot_scanner__Scanner_expect(v_dot_scanner__Scanner *s, string want,
                                   int start_pos);
void v_dot_scanner__Scanner_debug_tokens(v_dot_scanner__Scanner *s);
void v_dot_scanner__Scanner_ignore_line(v_dot_scanner__Scanner *s);
void v_dot_scanner__Scanner_eat_to_end_of_line(v_dot_scanner__Scanner *s);
void v_dot_scanner__Scanner_inc_line_number(v_dot_scanner__Scanner *s);
string v_dot_scanner__Scanner_line(v_dot_scanner__Scanner s, int n);
bool v_dot_scanner__is_name_char(byte c);
static inline bool v_dot_scanner__is_nl(byte c);
bool v_dot_scanner__contains_capital(string s);
bool v_dot_scanner__good_type_name(string s);
void v_dot_scanner__Scanner_error(v_dot_scanner__Scanner *s, string msg);
void v_dot_scanner__verror(string s);
string v_dot_scanner__vhash();
string v_dot_scanner__cescaped_path(string s);
int runtime__nr_cpus();
int runtime__nr_jobs();
bool runtime__is_32bit();
bool runtime__is_64bit();
bool runtime__is_little_endian();
bool runtime__is_big_endian();
int runtime__nr_cpus_win();
int runtime__nr_cpus_nix();
Option_array_string
internal_dot_flag__Instance_parse_impl(internal_dot_flag__Instance *p,
                                       array_string args, void *value,
                                       internal_dot_flag__void_cb callback);
Option_string
internal_dot_flag__Instance_string(internal_dot_flag__Instance *p);
Option_int internal_dot_flag__Instance_int(internal_dot_flag__Instance *p);
Option_f32 internal_dot_flag__Instance_f32(internal_dot_flag__Instance *p);
Option_f64 internal_dot_flag__Instance_f64(internal_dot_flag__Instance *p);
Option_i64 internal_dot_flag__Instance_i64(internal_dot_flag__Instance *p);
bool internal_dot_flag__Instance_bool(internal_dot_flag__Instance *p);
void internal_dot_flag__Instance_allow_duplicate(
    internal_dot_flag__Instance *p);
void internal_dot_flag__Instance_is_equivalent_to(
    internal_dot_flag__Instance *p, array_string flags);
Option_array_string internal_dot_flag__parse_pref(
    array_string args,
    void (*callback)(string, internal_dot_flag__Instance *,
                     v_dot_pref__Preferences * /*FFF*/),
    v_dot_pref__Preferences *obj);
Option_array_string internal_dot_flag__parse_main_cmd(
    array_string args,
    void (*callback)(string, internal_dot_flag__Instance *,
                     internal_dot_flag__MainCmdPreferences * /*FFF*/),
    internal_dot_flag__MainCmdPreferences *obj);
void internal_dot_help__print_and_exit(string topic);
benchmark__Benchmark benchmark__new_benchmark();
benchmark__Benchmark *benchmark__new_benchmark_pointer();
void benchmark__Benchmark_set_total_expected_steps(benchmark__Benchmark *b,
                                                   int n);
void benchmark__Benchmark_stop(benchmark__Benchmark *b);
void benchmark__Benchmark_step(benchmark__Benchmark *b);
void benchmark__Benchmark_fail(benchmark__Benchmark *b);
void benchmark__Benchmark_ok(benchmark__Benchmark *b);
void benchmark__Benchmark_fail_many(benchmark__Benchmark *b, int n);
void benchmark__Benchmark_ok_many(benchmark__Benchmark *b, int n);
void benchmark__Benchmark_neither_fail_nor_ok(benchmark__Benchmark *b);
benchmark__Benchmark benchmark__start();
i64 benchmark__Benchmark_measure(benchmark__Benchmark *b, string label);
string benchmark__Benchmark_step_message_with_label(benchmark__Benchmark *b,
                                                    string label, string msg);
string benchmark__Benchmark_step_message(benchmark__Benchmark *b, string msg);
string benchmark__Benchmark_step_message_ok(benchmark__Benchmark *b,
                                            string msg);
string benchmark__Benchmark_step_message_fail(benchmark__Benchmark *b,
                                              string msg);
string benchmark__Benchmark_total_message(benchmark__Benchmark *b, string msg);
i64 benchmark__Benchmark_total_duration(benchmark__Benchmark *b);
string benchmark__Benchmark_tdiff_in_ms(benchmark__Benchmark *b, string s,
                                        i64 sticks, i64 eticks);
i64 benchmark__now();
v_dot_ast__IdentVar v_dot_ast__Ident_var_info(v_dot_ast__Ident *i);
v_dot_ast__Scope *v_dot_ast__new_scope(v_dot_ast__Scope *parent, int start_pos);
Option__V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var
v_dot_ast__Scope_find_scope_and_var(v_dot_ast__Scope *s, string name);
Option_v_dot_ast__Var v_dot_ast__Scope_find_var(v_dot_ast__Scope *s,
                                                string name);
bool v_dot_ast__Scope_known_var(v_dot_ast__Scope *s, string name);
void v_dot_ast__Scope_register_var(v_dot_ast__Scope *s, v_dot_ast__Var var);
void v_dot_ast__Scope_override_var(v_dot_ast__Scope *s, v_dot_ast__Var var);
v_dot_ast__Scope *v_dot_ast__Scope_outermost(v_dot_ast__Scope *s);
v_dot_ast__Scope *v_dot_ast__Scope_innermost(v_dot_ast__Scope *s, int pos);
static inline bool v_dot_ast__Scope_contains(v_dot_ast__Scope *s, int pos);
string v_dot_ast__Scope_show(v_dot_ast__Scope *sc, int level);
string v_dot_ast__Scope_str(v_dot_ast__Scope *sc);
string v_dot_ast__FnDecl_str(v_dot_ast__FnDecl *node, v_dot_table__Table *t);
string v_dot_ast__Expr_str(v_dot_ast__Expr x);
string v_dot_ast__Stmt_str(v_dot_ast__Stmt node);
sync__PoolProcessor *
sync__new_pool_processor(sync__PoolProcessorConfig context);
void sync__PoolProcessor_set_max_jobs(sync__PoolProcessor *pool, int njobs);
void sync__PoolProcessor_work_on_pointers(sync__PoolProcessor *pool,
                                          array_voidptr items);
void sync__process_in_thread(sync__PoolProcessor *pool, int task_id);
string sync__PoolProcessor_get_string_item(sync__PoolProcessor *pool, int idx);
int sync__PoolProcessor_get_int_item(sync__PoolProcessor *pool, int idx);
void sync__PoolProcessor_set_shared_context(sync__PoolProcessor *pool,
                                            void *context);
void *sync__PoolProcessor_get_shared_context(sync__PoolProcessor *pool);
void sync__PoolProcessor_set_thread_context(sync__PoolProcessor *pool, int idx,
                                            void *context);
void *sync__PoolProcessor_get_thread_context(sync__PoolProcessor *pool,
                                             int idx);
sync__Mutex *sync__new_mutex();
void sync__Mutex_lock(sync__Mutex *m);
void sync__Mutex_unlock(sync__Mutex *m);
void sync__Mutex_destroy(sync__Mutex *m);
sync__WaitGroup *sync__new_waitgroup();
void sync__WaitGroup_add(sync__WaitGroup *wg, int delta);
void sync__WaitGroup_done(sync__WaitGroup *wg);
void sync__WaitGroup_wait(sync__WaitGroup *wg);
v_dot_ast__CompIf v_dot_parser__Parser_comp_if(v_dot_parser__Parser *p);
v_dot_ast__CallExpr v_dot_parser__Parser_call_expr(v_dot_parser__Parser *p,
                                                   bool is_c, string mod);
array_v_dot_ast__CallArg
v_dot_parser__Parser_call_args(v_dot_parser__Parser *p);
v_dot_ast__FnDecl v_dot_parser__Parser_fn_decl(v_dot_parser__Parser *p);
_V_MulRet_array_v_dot_table__Arg_V_bool
v_dot_parser__Parser_fn_args(v_dot_parser__Parser *p);
bool v_dot_parser__Parser_known_import(v_dot_parser__Parser *p, string mod);
string v_dot_parser__Parser_prepend_mod(v_dot_parser__Parser *p, string name);
v_dot_table__Type
v_dot_parser__Parser_parse_array_type(v_dot_parser__Parser *p);
v_dot_table__Type v_dot_parser__Parser_parse_map_type(v_dot_parser__Parser *p);
v_dot_table__Type
v_dot_parser__Parser_parse_multi_return_type(v_dot_parser__Parser *p);
v_dot_table__Type v_dot_parser__Parser_parse_fn_type(v_dot_parser__Parser *p,
                                                     string name);
v_dot_table__Type v_dot_parser__Parser_parse_type(v_dot_parser__Parser *p);
v_dot_table__Type v_dot_parser__Parser_parse_any_type(v_dot_parser__Parser *p,
                                                      bool is_c, bool is_ptr);
v_dot_ast__Stmt v_dot_parser__parse_stmt(string text, v_dot_table__Table *table,
                                         v_dot_ast__Scope *scope);
v_dot_ast__File
v_dot_parser__parse_file(string path, v_dot_table__Table *table,
                         v_dot_scanner__CommentsMode comments_mode);
void v_dot_parser__Queue_run(v_dot_parser__Queue *q);
array_v_dot_ast__File v_dot_parser__parse_files(array_string paths,
                                                v_dot_table__Table *table);
void v_dot_parser__Parser_init_parse_fns(v_dot_parser__Parser *p);
void v_dot_parser__Parser_read_first_token(v_dot_parser__Parser *p);
void v_dot_parser__Parser_open_scope(v_dot_parser__Parser *p);
void v_dot_parser__Parser_close_scope(v_dot_parser__Parser *p);
array_v_dot_ast__Stmt v_dot_parser__Parser_parse_block(v_dot_parser__Parser *p);
void v_dot_parser__Parser_next(v_dot_parser__Parser *p);
void v_dot_parser__Parser_check(v_dot_parser__Parser *p,
                                v_dot_token__Kind expected);
string v_dot_parser__Parser_check_name(v_dot_parser__Parser *p);
v_dot_ast__Stmt v_dot_parser__Parser_top_stmt(v_dot_parser__Parser *p);
v_dot_ast__LineComment
v_dot_parser__Parser_line_comment(v_dot_parser__Parser *p);
v_dot_ast__Stmt v_dot_parser__Parser_stmt(v_dot_parser__Parser *p);
v_dot_ast__AssignExpr v_dot_parser__Parser_assign_expr(v_dot_parser__Parser *p,
                                                       v_dot_ast__Expr left);
v_dot_ast__Attr v_dot_parser__Parser_attribute(v_dot_parser__Parser *p);
void v_dot_parser__Parser_error(v_dot_parser__Parser *p, string s);
void v_dot_parser__Parser_error_at_line(v_dot_parser__Parser *p, string s,
                                        int line_nr);
void v_dot_parser__Parser_warn(v_dot_parser__Parser *p, string s);
v_dot_ast__Ident v_dot_parser__Parser_parse_ident(v_dot_parser__Parser *p,
                                                  bool is_c);
v_dot_ast__StructInit v_dot_parser__Parser_struct_init(v_dot_parser__Parser *p);
v_dot_ast__Expr v_dot_parser__Parser_name_expr(v_dot_parser__Parser *p);
v_dot_ast__Expr v_dot_parser__Parser_expr(v_dot_parser__Parser *p,
                                          int precedence);
v_dot_ast__PrefixExpr v_dot_parser__Parser_prefix_expr(v_dot_parser__Parser *p);
v_dot_ast__IndexExpr v_dot_parser__Parser_index_expr(v_dot_parser__Parser *p,
                                                     v_dot_ast__Expr left);
void v_dot_parser__Parser_filter(v_dot_parser__Parser *p);
v_dot_ast__Expr v_dot_parser__Parser_dot_expr(v_dot_parser__Parser *p,
                                              v_dot_ast__Expr left);
v_dot_ast__Expr v_dot_parser__Parser_infix_expr(v_dot_parser__Parser *p,
                                                v_dot_ast__Expr left);
v_dot_ast__EnumVal v_dot_parser__Parser_enum_val(v_dot_parser__Parser *p);
v_dot_ast__Stmt v_dot_parser__Parser_for_statement(v_dot_parser__Parser *p);
v_dot_ast__Expr v_dot_parser__Parser_if_expr(v_dot_parser__Parser *p);
v_dot_ast__Expr v_dot_parser__Parser_string_expr(v_dot_parser__Parser *p);
v_dot_ast__ArrayInit v_dot_parser__Parser_array_init(v_dot_parser__Parser *p);
v_dot_ast__Expr
v_dot_parser__Parser_parse_number_literal(v_dot_parser__Parser *p);
v_dot_ast__Module v_dot_parser__Parser_module_decl(v_dot_parser__Parser *p);
v_dot_ast__Import v_dot_parser__Parser_parse_import(v_dot_parser__Parser *p);
array_v_dot_ast__Import
v_dot_parser__Parser_import_stmt(v_dot_parser__Parser *p);
v_dot_ast__ConstDecl v_dot_parser__Parser_const_decl(v_dot_parser__Parser *p);
v_dot_ast__StructDecl v_dot_parser__Parser_struct_decl(v_dot_parser__Parser *p);
v_dot_ast__Return v_dot_parser__Parser_return_stmt(v_dot_parser__Parser *p);
array_v_dot_ast__Ident
v_dot_parser__Parser_parse_assign_lhs(v_dot_parser__Parser *p);
array_v_dot_ast__Expr
v_dot_parser__Parser_parse_assign_rhs(v_dot_parser__Parser *p);
v_dot_ast__Stmt v_dot_parser__Parser_assign_stmt(v_dot_parser__Parser *p);
v_dot_ast__HashStmt v_dot_parser__Parser_hash(v_dot_parser__Parser *p);
v_dot_ast__GlobalDecl v_dot_parser__Parser_global_decl(v_dot_parser__Parser *p);
v_dot_ast__MatchExpr v_dot_parser__Parser_match_expr(v_dot_parser__Parser *p);
v_dot_ast__EnumDecl v_dot_parser__Parser_enum_decl(v_dot_parser__Parser *p);
v_dot_ast__TypeDecl v_dot_parser__Parser_type_decl(v_dot_parser__Parser *p);
void v_dot_parser__verror(string s);
v_dot_checker__Checker v_dot_checker__new_checker(v_dot_table__Table *table);
void v_dot_checker__Checker_check(v_dot_checker__Checker *c,
                                  v_dot_ast__File ast_file);
array_string v_dot_checker__Checker_check2(v_dot_checker__Checker *c,
                                           v_dot_ast__File ast_file);
void v_dot_checker__Checker_check_files(v_dot_checker__Checker *c,
                                        array_v_dot_ast__File ast_files);
v_dot_table__Type
v_dot_checker__Checker_check_struct_init(v_dot_checker__Checker *c,
                                         v_dot_ast__StructInit struct_init);
v_dot_table__Type
v_dot_checker__Checker_infix_expr(v_dot_checker__Checker *c,
                                  v_dot_ast__InfixExpr *infix_expr);
void v_dot_checker__Checker_assign_expr(v_dot_checker__Checker *c,
                                        v_dot_ast__AssignExpr *assign_expr);
v_dot_table__Type
v_dot_checker__Checker_call_expr(v_dot_checker__Checker *c,
                                 v_dot_ast__CallExpr *call_expr);
v_dot_table__Type v_dot_checker__Checker_method_call_expr(
    v_dot_checker__Checker *c, v_dot_ast__MethodCallExpr *method_call_expr);
v_dot_table__Type
v_dot_checker__Checker_selector_expr(v_dot_checker__Checker *c,
                                     v_dot_ast__SelectorExpr *selector_expr);
void v_dot_checker__Checker_return_stmt(v_dot_checker__Checker *c,
                                        v_dot_ast__Return *return_stmt);
void v_dot_checker__Checker_assign_stmt(v_dot_checker__Checker *c,
                                        v_dot_ast__AssignStmt *assign_stmt);
v_dot_table__Type
v_dot_checker__Checker_array_init(v_dot_checker__Checker *c,
                                  v_dot_ast__ArrayInit *array_init);
void v_dot_checker__Checker_stmt(v_dot_checker__Checker *c,
                                 v_dot_ast__Stmt node);
void v_dot_checker__Checker_stmts(v_dot_checker__Checker *c,
                                  array_v_dot_ast__Stmt stmts);
v_dot_table__Type v_dot_checker__Checker_expr(v_dot_checker__Checker *c,
                                              v_dot_ast__Expr node);
v_dot_table__Type v_dot_checker__Checker_ident(v_dot_checker__Checker *c,
                                               v_dot_ast__Ident *ident);
v_dot_table__Type v_dot_checker__Checker_match_expr(v_dot_checker__Checker *c,
                                                    v_dot_ast__MatchExpr *node);
v_dot_table__Type v_dot_checker__Checker_if_expr(v_dot_checker__Checker *c,
                                                 v_dot_ast__IfExpr *node);
v_dot_table__Type
v_dot_checker__Checker_postfix_expr(v_dot_checker__Checker *c,
                                    v_dot_ast__PostfixExpr node);
v_dot_table__Type v_dot_checker__Checker_index_expr(v_dot_checker__Checker *c,
                                                    v_dot_ast__IndexExpr *node);
v_dot_table__Type v_dot_checker__Checker_enum_val(v_dot_checker__Checker *c,
                                                  v_dot_ast__EnumVal *node);
v_dot_table__Type v_dot_checker__Checker_map_init(v_dot_checker__Checker *c,
                                                  v_dot_ast__MapInit *node);
void v_dot_checker__Checker_error(v_dot_checker__Checker *c, string s,
                                  v_dot_token__Position pos);
string v_dot_gen__cgen(array_v_dot_ast__File files, v_dot_table__Table *table);
void v_dot_gen__Gen_init(v_dot_gen__Gen *g);
string v_dot_gen__Gen_typ(v_dot_gen__Gen *g, v_dot_table__Type t);
void v_dot_gen__Gen_write_typedef_types(v_dot_gen__Gen *g);
void v_dot_gen__Gen_write_multi_return_types(v_dot_gen__Gen *g);
void v_dot_gen__Gen_write_variadic_types(v_dot_gen__Gen *g);
void v_dot_gen__Gen_save(v_dot_gen__Gen *g);
void v_dot_gen__Gen_write(v_dot_gen__Gen *g, string s);
void v_dot_gen__Gen_writeln(v_dot_gen__Gen *g, string s);
string v_dot_gen__Gen_new_tmp_var(v_dot_gen__Gen *g);
void v_dot_gen__Gen_reset_tmp_count(v_dot_gen__Gen *g);
void v_dot_gen__Gen_stmts(v_dot_gen__Gen *g, array_v_dot_ast__Stmt stmts);
void v_dot_gen__Gen_stmt(v_dot_gen__Gen *g, v_dot_ast__Stmt node);
bool v_dot_gen__Gen_is_sum_cast(v_dot_gen__Gen *g, v_dot_table__Type got_type,
                                v_dot_table__Type exp_type);
void v_dot_gen__Gen_sum_cast(v_dot_gen__Gen *g, v_dot_table__Type got_type,
                             v_dot_table__Type exp_type, v_dot_ast__Expr expr);
void v_dot_gen__Gen_gen_assign_stmt(v_dot_gen__Gen *g,
                                    v_dot_ast__AssignStmt assign_stmt);
void v_dot_gen__Gen_gen_fn_decl(v_dot_gen__Gen *g, v_dot_ast__FnDecl it);
void v_dot_gen__Gen_fn_args(v_dot_gen__Gen *g, array_v_dot_table__Arg args,
                            bool is_variadic);
void v_dot_gen__Gen_expr(v_dot_gen__Gen *g, v_dot_ast__Expr node);
void v_dot_gen__Gen_infix_expr(v_dot_gen__Gen *g, v_dot_ast__InfixExpr node);
void v_dot_gen__Gen_match_expr(v_dot_gen__Gen *g, v_dot_ast__MatchExpr node);
void v_dot_gen__Gen_ident(v_dot_gen__Gen *g, v_dot_ast__Ident node);
void v_dot_gen__Gen_index_expr(v_dot_gen__Gen *g, v_dot_ast__IndexExpr node);
void v_dot_gen__Gen_return_statement(v_dot_gen__Gen *g, v_dot_ast__Return it);
void v_dot_gen__Gen_const_decl(v_dot_gen__Gen *g, v_dot_ast__ConstDecl node);
void v_dot_gen__Gen_call_args(v_dot_gen__Gen *g, array_v_dot_ast__CallArg args);
static inline void v_dot_gen__Gen_ref_or_deref_arg(v_dot_gen__Gen *g,
                                                   v_dot_ast__CallArg arg);
void v_dot_gen__verror(string s);
void v_dot_gen__Gen_write_builtin_types(v_dot_gen__Gen *g);
void v_dot_gen__Gen_write_sorted_types(v_dot_gen__Gen *g);
void v_dot_gen__Gen_write_types(v_dot_gen__Gen *g,
                                array_v_dot_table__TypeSymbol types);
array_v_dot_table__TypeSymbol
v_dot_gen__Gen_sort_structs(v_dot_gen__Gen *g,
                            array_v_dot_table__TypeSymbol types);
string v_dot_gen__op_to_fn_name(string name);
string v_dot_gen__jsgen(v_dot_ast__File program, v_dot_table__Table *table);
void v_dot_gen__JsGen_save(v_dot_gen__JsGen *g);
void v_dot_gen__JsGen_write(v_dot_gen__JsGen *g, string s);
void v_dot_gen__JsGen_writeln(v_dot_gen__JsGen *g, string s);
void v_dot_gen__JsGen_stmt(v_dot_gen__JsGen *g, v_dot_ast__Stmt node);
void v_dot_gen__JsGen_expr(v_dot_gen__JsGen *g, v_dot_ast__Expr node);
void v_dot_gen_dot_x64__Gen_generate_elf_header(v_dot_gen_dot_x64__Gen *g);
void v_dot_gen_dot_x64__Gen_generate_elf_footer(v_dot_gen_dot_x64__Gen *g);
void v_dot_gen_dot_x64__Gen_section_header(v_dot_gen_dot_x64__Gen *g,
                                           v_dot_gen_dot_x64__SectionConfig c);
void v_dot_gen_dot_x64__genobj();
void v_dot_gen_dot_x64__gen(array_v_dot_ast__File files, string out_name);
i64 v_dot_gen_dot_x64__Gen_pos(v_dot_gen_dot_x64__Gen *g);
void v_dot_gen_dot_x64__Gen_write8(v_dot_gen_dot_x64__Gen *g, int n);
void v_dot_gen_dot_x64__Gen_write16(v_dot_gen_dot_x64__Gen *g, int n);
void v_dot_gen_dot_x64__Gen_write32(v_dot_gen_dot_x64__Gen *g, int n);
void v_dot_gen_dot_x64__Gen_write64(v_dot_gen_dot_x64__Gen *g, i64 n);
void v_dot_gen_dot_x64__Gen_write64_at(v_dot_gen_dot_x64__Gen *g, i64 n,
                                       i64 at);
void v_dot_gen_dot_x64__Gen_write_string(v_dot_gen_dot_x64__Gen *g, string s);
void v_dot_gen_dot_x64__Gen_inc(v_dot_gen_dot_x64__Gen *g,
                                v_dot_gen_dot_x64__Register reg);
void v_dot_gen_dot_x64__Gen_cmp(v_dot_gen_dot_x64__Gen *g,
                                v_dot_gen_dot_x64__Register reg,
                                v_dot_gen_dot_x64__Size size, i64 val);
i64 v_dot_gen_dot_x64__abs(i64 a);
void v_dot_gen_dot_x64__Gen_jle(v_dot_gen_dot_x64__Gen *g, i64 addr);
void v_dot_gen_dot_x64__Gen_jl(v_dot_gen_dot_x64__Gen *g, i64 addr);
int v_dot_gen_dot_x64__Gen_abs_to_rel_addr(v_dot_gen_dot_x64__Gen *g, i64 addr);
void v_dot_gen_dot_x64__Gen_jmp(v_dot_gen_dot_x64__Gen *g, i64 addr);
void v_dot_gen_dot_x64__Gen_mov64(v_dot_gen_dot_x64__Gen *g,
                                  v_dot_gen_dot_x64__Register reg, i64 val);
void v_dot_gen_dot_x64__Gen_call(v_dot_gen_dot_x64__Gen *g, int addr);
void v_dot_gen_dot_x64__Gen_syscall(v_dot_gen_dot_x64__Gen *g);
void v_dot_gen_dot_x64__Gen_ret(v_dot_gen_dot_x64__Gen *g);
int v_dot_gen_dot_x64__Gen_gen_loop_start(v_dot_gen_dot_x64__Gen *g, int from);
void v_dot_gen_dot_x64__Gen_gen_loop_end(v_dot_gen_dot_x64__Gen *g, int to,
                                         int label);
void v_dot_gen_dot_x64__Gen_save_main_fn_addr(v_dot_gen_dot_x64__Gen *g);
void v_dot_gen_dot_x64__Gen_gen_print_from_expr(v_dot_gen_dot_x64__Gen *g,
                                                v_dot_ast__Expr expr);
void v_dot_gen_dot_x64__Gen_gen_print(v_dot_gen_dot_x64__Gen *g, string s);
void v_dot_gen_dot_x64__Gen_gen_exit(v_dot_gen_dot_x64__Gen *g);
void v_dot_gen_dot_x64__Gen_mov(v_dot_gen_dot_x64__Gen *g,
                                v_dot_gen_dot_x64__Register reg, int val);
void v_dot_gen_dot_x64__Gen_register_function_address(v_dot_gen_dot_x64__Gen *g,
                                                      string name);
void v_dot_gen_dot_x64__Gen_write(v_dot_gen_dot_x64__Gen *g, string s);
void v_dot_gen_dot_x64__Gen_writeln(v_dot_gen_dot_x64__Gen *g, string s);
void v_dot_gen_dot_x64__Gen_call_fn(v_dot_gen_dot_x64__Gen *g, string name);
void v_dot_gen_dot_x64__Gen_stmt(v_dot_gen_dot_x64__Gen *g,
                                 v_dot_ast__Stmt node);
void v_dot_gen_dot_x64__Gen_expr(v_dot_gen_dot_x64__Gen *g,
                                 v_dot_ast__Expr node);
void v_dot_gen_dot_x64__verror(string s);
string v_dot_doc__doc(string mod, v_dot_table__Table *table);
string v_dot_doc__Doc_get_fn_node(v_dot_doc__Doc *d, v_dot_ast__FnDecl f);
void v_dot_doc__Doc_print_fns(v_dot_doc__Doc *d);
void v_dot_doc__Doc_print_methods(v_dot_doc__Doc *d);
static inline void
v_dot_doc__Doc_write_fn_signatures(v_dot_doc__Doc *d,
                                   array_string fn_signatures);
array_string v_dot_doc__Doc_get_fn_signatures(v_dot_doc__Doc d,
                                              v_dot_doc__FilterFn filter_fn);
bool v_dot_doc__is_pub_method(v_dot_ast__FnDecl node);
bool v_dot_doc__is_pub_function(v_dot_ast__FnDecl node);
void v_dot_doc__Doc_print_enums(v_dot_doc__Doc *d);
void v_dot_doc__Doc_print_structs(v_dot_doc__Doc *d);
v_dot_builder__Builder
v_dot_builder__new_builder(v_dot_pref__Preferences *pref);
string v_dot_builder__Builder_gen_c(v_dot_builder__Builder *b,
                                    array_string v_files);
void v_dot_builder__Builder_build_c(v_dot_builder__Builder *b,
                                    array_string v_files, string out_file);
void v_dot_builder__Builder_build_x64(v_dot_builder__Builder *b,
                                      array_string v_files, string out_file);
void v_dot_builder__Builder_parse_imports(v_dot_builder__Builder *b);
array_string v_dot_builder__Builder_v_files_from_dir(v_dot_builder__Builder *b,
                                                     string dir);
void v_dot_builder__verror(string err);
void v_dot_builder__Builder_log(v_dot_builder__Builder *b, string s);
static inline string v_dot_builder__module_path(string mod);
Option_string v_dot_builder__Builder_find_module_path(v_dot_builder__Builder *b,
                                                      string mod);
compiler__Parser compiler__V_new_parser_from_string(compiler__V *v,
                                                    string text);
void compiler__V_reset_cgen_file_line_parameters(compiler__V *v);
compiler__Parser compiler__V_new_parser_from_file(compiler__V *v, string path);
compiler__Parser compiler__V_new_parser(compiler__V *v,
                                        compiler__Scanner *scanner);
void compiler__Parser_scan_tokens(compiler__Parser *p);
void compiler__Parser_set_current_fn(compiler__Parser *p, compiler__Fn f);
void compiler__Parser_next(compiler__Parser *p);
compiler__TokenKind compiler__Parser_peek(compiler__Parser *p);
static inline compiler__Token compiler__Parser_prev_token(compiler__Parser *p);
static inline compiler__Token compiler__Parser_cur_tok(compiler__Parser *p);
static inline compiler__Token compiler__Parser_peek_token(compiler__Parser *p);
void compiler__Parser_log(compiler__Parser *p, string s);
compiler__ParserState compiler__Parser_save_state(compiler__Parser *p);
void compiler__Parser_restore_state(compiler__Parser *p,
                                    compiler__ParserState state, bool scanner,
                                    bool cgen);
void compiler__Parser_clear_state(compiler__Parser *p, bool scanner, bool cgen);
void compiler__Parser_add_text(compiler__Parser *p, string text);
void compiler__Parser_statements_from_text(compiler__Parser *p, string text,
                                           bool rcbr, string fpath);
void compiler__Parser_parse(compiler__Parser *p, compiler__Pass pass);
void compiler__Parser_imports(compiler__Parser *p);
void compiler__Parser_import_statement(compiler__Parser *p);
void compiler__Parser_const_decl(compiler__Parser *p);
void compiler__Parser_type_decl(compiler__Parser *p);
compiler__Fn *compiler__Parser_interface_method(compiler__Parser *p,
                                                string field_name,
                                                string receiver);
compiler__TypeCategory compiler__key_to_type_cat(compiler__TokenKind tok);
string compiler__Parser_check_name(compiler__Parser *p);
string compiler__Parser_check_string(compiler__Parser *p);
void compiler__Parser_check_not_reserved(compiler__Parser *p);
string compiler__Parser_strtok(compiler__Parser *p);
void compiler__Parser_check_space(compiler__Parser *p,
                                  compiler__TokenKind expected);
void compiler__Parser_check(compiler__Parser *p, compiler__TokenKind expected);
static inline bool compiler__Parser_first_pass(compiler__Parser *p);
string compiler__Parser_get_type(compiler__Parser *p);
void compiler__Parser_print_tok(compiler__Parser *p);
string compiler__Parser_statements(compiler__Parser *p);
string compiler__Parser_statements_no_rcbr(compiler__Parser *p);
void compiler__Parser_close_scope(compiler__Parser *p);
void compiler__Parser_free_var(compiler__Parser *p, compiler__Var v);
void compiler__Parser_genln(compiler__Parser *p, string s);
void compiler__Parser_gen(compiler__Parser *p, string s);
string compiler__Parser_statement(compiler__Parser *p, bool add_semi);
void compiler__Parser_assign_statement(compiler__Parser *p, compiler__Var v,
                                       int ph, bool is_map);
void compiler__Parser_var_decl(compiler__Parser *p);
string compiler__Parser_get_struct_type(compiler__Parser *p, string name_,
                                        bool is_c, bool is_ptr);
string compiler__Parser_get_var_type(compiler__Parser *p, string name,
                                     bool is_ptr, int deref_nr);
string compiler__Parser_get_const_type(compiler__Parser *p, string name,
                                       bool is_ptr);
string compiler__Parser_get_c_func_type(compiler__Parser *p, string name);
void compiler__Parser_undefined_error(compiler__Parser *p, string name,
                                      string orig_name);
string compiler__Parser_var_expr(compiler__Parser *p, compiler__Var v);
string compiler__Parser_dot(compiler__Parser *p, string str_typ_,
                            int method_ph);
compiler__IndexType compiler__get_index_type(string typ);
string compiler__Parser_index_expr(compiler__Parser *p, string typ_, int fn_ph);
bool compiler__Parser_fileis(compiler__Parser *p, string s);
string compiler__Parser_indot_expr(compiler__Parser *p);
string compiler__Parser_assoc(compiler__Parser *p);
void compiler__Parser_char_expr(compiler__Parser *p);
string compiler__format_str(string _str);
string compiler__Parser_map_init(compiler__Parser *p);
string compiler__Parser_array_init(compiler__Parser *p);
string compiler__Parser_get_tmp(compiler__Parser *p);
int compiler__Parser_get_tmp_counter(compiler__Parser *p);
void compiler__Parser_assert_statement(compiler__Parser *p);
void compiler__Parser_return_st(compiler__Parser *p);
string compiler__Parser_get_deferred_text(compiler__Parser *p);
string compiler__prepend_mod(string mod, string name);
string compiler__Parser_prepend_mod(compiler__Parser *p, string name);
void compiler__Parser_go_statement(compiler__Parser *p);
string compiler__Parser_js_decode(compiler__Parser *p);
void compiler__Parser_attribute(compiler__Parser *p);
void compiler__Parser_defer_st(compiler__Parser *p);
void compiler__Parser_check_and_register_used_imported_type(compiler__Parser *p,
                                                            string typ_name);
void compiler__Parser_check_unused_imports(compiler__Parser *p);
_V_MulRet_bool_V_string compiler__Parser_is_expr_fn_call(compiler__Parser *p,
                                                         int start_tok_idx);
static inline void compiler__Parser_skip_block(compiler__Parser *p,
                                               bool inside_first_lcbr);
void compiler__todo_remove();
void compiler__Parser_check_if_parser_is_stuck(compiler__Parser *p,
                                               u64 parsing_cycle,
                                               i64 parsing_start_ticks);
void compiler__Parser_inline_asm(compiler__Parser *p);
void compiler__todo();
bool compiler__V_no_cc_installed(compiler__V *v);
void compiler__V_cc(compiler__V *v);
void compiler__V_cc_windows_cross(compiler__V *c);
void compiler__V_build_thirdparty_obj_files(compiler__V *c);
string compiler__missing_compiler_info();
array_string compiler__error_context_lines(string text, string keyword,
                                           int before, int after);
string compiler__CFlag_str(compiler__CFlag *c);
array_compiler__CFlag compiler__V_get_os_cflags(compiler__V *v);
array_compiler__CFlag compiler__V_get_rest_of_module_cflags(compiler__V *v,
                                                            compiler__CFlag *c);
string compiler__CFlag_format(compiler__CFlag *cf);
bool compiler__Table_has_cflag(compiler__Table *table, compiler__CFlag cflag);
Option_bool compiler__Table_parse_cflag(compiler__Table *table, string cflag,
                                        string mod, array_string ctimedefines);
string array_compiler__CFlag_c_options_before_target_msvc(
    array_compiler__CFlag cflags);
string
array_compiler__CFlag_c_options_after_target_msvc(array_compiler__CFlag cflags);
string
array_compiler__CFlag_c_options_before_target(array_compiler__CFlag cflags);
string
array_compiler__CFlag_c_options_after_target(array_compiler__CFlag cflags);
string array_compiler__CFlag_c_options_without_object_files(
    array_compiler__CFlag cflags);
string
array_compiler__CFlag_c_options_only_object_files(array_compiler__CFlag cflags);
compiler__CGen *compiler__new_cgen(string out_name_c);
void compiler__CGen_genln(compiler__CGen *g, string s);
void compiler__CGen_prepend_to_statement(compiler__CGen *g, string s);
void compiler__CGen_gen(compiler__CGen *g, string s);
void compiler__CGen_resetln(compiler__CGen *g, string s);
void compiler__CGen_save(compiler__CGen *g);
_V_MulRet_string_V_string compiler__Parser_tmp_expr(compiler__Parser *p);
int compiler__CGen_add_placeholder(compiler__CGen *g);
void compiler__CGen_start_cut(compiler__CGen *g);
string compiler__CGen_cut(compiler__CGen *g);
void compiler__CGen_set_placeholder(compiler__CGen *g, int pos, string val);
void compiler__CGen_insert_before(compiler__CGen *g, string val);
void compiler__CGen_register_thread_fn(compiler__CGen *g, string wrapper_name,
                                       string wrapper_text, string struct_text);
string compiler__V_prof_counters(compiler__V *v);
string compiler__Parser_print_prof_counters(compiler__Parser *p);
void compiler__Parser_gen_typedef(compiler__Parser *p, string s);
void compiler__Parser_gen_type_alias(compiler__Parser *p, string s);
void compiler__CGen_add_to_main(compiler__CGen *g, string s);
void compiler__V_build_thirdparty_obj_file(compiler__V *v, string path,
                                           array_compiler__CFlag moduleflags);
string compiler__os_name_to_ifdef(string name);
string compiler__V_platform_postfix_to_ifdefguard(compiler__V *v, string name);
string compiler__V_type_definitions(compiler__V *v);
array_compiler__Type compiler__sort_structs(array_compiler__Type types);
string compiler__V_interface_table(compiler__V *v);
void compiler__Parser_error(compiler__Parser *p, string s);
void compiler__Parser_warn_or_error(compiler__Parser *p, string s);
void compiler__Parser_warn(compiler__Parser *p, string s);
void compiler__Parser_production_error_with_token_index(compiler__Parser *p,
                                                        string e,
                                                        int tokenindex);
void compiler__Parser_error_with_token_index(compiler__Parser *p, string s,
                                             int tokenindex);
void compiler__Parser_warn_with_token_index(compiler__Parser *p, string s,
                                            int tokenindex);
void compiler__Parser_error_with_position(compiler__Parser *p, string s,
                                          compiler__ScannerPos sp);
void compiler__Parser_warn_with_position(compiler__Parser *p, string s,
                                         compiler__ScannerPos sp);
void compiler__Scanner_error(compiler__Scanner *s, string msg);
void compiler__Scanner_warn(compiler__Scanner *s, string msg);
void compiler__Scanner_warn_with_col(compiler__Scanner *s, string msg, int col);
void compiler__Scanner_error_with_col(compiler__Scanner *s, string msg,
                                      int col);
static inline int compiler__Parser_cur_tok_index(compiler__Parser *p);
static inline int compiler__imax(int a, int b);
static inline int compiler__imin(int a, int b);
string compiler__Scanner_get_error_filepath(compiler__Scanner *s);
bool compiler__Scanner_is_color_output_on(compiler__Scanner *s);
void compiler__Parser_print_error_context(compiler__Parser *p);
int compiler__ienv_default(string ename, int idefault);
void compiler__Parser_print_current_tokens(compiler__Parser *p, string label);
string compiler__normalized_error(string s);
string compiler__ScannerPos_str(compiler__ScannerPos s);
compiler__ScannerPos compiler__Scanner_get_scanner_pos(compiler__Scanner *s);
void compiler__Scanner_goto_scanner_position(compiler__Scanner *s,
                                             compiler__ScannerPos scp);
int compiler__Scanner_get_last_nl_from_pos(compiler__Scanner *s, int _pos);
compiler__ScannerPos
compiler__Scanner_get_scanner_pos_of_token(compiler__Scanner *s,
                                           compiler__Token *tok);
void compiler__Parser_mutable_arg_error(compiler__Parser *p, int i,
                                        compiler__Var arg, compiler__Fn f);
_V_MulRet_array_string_V_string
compiler__get_v_options_and_main_command(array_string args);
void compiler__Parser_comp_time(compiler__Parser *p);
void compiler__Parser_chash(compiler__Parser *p);
void compiler__Parser_comptime_method_call(compiler__Parser *p,
                                           compiler__Type typ);
_V_MulRet_bool_V_string
compiler__Parser_gen_default_str_method_if_missing(compiler__Parser *p,
                                                   string typename);
void compiler__Parser_gen_array_str(compiler__Parser *p, compiler__Type typ);
void compiler__Parser_gen_struct_str(compiler__Parser *p, compiler__Type typ);
void compiler__Parser_gen_varg_str(compiler__Parser *p, compiler__Type typ);
void compiler__Parser_gen_array_filter(compiler__Parser *p, string str_typ,
                                       int method_ph);
string compiler__Parser_gen_array_map(compiler__Parser *p, string str_typ,
                                      int method_ph);
void compiler__Parser_comptime_if_block(compiler__Parser *p, string name,
                                        bool not);
void compiler__Parser_gen_enum_flag_methods(compiler__Parser *p,
                                            compiler__Type *typ);
void compiler__OrderedDepMap_set(compiler__OrderedDepMap *o, string name,
                                 array_string deps);
void compiler__OrderedDepMap_add(compiler__OrderedDepMap *o, string name,
                                 array_string deps);
array_string compiler__OrderedDepMap_get(compiler__OrderedDepMap *o,
                                         string name);
void compiler__OrderedDepMap_delete(compiler__OrderedDepMap *o, string name);
void compiler__OrderedDepMap_apply_diff(compiler__OrderedDepMap *o, string name,
                                        array_string deps);
int compiler__OrderedDepMap_size(compiler__OrderedDepMap *o);
compiler__DepGraph *compiler__new_dep_graph();
void compiler__DepGraph_add(compiler__DepGraph *graph, string mod,
                            array_string deps);
compiler__DepGraph *compiler__DepGraph_resolve(compiler__DepGraph *graph);
compiler__DepGraphNode compiler__DepGraph_last_node(compiler__DepGraph *graph);
string compiler__DepGraph_display(compiler__DepGraph *graph);
string compiler__DepGraph_display_cycles(compiler__DepGraph *graph);
void compiler__Parser_enum_decl(compiler__Parser *p, bool no_name);
void compiler__Parser_check_enum_member_access(compiler__Parser *p);
string compiler__Parser_bool_expression(compiler__Parser *p);
string compiler__Parser_key_as(compiler__Parser *p, string typ, int start_ph);
string compiler__Parser_bterm(compiler__Parser *p);
string compiler__Parser_name_expr(compiler__Parser *p);
string compiler__Parser_expression(compiler__Parser *p);
void compiler__Parser_handle_operator(compiler__Parser *p, string op,
                                      string typ, string cpostfix, int ph,
                                      compiler__Type *tt);
string compiler__Parser_term(compiler__Parser *p);
string compiler__Parser_unary(compiler__Parser *p);
string compiler__Parser_factor(compiler__Parser *p);
string array_compiler__TypeInst_str(array_compiler__TypeInst a);
Option_compiler__Var compiler__Parser_find_var_or_const(compiler__Parser *p,
                                                        string name);
Option_compiler__Var compiler__Parser_find_var(compiler__Parser *p,
                                               string name);
Option_compiler__Var
compiler__Parser_find_var_check_new_var(compiler__Parser *p, string name);
void compiler__Parser_open_scope(compiler__Parser *p);
void compiler__Parser_mark_var_used(compiler__Parser *p, compiler__Var v);
void compiler__Parser_mark_var_returned(compiler__Parser *p, compiler__Var v);
void compiler__Parser_mark_var_changed(compiler__Parser *p, compiler__Var v);
void compiler__Parser_mark_arg_moved(compiler__Parser *p, compiler__Var v);
bool compiler__Parser_known_var(compiler__Parser *p, string name);
bool compiler__Parser_known_var_check_new_var(compiler__Parser *p, string name);
void compiler__Parser_register_var(compiler__Parser *p, compiler__Var v);
void compiler__Parser_clear_vars(compiler__Parser *p);
void compiler__Parser_fn_decl(compiler__Parser *p);
static inline void compiler__Parser_skip_fn_body(compiler__Parser *p);
string compiler__Parser_get_linkage_prefix(compiler__Parser *p);
void compiler__Parser_check_unused_and_mut_vars(compiler__Parser *p);
void compiler__Parser_async_fn_call(compiler__Parser *p, compiler__Fn f,
                                    int method_ph, string receiver_var,
                                    string receiver_type);
void compiler__Parser_verify_fn_before_call(compiler__Parser *p,
                                            compiler__Fn *f);
void compiler__Parser_fn_call(compiler__Parser *p, compiler__Fn *f,
                              int method_ph, string receiver_var,
                              string receiver_type);
void compiler__Parser_fn_args(compiler__Parser *p, compiler__Fn *f);
void compiler__Parser_fn_call_args(compiler__Parser *p, compiler__Fn *f,
                                   array_string generic_param_types);
compiler__TypeInst compiler__Parser_extract_type_inst(compiler__Parser *p,
                                                      compiler__Fn *f,
                                                      array_string args_);
string compiler__replace_generic_type(string gen_type, compiler__TypeInst *ti);
void compiler__replace_generic_type_params(compiler__Fn *f,
                                           compiler__TypeInst *ti);
string compiler__Parser_register_vargs_stuct(compiler__Parser *p, string typ,
                                             int len);
_V_MulRet_string_V_array_string
compiler__Parser_fn_call_vargs(compiler__Parser *p, compiler__Fn f);
void compiler__Parser_fn_gen_caller_vargs(compiler__Parser *p, compiler__Fn *f,
                                          string varg_type,
                                          array_string values);
string compiler__Parser_register_multi_return_stuct(compiler__Parser *p,
                                                    array_string types);
void compiler__rename_generic_fn_instance(compiler__Fn *f,
                                          compiler__TypeInst *ti);
void compiler__Parser_dispatch_generic_fn_instance(compiler__Parser *p,
                                                   compiler__Fn *f,
                                                   compiler__TypeInst *ti);
string compiler__Fn_typ_str(compiler__Fn *f);
string compiler__Fn_str_args(compiler__Fn *f, compiler__Table *table);
string compiler__Fn_str_args_without_types(compiler__Fn *f,
                                           compiler__Table *table);
string compiler__Parser_find_misspelled_local_var(compiler__Parser *p,
                                                  string name, f32 min_match);
bool array_compiler__Fn_contains(array_compiler__Fn fns, compiler__Fn f);
string compiler__Parser_fn_signature(compiler__Parser *p, compiler__Fn *f);
string compiler__Fn_v_fn_module(compiler__Fn *f);
string compiler__Fn_v_fn_name(compiler__Fn *f);
string compiler__Fn_str_for_error(compiler__Fn *f);
void compiler__Parser_for_st(compiler__Parser *p);
string compiler__Parser_gen_var_decl(compiler__Parser *p, string name,
                                     bool is_static);
void compiler__Parser_gen_fn_decl(compiler__Parser *p, compiler__Fn f,
                                  string typ, string str_args);
void compiler__Parser_gen_blank_identifier_assign(compiler__Parser *p);
string compiler__Parser_gen_handle_option_or_else(compiler__Parser *p,
                                                  string _typ, string name,
                                                  int fn_call_ph);
string compiler__Parser_gen_handle_question_suffix(compiler__Parser *p,
                                                   compiler__Fn f, int ph);
string compiler__types_to_c(array_compiler__Type types, compiler__Table *table);
void compiler__Parser_index_get(compiler__Parser *p, string typ, int fn_ph,
                                compiler__IndexConfig cfg);
string compiler__Table_fn_gen_name(compiler__Table *table, compiler__Fn *f);
void compiler__Parser_gen_method_call(compiler__Parser *p,
                                      compiler__Var *receiver,
                                      string receiver_type, string cgen_name,
                                      string ftyp, int method_ph);
void compiler__Parser_gen_array_at(compiler__Parser *p, string typ_,
                                   bool is_arr0, int fn_ph);
void compiler__Parser_gen_for_header(compiler__Parser *p, string i, string tmp,
                                     string var_typ, string val);
void compiler__Parser_gen_for_fixed_header(compiler__Parser *p, string i,
                                           string tmp, string var_typ,
                                           string val);
void compiler__Parser_gen_for_str_header(compiler__Parser *p, string i,
                                         string tmp, string var_typ,
                                         string val);
void compiler__Parser_gen_for_range_header(compiler__Parser *p, string i,
                                           string range_end, string tmp,
                                           string var_type, string val);
void compiler__Parser_gen_for_map_header(compiler__Parser *p, string i,
                                         string tmp, string var_typ, string val,
                                         string typ);
void compiler__Parser_gen_for_varg_header(compiler__Parser *p, string i,
                                          string varg, string var_typ,
                                          string val);
void compiler__Parser_gen_array_init(compiler__Parser *p, string typ,
                                     bool no_alloc, int new_arr_ph,
                                     int nr_elems);
void compiler__Parser_gen_array_set(compiler__Parser *p, string typ,
                                    bool is_ptr, bool is_map, int fn_ph,
                                    int assign_pos, bool is_cao);
bool compiler__Parser_gen_struct_init(compiler__Parser *p, string typ,
                                      compiler__Type *t);
void compiler__Parser_gen_struct_field_init(compiler__Parser *p, string field);
void compiler__Parser_gen_empty_map(compiler__Parser *p, string typ);
void compiler__Parser_cast(compiler__Parser *p, string typ);
string compiler__type_default(string typ);
void compiler__Parser_gen_array_push(compiler__Parser *p, int ph, string typ,
                                     string expr_type, string tmp,
                                     string elm_type);
compiler__Type compiler__Parser_get_type2(compiler__Parser *p);
string compiler__parse_pointer(string _typ);
string compiler__stringify_pointer(string typ);
string compiler__Parser_match_statement(compiler__Parser *p, bool is_expr);
void compiler__Parser_switch_statement(compiler__Parser *p);
string compiler__Parser_if_statement(compiler__Parser *p, bool is_expr,
                                     int elif_depth);
void compiler__Parser_gen_json_for_type(compiler__Parser *p,
                                        compiler__Type typ);
bool compiler__is_js_prim(string typ);
string compiler__Parser_decode_array(compiler__Parser *p, string array_type);
string compiler__js_enc_name(string typ);
string compiler__js_dec_name(string typ);
string compiler__Parser_encode_array(compiler__Parser *p, string array_type);
array_string
compiler__V_generate_hotcode_reloading_compiler_flags(compiler__V *v);
void compiler__V_generate_hotcode_reloading_declarations(compiler__V *v);
void compiler__V_generate_hotcode_reloading_main_caller(compiler__V *v);
void compiler__V_generate_hot_reload_code(compiler__V *v);
compiler__V *compiler__new_v(v_dot_pref__Preferences *pref);
void compiler__V_finalize_compilation(compiler__V *v);
int compiler__V_add_parser(compiler__V *v, compiler__Parser parser);
Option_int compiler__V_get_file_parser_index(compiler__V *v, string file);
int compiler__V_parse(compiler__V *v, string file, compiler__Pass pass);
void compiler__V_compile(compiler__V *v);
void compiler__V_compile2(compiler__V *v);
void compiler__V_compile_x64(compiler__V *v);
v_dot_builder__Builder compiler__V_new_v2(compiler__V *v);
void compiler__V_generate_init(compiler__V *v);
void compiler__V_generate_main(compiler__V *v);
void compiler__V_gen_main_start(compiler__V *v, bool add_os_args);
void compiler__V_gen_main_end(compiler__V *v, string return_statement);
array_string compiler__V_v_files_from_dir(compiler__V *v, string dir);
void compiler__V_add_v_files_to_compile(compiler__V *v);
array_string compiler__V_get_builtin_files(compiler__V *v);
array_string compiler__V_get_user_files(compiler__V *v);
array_string compiler__V_get_imported_module_files(compiler__V *v, string mod);
void compiler__V_parse_lib_imports(compiler__V *v);
void compiler__V_log(compiler__V *v, string s);
void compiler__verror(string s);
string compiler__vhash();
string compiler__cescaped_path(string s);
v_dot_pref__OS compiler__os_from_string(string os);
void compiler__set_vroot_folder(string vroot_path);
void compiler__generate_vh(string mod);
void compiler__VhGen_generate_fn(compiler__VhGen *g);
void compiler__VhGen_generate_alias(compiler__VhGen *g);
void compiler__VhGen_generate_const(compiler__VhGen *g);
void compiler__VhGen_generate_type(compiler__VhGen *g);
string compiler__Table_qualify_module(compiler__Table *table, string mod,
                                      string file_path);
compiler__ImportTable compiler__new_import_table();
void compiler__Parser_register_import(compiler__Parser *p, string mod,
                                      int tok_idx);
void compiler__Parser_register_import_alias(compiler__Parser *p, string alias,
                                            string mod, int tok_idx);
int compiler__ImportTable_get_import_tok_idx(compiler__ImportTable *it,
                                             string mod);
bool compiler__ImportTable_known_import(compiler__ImportTable *it, string mod);
bool compiler__ImportTable_known_alias(compiler__ImportTable *it, string alias);
bool compiler__ImportTable_is_aliased(compiler__ImportTable *it, string mod);
string compiler__ImportTable_resolve_alias(compiler__ImportTable *it,
                                           string alias);
void compiler__ImportTable_register_used_import(compiler__ImportTable *it,
                                                string alias);
bool compiler__ImportTable_is_used_import(compiler__ImportTable *it,
                                          string alias);
bool compiler__Parser_is_mod_in_scope(compiler__Parser *p, string mod);
compiler__DepGraph *compiler__V_resolve_deps(compiler__V *v);
compiler__DepGraph *compiler__V_import_graph(compiler__V *v);
array_string compiler__DepGraph_imports(compiler__DepGraph *graph);
static inline string compiler__V_module_path(compiler__V *v, string mod);
void compiler__V_set_module_lookup_paths(compiler__V *v);
Option_string compiler__Parser_find_module_path(compiler__Parser *p,
                                                string mod);
static inline string compiler__mod_gen_name(string mod);
static inline string compiler__mod_gen_name_rev(string mod);
Option_string compiler__find_windows_kit_internal(compiler__RegKey key,
                                                  array_string versions);
Option_compiler__WindowsKit compiler__find_windows_kit_root(string host_arch);
Option_compiler__VsInstallation compiler__find_vs(string vswhere_dir,
                                                  string host_arch);
Option_compiler__MsvcResult compiler__find_msvc();
void compiler__V_cc_msvc(compiler__V *v);
void compiler__build_thirdparty_obj_file_with_msvc(
    string path, array_compiler__CFlag moduleflags);
compiler__MsvcStringFlags
array_compiler__CFlag_msvc_string_flags(array_compiler__CFlag cflags);
void compiler__Parser_in_optimization(compiler__Parser *p, string typ, int ph);
string compiler__sql_params2params_gen(array_string sql_params,
                                       array_string sql_types, string qprefix);
string compiler__Parser_select_query(compiler__Parser *p, int fn_ph);
void compiler__Parser_insert_query(compiler__Parser *p, int fn_ph);
void compiler__Parser_update_query(compiler__Parser *p, int fn_ph);
compiler__Scanner *compiler__new_scanner_file(string file_path);
compiler__Scanner *compiler__new_scanner(string text);
compiler__ScanRes compiler__scan_res(compiler__TokenKind tok, string lit);
string compiler__Scanner_ident_name(compiler__Scanner *s);
string compiler__filter_num_sep(byte *txt, int start, int end);
string compiler__Scanner_ident_bin_number(compiler__Scanner *s);
string compiler__Scanner_ident_hex_number(compiler__Scanner *s);
string compiler__Scanner_ident_oct_number(compiler__Scanner *s);
string compiler__Scanner_ident_dec_number(compiler__Scanner *s);
string compiler__Scanner_ident_number(compiler__Scanner *s);
void compiler__Scanner_skip_whitespace(compiler__Scanner *s);
compiler__ScanRes compiler__Scanner_end_of_file(compiler__Scanner *s);
compiler__ScanRes compiler__Scanner_scan(compiler__Scanner *s);
int compiler__Scanner_current_column(compiler__Scanner *s);
int compiler__Scanner_count_symbol_before(compiler__Scanner s, int p, byte sym);
string compiler__Scanner_ident_string(compiler__Scanner *s);
string compiler__Scanner_ident_char(compiler__Scanner *s);
bool compiler__Scanner_expect(compiler__Scanner *s, string want, int start_pos);
void compiler__Scanner_debug_tokens(compiler__Scanner *s);
void compiler__Scanner_ignore_line(compiler__Scanner *s);
void compiler__Scanner_eat_to_end_of_line(compiler__Scanner *s);
void compiler__Scanner_inc_line_number(compiler__Scanner *s);
string compiler__Scanner_line(compiler__Scanner s, int n);
bool compiler__is_name_char(byte c);
static inline bool compiler__is_nl(byte c);
bool compiler__contains_capital(string s);
bool compiler__good_type_name(string s);
void compiler__Parser_string_expr(compiler__Parser *p);
void compiler__Parser_struct_decl(compiler__Parser *p,
                                  array_string generic_param_types);
string compiler__Parser_struct_init(compiler__Parser *p, string typ_);
void compiler__Type_rename_generic_struct(compiler__Type *t,
                                          map_string generic_types);
void compiler__Parser_dispatch_generic_struct(compiler__Parser *p,
                                              compiler__Type *t,
                                              array_string type_params);
bool array_compiler__AccessMod_contains(array_compiler__AccessMod a,
                                        compiler__AccessMod b);
string compiler__Fn_str(compiler__Fn f);
string compiler__Table_debug_fns(compiler__Table *t);
bool compiler__is_number_type(string typ);
bool compiler__is_integer_type(string typ);
bool compiler__is_float_type(string typ);
bool compiler__is_primitive_type(string typ);
bool compiler__is_pointer_type(string typ);
compiler__Table *compiler__new_table(bool obfuscate);
string compiler__Table_var_cgen_name(compiler__Table *t, string name);
void compiler__Table_register_module(compiler__Table *t, string mod);
void compiler__Parser_register_array(compiler__Parser *p, string typ);
void compiler__Parser_register_map(compiler__Parser *p, string typ);
bool compiler__Table_known_mod(compiler__Table *table, string mod);
void compiler__Table_register_const(compiler__Table *t, string name, string typ,
                                    string mod, bool is_pub);
void compiler__Parser_register_global(compiler__Parser *p, string name,
                                      string typ);
void compiler__Table_register_fn(compiler__Table *t, compiler__Fn new_fn);
bool compiler__Table_known_type(compiler__Table *table, string typ_);
bool compiler__Table_known_type_fast(compiler__Table *table, compiler__Type *t);
Option_compiler__Fn compiler__Table_find_fn(compiler__Table *t, string name);
Option_compiler__Fn compiler__Table_find_fn_is_script(compiler__Table *t,
                                                      string name,
                                                      bool is_script);
bool compiler__Table_known_fn(compiler__Table *t, string name);
bool compiler__Table_known_const(compiler__Table *t, string name);
void compiler__Table_register_builtin(compiler__Table *t, string typ);
void compiler__Parser_register_type_with_parent(compiler__Parser *p,
                                                string strtyp, string parent);
void compiler__Table_register_type_with_parent(compiler__Table *t, string typ,
                                               string parent);
void compiler__Table_register_type(compiler__Table *t, compiler__Type typ);
void compiler__Table_rewrite_type(compiler__Table *t, compiler__Type typ);
void compiler__Table_add_field(compiler__Table *table, string type_name,
                               string field_name, string field_type,
                               bool is_mut, string attr,
                               compiler__AccessMod access_mod);
void compiler__Table_add_default_val(compiler__Table *table, int idx,
                                     string type_name, string val_expr);
bool compiler__Type_has_field(compiler__Type *t, string name);
bool compiler__Type_has_enum_val(compiler__Type *t, string name);
Option_compiler__Var compiler__Type_find_field(compiler__Type *t, string name);
bool compiler__Table_type_has_field(compiler__Table *table, compiler__Type *typ,
                                    string name);
Option_compiler__Var compiler__Table_find_field(compiler__Table *table,
                                                compiler__Type *typ,
                                                string name);
void compiler__Parser_add_method(compiler__Parser *p, string type_name,
                                 compiler__Fn f);
bool compiler__Type_has_method(compiler__Type *t, string name);
bool compiler__Table_type_has_method(compiler__Table *table,
                                     compiler__Type *typ, string name);
Option_compiler__Fn compiler__Table_find_method(compiler__Table *table,
                                                compiler__Type *typ,
                                                string name);
Option_compiler__Fn compiler__Type_find_method(compiler__Type *t, string name);
void compiler__Table_add_gen_type(compiler__Table *table, string type_name,
                                  string gen_type);
compiler__Type compiler__Parser_find_type(compiler__Parser *p, string name);
compiler__Type compiler__Table_find_type(compiler__Table *t, string name_);
bool compiler__Parser_check_types2(compiler__Parser *p, string got_,
                                   string expected_, bool throw);
string compiler__Parser_base_type(compiler__Parser *p, string name);
bool compiler__Parser_check_types(compiler__Parser *p, string got,
                                  string expected);
bool compiler__Parser_check_types_no_throw(compiler__Parser *p, string got,
                                           string expected);
void compiler__Parser_check_types_with_token_index(compiler__Parser *p,
                                                   string got, string expected,
                                                   int var_token_idx);
bool compiler__Parser_satisfies_interface(compiler__Parser *p,
                                          string interface_name, string _typ,
                                          bool throw);
bool compiler__Table_is_interface(compiler__Table *table, string name);
bool compiler__Table_main_exists(compiler__Table *t);
array_string compiler__Table_all_test_function_names(compiler__Table *t);
Option_compiler__Var compiler__Table_find_const(compiler__Table *t,
                                                string name);
string compiler__Table_cgen_name_type_pair(compiler__Table *table, string name,
                                           string typ);
bool compiler__is_valid_int_const(string val, string typ);
string compiler__Parser_typ_to_fmt(compiler__Parser *p, string typ, int level);
string compiler__type_to_safe_str(string typ);
bool compiler__is_compile_time_const(string s_);
bool compiler__Type_contains_field_type(compiler__Type *t, string typ);
string compiler__Parser_identify_typo(compiler__Parser *p, string name);
f32 compiler__typo_compare_name_mod(string a, string b, string b_mod);
string compiler__Table_find_misspelled_fn(compiler__Table *table, string name,
                                          compiler__Parser *p, f32 min_match);
string compiler__Table_find_misspelled_imported_mod(compiler__Table *table,
                                                    string name,
                                                    compiler__Parser *p,
                                                    f32 min_match);
string compiler__Table_find_misspelled_const(compiler__Table *table,
                                             string name, compiler__Parser *p,
                                             f32 min_match);
_V_MulRet_string_V_string
compiler__Table_find_misspelled_type(compiler__Table *table, string name,
                                     compiler__Parser *p, f32 min_match);
string compiler__type_cat_str(compiler__TypeCategory tc);
map_int compiler__build_keys();
array_string compiler__build_token_str();
compiler__TokenKind compiler__key_to_token(string key);
bool compiler__is_key(string key);
string compiler__TokenKind_str(compiler__TokenKind t);
bool compiler__TokenKind_is_decl(compiler__TokenKind t);
bool compiler__TokenKind_is_assign(compiler__TokenKind t);
bool array_compiler__TokenKind_contains(array_compiler__TokenKind t,
                                        compiler__TokenKind val);
string compiler__Token_str(compiler__Token t);
string compiler__Token_detailed_str(compiler__Token t);
compiler__ModFileCacher *compiler__new_mod_file_cacher();
void compiler__ModFileCacher_dump(compiler__ModFileCacher *mcache);
compiler__ModFileAndFolder
compiler__ModFileCacher_get(compiler__ModFileCacher *mcache, string mfolder);
void compiler__ModFileCacher_add(compiler__ModFileCacher *cacher, string path,
                                 compiler__ModFileAndFolder result);
_V_MulRet_array_string_V_compiler__ModFileAndFolder
compiler__ModFileCacher_traverse(compiler__ModFileCacher *mcache,
                                 string mfolder);
void compiler__ModFileCacher_mark_folders_with_vmod(
    compiler__ModFileCacher *mcache, array_string folders_so_far,
    compiler__ModFileAndFolder vmod);
void compiler__ModFileCacher_mark_folders_as_vmod_free(
    compiler__ModFileCacher *mcache, array_string folders_so_far);
bool compiler__ModFileCacher_check_for_stop(compiler__ModFileCacher *mcache,
                                            string cfolder, array_string files);
array_string compiler__ModFileCacher_get_files(compiler__ModFileCacher *mcache,
                                               string cfolder);
void compiler__Scanner_fgen(compiler__Scanner *scanner, string s_);
void compiler__Scanner_fgenln(compiler__Scanner *scanner, string s_);
void compiler__Parser_fgen(compiler__Parser *p, string s);
void compiler__Parser_fspace(compiler__Parser *p);
void compiler__Parser_fspace_or_newline(compiler__Parser *p);
void compiler__Parser_fgenln(compiler__Parser *p, string s);
void compiler__Parser_fgen_nl(compiler__Parser *p);
void compiler__Scanner_fgen_nl(compiler__Scanner *scanner);
void compiler__Parser_fmt_inc(compiler__Parser *p);
void compiler__Parser_fmt_dec(compiler__Parser *p);
void compiler__Scanner_init_fmt(compiler__Scanner *s);
void compiler__Parser_fnext(compiler__Parser *p);
void compiler__Parser_fremove_last(compiler__Parser *p);
void compiler__Parser_gen_fmt(compiler__Parser *p);
string compiler__write_formatted_source(string file_name, string s);
string compiler__get_vtmp_folder();
string compiler__get_vtmp_filename(string base_file_name, string postfix);
void internal_dot_compile__check_for_common_mistake(array_string args,
                                                    v_dot_pref__Preferences *p);
void internal_dot_compile__compile(string command, array_string args);
void internal_dot_compile__run_compiled_executable_and_exit(
    compiler__V *v, array_string remaining_args);
static inline void
internal_dot_compile__parse_c_options(string flag,
                                      internal_dot_flag__Instance *f,
                                      v_dot_pref__Preferences *prefs);
static inline void internal_dot_compile__parse_js_options(
    string flag, internal_dot_flag__Instance f, v_dot_pref__Preferences prefs);
_V_MulRet_v_dot_pref__Preferences_V_array_string
internal_dot_compile__parse_arguments(array_string args);
void internal_dot_compile__parse_options(string flag,
                                         internal_dot_flag__Instance *f,
                                         v_dot_pref__Preferences *prefs);
static inline void
internal_dot_compile__parse_define(v_dot_pref__Preferences *prefs,
                                   string define);
static inline void
internal_dot_compile__parse_x64_options(string flag,
                                        internal_dot_flag__Instance *f,
                                        v_dot_pref__Preferences *prefs);
static inline void
internal_dot_compile__parse_executable_options(string flag,
                                               internal_dot_flag__Instance *f,
                                               v_dot_pref__Preferences *prefs);
void internal_dot_compile__parse_and_output_new_format(array_string args);
static inline array_internal_dot_compile__Deprecated
internal_dot_compile__add_if_found_deprecated(array_string args,
                                              string deprecated, string alt);
static inline array_string
internal_dot_compile__add_if_found_string(array_string args, string deprecated);
array_string main__join_flags_and_argument();
void main__parse_flags(string flag, internal_dot_flag__Instance *f,
                       internal_dot_flag__MainCmdPreferences *prefs);
void main__launch_tool(v_dot_pref__VerboseLevel verbosity, string tool_name);
string main__path_of_executable(string path);
void main__create_symlink();
void main__main();
void main__print_version_and_exit();
void main__invoke_help_and_exit(array_string remaining);
static inline void
main__disallow_unknown_flags(internal_dot_flag__MainCmdPreferences prefs);
string array_v_dot_table__Type_str();
string internal_dot_flag__MainCmdPreferences_str();

byte *g_m2_buf;     // global
byte *g_m2_ptr;     // global
byte *g_m2_buf;     // global
byte *g_m2_ptr;     // global
i64 total_m = 0;    // global
int nr_mallocs = 0; // global
int builtin__SYMOPT_UNDNAME;
int builtin__SYMOPT_DEFERRED_LOADS;
int builtin__SYMOPT_NO_CPP;
int builtin__SYMOPT_LOAD_LINES;
int builtin__SYMOPT_INCLUDE_32BIT_MODULES;
int builtin__SYMOPT_ALLOW_ZERO_ADDRESS;
int builtin__SYMOPT_DEBUG;
string builtin__digit_pairs;
int builtin__init_capicity;
int builtin__init_cap;
u32 builtin__hash_mask;
u32 builtin__probe_inc;
u32 builtin__max_probe;
int builtin__mid_index;
int builtin__max_size;
int builtin__children_bytes;
array_int g_ustring_runes; // global
u64 hash_dot_wyhash__wyp0;
u64 hash_dot_wyhash__wyp1;
u64 hash_dot_wyhash__wyp2;
u64 hash_dot_wyhash__wyp3;
u64 hash_dot_wyhash__wyp4;
u64 strconv__DOUBLE_PLUS_ZERO;
u64 strconv__DOUBLE_MINUS_ZERO;
u64 strconv__DOUBLE_PLUS_INFINITY;
u64 strconv__DOUBLE_MINUS_INFINITY;
u32 strconv__TEN;
u64 strconv__max_u64;
u64 math__uvnan;
u64 math__uvinf;
u64 math__uvneginf;
u64 math__uvone;
int math__mask;
int math__shift;
u64 math__sign_mask;
u64 math__frac_mask;
f32 math__log2_e;
f32 math__log10_e;
f32 math__max_f32;
f32 math__smallest_non_zero_f32;
f32 math__max_f64;
f32 math__smallest_non_zero_f64;
int math__min_i8;
int math__min_i16;
int math__min_i32;
u64 math__min_i64;
u32 math_dot_bits__de_bruijn32;
array_byte math_dot_bits__de_bruijn32tab;
u64 math_dot_bits__de_bruijn64;
array_byte math_dot_bits__de_bruijn64tab;
u64 math_dot_bits__m0;
u64 math_dot_bits__m1;
u64 math_dot_bits__m2;
u64 math_dot_bits__m3;
u64 math_dot_bits__m4;
u64 math_dot_bits__two32;
u64 math_dot_bits__mask32;
string math_dot_bits__overflow_error;
string math_dot_bits__divide_error;
array_byte math_dot_bits__ntz_8_tab;
array_byte math_dot_bits__pop_8_tab;
array_byte math_dot_bits__rev_8_tab;
array_byte math_dot_bits__len_8_tab;
string time__days_string;
array_int time__month_days;
string time__months_string;
i64 time__absolute_zero_year;
int time__seconds_per_hour;
int time__seconds_per_day;
int time__seconds_per_week;
int time__days_per_400_years;
int time__days_per_100_years;
int time__days_per_4_years;
array_int time__days_before;
#define time__time__FormatTime_hhmm12 0
#define time__time__FormatTime_hhmm24 1
#define time__time__FormatTime_hhmmss12 2
#define time__time__FormatTime_hhmmss24 3
#define time__time__FormatTime_no_time 4
#define time__time__FormatDate_ddmmyy 0
#define time__time__FormatDate_ddmmyyyy 1
#define time__time__FormatDate_mmddyy 2
#define time__time__FormatDate_mmddyyyy 3
#define time__time__FormatDate_mmmd 4
#define time__time__FormatDate_mmmdd 5
#define time__time__FormatDate_mmmddyyyy 6
#define time__time__FormatDate_no_date 7
#define time__time__FormatDate_yyyymmdd 8
#define time__time__FormatDelimiter_dot 0
#define time__time__FormatDelimiter_hyphen 1
#define time__time__FormatDelimiter_slash 2
#define time__time__FormatDelimiter_space 3
#define v_dot_token__v_dot_token__Kind_eof 0
#define v_dot_token__v_dot_token__Kind_name 1
#define v_dot_token__v_dot_token__Kind_number 2
#define v_dot_token__v_dot_token__Kind_string 3
#define v_dot_token__v_dot_token__Kind_str_inter 4
#define v_dot_token__v_dot_token__Kind_chartoken 5
#define v_dot_token__v_dot_token__Kind_plus 6
#define v_dot_token__v_dot_token__Kind_minus 7
#define v_dot_token__v_dot_token__Kind_mul 8
#define v_dot_token__v_dot_token__Kind_div 9
#define v_dot_token__v_dot_token__Kind_mod 10
#define v_dot_token__v_dot_token__Kind_xor 11
#define v_dot_token__v_dot_token__Kind_pipe 12
#define v_dot_token__v_dot_token__Kind_inc 13
#define v_dot_token__v_dot_token__Kind_dec 14
#define v_dot_token__v_dot_token__Kind_and 15
#define v_dot_token__v_dot_token__Kind_logical_or 16
#define v_dot_token__v_dot_token__Kind_not 17
#define v_dot_token__v_dot_token__Kind_bit_not 18
#define v_dot_token__v_dot_token__Kind_question 19
#define v_dot_token__v_dot_token__Kind_comma 20
#define v_dot_token__v_dot_token__Kind_semicolon 21
#define v_dot_token__v_dot_token__Kind_colon 22
#define v_dot_token__v_dot_token__Kind_arrow 23
#define v_dot_token__v_dot_token__Kind_amp 24
#define v_dot_token__v_dot_token__Kind_hash 25
#define v_dot_token__v_dot_token__Kind_dollar 26
#define v_dot_token__v_dot_token__Kind_str_dollar 27
#define v_dot_token__v_dot_token__Kind_left_shift 28
#define v_dot_token__v_dot_token__Kind_right_shift 29
#define v_dot_token__v_dot_token__Kind_assign 30
#define v_dot_token__v_dot_token__Kind_decl_assign 31
#define v_dot_token__v_dot_token__Kind_plus_assign 32
#define v_dot_token__v_dot_token__Kind_minus_assign 33
#define v_dot_token__v_dot_token__Kind_div_assign 34
#define v_dot_token__v_dot_token__Kind_mult_assign 35
#define v_dot_token__v_dot_token__Kind_xor_assign 36
#define v_dot_token__v_dot_token__Kind_mod_assign 37
#define v_dot_token__v_dot_token__Kind_or_assign 38
#define v_dot_token__v_dot_token__Kind_and_assign 39
#define v_dot_token__v_dot_token__Kind_right_shift_assign 40
#define v_dot_token__v_dot_token__Kind_left_shift_assign 41
#define v_dot_token__v_dot_token__Kind_lcbr 42
#define v_dot_token__v_dot_token__Kind_rcbr 43
#define v_dot_token__v_dot_token__Kind_lpar 44
#define v_dot_token__v_dot_token__Kind_rpar 45
#define v_dot_token__v_dot_token__Kind_lsbr 46
#define v_dot_token__v_dot_token__Kind_rsbr 47
#define v_dot_token__v_dot_token__Kind_eq 48
#define v_dot_token__v_dot_token__Kind_ne 49
#define v_dot_token__v_dot_token__Kind_gt 50
#define v_dot_token__v_dot_token__Kind_lt 51
#define v_dot_token__v_dot_token__Kind_ge 52
#define v_dot_token__v_dot_token__Kind_le 53
#define v_dot_token__v_dot_token__Kind_line_comment 54
#define v_dot_token__v_dot_token__Kind_mline_comment 55
#define v_dot_token__v_dot_token__Kind_nl 56
#define v_dot_token__v_dot_token__Kind_dot 57
#define v_dot_token__v_dot_token__Kind_dotdot 58
#define v_dot_token__v_dot_token__Kind_ellipsis 59
#define v_dot_token__v_dot_token__Kind_keyword_beg 60
#define v_dot_token__v_dot_token__Kind_key_as 61
#define v_dot_token__v_dot_token__Kind_key_asm 62
#define v_dot_token__v_dot_token__Kind_key_assert 63
#define v_dot_token__v_dot_token__Kind_key_atomic 64
#define v_dot_token__v_dot_token__Kind_key_break 65
#define v_dot_token__v_dot_token__Kind_key_const 66
#define v_dot_token__v_dot_token__Kind_key_continue 67
#define v_dot_token__v_dot_token__Kind_key_defer 68
#define v_dot_token__v_dot_token__Kind_key_else 69
#define v_dot_token__v_dot_token__Kind_key_embed 70
#define v_dot_token__v_dot_token__Kind_key_enum 71
#define v_dot_token__v_dot_token__Kind_key_false 72
#define v_dot_token__v_dot_token__Kind_key_for 73
#define v_dot_token__v_dot_token__Kind_key_fn 74
#define v_dot_token__v_dot_token__Kind_key_global 75
#define v_dot_token__v_dot_token__Kind_key_go 76
#define v_dot_token__v_dot_token__Kind_key_goto 77
#define v_dot_token__v_dot_token__Kind_key_if 78
#define v_dot_token__v_dot_token__Kind_key_import 79
#define v_dot_token__v_dot_token__Kind_key_import_const 80
#define v_dot_token__v_dot_token__Kind_key_in 81
#define v_dot_token__v_dot_token__Kind_key_interface 82
#define v_dot_token__v_dot_token__Kind_key_match 83
#define v_dot_token__v_dot_token__Kind_key_module 84
#define v_dot_token__v_dot_token__Kind_key_mut 85
#define v_dot_token__v_dot_token__Kind_key_none 86
#define v_dot_token__v_dot_token__Kind_key_return 87
#define v_dot_token__v_dot_token__Kind_key_select 88
#define v_dot_token__v_dot_token__Kind_key_sizeof 89
#define v_dot_token__v_dot_token__Kind_key_offsetof 90
#define v_dot_token__v_dot_token__Kind_key_struct 91
#define v_dot_token__v_dot_token__Kind_key_switch 92
#define v_dot_token__v_dot_token__Kind_key_true 93
#define v_dot_token__v_dot_token__Kind_key_type 94
#define v_dot_token__v_dot_token__Kind_key_orelse 95
#define v_dot_token__v_dot_token__Kind_key_union 96
#define v_dot_token__v_dot_token__Kind_key_pub 97
#define v_dot_token__v_dot_token__Kind_key_static 98
#define v_dot_token__v_dot_token__Kind_key_unsafe 99
#define v_dot_token__v_dot_token__Kind_keyword_end 100
array_v_dot_token__Kind v_dot_token__assign_tokens;
array_string v_dot_token__token_str;
map_int v_dot_token__keywords;
#define v_dot_token__v_dot_token__Precedence_lowest 0
#define v_dot_token__v_dot_token__Precedence_cond 1
#define v_dot_token__v_dot_token__Precedence_in_as 2
#define v_dot_token__v_dot_token__Precedence_assign 3
#define v_dot_token__v_dot_token__Precedence_eq 4
#define v_dot_token__v_dot_token__Precedence_sum 5
#define v_dot_token__v_dot_token__Precedence_product 6
#define v_dot_token__v_dot_token__Precedence_prefix 7
#define v_dot_token__v_dot_token__Precedence_postfix 8
#define v_dot_token__v_dot_token__Precedence_call 9
#define v_dot_token__v_dot_token__Precedence_index 10
array_v_dot_token__Precedence v_dot_token__precedences;
u32 strconv_dot_ftoa__mantbits32;
u32 strconv_dot_ftoa__expbits32;
u32 strconv_dot_ftoa__bias32;
u32 strconv_dot_ftoa__mantbits64;
u32 strconv_dot_ftoa__expbits64;
u32 strconv_dot_ftoa__bias64;
array_u64 strconv_dot_ftoa__powers_of_10;
array_u64 strconv_dot_ftoa__pow5_split_32;
array_u64 strconv_dot_ftoa__pow5_inv_split_32;
array_strconv_dot_ftoa__Uint128 strconv_dot_ftoa__pow5_split_64;
array_strconv_dot_ftoa__Uint128 strconv_dot_ftoa__pow5_inv_split_64;
int os__S_IFMT;
int os__S_IFDIR;
int os__S_IFLNK;
int os__STD_INPUT_HANDLE;
int os__STD_OUTPUT_HANDLE;
int os__STD_ERROR_HANDLE;
int os__FILE_ATTR_READONLY;
int os__FILE_ATTR_HIDDEN;
int os__FILE_ATTR_SYSTEM;
int os__FILE_ATTR_DIRECTORY;
int os__FILE_ATTR_ARCHIVE;
int os__FILE_ATTR_DEVICE;
int os__FILE_ATTR_NORMAL;
int os__FILE_ATTR_TEMPORARY;
int os__FILE_ATTR_SPARSE_FILE;
int os__FILE_ATTR_REPARSE_POINT;
int os__FILE_ATTR_COMPRESSED;
int os__FILE_ATTR_OFFLINE;
int os__FILE_ATTR_NOT_CONTENT_INDEXED;
int os__FILE_ATTR_ENCRYPTED;
int os__FILE_ATTR_INTEGRITY_STREAM;
int os__FILE_ATTR_VIRTUAL;
int os__FILE_ATTR_NO_SCRUB_DATA;
int os__FILE_TYPE_DISK;
int os__FILE_TYPE_CHAR;
int os__FILE_TYPE_PIPE;
int os__FILE_TYPE_UNKNOWN;
int os__FILE_INVALID_FILE_ID;
voidptr os__INVALID_HANDLE_VALUE;
int os__ENABLE_ECHO_INPUT;
int os__ENABLE_EXTENDED_FLAGS;
int os__ENABLE_INSERT_MODE;
int os__ENABLE_LINE_INPUT;
int os__ENABLE_MOUSE_INPUT;
int os__ENABLE_PROCESSED_INPUT;
int os__ENABLE_QUICK_EDIT_MODE;
int os__ENABLE_WINDOW_INPUT;
int os__ENABLE_VIRTUAL_TERMINAL_INPUT;
int os__ENABLE_PROCESSED_OUTPUT;
int os__ENABLE_WRAP_AT_EOL_OUTPUT;
int os__ENABLE_VIRTUAL_TERMINAL_PROCESSING;
int os__DISABLE_NEWLINE_AUTO_RETURN;
int os__ENABLE_LVB_GRID_WORLDWIDE;
int os__O_APPEND;
int os__O_CREATE;
int os__O_TRUNC;
int os__O_EXCL;
array_string os__args;
string os__wd_at_startup;
string os__path_separator;
int os__FORMAT_MESSAGE_ALLOCATE_BUFFER;
int os__FORMAT_MESSAGE_ARGUMENT_ARRAY;
int os__FORMAT_MESSAGE_FROM_HMODULE;
int os__FORMAT_MESSAGE_FROM_STRING;
int os__FORMAT_MESSAGE_FROM_SYSTEM;
int os__FORMAT_MESSAGE_IGNORE_INSERTS;
int os__SUBLANG_NEUTRAL;
int os__SUBLANG_DEFAULT;
int os__LANG_NEUTRAL;
string v_dot_pref__default_module_path;
#define v_dot_pref__v_dot_pref__OS__auto 0
#define v_dot_pref__v_dot_pref__OS_mac 1
#define v_dot_pref__v_dot_pref__OS_linux 2
#define v_dot_pref__v_dot_pref__OS_windows 3
#define v_dot_pref__v_dot_pref__OS_freebsd 4
#define v_dot_pref__v_dot_pref__OS_openbsd 5
#define v_dot_pref__v_dot_pref__OS_netbsd 6
#define v_dot_pref__v_dot_pref__OS_dragonfly 7
#define v_dot_pref__v_dot_pref__OS_js 8
#define v_dot_pref__v_dot_pref__OS_android 9
#define v_dot_pref__v_dot_pref__OS_solaris 10
#define v_dot_pref__v_dot_pref__OS_haiku 11
#define v_dot_pref__v_dot_pref__BuildMode_default_mode 0
#define v_dot_pref__v_dot_pref__BuildMode_build_module 1
#define v_dot_pref__v_dot_pref__Backend_c 0
#define v_dot_pref__v_dot_pref__Backend_experimental 1
#define v_dot_pref__v_dot_pref__Backend_js 2
#define v_dot_pref__v_dot_pref__Backend_x64 3
#define v_dot_pref__v_dot_pref__VerboseLevel_clean 0
#define v_dot_pref__v_dot_pref__VerboseLevel_level_one 1
#define v_dot_pref__v_dot_pref__VerboseLevel_level_two 2
#define v_dot_pref__v_dot_pref__VerboseLevel_level_three 3
//// SUMTYPE:  v.table | parent: v_dot_table__TypeInfo | name:
#define SumType_v_dot_table__TypeInfo_Array 1       // DEF2
#define SumType_v_dot_table__TypeInfo_ArrayFixed 2  // DEF2
#define SumType_v_dot_table__TypeInfo_Map 3         // DEF2
#define SumType_v_dot_table__TypeInfo_Struct 4      // DEF2
#define SumType_v_dot_table__TypeInfo_MultiReturn 5 // DEF2
#define SumType_v_dot_table__TypeInfo_Alias 6       // DEF2
#define SumType_v_dot_table__TypeInfo_Enum 7        // DEF2
#define SumType_v_dot_table__TypeInfo_SumType 8     // DEF2
#define SumType_v_dot_table__TypeInfo_Fn 9          // DEF2
const char *__SumTypeNames__v_dot_table__TypeInfo[] = {
    "v_dot_table__TypeInfo", "Array", "ArrayFixed", "Map",     "Struct",
    "MultiReturn",           "Alias", "Enum",       "SumType", "Fn",
};
#define v_dot_table__v_dot_table__TypeExtra_unset 0
#define v_dot_table__v_dot_table__TypeExtra_optional 1
#define v_dot_table__v_dot_table__TypeExtra_variadic 2
array_int v_dot_table__number_idxs;
v_dot_table__Type v_dot_table__void_type;
v_dot_table__Type v_dot_table__voidptr_type;
v_dot_table__Type v_dot_table__byteptr_type;
v_dot_table__Type v_dot_table__charptr_type;
v_dot_table__Type v_dot_table__i8_type;
v_dot_table__Type v_dot_table__int_type;
v_dot_table__Type v_dot_table__i16_type;
v_dot_table__Type v_dot_table__i64_type;
v_dot_table__Type v_dot_table__byte_type;
v_dot_table__Type v_dot_table__u16_type;
v_dot_table__Type v_dot_table__u32_type;
v_dot_table__Type v_dot_table__u64_type;
v_dot_table__Type v_dot_table__f32_type;
v_dot_table__Type v_dot_table__f64_type;
v_dot_table__Type v_dot_table__char_type;
v_dot_table__Type v_dot_table__bool_type;
v_dot_table__Type v_dot_table__none_type;
v_dot_table__Type v_dot_table__string_type;
v_dot_table__Type v_dot_table__array_type;
v_dot_table__Type v_dot_table__map_type;
array_string v_dot_table__builtin_type_names;
#define v_dot_table__v_dot_table__Kind_placeholder 0
#define v_dot_table__v_dot_table__Kind_void 1
#define v_dot_table__v_dot_table__Kind_voidptr 2
#define v_dot_table__v_dot_table__Kind_byteptr 3
#define v_dot_table__v_dot_table__Kind_charptr 4
#define v_dot_table__v_dot_table__Kind_i8 5
#define v_dot_table__v_dot_table__Kind_i16 6
#define v_dot_table__v_dot_table__Kind_int 7
#define v_dot_table__v_dot_table__Kind_i64 8
#define v_dot_table__v_dot_table__Kind_byte 9
#define v_dot_table__v_dot_table__Kind_u16 10
#define v_dot_table__v_dot_table__Kind_u32 11
#define v_dot_table__v_dot_table__Kind_u64 12
#define v_dot_table__v_dot_table__Kind_f32 13
#define v_dot_table__v_dot_table__Kind_f64 14
#define v_dot_table__v_dot_table__Kind_char 15
#define v_dot_table__v_dot_table__Kind_bool 16
#define v_dot_table__v_dot_table__Kind_none_ 17
#define v_dot_table__v_dot_table__Kind_string 18
#define v_dot_table__v_dot_table__Kind_array 19
#define v_dot_table__v_dot_table__Kind_array_fixed 20
#define v_dot_table__v_dot_table__Kind_map 21
#define v_dot_table__v_dot_table__Kind_struct_ 22
#define v_dot_table__v_dot_table__Kind_multi_return 23
#define v_dot_table__v_dot_table__Kind_sum_type 24
#define v_dot_table__v_dot_table__Kind_alias 25
#define v_dot_table__v_dot_table__Kind_enum_ 26
#define v_dot_table__v_dot_table__Kind_function 27
#define v_dot_scanner__v_dot_scanner__CommentsMode_skip_comments 0
#define v_dot_scanner__v_dot_scanner__CommentsMode_parse_comments 1
bool v_dot_scanner__is_fmt;
array_string internal_dot_flag__truthy;
array_string internal_dot_flag__falsey;
#define internal_dot_flag__internal_dot_flag__MainCmdAction_unspecified 0
#define internal_dot_flag__internal_dot_flag__MainCmdAction_version 1
#define internal_dot_flag__internal_dot_flag__MainCmdAction_help 2
string internal_dot_help__unknown_topic;
string benchmark__BOK;
string benchmark__BFAIL;
string benchmark__BSPENT;
//// SUMTYPE:  v.ast | parent: v_dot_ast__TypeDecl | name:
#define SumType_v_dot_ast__TypeDecl_AliasTypeDecl 1 // DEF2
#define SumType_v_dot_ast__TypeDecl_SumTypeDecl 2   // DEF2
#define SumType_v_dot_ast__TypeDecl_FnTypeDecl 3    // DEF2
const char *__SumTypeNames__v_dot_ast__TypeDecl[] = {
    "v_dot_ast__TypeDecl",
    "AliasTypeDecl",
    "SumTypeDecl",
    "FnTypeDecl",
};
//// SUMTYPE:  v.ast | parent: v_dot_ast__Expr | name:
#define SumType_v_dot_ast__Expr_InfixExpr 1       // DEF2
#define SumType_v_dot_ast__Expr_IfExpr 2          // DEF2
#define SumType_v_dot_ast__Expr_StringLiteral 3   // DEF2
#define SumType_v_dot_ast__Expr_IntegerLiteral 4  // DEF2
#define SumType_v_dot_ast__Expr_CharLiteral 5     // DEF2
#define SumType_v_dot_ast__Expr_FloatLiteral 6    // DEF2
#define SumType_v_dot_ast__Expr_Ident 7           // DEF2
#define SumType_v_dot_ast__Expr_CallExpr 8        // DEF2
#define SumType_v_dot_ast__Expr_BoolLiteral 9     // DEF2
#define SumType_v_dot_ast__Expr_StructInit 10     // DEF2
#define SumType_v_dot_ast__Expr_ArrayInit 11      // DEF2
#define SumType_v_dot_ast__Expr_SelectorExpr 12   // DEF2
#define SumType_v_dot_ast__Expr_PostfixExpr 13    // DEF2
#define SumType_v_dot_ast__Expr_AssignExpr 14     // DEF2
#define SumType_v_dot_ast__Expr_PrefixExpr 15     // DEF2
#define SumType_v_dot_ast__Expr_MethodCallExpr 16 // DEF2
#define SumType_v_dot_ast__Expr_IndexExpr 17      // DEF2
#define SumType_v_dot_ast__Expr_RangeExpr 18      // DEF2
#define SumType_v_dot_ast__Expr_MatchExpr 19      // DEF2
#define SumType_v_dot_ast__Expr_CastExpr 20       // DEF2
#define SumType_v_dot_ast__Expr_EnumVal 21        // DEF2
#define SumType_v_dot_ast__Expr_Assoc 22          // DEF2
#define SumType_v_dot_ast__Expr_SizeOf 23         // DEF2
#define SumType_v_dot_ast__Expr_None 24           // DEF2
#define SumType_v_dot_ast__Expr_MapInit 25        // DEF2
#define SumType_v_dot_ast__Expr_IfGuardExpr 26    // DEF2
#define SumType_v_dot_ast__Expr_ParExpr 27        // DEF2
#define SumType_v_dot_ast__Expr_OrExpr 28         // DEF2
#define SumType_v_dot_ast__Expr_ConcatExpr 29     // DEF2
#define SumType_v_dot_ast__Expr_Type 30           // DEF2
#define SumType_v_dot_ast__Expr_AsCast 31         // DEF2
const char *__SumTypeNames__v_dot_ast__Expr[] = {
    "v_dot_ast__Expr",
    "InfixExpr",
    "IfExpr",
    "StringLiteral",
    "IntegerLiteral",
    "CharLiteral",
    "FloatLiteral",
    "Ident",
    "CallExpr",
    "BoolLiteral",
    "StructInit",
    "ArrayInit",
    "SelectorExpr",
    "PostfixExpr",
    "AssignExpr",
    "PrefixExpr",
    "MethodCallExpr",
    "IndexExpr",
    "RangeExpr",
    "MatchExpr",
    "CastExpr",
    "EnumVal",
    "Assoc",
    "SizeOf",
    "None",
    "MapInit",
    "IfGuardExpr",
    "ParExpr",
    "OrExpr",
    "ConcatExpr",
    "Type",
    "AsCast",
};
//// SUMTYPE:  v.ast | parent: v_dot_ast__Stmt | name:
#define SumType_v_dot_ast__Stmt_GlobalDecl 1        // DEF2
#define SumType_v_dot_ast__Stmt_FnDecl 2            // DEF2
#define SumType_v_dot_ast__Stmt_Return 3            // DEF2
#define SumType_v_dot_ast__Stmt_Module 4            // DEF2
#define SumType_v_dot_ast__Stmt_Import 5            // DEF2
#define SumType_v_dot_ast__Stmt_ExprStmt 6          // DEF2
#define SumType_v_dot_ast__Stmt_ForStmt 7           // DEF2
#define SumType_v_dot_ast__Stmt_StructDecl 8        // DEF2
#define SumType_v_dot_ast__Stmt_ForCStmt 9          // DEF2
#define SumType_v_dot_ast__Stmt_ForInStmt 10        // DEF2
#define SumType_v_dot_ast__Stmt_CompIf 11           // DEF2
#define SumType_v_dot_ast__Stmt_ConstDecl 12        // DEF2
#define SumType_v_dot_ast__Stmt_Attr 13             // DEF2
#define SumType_v_dot_ast__Stmt_BranchStmt 14       // DEF2
#define SumType_v_dot_ast__Stmt_HashStmt 15         // DEF2
#define SumType_v_dot_ast__Stmt_AssignStmt 16       // DEF2
#define SumType_v_dot_ast__Stmt_EnumDecl 17         // DEF2
#define SumType_v_dot_ast__Stmt_TypeDecl 18         // DEF2
#define SumType_v_dot_ast__Stmt_DeferStmt 19        // DEF2
#define SumType_v_dot_ast__Stmt_GotoLabel 20        // DEF2
#define SumType_v_dot_ast__Stmt_GotoStmt 21         // DEF2
#define SumType_v_dot_ast__Stmt_LineComment 22      // DEF2
#define SumType_v_dot_ast__Stmt_MultiLineComment 23 // DEF2
#define SumType_v_dot_ast__Stmt_AssertStmt 24       // DEF2
#define SumType_v_dot_ast__Stmt_UnsafeStmt 25       // DEF2
#define SumType_v_dot_ast__Stmt_GoStmt 26           // DEF2
const char *__SumTypeNames__v_dot_ast__Stmt[] = {
    "v_dot_ast__Stmt", "GlobalDecl", "FnDecl",      "Return",
    "Module",          "Import",     "ExprStmt",    "ForStmt",
    "StructDecl",      "ForCStmt",   "ForInStmt",   "CompIf",
    "ConstDecl",       "Attr",       "BranchStmt",  "HashStmt",
    "AssignStmt",      "EnumDecl",   "TypeDecl",    "DeferStmt",
    "GotoLabel",       "GotoStmt",   "LineComment", "MultiLineComment",
    "AssertStmt",      "UnsafeStmt", "GoStmt",
};
//// SUMTYPE:  v.ast | parent: v_dot_ast__IdentInfo | name:
#define SumType_v_dot_ast__IdentInfo_IdentFn 1  // DEF2
#define SumType_v_dot_ast__IdentInfo_IdentVar 2 // DEF2
const char *__SumTypeNames__v_dot_ast__IdentInfo[] = {
    "v_dot_ast__IdentInfo",
    "IdentFn",
    "IdentVar",
};
#define v_dot_ast__v_dot_ast__IdentKind_unresolved 0
#define v_dot_ast__v_dot_ast__IdentKind_blank_ident 1
#define v_dot_ast__v_dot_ast__IdentKind_variable 2
#define v_dot_ast__v_dot_ast__IdentKind_constant 3
#define v_dot_ast__v_dot_ast__IdentKind_function 4
voidptr sync__no_result;
#define sync__sync__MutexState_broken 0
#define sync__sync__MutexState_waiting 1
#define sync__sync__MutexState_released 2
#define sync__sync__MutexState_abandoned 3
#define sync__sync__MutexState_destroyed 4
int sync__INFINITE;
int sync__WAIT_ABANDONED;
int sync__WAIT_IO_COMPLETION;
int sync__WAIT_OBJECT_0;
int sync__WAIT_TIMEOUT;
int sync__WAIT_FAILED;
bool v_dot_parser__colored_output;
array_string v_dot_gen__builtins;
string v_dot_gen__c_common_macros;
string v_dot_gen__c_headers;
string v_dot_gen__c_builtin_types;
string v_dot_gen__bare_c_headers;
int v_dot_gen_dot_x64__mag0;
int v_dot_gen_dot_x64__e_machine;
int v_dot_gen_dot_x64__shn_xindex;
int v_dot_gen_dot_x64__segment_start;
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__SectionType_null 0
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__SectionType_progbits 1
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__SectionType_symtab 2
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__SectionType_strtab 3
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__SectionType_rela 4
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_eax 0
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_edi 1
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_rax 2
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_rdi 3
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_rsi 4
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_edx 5
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_rdx 6
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_r12 7
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__Size__8 0
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__Size__16 1
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__Size__32 2
#define v_dot_gen_dot_x64__v_dot_gen_dot_x64__Size__64 3
map_bool compiler__reserved_types;
#define compiler__compiler__IndexType_noindex 0
#define compiler__compiler__IndexType_str 1
#define compiler__compiler__IndexType_map 2
#define compiler__compiler__IndexType_array 3
#define compiler__compiler__IndexType_array0 4
#define compiler__compiler__IndexType_fixed_array 5
#define compiler__compiler__IndexType_ptr 6
string compiler__c_common_macros;
string compiler__c_headers;
string compiler__js_headers;
string compiler__c_builtin_types;
string compiler__bare_c_headers;
string compiler__warn_match_arrow;
string compiler__err_used_as_value;
string compiler__and_or_error;
string compiler__err_modify_bitfield;
compiler__Fn compiler__EmptyFn;
compiler__Fn compiler__MainFn;
string compiler__dot_ptr;
string compiler__Version;
array_string compiler__supported_platforms;
#define compiler__compiler__Pass_imports 0
#define compiler__compiler__Pass_decl 1
#define compiler__compiler__Pass_main 2
string compiler__v_modules_path;
compiler__RegKey compiler__HKEY_LOCAL_MACHINE;
int compiler__KEY_QUERY_VALUE;
int compiler__KEY_WOW64_32KEY;
int compiler__KEY_ENUMERATE_SUB_KEYS;
#define compiler__compiler__NameCategory_constant 0
#define compiler__compiler__NameCategory_mod 1
#define compiler__compiler__NameCategory_var 2
#define compiler__compiler__NameCategory_typ 3
#define compiler__compiler__AccessMod_private 0
#define compiler__compiler__AccessMod_private_mut 1
#define compiler__compiler__AccessMod_public 2
#define compiler__compiler__AccessMod_public_mut 3
#define compiler__compiler__AccessMod_global 4
#define compiler__compiler__TypeCategory_builtin 0
#define compiler__compiler__TypeCategory_struct_ 1
#define compiler__compiler__TypeCategory_func 2
#define compiler__compiler__TypeCategory_interface_ 3
#define compiler__compiler__TypeCategory_enum_ 4
#define compiler__compiler__TypeCategory_union_ 5
#define compiler__compiler__TypeCategory_c_struct 6
#define compiler__compiler__TypeCategory_c_typedef 7
#define compiler__compiler__TypeCategory_objc_interface 8
#define compiler__compiler__TypeCategory_array 9
#define compiler__compiler__TypeCategory_alias 10
array_string compiler__c_reserved;
array_string compiler__integer_types;
array_string compiler__float_types;
array_string compiler__reserved_type_param_names;
array_string compiler__pointer_types;
array_string compiler__builtin_types;
#define compiler__compiler__TokenKind_eof 0
#define compiler__compiler__TokenKind_name 1
#define compiler__compiler__TokenKind_number 2
#define compiler__compiler__TokenKind_string 3
#define compiler__compiler__TokenKind_str_inter 4
#define compiler__compiler__TokenKind_chartoken 5
#define compiler__compiler__TokenKind_plus 6
#define compiler__compiler__TokenKind_minus 7
#define compiler__compiler__TokenKind_mul 8
#define compiler__compiler__TokenKind_div 9
#define compiler__compiler__TokenKind_mod 10
#define compiler__compiler__TokenKind_xor 11
#define compiler__compiler__TokenKind_pipe 12
#define compiler__compiler__TokenKind_inc 13
#define compiler__compiler__TokenKind_dec 14
#define compiler__compiler__TokenKind_and 15
#define compiler__compiler__TokenKind_logical_or 16
#define compiler__compiler__TokenKind_not 17
#define compiler__compiler__TokenKind_bit_not 18
#define compiler__compiler__TokenKind_question 19
#define compiler__compiler__TokenKind_comma 20
#define compiler__compiler__TokenKind_semicolon 21
#define compiler__compiler__TokenKind_colon 22
#define compiler__compiler__TokenKind_arrow 23
#define compiler__compiler__TokenKind_left_arrow 24
#define compiler__compiler__TokenKind_amp 25
#define compiler__compiler__TokenKind_hash 26
#define compiler__compiler__TokenKind_dollar 27
#define compiler__compiler__TokenKind_str_dollar 28
#define compiler__compiler__TokenKind_left_shift 29
#define compiler__compiler__TokenKind_righ_shift 30
#define compiler__compiler__TokenKind_assign 31
#define compiler__compiler__TokenKind_decl_assign 32
#define compiler__compiler__TokenKind_plus_assign 33
#define compiler__compiler__TokenKind_minus_assign 34
#define compiler__compiler__TokenKind_div_assign 35
#define compiler__compiler__TokenKind_mult_assign 36
#define compiler__compiler__TokenKind_xor_assign 37
#define compiler__compiler__TokenKind_mod_assign 38
#define compiler__compiler__TokenKind_or_assign 39
#define compiler__compiler__TokenKind_and_assign 40
#define compiler__compiler__TokenKind_righ_shift_assign 41
#define compiler__compiler__TokenKind_left_shift_assign 42
#define compiler__compiler__TokenKind_lcbr 43
#define compiler__compiler__TokenKind_rcbr 44
#define compiler__compiler__TokenKind_lpar 45
#define compiler__compiler__TokenKind_rpar 46
#define compiler__compiler__TokenKind_lsbr 47
#define compiler__compiler__TokenKind_rsbr 48
#define compiler__compiler__TokenKind_eq 49
#define compiler__compiler__TokenKind_ne 50
#define compiler__compiler__TokenKind_gt 51
#define compiler__compiler__TokenKind_lt 52
#define compiler__compiler__TokenKind_ge 53
#define compiler__compiler__TokenKind_le 54
#define compiler__compiler__TokenKind_line_comment 55
#define compiler__compiler__TokenKind_mline_comment 56
#define compiler__compiler__TokenKind_nl 57
#define compiler__compiler__TokenKind_dot 58
#define compiler__compiler__TokenKind_dotdot 59
#define compiler__compiler__TokenKind_ellipsis 60
#define compiler__compiler__TokenKind_keyword_beg 61
#define compiler__compiler__TokenKind_key_as 62
#define compiler__compiler__TokenKind_key_asm 63
#define compiler__compiler__TokenKind_key_assert 64
#define compiler__compiler__TokenKind_key_atomic 65
#define compiler__compiler__TokenKind_key_break 66
#define compiler__compiler__TokenKind_key_const 67
#define compiler__compiler__TokenKind_key_continue 68
#define compiler__compiler__TokenKind_key_defer 69
#define compiler__compiler__TokenKind_key_else 70
#define compiler__compiler__TokenKind_key_embed 71
#define compiler__compiler__TokenKind_key_enum 72
#define compiler__compiler__TokenKind_key_false 73
#define compiler__compiler__TokenKind_key_for 74
#define compiler__compiler__TokenKind_key_fn 75
#define compiler__compiler__TokenKind_key_global 76
#define compiler__compiler__TokenKind_key_go 77
#define compiler__compiler__TokenKind_key_goto 78
#define compiler__compiler__TokenKind_key_if 79
#define compiler__compiler__TokenKind_key_import 80
#define compiler__compiler__TokenKind_key_import_const 81
#define compiler__compiler__TokenKind_key_in 82
#define compiler__compiler__TokenKind_key_interface 83
#define compiler__compiler__TokenKind_key_match 84
#define compiler__compiler__TokenKind_key_module 85
#define compiler__compiler__TokenKind_key_mut 86
#define compiler__compiler__TokenKind_key_none 87
#define compiler__compiler__TokenKind_key_return 88
#define compiler__compiler__TokenKind_key_select 89
#define compiler__compiler__TokenKind_key_sizeof 90
#define compiler__compiler__TokenKind_key_offsetof 91
#define compiler__compiler__TokenKind_key_nameof 92
#define compiler__compiler__TokenKind_key_struct 93
#define compiler__compiler__TokenKind_key_switch 94
#define compiler__compiler__TokenKind_key_true 95
#define compiler__compiler__TokenKind_key_type 96
#define compiler__compiler__TokenKind_key_typeof 97
#define compiler__compiler__TokenKind_key_orelse 98
#define compiler__compiler__TokenKind_key_union 99
#define compiler__compiler__TokenKind_key_pub 100
#define compiler__compiler__TokenKind_key_static 101
#define compiler__compiler__TokenKind_key_unsafe 102
#define compiler__compiler__TokenKind_keyword_end 103
array_string compiler__TokenStr;
map_int compiler__KEYWORDS;
array_compiler__TokenKind compiler__AssignTokens;
array_string compiler__MOD_FILE_STOP_PATHS;
array_string main__list_of_flags;
array_string main__simple_cmd;
typedef struct thread_arg_sync__process_in_thread {
  sync__PoolProcessor *pool;
  int task_id;
} thread_arg_sync__process_in_thread;
DWORD WINAPI sync__process_in_thread_thread_wrapper(
    thread_arg_sync__process_in_thread *arg) {
  sync__process_in_thread(/*f*/ arg->pool, arg->task_id);
  return 0;
}

array new_array(int mylen, int cap, int elm_size) {
  int cap_ = ((cap == 0) ? (1) : (cap));
  array arr = (array){.len = mylen,
                      .cap = cap_,
                      .element_size = elm_size,
                      .data = vcalloc(cap_ * elm_size)};
  return arr;
}
array make(int len, int cap, int elm_size) {
  return new_array(len, cap, elm_size);
}
array new_array_from_c_array(int len, int cap, int elm_size, void *c_array) {
  int cap_ = ((cap == 0) ? (1) : (cap));
  array arr = (array){.len = len,
                      .cap = cap,
                      .element_size = elm_size,
                      .data = vcalloc(cap_ * elm_size)};
  memcpy(arr.data, c_array, len * elm_size);
  return arr;
}
array new_array_from_c_array_no_alloc(int len, int cap, int elm_size,
                                      void *c_array) {
  array arr = (array){
      .len = len, .cap = cap, .element_size = elm_size, .data = c_array};
  return arr;
}
void array_ensure_cap(array *a, int required) {
  if (required <= a->cap) {

    return;
  };
  int cap = ((a->cap == 0) ? (2) : (a->cap * 2));
  while (required > cap) {

    cap *= 2;
  };
  if (a->cap == 0) {
    a->data = vcalloc(cap * a->element_size);
  } else {
    a->data = realloc(a->data, cap * a->element_size);
  };
  a->cap = cap;
}
array array_repeat(array a, int count) {
  if (count < 0) {
    v_panic(_STR("array.repeat: count is negative: %d", count));
  };
  int size = count * a.len * a.element_size;
  if (size == 0) {
    size = a.element_size;
  };
  array arr = (array){.len = count * a.len,
                      .cap = count * a.len,
                      .element_size = a.element_size,
                      .data = vcalloc(size)};
  int tmp1 = 0;
  ;
  for (int tmp2 = tmp1; tmp2 < count; tmp2++) {
    int i = tmp2;

    memcpy((byte *)arr.data + i * a.len * a.element_size, a.data,
           a.len * a.element_size);
  };
  return arr;
}
void array_sort_with_compare(array *a, void *compare) {
  qsort(a->data, a->len, a->element_size, compare);
}
void array_insert(array *a, int i, void *val) {
#ifndef CUSTOM_DEFINE_no_bounds_checking
  if (i < 0 || i > a->len) {
    v_panic(_STR("array.insert: index out of range (i == %d, a.len == %d)", i,
                 a->len));
  };
#endif
  ;
  array_ensure_cap(a, a->len + 1);
  int size = a->element_size;
  memmove((byte *)a->data + (i + 1) * size, (byte *)a->data + i * size,
          (a->len - i) * size);
  memcpy((byte *)a->data + i * size, val, size);
  a->len++;
}
void array_prepend(array *a, void *val) { array_insert(a, 0, val); }
void v_array_delete(array *a, int i) {
#ifndef CUSTOM_DEFINE_no_bounds_checking
  if (i < 0 || i >= a->len) {
    v_panic(_STR("array.delete: index out of range (i == %d, a.len == %d)", i,
                 a->len));
  };
#endif
  ;
  int size = a->element_size;
  memmove((byte *)a->data + i * size, (byte *)a->data + (i + 1) * size,
          (a->len - i) * size);
  a->len--;
}
void array_clear(array *a) { a->len = 0; }
void array_trim(array *a, int index) {
  if (index < a->len) {
    a->len = index;
  };
}
void *array_get(array a, int i) {
#ifndef CUSTOM_DEFINE_no_bounds_checking
  if (i < 0 || i >= a.len) {
    v_panic(
        _STR("array.get: index out of range (i == %d, a.len == %d)", i, a.len));
  };
#endif
  ;
  return (byte *)a.data + i * a.element_size;
}
void *array_first(array a) {
#ifndef CUSTOM_DEFINE_no_bounds_checking
  if (a.len == 0) {
    v_panic(tos3("array.first: array is empty"));
  };
#endif
  ;
  return (byte *)a.data + 0;
}
void *array_last(array a) {
#ifndef CUSTOM_DEFINE_no_bounds_checking
  if (a.len == 0) {
    v_panic(tos3("array.last: array is empty"));
  };
#endif
  ;
  return (byte *)a.data + (a.len - 1) * a.element_size;
}
array array_slice(array a, int start, int _end) {
  int end = _end;
#ifndef CUSTOM_DEFINE_no_bounds_checking
  if (start > end) {
    v_panic(_STR("array.slice: invalid slice index (%d > %d)", start, end));
  };
  if (end > a.len) {
    v_panic(
        _STR("array.slice: slice bounds out of range (%d >= %d)", end, a.len));
  };
  if (start < 0) {
    v_panic(_STR("array.slice: slice bounds out of range (%d < 0)", start));
  };
#endif
  ;
  int l = end - start;
  array res = (array){.element_size = a.element_size,
                      .data = (byte *)a.data + start * a.element_size,
                      .len = l,
                      .cap = l};
  return res;
}
array array_slice2(array a, int start, int _end, bool end_max) {
  int end = ((end_max) ? (a.len) : (_end));
  return array_slice(a, start, end);
}
array array_clone(array *a) {
  int size = a->cap * a->element_size;
  if (size == 0) {
    size++;
  };
  array arr = (array){.len = a->len,
                      .cap = a->cap,
                      .element_size = a->element_size,
                      .data = vcalloc(size)};
  memcpy(arr.data, a->data, a->cap * a->element_size);
  return arr;
}
array array_slice_clone(array *a, int start, int _end) {
  int end = _end;
#ifndef CUSTOM_DEFINE_no_bounds_checking
  if (start > end) {
    v_panic(_STR("array.slice: invalid slice index (%d > %d)", start, end));
  };
  if (end > a->len) {
    v_panic(
        _STR("array.slice: slice bounds out of range (%d >= %d)", end, a->len));
  };
  if (start < 0) {
    v_panic(_STR("array.slice: slice bounds out of range (%d < 0)", start));
  };
#endif
  ;
  int l = end - start;
  array res = (array){.element_size = a->element_size,
                      .data = (byte *)a->data + start * a->element_size,
                      .len = l,
                      .cap = l};
  return array_clone(&/* ? */ res);
}
void array_set(array *a, int i, void *val) {
#ifndef CUSTOM_DEFINE_no_bounds_checking
  if (i < 0 || i >= a->len) {
    v_panic(_STR("array.set: index out of range (i == %d, a.len == %d)", i,
                 a->len));
  };
#endif
  ;
  memcpy((byte *)a->data + a->element_size * i, val, a->element_size);
}
void array_push(array *a, void *val) {
  array_ensure_cap(a, a->len + 1);
  memcpy((byte *)a->data + a->element_size * a->len, val, a->element_size);
  a->len++;
}
void array_push_many(array *a3, void *val, int size) {
  if (a3->data == val) {
    array copy = array_clone(&/* ? */ *a3);
    array_ensure_cap(a3, a3->len + size);
    memcpy((byte *)a3->data + a3->element_size * a3->len, copy.data,
           a3->element_size * size);
  } else {
    array_ensure_cap(a3, a3->len + size);
    memcpy((byte *)a3->data + a3->element_size * a3->len, val,
           a3->element_size * size);
  };
  a3->len += size;
}
array array_reverse(array a) {
  if (a.len < 2) {
    return a;
  };
  array arr = (array){.len = a.len,
                      .cap = a.cap,
                      .element_size = a.element_size,
                      .data = vcalloc(a.cap * a.element_size)};
  int tmp3 = 0;
  ;
  for (int tmp4 = tmp3; tmp4 < a.len; tmp4++) {
    int i = tmp4;

    memcpy((byte *)arr.data + i * arr.element_size,
           &(*(array *)array_get(a, a.len - 1 - i)), arr.element_size);
  };
  return arr;
}
void v_array_free(array a) { free(a.data); }
string array_string_str(array_string a) {
  strings__Builder sb = strings__new_builder(a.len * 3);
  strings__Builder_write(&/* ? */ sb, tos3("["));
  int tmp7 = 0;
  ;
  for (int tmp8 = tmp7; tmp8 < a.len; tmp8++) {
    int i = tmp8;

    string val = (*(string *)array_get(a, i));
    strings__Builder_write(&/* ? */ sb, tos3("\""));
    strings__Builder_write(&/* ? */ sb, val);
    strings__Builder_write(&/* ? */ sb, tos3("\""));
    if (i < a.len - 1) {
      strings__Builder_write(&/* ? */ sb, tos3(", "));
    };
  };
  strings__Builder_write(&/* ? */ sb, tos3("]"));
  return strings__Builder_str(&/* ? */ sb);
}
string array_int_str(array_int a) {
  strings__Builder sb = strings__new_builder(a.len * 13);
  strings__Builder_write(&/* ? */ sb, tos3("["));
  int tmp11 = 0;
  ;
  for (int tmp12 = tmp11; tmp12 < a.len; tmp12++) {
    int i = tmp12;

    strings__Builder_write(&/* ? */ sb, int_str((*(int *)array_get(a, i))));
    if (i < a.len - 1) {
      strings__Builder_write(&/* ? */ sb, tos3(", "));
    };
  };
  strings__Builder_write(&/* ? */ sb, tos3("]"));
  return strings__Builder_str(&/* ? */ sb);
}
string array_bool_str(array_bool a) {
  strings__Builder sb = strings__new_builder(a.len * 3);
  strings__Builder_write(&/* ? */ sb, tos3("["));
  int tmp15 = 0;
  ;
  for (int tmp16 = tmp15; tmp16 < a.len; tmp16++) {
    int i = tmp16;

    bool val = (*(bool *)array_get(a, i));
    if (val) {
      strings__Builder_write(&/* ? */ sb, tos3("true"));
    } else {
      strings__Builder_write(&/* ? */ sb, tos3("false"));
    };
    if (i < a.len - 1) {
      strings__Builder_write(&/* ? */ sb, tos3(", "));
    };
  };
  strings__Builder_write(&/* ? */ sb, tos3("]"));
  return strings__Builder_str(&/* ? */ sb);
}
string array_byte_hex(array_byte b) {
  byte *hex = v_malloc(b.len * 2 + 1);
  int dst_i = 0;
  array_byte tmp19 = b;
  for (int tmp20 = 0; tmp20 < tmp19.len; tmp20++) {
    byte i = ((byte *)tmp19.data)[tmp20];

    byte n0 = i >> 4;
    hex[/*ptr!*/ dst_i++] /*rbyte 1*/ = ((n0 < 10) ? (n0 + '0') : (n0 + 87));
    byte n1 = i & 0xF;
    hex[/*ptr!*/ dst_i++] /*rbyte 1*/ = ((n1 < 10) ? (n1 + '0') : (n1 + 87));
  };
  hex[/*ptr!*/ dst_i] /*rbyte 1*/ = '\0';
  return tos(hex, dst_i);
}
int copy(array_byte dst, array_byte src) {
  if (dst.len > 0 && src.len > 0) {
    int min = 0;
    min = ((dst.len < src.len) ? (dst.len) : (src.len));
    memcpy(dst.data, array_slice2(src, 0, min, false).data,
           dst.element_size * min);
    return min;
  };
  return 0;
}
int compare_ints(int *a, int *b) {
  if (*a < *b) {
    return -1;
  };
  if (*a > *b) {
    return 1;
  };
  return 0;
}
void array_int_sort(array_int *a) {
  array_sort_with_compare(
      a, &/*112 e="void*" g="fn (int*,int*) int" */ compare_ints);
}
int array_string_index(array_string a, string v) {
  int tmp23 = 0;
  ;
  for (int tmp24 = tmp23; tmp24 < a.len; tmp24++) {
    int i = tmp24;

    if (string_eq((*(string *)array_get(a, i)), v)) {
      return i;
    };
  };
  return -1;
}
int array_int_index(array_int a, int v) {
  int tmp27 = 0;
  ;
  for (int tmp28 = tmp27; tmp28 < a.len; tmp28++) {
    int i = tmp28;

    if ((*(int *)array_get(a, i)) == v) {
      return i;
    };
  };
  return -1;
}
int array_byte_index(array_byte a, byte v) {
  int tmp31 = 0;
  ;
  for (int tmp32 = tmp31; tmp32 < a.len; tmp32++) {
    int i = tmp32;

    if ((*(byte *)array_get(a, i)) == v) {
      return i;
    };
  };
  return -1;
}
int array_char_index(array_char a, char v) {
  int tmp35 = 0;
  ;
  for (int tmp36 = tmp35; tmp36 < a.len; tmp36++) {
    int i = tmp36;

    if ((*(char *)array_get(a, i)) == v) {
      return i;
    };
  };
  return -1;
}
int array_int_reduce(array_int a, int (*iter)(int accum, int curr /*FFF*/),
                     int accum_start) {
  int _accum = accum_start;
  array_int tmp39 = a;
  for (int tmp40 = 0; tmp40 < tmp39.len; tmp40++) {
    int i = ((int *)tmp39.data)[tmp40];

    _accum = iter(_accum, i);
  };
  return _accum;
}
bool array_string_eq(array_string a1, array_string a2) {
  if (a1.len != a2.len) {
    return 0;
  };
  int tmp41 = 0;
  ;
  for (int tmp42 = tmp41; tmp42 < a1.len; tmp42++) {
    int i = tmp42;

    if (string_ne((*(string *)array_get(a1, i)),
                  (*(string *)array_get(a2, i)))) {
      return 0;
    };
  };
  return 1;
}
int compare_i64(i64 *a, i64 *b) {
  if (*a < *b) {
    return -1;
  };
  if (*a > *b) {
    return 1;
  };
  return 0;
}
int compare_f64(f64 *a, f64 *b) {
  if (macro_f64_lt(*a, *b)) {
    return -1;
  };
  if (macro_f64_gt(*a, *b)) {
    return 1;
  };
  return 0;
}
int compare_f32(f32 *a, f32 *b) {
  if (macro_f32_lt(*a, *b)) {
    return -1;
  };
  if (macro_f32_gt(*a, *b)) {
    return 1;
  };
  return 0;
}
array_voidptr array_pointers(array a) {
  array_ptr_void res = new_array_from_c_array(
      0, 0, sizeof(void *), EMPTY_ARRAY_OF_ELEMS(void *, 0){TCCSKIP(0)});
  int tmp47 = 0;
  ;
  for (int tmp48 = tmp47; tmp48 < a.len; tmp48++) {
    int i = tmp48;

    _PUSH(&res,
          (/*typ = array_ptr_void   tmp_typ=void**/ (byte *)a.data +
           i * a.element_size),
          tmp49, void *);
  };
  return res;
}
void builtin__init() {
#ifdef _WIN32
  if (is_atty(1) > 0) {
    SetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE),
                   ENABLE_PROCESSED_OUTPUT | 0x0004);
    setbuf(stdout, 0);
  };
#endif
  ;
}
void v_exit(int code) { exit(code); }
bool isnil(void *v) { return v == 0; }
void print_backtrace_skipping_top_frames(int skipframes) {
#ifdef _WIN32
#ifdef _MSC_VER
  if (print_backtrace_skipping_top_frames_msvc(skipframes)) {

    return;
  };
#endif
  ;
#ifdef __MINGW32__
  if (print_backtrace_skipping_top_frames_mingw(skipframes)) {

    return;
  };
#endif
  ;
#else
  if (print_backtrace_skipping_top_frames_nix(skipframes)) {

    return;
  };
#endif
  ;
  println(tos3("print_backtrace_skipping_top_frames is not implemented on this "
               "platform for now...\n"));
}
void print_backtrace() { print_backtrace_skipping_top_frames(2); }
void panic_debug(int line_no, string file, string mod, string fn_name,
                 string s) {
  println(tos3("================ V panic ================"));
  printf("   module: %.*s\n", mod.len, mod.str);
  printf(" function: %.*s()\n", fn_name.len, fn_name.str);
  printf("     file: %.*s\n", file.len, file.str);
  println(string_add(tos3("     line: "), int_str(line_no)));
  printf("  message: %.*s\n", s.len, s.str);
  println(tos3("========================================="));
  print_backtrace_skipping_top_frames(1);
  exit(1);
}
void v_panic(string s) {
  printf("V panic: %.*s\n", s.len, s.str);
  print_backtrace();
  exit(1);
}
void eprintln(string s) {
  if (isnil(s.str)) {
    v_panic(tos3("eprintln(NIL)"));
  };
#ifndef _WIN32
#endif
  ;
  println(s);
}
void eprint(string s) {
  if (isnil(s.str)) {
    v_panic(tos3("eprint(NIL)"));
  };
#ifndef _WIN32
#endif
  ;
  print(s);
}
void print(string s) {
#ifdef _WIN32
  void *output_handle = GetStdHandle(STD_OUTPUT_HANDLE);
  int bytes_written = 0;
  if (is_atty(1) > 0) {
    u16 *wide_str = string_to_wide(s);
    int wide_len = wcslen(wide_str);
    WriteConsole(output_handle, wide_str, wide_len, &bytes_written, 0);
  } else {
    WriteFile(output_handle, (char *)s.str, s.len, &bytes_written, 0);
  };
#else
  printf("%.*s", s.len, (char *)s.str);
#endif
  ;
}
void looo() {}
byte *v_malloc(int n) {
  if (n <= 0) {
    v_panic(tos3("malloc(<=0)"));
  };
#ifdef VPREALLOC
  byte *res = g_m2_ptr;
  g_m2_ptr += n;
  nr_mallocs++;
  return res;
#else
  byte *ptr = malloc(n);
  if (ptr == 0) {
    v_panic(_STR("malloc(%d) failed", n));
  };
  return ptr;
#endif
  ;
}
byte *v_calloc(int n) { return calloc(n, 1); }
byte *vcalloc(int n) {
  if (n <= 0) {
    v_panic(tos3("calloc(<=0)"));
  };
  return calloc(n, 1);
}
void v_free(void *ptr) { free(ptr); }
void *memdup(void *src, int sz) {
  byte *mem = v_malloc(sz);
  return memcpy((char *)mem, src, sz);
}
void v_ptr_free(void *ptr) { free(ptr); }
int is_atty(int fd) {
#ifdef _WIN32
  u32 mode = ((u32)(0));
  voidptr osfh = ((voidptr)(_get_osfhandle(fd)));
  GetConsoleMode(osfh, ((voidptr)(&mode)));
  return ((int)(mode));
#else
  return isatty(fd);
#endif
  ;
}
bool print_backtrace_skipping_top_frames_msvc(int skipframes) {
#ifdef _MSC_VER
  u64 offset = ((u64)(0));
  void *backtraces[100];
  SymbolInfoContainer sic = (SymbolInfoContainer){EMPTY_STRUCT_INITIALIZATION};
  SymbolInfo *si = &sic.syminfo;
  si->f_size_of_struct = sizeof(SymbolInfo);
  si->f_max_name_len = sizeof(SymbolInfoContainer) - sizeof(SymbolInfo) - 1;
  charptr fname = ((charptr)(&si->f_name));
  Line64 sline64 = (Line64){.f_size_of_struct = 0,
                            .f_key = 0,
                            .f_line_number = 0,
                            .f_file_name = 0,
                            .f_address = 0};
  sline64.f_size_of_struct = sizeof(Line64);
  void *handle = GetCurrentProcess();
  u32 options =
      SymSetOptions(builtin__SYMOPT_DEBUG | builtin__SYMOPT_LOAD_LINES |
                    builtin__SYMOPT_UNDNAME);
  int syminitok = SymInitialize(handle, 0, 1);
  if (syminitok != 1) {
    println(tos3("Failed getting process: Aborting backtrace.\n"));
    bool tmp1 = 1;
    { SymCleanup(handle); }
    return tmp1;
    ;
  };
  int frames =
      ((int)(CaptureStackBackTrace(skipframes + 1, 100, backtraces, 0)));
  for (int i = 0; i < frames; i++) {

    voidptr *s =
        ((voidptr *)(((u64)(backtraces)) + ((u64)(i * sizeof(void *)))));
    int symfa_ok = SymFromAddr(handle, *s, &offset, si);
    if (symfa_ok == 1) {
      int nframe = frames - i - 1;
      string lineinfo = tos3("");
      int symglfa_ok = SymGetLineFromAddr64(handle, *s, &offset, &sline64);
      if (symglfa_ok == 1) {
        lineinfo = _STR(" %s:%u", sline64.f_file_name, sline64.f_line_number);
      } else {
        lineinfo = _STR(" ?? : address= %p", s);
      };
      string sfunc = tos3(fname);
      printf("%-2d: %-25s  %.*s\n", nframe, sfunc.str, lineinfo.len,
             lineinfo.str);
    } else {
      int cerr = ((int)(GetLastError()));
      if ((cerr == 87)) {
        printf("SymFromAddr failure: %d = The parameter is incorrect)\n", cerr);
      } else if ((cerr == 487)) {
        printf("SymFromAddr failure: %d = Attempt to access invalid address "
               "(Verify that you have the .pdb file in the right folder.)\n",
               cerr);
      } else {
        printf("SymFromAddr failure: %d (see "
               "https://docs.microsoft.com/en-us/windows/win32/debug/"
               "system-error-codes)\n",
               cerr);
      };
    };
  };
  bool tmp2 = 1;
  { SymCleanup(handle); }
  return tmp2;
  ;
  {
    SymCleanup(handle);
  }
#else
  println(tos3("TODO: Not implemented on Windows without msvc."));
  return 0;
#endif
  ;
}
bool print_backtrace_skipping_top_frames_mingw(int skipframes) {
  printf("TODO: print_backtrace_skipping_top_frames_mingw(%d)\n", skipframes);
  return 0;
}
bool print_backtrace_skipping_top_frames_nix(int skipframes) {
  println(tos3("not implemented, see builtin_nix.v"));
  return 0;
}
void println(string s) { print(_STR("%.*s\n", s.len, s.str)); }
int backtrace(void *a, int b);
byteptr *backtrace_symbols(void *, int);
void backtrace_symbols_fd(void *, int, int);
int proc_pidpath(int, void *, int);
static inline string f64_str(f64 d) { return strconv_dot_ftoa__ftoa_64(d); }
static inline string f64_strsci(f64 x, int digit_num) {
  int n_digit = digit_num;
  if (n_digit < 1) {
    n_digit = 1;
  } else if (n_digit > 17) {
    n_digit = 17;
  };
  return strconv_dot_ftoa__f64_to_str(x, n_digit);
}
static inline string f64_strlong(f64 x) {
  return strconv_dot_ftoa__f64_to_str_l(x);
}
static inline string f32_str(f32 d) { return strconv_dot_ftoa__ftoa_32(d); }
static inline string f32_strsci(f32 x, int digit_num) {
  int n_digit = digit_num;
  if (n_digit < 1) {
    n_digit = 1;
  } else if (n_digit > 8) {
    n_digit = 8;
  };
  return strconv_dot_ftoa__f32_to_str(x, n_digit);
}
static inline string f32_strlong(f32 x) {
  return strconv_dot_ftoa__f32_to_str_l(x);
}
static inline f32 f32_abs(f32 a) { return ((a < 0) ? (-a) : (a)); }
static inline f64 f64_abs(f64 a) { return ((a < 0) ? (-a) : (a)); }
static inline bool f64_eq(f64 a, f64 b) {
  return f64_abs(a - b) <= DBL_EPSILON;
}
static inline bool f32_eq(f32 a, f32 b) {
  return f32_abs(a - b) <= FLT_EPSILON;
}
bool f64_eqbit(f64 a, f64 b) { return DEFAULT_EQUAL(a, b); }
bool f32_eqbit(f32 a, f32 b) { return DEFAULT_EQUAL(a, b); }
bool f64_ne(f64 a, f64 b) { return !f64_eq(a, b); }
bool f32_ne(f32 a, f32 b) { return !f32_eq(a, b); }
bool f64_nebit(f64 a, f64 b) { return DEFAULT_NOT_EQUAL(a, b); }
bool f32_nebit(f32 a, f32 b) { return DEFAULT_NOT_EQUAL(a, b); }
bool f64_lt(f64 a, f64 b) { return f64_ne(a, b) && f64_ltbit(a, b); }
bool f32_lt(f32 a, f32 b) { return f32_ne(a, b) && f32_ltbit(a, b); }
bool f64_ltbit(f64 a, f64 b) { return DEFAULT_LT(a, b); }
bool f32_ltbit(f32 a, f32 b) { return DEFAULT_LT(a, b); }
bool f64_le(f64 a, f64 b) { return !f64_gt(a, b); }
bool f32_le(f32 a, f32 b) { return !f32_gt(a, b); }
bool f64_lebit(f64 a, f64 b) { return DEFAULT_LE(a, b); }
bool f32_lebit(f32 a, f32 b) { return DEFAULT_LE(a, b); }
bool f64_gt(f64 a, f64 b) { return f64_ne(a, b) && f64_gtbit(a, b); }
bool f32_gt(f32 a, f32 b) { return f32_ne(a, b) && f32_gtbit(a, b); }
bool f64_gtbit(f64 a, f64 b) { return DEFAULT_GT(a, b); }
bool f32_gtbit(f32 a, f32 b) { return DEFAULT_GT(a, b); }
bool f64_ge(f64 a, f64 b) { return !f64_lt(a, b); }
bool f32_ge(f32 a, f32 b) { return !f32_lt(a, b); }
bool f64_gebit(f64 a, f64 b) { return DEFAULT_GE(a, b); }
bool f32_gebit(f32 a, f32 b) { return DEFAULT_GE(a, b); }
string ptr_str(void *ptr) {
  string buf1 = u64_hex(((u64)(ptr)));
  return buf1;
}
static inline string int_str_l(int nn, int max) {
  int n = nn;
  int d = 0;
  if (n == 0) {
    return tos3("0");
  };
  byte *buf = v_malloc(max + 1);
  bool is_neg = 0;
  if (n < 0) {
    n = -n;
    is_neg = 1;
  };
  int index = max;
  buf[/*ptr!*/ index--] /*rbyte 1*/ = '\0';
  while (n > 0) {

    int n1 = n / 100;
    d = ((n - (n1 * 100)) << 1);
    n = n1;
    buf[/*ptr!*/ index--] /*rbyte 1*/ =
        builtin__digit_pairs.str[d++] /*rbyte 0*/;
    buf[/*ptr!*/ index--] /*rbyte 1*/ = builtin__digit_pairs.str[d] /*rbyte 0*/;
  };
  index++;
  if (d < 20) {
    index++;
  };
  if (is_neg) {
    index--;
    buf[/*ptr!*/ index] /*rbyte 1*/ = '-';
  };
  return tos((byte *)buf + index, (max - index));
}
string i8_str(i8 n) { return int_str_l(((int)(n)), 5); }
string i16_str(i16 n) { return int_str_l(((int)(n)), 7); }
string u16_str(u16 n) { return int_str_l(((int)(n)), 7); }
string int_str(int n) { return int_str_l(n, 12); }
string u32_str(u32 nn) {
  u32 n = nn;
  u32 d = ((u32)(0));
  if (n == 0) {
    return tos3("0");
  };
  int max = 12;
  byte *buf = v_malloc(max + 1);
  int index = max;
  buf[/*ptr!*/ index--] /*rbyte 1*/ = '\0';
  while (n > 0) {

    u32 n1 = n / ((u32)(100));
    d = ((n - (n1 * ((u32)(100)))) << ((u32)(1)));
    n = n1;
    buf[/*ptr!*/ index--] /*rbyte 1*/ =
        builtin__digit_pairs.str[d++] /*rbyte 0*/;
    buf[/*ptr!*/ index--] /*rbyte 1*/ = builtin__digit_pairs.str[d] /*rbyte 0*/;
  };
  index++;
  if (d < ((u32)(20))) {
    index++;
  };
  return tos((byte *)buf + index, (max - index));
}
string i64_str(i64 nn) {
  i64 n = nn;
  i64 d = ((i64)(0));
  if (n == 0) {
    return tos3("0");
  };
  int max = 20;
  byte *buf = vcalloc(max + 1);
  bool is_neg = 0;
  if (n < 0) {
    n = -n;
    is_neg = 1;
  };
  int index = max;
  buf[/*ptr!*/ index--] /*rbyte 1*/ = '\0';
  while (n > 0) {

    i64 n1 = n / ((i64)(100));
    d = ((n - (n1 * ((i64)(100)))) << ((i64)(1)));
    n = n1;
    buf[/*ptr!*/ index--] /*rbyte 1*/ =
        builtin__digit_pairs.str[d++] /*rbyte 0*/;
    buf[/*ptr!*/ index--] /*rbyte 1*/ = builtin__digit_pairs.str[d] /*rbyte 0*/;
  };
  index++;
  if (d < ((i64)(20))) {
    index++;
  };
  if (is_neg) {
    index--;
    buf[/*ptr!*/ index] /*rbyte 1*/ = '-';
  };
  return tos((byte *)buf + index, (max - index));
}
string u64_str(u64 nn) {
  u64 n = nn;
  int d = 0;
  if (n == 0) {
    return tos3("0");
  };
  int max = 20;
  byte *buf = vcalloc(max + 1);
  int index = max;
  buf[/*ptr!*/ index--] /*rbyte 1*/ = '\0';
  while (n > 0) {

    u64 n1 = n / 100;
    d = ((n - (n1 * 100)) << 1);
    n = n1;
    buf[/*ptr!*/ index--] /*rbyte 1*/ =
        builtin__digit_pairs.str[d++] /*rbyte 0*/;
    buf[/*ptr!*/ index--] /*rbyte 1*/ = builtin__digit_pairs.str[d] /*rbyte 0*/;
  };
  index++;
  if (d < 20) {
    index++;
  };
  return tos((byte *)buf + index, (max - index));
}
string bool_str(bool b) {
  if (b) {
    return tos3("true");
  };
  return tos3("false");
}
string int_hex(int nn) {
  u32 n = ((u32)(nn));
  int max = 10;
  byte *buf = v_malloc(max + 1);
  int index = max;
  buf[/*ptr!*/ index--] /*rbyte 1*/ = '\0';
  while (n > 0) {

    u32 d = n & 0xF;
    n = n >> 4;
    buf[/*ptr!*/ index--] /*rbyte 1*/ = ((d < 10) ? (d + '0') : (d + 87));
  };
  index++;
  return tos((byte *)buf + index, (max - index));
}
string u64_hex(u64 nn) {
  u64 n = nn;
  int max = 18;
  byte *buf = v_malloc(max + 1);
  int index = max;
  buf[/*ptr!*/ index--] /*rbyte 1*/ = '\0';
  while (n > 0) {

    u64 d = n & 0xF;
    n = n >> 4;
    buf[/*ptr!*/ index--] /*rbyte 1*/ = ((d < 10) ? (d + '0') : (d + 87));
  };
  index++;
  return tos((byte *)buf + index, (max - index));
}
string i64_hex(i64 nn) {
  u64 n = ((u64)(nn));
  return u64_hex(n);
}
bool array_byte_contains(array_byte a, byte val) {
  array_byte tmp1 = a;
  for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
    byte aa = ((byte *)tmp1.data)[tmp2];

    if (aa == val) {
      return 1;
    };
  };
  return 0;
}
string rune_str(rune c) {
  int fst_byte = ((int)(c)) >> 8 * 3 & 0xff;
  int len = utf8_char_len(fst_byte);
  string str = (string){.len = len, .str = v_malloc(len + 1)};
  int tmp3 = 0;
  ;
  for (int tmp4 = tmp3; tmp4 < len; tmp4++) {
    int i = tmp4;

    str.str[/*ptr!*/ i] /*rbyte 1*/ = ((int)(c)) >> 8 * (3 - i) & 0xff;
  };
  str.str[/*ptr!*/ len] /*rbyte 1*/ = '\0';
  return str;
}
string byte_str(byte c) {
  string str = (string){.len = 1, .str = v_malloc(2)};
  str.str[/*ptr!*/ 0] /*rbyte 1*/ = c;
  str.str[/*ptr!*/ 1] /*rbyte 1*/ = '\0';
  return str;
}
bool byte_is_capital(byte c) { return c >= 'A' && c <= 'Z'; }
array_byte array_byte_clone(array_byte b) {
  array_byte res = array_repeat(
      new_array_from_c_array(1, 1, sizeof(byte),
                             EMPTY_ARRAY_OF_ELEMS(byte, 1){((byte)(0))}),
      b.len);
  int tmp5 = 0;
  ;
  for (int tmp6 = tmp5; tmp6 < b.len; tmp6++) {
    int i = tmp6;

    array_set(&/*q*/ res, i, &(byte[]){(*(byte *)array_get(b, i))});
  };
  return res;
}
static inline DenseArray new_dense_array() {
  {
    return (DenseArray){.data = ((KeyValue *)(v_malloc(8 * sizeof(KeyValue)))),
                        .cap = 8,
                        .size = 0};
  };
}
static inline u32 DenseArray_push(DenseArray *d, KeyValue kv) {
  if (d->cap == d->size) {
    d->cap += d->cap >> 3;
    d->data = ((KeyValue *)(realloc(d->data, sizeof(KeyValue) * d->cap)));
  };
  u32 push_index = d->size;
  d->data[/*ptr!*/ push_index] /*rKeyValue 1*/ = kv;
  d->size++;
  return push_index;
}
void DenseArray_zeros_to_end(DenseArray *d) {
  u32 count = ((u32)(0));
  int tmp1 = 0;
  ;
  for (int tmp2 = tmp1; tmp2 < d->size; tmp2++) {
    int i = tmp2;

    if (d->data[/*ptr!*/ i] /*rKeyValue 1*/.key.str != 0) {
      KeyValue tmp = d->data[/*ptr!*/ count] /*rKeyValue 1*/;
      d->data[/*ptr!*/ count] /*rKeyValue 1*/ =
          d->data[/*ptr!*/ i] /*rKeyValue 1*/;
      d->data[/*ptr!*/ i] /*rKeyValue 1*/ = tmp;
      count++;
    };
  };
  d->size = count;
  d->cap = ((count < 8) ? (8) : (count));
  d->data = ((KeyValue *)(realloc(d->data, sizeof(KeyValue) * d->cap)));
}
map new_map(int n, int value_bytes) {
  return (map){.value_bytes = value_bytes,
               .cap = builtin__init_cap,
               .window = builtin__cached_hashbits,
               .shift = builtin__init_log_capicity,
               .key_values = new_dense_array(),
               .metas =
                   ((u32 *)(vcalloc(sizeof(u32) * (builtin__init_capicity +
                                                   builtin__extra_metas_inc)))),
               .max_load_factor = builtin__init_max_load_factor,
               .extra_metas = builtin__extra_metas_inc,
               .size = 0};
}
map new_map_init(int n, int value_bytes, string *keys, void *values) {
  map out = new_map(n, value_bytes);
  int tmp3 = 0;
  ;
  for (int tmp4 = tmp3; tmp4 < n; tmp4++) {
    int i = tmp4;

    map_set(&/* ? */ out, keys[/*ptr!*/ i] /*rstring 0*/,
            (byte *)values + i * value_bytes);
  };
  return out;
}
void map_set(map *m, string key, void *value) {
  if (macro_f32_gt((((f32)(m->size << 1)) / ((f32)(m->cap))),
                   m->max_load_factor)) {
    map_expand(m);
  };
  u64 hash = hash_dot_wyhash__wyhash_c(key.str, ((u64)(key.len)), 0);
  u32 meta =
      ((u32)(((hash >> m->shift) & builtin__hash_mask) | builtin__probe_inc));
  u64 index = hash & m->cap;
  while (meta < m->metas[/*ptr!*/ index] /*ru32 1*/) {

    index += 2;
    meta += builtin__probe_inc;
  };
  while (meta == m->metas[/*ptr!*/ index] /*ru32 1*/) {

    u32 kv_index = m->metas[/*ptr!*/ index + 1] /*ru32 1*/;
    if (string_eq(key,
                  m->key_values.data[/*ptr!*/ kv_index] /*rKeyValue 1*/.key)) {
      memcpy(m->key_values.data[/*ptr!*/ kv_index] /*rKeyValue 1*/.value, value,
             m->value_bytes);

      return;
    };
    index += 2;
    meta += builtin__probe_inc;
  };
  KeyValue kv = (KeyValue){.key = key, .value = v_malloc(m->value_bytes)};
  memcpy(kv.value, value, m->value_bytes);
  u32 kv_index = DenseArray_push(&/* ? */ m->key_values, kv);
  while (m->metas[/*ptr!*/ index] /*ru32 1*/ != 0) {

    if (meta > m->metas[/*ptr!*/ index] /*ru32 1*/) {
      u32 tmp_meta = m->metas[/*ptr!*/ index] /*ru32 1*/;
      m->metas[/*ptr!*/ index] /*ru32 1*/ = meta;
      meta = tmp_meta;
      u32 tmp_index = m->metas[/*ptr!*/ index + 1] /*ru32 1*/;
      m->metas[/*ptr!*/ index + 1] /*ru32 1*/ = kv_index;
      kv_index = tmp_index;
    };
    index += 2;
    meta += builtin__probe_inc;
  };
  u32 probe_count = (meta >> builtin__hashbits) - 1;
  if ((probe_count << 1) == m->extra_metas) {
    if ((meta & builtin__max_probe) == builtin__max_probe) {
      map_expand(m);
      map_set(m, kv.key, kv.value);

      return;
    };
    m->extra_metas += builtin__extra_metas_inc;
    u32 mem_size = (m->cap + 2 + m->extra_metas);
    m->metas = ((u32 *)(realloc(m->metas, sizeof(u32) * mem_size)));
    memset((u32 *)(u32 *)m->metas + mem_size - builtin__extra_metas_inc, 0,
           sizeof(u32) * builtin__extra_metas_inc);
  };
  m->metas[/*ptr!*/ index] /*ru32 1*/ = meta;
  m->metas[/*ptr!*/ index + 1] /*ru32 1*/ = kv_index;
  m->size++;
}
void map_expand(map *m) {
  u32 old_cap = m->cap;
  m->cap = ((m->cap + 2) << 1) - 2;
  if (m->window == 0) {
    m->shift += builtin__cached_hashbits;
    map_rehash(m);
    m->window = builtin__cached_hashbits;
  } else {
    map_cached_rehash(m, old_cap);
  };
  m->window--;
}
void map_shrink(map *m) {
  DenseArray_zeros_to_end(&/* ? */ m->key_values);
  m->cap = ((m->cap + 2) >> 1) - 2;
  if (m->window == 16) {
    m->shift -= builtin__cached_hashbits;
    m->window = 0;
  };
  map_rehash(m);
  m->window++;
}
void map_rehash(map *m) {
  int meta_bytes = sizeof(u32) * (m->cap + 2 + m->extra_metas);
  m->metas = ((u32 *)(realloc(m->metas, meta_bytes)));
  memset(m->metas, 0, meta_bytes);
  for (u32 i = ((u32)(0)); i < m->key_values.size; i++) {

    if (m->key_values.data[/*ptr!*/ i] /*rKeyValue 1*/.key.str == 0) {
      continue;
    };
    KeyValue kv = m->key_values.data[/*ptr!*/ i] /*rKeyValue 1*/;
    u64 hash = hash_dot_wyhash__wyhash_c(kv.key.str, ((u64)(kv.key.len)), 0);
    u32 meta =
        ((u32)(((hash >> m->shift) & builtin__hash_mask) | builtin__probe_inc));
    u64 index = hash & m->cap;
    while (meta < m->metas[/*ptr!*/ index] /*ru32 1*/) {

      index += 2;
      meta += builtin__probe_inc;
    };
    u32 kv_index = i;
    while (m->metas[/*ptr!*/ index] /*ru32 1*/ != 0) {

      if (meta > m->metas[/*ptr!*/ index] /*ru32 1*/) {
        u32 tmp_meta = m->metas[/*ptr!*/ index] /*ru32 1*/;
        m->metas[/*ptr!*/ index] /*ru32 1*/ = meta;
        meta = tmp_meta;
        u32 tmp_index = m->metas[/*ptr!*/ index + 1] /*ru32 1*/;
        m->metas[/*ptr!*/ index + 1] /*ru32 1*/ = kv_index;
        kv_index = tmp_index;
      };
      index += 2;
      meta += builtin__probe_inc;
    };
    u32 probe_count = (meta >> builtin__hashbits) - 1;
    if ((probe_count << 1) == m->extra_metas) {
      if ((meta & builtin__max_probe) == builtin__max_probe) {
        map_expand(m);

        return;
      };
      m->extra_metas += builtin__extra_metas_inc;
      u32 mem_size = (m->cap + 2 + m->extra_metas);
      m->metas = ((u32 *)(realloc(m->metas, sizeof(u32) * mem_size)));
      memset((u32 *)(u32 *)m->metas + mem_size - builtin__extra_metas_inc, 0,
             sizeof(u32) * builtin__extra_metas_inc);
    };
    m->metas[/*ptr!*/ index] /*ru32 1*/ = meta;
    m->metas[/*ptr!*/ index + 1] /*ru32 1*/ = kv_index;
  };
}
void map_cached_rehash(map *m, u32 old_cap) {
  u32 *new_meta =
      ((u32 *)(vcalloc(sizeof(u32) * (m->cap + 2 + m->extra_metas))));
  u32 old_extra_metas = m->extra_metas;
  for (int i = 0; i <= old_cap + old_extra_metas; i += 2) {

    if (m->metas[/*ptr!*/ i] /*ru32 1*/ == 0) {
      continue;
    };
    u32 old_meta = m->metas[/*ptr!*/ i] /*ru32 1*/;
    u64 old_probe_count = ((u64)((old_meta >> builtin__hashbits) - 1)) << 1;
    int old_index = (i - old_probe_count) & (m->cap >> 1);
    u64 index = ((u64)(old_index)) | (old_meta << m->shift) & m->cap;
    u32 meta = (old_meta & builtin__hash_mask) | builtin__probe_inc;
    while (meta < new_meta[/*ptr!*/ index] /*ru32 1*/) {

      index += 2;
      meta += builtin__probe_inc;
    };
    u32 kv_index = m->metas[/*ptr!*/ i + 1] /*ru32 1*/;
    while (new_meta[/*ptr!*/ index] /*ru32 1*/ != 0) {

      if (meta > new_meta[/*ptr!*/ index] /*ru32 1*/) {
        u32 tmp_meta = new_meta[/*ptr!*/ index] /*ru32 1*/;
        new_meta[/*ptr!*/ index] /*ru32 1*/ = meta;
        meta = tmp_meta;
        u32 tmp_index = new_meta[/*ptr!*/ index + 1] /*ru32 1*/;
        new_meta[/*ptr!*/ index + 1] /*ru32 1*/ = kv_index;
        kv_index = tmp_index;
      };
      index += 2;
      meta += builtin__probe_inc;
    };
    u32 probe_count = (meta >> builtin__hashbits) - 1;
    if ((probe_count << 1) == m->extra_metas) {
      if ((meta & builtin__max_probe) == builtin__max_probe) {
        v_free(new_meta);
        map_expand(m);

        return;
      };
      m->extra_metas += builtin__extra_metas_inc;
      u32 mem_size = (m->cap + 2 + m->extra_metas);
      new_meta = ((u32 *)(realloc(new_meta, sizeof(u32) * mem_size)));
      memset((u32 *)(u32 *)new_meta + mem_size - builtin__extra_metas_inc, 0,
             sizeof(u32) * builtin__extra_metas_inc);
    };
    new_meta[/*ptr!*/ index] /*ru32 1*/ = meta;
    new_meta[/*ptr!*/ index + 1] /*ru32 1*/ = kv_index;
  };
  { v_free(m->metas); };
  m->metas = new_meta;
}
static inline bool map_get(map m, string key, void *out) {
  u64 hash = hash_dot_wyhash__wyhash_c(key.str, ((u64)(key.len)), 0);
  u64 index = hash & m.cap;
  u32 meta =
      ((u32)(((hash >> m.shift) & builtin__hash_mask) | builtin__probe_inc));
  while (meta < m.metas[/*ptr!*/ index] /*ru32 0*/) {

    index += 2;
    meta += builtin__probe_inc;
  };
  while (meta == m.metas[/*ptr!*/ index] /*ru32 0*/) {

    u32 kv_index = m.metas[/*ptr!*/ index + 1] /*ru32 0*/;
    if (string_eq(key,
                  m.key_values.data[/*ptr!*/ kv_index] /*rKeyValue 0*/.key)) {
      memcpy(out, m.key_values.data[/*ptr!*/ kv_index] /*rKeyValue 0*/.value,
             m.value_bytes);
      return 1;
    };
    index += 2;
    meta += builtin__probe_inc;
  };
  return 0;
}
static inline bool map_exists(map m, string key) {
  if (m.value_bytes == 0) {
    return 0;
  };
  u64 hash = hash_dot_wyhash__wyhash_c(key.str, ((u64)(key.len)), 0);
  u64 index = hash & m.cap;
  u32 meta =
      ((u32)(((hash >> m.shift) & builtin__hash_mask) | builtin__probe_inc));
  while (meta < m.metas[/*ptr!*/ index] /*ru32 0*/) {

    index += 2;
    meta += builtin__probe_inc;
  };
  while (meta == m.metas[/*ptr!*/ index] /*ru32 0*/) {

    u32 kv_index = m.metas[/*ptr!*/ index + 1] /*ru32 0*/;
    if (string_eq(key,
                  m.key_values.data[/*ptr!*/ kv_index] /*rKeyValue 0*/.key)) {
      return 1;
    };
    index += 2;
    meta += builtin__probe_inc;
  };
  return 0;
}
void v_map_delete(map *m, string key) {
  u64 hash = hash_dot_wyhash__wyhash_c(key.str, ((u64)(key.len)), 0);
  u64 index = hash & m->cap;
  u32 meta =
      ((u32)(((hash >> m->shift) & builtin__hash_mask) | builtin__probe_inc));
  while (meta < m->metas[/*ptr!*/ index] /*ru32 1*/) {

    index += 2;
    meta += builtin__probe_inc;
  };
  while (meta == m->metas[/*ptr!*/ index] /*ru32 1*/) {

    u32 kv_index = m->metas[/*ptr!*/ index + 1] /*ru32 1*/;
    if (string_eq(key,
                  m->key_values.data[/*ptr!*/ kv_index] /*rKeyValue 1*/.key)) {
      memset(&m->key_values.data[/*ptr!*/ kv_index] /*rKeyValue 1*/, 0,
             sizeof(KeyValue));
      u64 old_index = index;
      index += 2;
      u32 cur_meta = m->metas[/*ptr!*/ index] /*ru32 1*/;
      u32 cur_index = m->metas[/*ptr!*/ index + 1] /*ru32 1*/;
      while ((cur_meta >> builtin__hashbits) > 1) {

        m->metas[/*ptr!*/ old_index] /*ru32 1*/ = cur_meta - builtin__probe_inc;
        m->metas[/*ptr!*/ old_index + 1] /*ru32 1*/ = cur_index;
        old_index = index;
        index += 2;
        cur_meta = m->metas[/*ptr!*/ index] /*ru32 1*/;
        cur_index = m->metas[/*ptr!*/ index + 1] /*ru32 1*/;
      };
      m->metas[/*ptr!*/ old_index] /*ru32 1*/ = 0;
      m->size--;
      if (m->cap == 30) {

        return;
      };
      if (macro_f32_lt((((f32)(m->size << 1)) / ((f32)(m->cap))),
                       builtin__min_load_factor)) {
        map_shrink(m);
      };

      return;
    };
    index += 2;
    meta += builtin__probe_inc;
  };
}
array_string map_keys(map *m) {
  array_string keys = array_repeat(
      new_array_from_c_array(1, 1, sizeof(string),
                             EMPTY_ARRAY_OF_ELEMS(string, 1){tos3("")}),
      m->size);
  if (m->value_bytes == 0) {
    return keys;
  };
  int j = 0;
  for (u32 i = ((u32)(0)); i < m->key_values.size; i++) {

    if (m->key_values.data[/*ptr!*/ i] /*rKeyValue 0*/.key.str == 0) {
      continue;
    };
    array_set(&/*q*/ keys, j,
              &(string[]){m->key_values.data[/*ptr!*/ i] /*rKeyValue 0*/.key});
    j++;
  };
  return keys;
}
void v_map_free(map m) {
  {
    v_free(m.metas);
    v_free(m.key_values.data);
  };
}
void map_print(map m) { println(tos3("TODO")); }
string map_string_str(map_string m) {
  if (m.size == 0) {
    return tos3("{}");
  };
  strings__Builder sb = strings__new_builder(50);
  strings__Builder_writeln(&/* ? */ sb, tos3("{"));
  map_string tmp5 = m;
  array_string keys_tmp5 = map_keys(&tmp5);
  for (int l = 0; l < keys_tmp5.len; l++) {
    string key = ((string *)keys_tmp5.data)[l];
    string val = tos3("");
    map_get(tmp5, key, &val);

    strings__Builder_writeln(
        &/* ? */ sb,
        _STR("  \"%.*s\" => \"%.*s\"", key.len, key.str, val.len, val.str));
  };
  strings__Builder_writeln(&/* ? */ sb, tos3("}"));
  return strings__Builder_str(&/* ? */ sb);
}
Option opt_ok(void *data, int size) {
  if (size >= 300) {
    v_panic(
        _STR("option size too big: %d (max is 300), this is a temporary limit",
             size));
  };
  Option res = (Option){.ok = 1, .error = tos3(""), .ecode = 0, .is_none = 0};
  memcpy(res.data, data, size);
  return res;
}
Option opt_none() {
  return (Option){
      .is_none = 1,
      .error = tos3(""),
      .ecode = 0,
      .ok = 0,
  };
}
Option v_error(string s) {
  return (Option){.error = s, .ecode = 0, .ok = 0, .is_none = 0};
}
Option error_with_code(string s, int code) {
  return (Option){.error = s, .ecode = code, .ok = 0, .is_none = 0};
}
SortedMap new_sorted_map(int n, int value_bytes) {
  return (SortedMap){.value_bytes = value_bytes, .root = new_node(), .size = 0};
}
SortedMap new_sorted_map_init(int n, int value_bytes, string *keys,
                              void *values) {
  SortedMap out = new_sorted_map(n, value_bytes);
  int tmp1 = 0;
  ;
  for (int tmp2 = tmp1; tmp2 < n; tmp2++) {
    int i = tmp2;

    SortedMap_set(&/* ? */ out, keys[/*ptr!*/ i] /*rstring 0*/,
                  (byte *)values + i * value_bytes);
  };
  return out;
}
mapnode *new_node() {
  return (mapnode *)memdup(
      &(mapnode){
          .children = 0,
          .size = 0,
      },
      sizeof(mapnode));
}
void SortedMap_set(SortedMap *m, string key, void *value) {
  mapnode *node = m->root;
  int child_index = 0;
  mapnode *parent = ((mapnode *)(0));
  while (1) {
    if (node->size == builtin__max_size) {
      if (isnil(parent)) {
        parent = new_node();
        m->root = parent;
      };
      mapnode_split_child(parent, child_index, node);
      if (string_eq(key, parent->keys[child_index] /*rstring 1*/)) {
        memcpy(parent->values[child_index] /*rvoidptr 1*/, value,
               m->value_bytes);

        return;
      };
      node = ((string_lt(key, parent->keys[child_index] /*rstring 1*/))
                  ? (((mapnode *)(parent->children
                                      [/*ptr!*/ child_index] /*rvoidptr 1*/)))
                  : (((mapnode *)(parent->children[/*ptr!*/ child_index +
                                                   1] /*rvoidptr 1*/))));
    };
    int i = 0;
    while (i < node->size && string_gt(key, node->keys[i] /*rstring 1*/)) {

      i++;
    };
    if (i != node->size && string_eq(key, node->keys[i] /*rstring 1*/)) {
      memcpy(node->values[i] /*rvoidptr 1*/, value, m->value_bytes);

      return;
    };
    if (isnil(node->children)) {
      int j = node->size - 1;
      while (j >= 0 && string_lt(key, node->keys[j] /*rstring 1*/)) {

        node->keys[j + 1] /*rstring 1*/ = node->keys[j] /*rstring 1*/;
        node->values[j + 1] /*rvoidptr 1*/ = node->values[j] /*rvoidptr 1*/;
        j--;
      };
      node->keys[j + 1] /*rstring 1*/ = key;
      node->values[j + 1] /*rvoidptr 1*/ = v_malloc(m->value_bytes);
      memcpy(node->values[j + 1] /*rvoidptr 1*/, value, m->value_bytes);
      node->size++;
      m->size++;

      return;
    };
    parent = node;
    child_index = i;
    node = ((mapnode *)(node->children[/*ptr!*/ child_index] /*rvoidptr 1*/));
  };
}
void mapnode_split_child(mapnode *n, int child_index, mapnode *y) {
  mapnode *z = new_node();
  z->size = builtin__mid_index;
  y->size = builtin__mid_index;
  for (int j = builtin__mid_index - 1; j >= 0; j--) {

    z->keys[j] /*rstring 1*/ = y->keys[j + builtin__degree] /*rstring 1*/;
    z->values[j] /*rvoidptr 1*/ = y->values[j + builtin__degree] /*rvoidptr 1*/;
  };
  if (!isnil(y->children)) {
    z->children = ((voidptr *)(v_malloc(builtin__children_bytes)));
    for (int jj = builtin__degree - 1; jj >= 0; jj--) {

      z->children[/*ptr!*/ jj] /*rvoidptr 1*/ =
          y->children[/*ptr!*/ jj + builtin__degree] /*rvoidptr 1*/;
    };
  };
  if (isnil(n->children)) {
    n->children = ((voidptr *)(v_malloc(builtin__children_bytes)));
  };
  n->children[/*ptr!*/ n->size + 1] /*rvoidptr 1*/ =
      n->children[/*ptr!*/ n->size] /*rvoidptr 1*/;
  for (int j = n->size; j > child_index; j--) {

    n->keys[j] /*rstring 1*/ = n->keys[j - 1] /*rstring 1*/;
    n->values[j] /*rvoidptr 1*/ = n->values[j - 1] /*rvoidptr 1*/;
    n->children[/*ptr!*/ j] /*rvoidptr 1*/ =
        n->children[/*ptr!*/ j - 1] /*rvoidptr 1*/;
  };
  n->keys[child_index] /*rstring 1*/ =
      y->keys[builtin__mid_index] /*rstring 1*/;
  n->values[child_index] /*rvoidptr 1*/ =
      y->values[builtin__mid_index] /*rvoidptr 1*/;
  n->children[/*ptr!*/ child_index] /*rvoidptr 1*/ = ((voidptr)(y));
  n->children[/*ptr!*/ child_index + 1] /*rvoidptr 1*/ = ((voidptr)(z));
  n->size++;
}
bool SortedMap_get(SortedMap m, string key, void *out) {
  mapnode *node = m.root;
  while (1) {
    int i = node->size - 1;
    while (i >= 0 && string_lt(key, node->keys[i] /*rstring 1*/)) {

      i--;
    };
    if (i != -1 && string_eq(key, node->keys[i] /*rstring 1*/)) {
      memcpy(out, node->values[i] /*rvoidptr 1*/, m.value_bytes);
      return 1;
    };
    if (isnil(node->children)) {
      break;
    };
    node = ((mapnode *)(node->children[/*ptr!*/ i + 1] /*rvoidptr 1*/));
  };
  return 0;
}
bool SortedMap_exists(SortedMap m, string key) {
  if (isnil(m.root)) {
    return 0;
  };
  mapnode *node = m.root;
  while (1) {
    int i = node->size - 1;
    while (i >= 0 && string_lt(key, node->keys[i] /*rstring 1*/)) {

      i--;
    };
    if (i != -1 && string_eq(key, node->keys[i] /*rstring 1*/)) {
      return 1;
    };
    if (isnil(node->children)) {
      break;
    };
    node = ((mapnode *)(node->children[/*ptr!*/ i + 1] /*rvoidptr 1*/));
  };
  return 0;
}
int mapnode_find_key(mapnode *n, string k) {
  int idx = 0;
  while (idx < n->size && string_lt(n->keys[idx] /*rstring 0*/, k)) {

    idx++;
  };
  return idx;
}
bool mapnode_remove_key(mapnode *n, string k) {
  int idx = mapnode_find_key(&/* ? */ *n, k);
  if (idx < n->size && string_eq(n->keys[idx] /*rstring 1*/, k)) {
    if (isnil(n->children)) {
      mapnode_remove_from_leaf(n, idx);
    } else {
      mapnode_remove_from_non_leaf(n, idx);
    };
    return 1;
  } else {
    if (isnil(n->children)) {
      return 0;
    };
    bool flag = ((idx == n->size) ? (1) : (0));
    if ((((mapnode *)(n->children[/*ptr!*/ idx] /*rvoidptr 1*/)))->size <
        builtin__degree) {
      mapnode_fill(n, idx);
    };
    if (flag && idx > n->size) {
      return mapnode_remove_key(
          (((mapnode *)(n->children[/*ptr!*/ idx - 1] /*rvoidptr 1*/))), k);
    } else {
      return mapnode_remove_key(
          (((mapnode *)(n->children[/*ptr!*/ idx] /*rvoidptr 1*/))), k);
    };
  };
}
void mapnode_remove_from_leaf(mapnode *n, int idx) {
  for (int i = idx + 1; i < n->size; i++) {

    n->keys[i - 1] /*rstring 1*/ = n->keys[i] /*rstring 1*/;
    n->values[i - 1] /*rvoidptr 1*/ = n->values[i] /*rvoidptr 1*/;
  };
  n->size--;
}
void mapnode_remove_from_non_leaf(mapnode *n, int idx) {
  string k = n->keys[idx] /*rstring 1*/;
  if (((mapnode *)(n->children[/*ptr!*/ idx] /*rvoidptr 1*/))->size >=
      builtin__degree) {
    mapnode *current = ((mapnode *)(n->children[/*ptr!*/ idx] /*rvoidptr 1*/));
    while (!isnil(current->children)) {

      current = ((
          mapnode *)(current->children[/*ptr!*/ current->size] /*rvoidptr 1*/));
    };
    string predecessor = current->keys[current->size - 1] /*rstring 1*/;
    n->keys[idx] /*rstring 1*/ = predecessor;
    n->values[idx] /*rvoidptr 1*/ =
        current->values[current->size - 1] /*rvoidptr 1*/;
    mapnode_remove_key(
        (((mapnode *)(n->children[/*ptr!*/ idx] /*rvoidptr 1*/))), predecessor);
  } else if (((mapnode *)(n->children[/*ptr!*/ idx + 1] /*rvoidptr 1*/))
                 ->size >= builtin__degree) {
    mapnode *current =
        ((mapnode *)(n->children[/*ptr!*/ idx + 1] /*rvoidptr 1*/));
    while (!isnil(current->children)) {

      current = ((mapnode *)(current->children[/*ptr!*/ 0] /*rvoidptr 1*/));
    };
    string successor = current->keys[0] /*rstring 1*/;
    n->keys[idx] /*rstring 1*/ = successor;
    n->values[idx] /*rvoidptr 1*/ = current->values[0] /*rvoidptr 1*/;
    mapnode_remove_key(
        (((mapnode *)(n->children[/*ptr!*/ idx + 1] /*rvoidptr 1*/))),
        successor);
  } else {
    mapnode_merge(n, idx);
    mapnode_remove_key(
        (((mapnode *)(n->children[/*ptr!*/ idx] /*rvoidptr 1*/))), k);
  };
}
void mapnode_fill(mapnode *n, int idx) {
  if (idx != 0 &&
      ((mapnode *)(n->children[/*ptr!*/ idx - 1] /*rvoidptr 1*/))->size >=
          builtin__degree) {
    mapnode_borrow_from_prev(n, idx);
  } else if (idx != n->size &&
             ((mapnode *)(n->children[/*ptr!*/ idx + 1] /*rvoidptr 1*/))
                     ->size >= builtin__degree) {
    mapnode_borrow_from_next(n, idx);
  } else if (idx != n->size) {
    mapnode_merge(n, idx);
  } else {
    mapnode_merge(n, idx - 1);
  };
}
void mapnode_borrow_from_prev(mapnode *n, int idx) {
  mapnode *child = ((mapnode *)(n->children[/*ptr!*/ idx] /*rvoidptr 1*/));
  mapnode *sibling =
      ((mapnode *)(n->children[/*ptr!*/ idx - 1] /*rvoidptr 1*/));
  for (int i = child->size - 1; i >= 0; i--) {

    child->keys[i + 1] /*rstring 1*/ = child->keys[i] /*rstring 1*/;
    child->values[i + 1] /*rvoidptr 1*/ = child->values[i] /*rvoidptr 1*/;
  };
  if (!isnil(child->children)) {
    for (int i = child->size; i >= 0; i--) {

      child->children[/*ptr!*/ i + 1] /*rvoidptr 1*/ =
          child->children[/*ptr!*/ i] /*rvoidptr 1*/;
    };
  };
  child->keys[0] /*rstring 1*/ = n->keys[idx - 1] /*rstring 1*/;
  child->values[0] /*rvoidptr 1*/ = n->values[idx - 1] /*rvoidptr 1*/;
  if (!isnil(child->children)) {
    child->children[/*ptr!*/ 0] /*rvoidptr 1*/ =
        sibling->children[/*ptr!*/ sibling->size] /*rvoidptr 1*/;
  };
  n->keys[idx - 1] /*rstring 1*/ =
      sibling->keys[sibling->size - 1] /*rstring 1*/;
  n->values[idx - 1] /*rvoidptr 1*/ =
      sibling->values[sibling->size - 1] /*rvoidptr 1*/;
  child->size++;
  sibling->size--;
}
void mapnode_borrow_from_next(mapnode *n, int idx) {
  mapnode *child = ((mapnode *)(n->children[/*ptr!*/ idx] /*rvoidptr 1*/));
  mapnode *sibling =
      ((mapnode *)(n->children[/*ptr!*/ idx + 1] /*rvoidptr 1*/));
  child->keys[child->size] /*rstring 1*/ = n->keys[idx] /*rstring 1*/;
  child->values[child->size] /*rvoidptr 1*/ = n->values[idx] /*rvoidptr 1*/;
  if (!isnil(child->children)) {
    child->children[/*ptr!*/ child->size + 1] /*rvoidptr 1*/ =
        sibling->children[/*ptr!*/ 0] /*rvoidptr 1*/;
  };
  n->keys[idx] /*rstring 1*/ = sibling->keys[0] /*rstring 1*/;
  n->values[idx] /*rvoidptr 1*/ = sibling->values[0] /*rvoidptr 1*/;
  for (int i = 1; i < sibling->size; i++) {

    sibling->keys[i - 1] /*rstring 1*/ = sibling->keys[i] /*rstring 1*/;
    sibling->values[i - 1] /*rvoidptr 1*/ = sibling->values[i] /*rvoidptr 1*/;
  };
  if (!isnil(sibling->children)) {
    for (int i = 1; i <= sibling->size; i++) {

      sibling->children[/*ptr!*/ i - 1] /*rvoidptr 1*/ =
          sibling->children[/*ptr!*/ i] /*rvoidptr 1*/;
    };
  };
  child->size++;
  sibling->size--;
}
void mapnode_merge(mapnode *n, int idx) {
  mapnode *child = ((mapnode *)(n->children[/*ptr!*/ idx] /*rvoidptr 1*/));
  mapnode *sibling =
      ((mapnode *)(n->children[/*ptr!*/ idx + 1] /*rvoidptr 1*/));
  child->keys[builtin__mid_index] /*rstring 1*/ = n->keys[idx] /*rstring 1*/;
  child->values[builtin__mid_index] /*rvoidptr 1*/ =
      n->values[idx] /*rvoidptr 1*/;
  int tmp3 = 0;
  ;
  for (int tmp4 = tmp3; tmp4 < sibling->size; tmp4++) {
    int i = tmp4;

    child->keys[i + builtin__degree] /*rstring 1*/ =
        sibling->keys[i] /*rstring 0*/;
    child->values[i + builtin__degree] /*rvoidptr 1*/ =
        sibling->values[i] /*rvoidptr 0*/;
  };
  if (!isnil(child->children)) {
    for (int i = 0; i <= sibling->size; i++) {

      child->children[/*ptr!*/ i + builtin__degree] /*rvoidptr 1*/ =
          sibling->children[/*ptr!*/ i] /*rvoidptr 0*/;
    };
  };
  for (int i = idx + 1; i < n->size; i++) {

    n->keys[i - 1] /*rstring 1*/ = n->keys[i] /*rstring 1*/;
    n->values[i - 1] /*rvoidptr 1*/ = n->values[i] /*rvoidptr 1*/;
  };
  for (int i = idx + 2; i <= n->size; i++) {

    n->children[/*ptr!*/ i - 1] /*rvoidptr 1*/ =
        n->children[/*ptr!*/ i] /*rvoidptr 1*/;
  };
  child->size += sibling->size + 1;
  n->size--;
}
void v_SortedMap_delete(SortedMap *m, string key) {
  if (m->root->size == 0) {

    return;
  };
  bool removed = mapnode_remove_key(m->root, key);
  if (removed) {
    m->size--;
  };
  if (m->root->size == 0) {
    if (isnil(m->root->children)) {

      return;
    } else {
      m->root = ((mapnode *)(m->root->children[/*ptr!*/ 0] /*rvoidptr 1*/));
    };
  };
}
int mapnode_subkeys(mapnode *n, array_string *keys, int at) {
  int position = at;
  if (!isnil(n->children)) {
    int tmp5 = 0;
    ;
    for (int tmp6 = tmp5; tmp6 < n->size; tmp6++) {
      int i = tmp6;

      mapnode *child = ((mapnode *)(n->children[/*ptr!*/ i] /*rvoidptr 0*/));
      position += mapnode_subkeys(&/* ? */ *child, keys, position);
      array_set(keys, position, &(string[]){n->keys[i] /*rstring 0*/});
      position++;
    };
    mapnode *child =
        ((mapnode *)(n->children[/*ptr!*/ n->size] /*rvoidptr 0*/));
    position += mapnode_subkeys(&/* ? */ *child, keys, position);
  } else {
    int tmp7 = 0;
    ;
    for (int tmp8 = tmp7; tmp8 < n->size; tmp8++) {
      int i = tmp8;

      array_set(keys, position + i, &(string[]){n->keys[i] /*rstring 0*/});
    };
    position += n->size;
  };
  return position - at;
}
array_string SortedMap_keys(SortedMap *m) {
  array_string keys = array_repeat(
      new_array_from_c_array(1, 1, sizeof(string),
                             EMPTY_ARRAY_OF_ELEMS(string, 1){tos3("")}),
      m->size);
  if (isnil(m->root) || m->root->size == 0) {
    return keys;
  };
  mapnode_subkeys(&/* ? */ *m->root, &/*111*/ (array[]){keys}[0], 0);
  return keys;
}
void v_mapnode_free(mapnode *n) { println(tos3("TODO")); }
void v_SortedMap_free(SortedMap *m) {
  if (isnil(m->root)) {

    return;
  };
  v_mapnode_free(m->root);
}
void SortedMap_print(SortedMap m) { println(tos3("TODO")); }
int vstrlen(byte *s) { return strlen(((charptr)(s))); }
string tos(byte *s, int len) {
  if (s == 0) {
    v_panic(tos3("tos(): nil string"));
  };
  return (string){.str = s, .len = len};
}
string tos_clone(byte *s) {
  if (s == 0) {
    v_panic(tos3("tos: nil string"));
  };
  return string_clone(tos2(s));
}
string tos2(byte *s) {
  if (s == 0) {
    v_panic(tos3("tos2: nil string"));
  };
  return (string){.str = s, .len = vstrlen(s)};
}
string tos3(charptr s) {
  if (s == 0) {
    v_panic(tos3("tos3: nil string"));
  };
  return (string){.str = ((byteptr)(s)), .len = strlen(s)};
}
string string_clone(string a) {
  string b = (string){.len = a.len, .str = v_malloc(a.len + 1)};
  int tmp1 = 0;
  ;
  for (int tmp2 = tmp1; tmp2 < a.len; tmp2++) {
    int i = tmp2;

    b.str[/*ptr!*/ i] /*rbyte 1*/ = a.str[/*ptr!*/ i] /*rbyte 0*/;
  };
  b.str[/*ptr!*/ a.len] /*rbyte 1*/ = '\0';
  return b;
}
string cstring_to_vstring(byte *cstr) {
  int slen = strlen((char *)cstr);
  byteptr s = ((byteptr)(memdup(cstr, slen + 1)));
  s[/*ptr!*/ slen] /*rbyteptr 1*/ = '\0';
  return tos(s, slen);
}
string string_replace_once(string s, string rep, string with) {
  Option_int tmp3 = string_index(s, rep);
  int index;
  if (!tmp3.ok) {
    string err = tmp3.error;
    int errcode = tmp3.ecode;
    return s;
  }
  index = *(int *)tmp3.data;
  ;
  return string_add(string_add(string_substr(s, 0, index), with),
                    string_substr(s, index + rep.len, s.len));
}
string string_replace(string s, string rep, string with) {
  if (s.len == 0 || rep.len == 0) {
    return s;
  };
  array_int idxs = new_array_from_c_array(
      0, 0, sizeof(int), EMPTY_ARRAY_OF_ELEMS(int, 0){TCCSKIP(0)});
  int idx = 0;
  while (1) {
    idx = string_index_after(s, rep, idx);
    if (idx == -1) {
      break;
    };
    _PUSH(&idxs, (/*typ = array_int   tmp_typ=int*/ idx), tmp4, int);
    idx += rep.len;
  };
  if (idxs.len == 0) {
    return s;
  };
  int new_len = s.len + idxs.len * (with.len - rep.len);
  byte *b = v_malloc(new_len + 1);
  int idx_pos = 0;
  int cur_idx = (*(int *)array_get(idxs, idx_pos));
  int b_i = 0;
  for (int i = 0; i < s.len; i++) {

    if (i == cur_idx) {
      int tmp7 = 0;
      ;
      for (int tmp8 = tmp7; tmp8 < with.len; tmp8++) {
        int j = tmp8;

        b[/*ptr!*/ b_i] /*rbyte 1*/ = with.str[j] /*rbyte 0*/;
        b_i++;
      };
      i += rep.len - 1;
      idx_pos++;
      if (idx_pos < idxs.len) {
        cur_idx = (*(int *)array_get(idxs, idx_pos));
      };
    } else {
      b[/*ptr!*/ b_i] /*rbyte 1*/ = s.str[i] /*rbyte 0*/;
      b_i++;
    };
  };
  b[/*ptr!*/ new_len] /*rbyte 1*/ = '\0';
  return tos(b, new_len);
}
int compare_rep_index(RepIndex *a, RepIndex *b) {
  if (a->idx < b->idx) {
    return -1;
  };
  if (a->idx > b->idx) {
    return 1;
  };
  return 0;
}
void array_RepIndex_sort(array_RepIndex *a) {
  array_sort_with_compare(
      a,
      &/*112 e="void*" g="fn (RepIndex*,RepIndex*) int" */ compare_rep_index);
}
string string_replace_each(string s, array_string vals) {
  if (s.len == 0 || vals.len == 0) {
    return s;
  };
  if (vals.len % 2 != 0) {
    println(tos3("string.replace_many(): odd number of strings"));
    return s;
  };
  int new_len = s.len;
  array_RepIndex idxs = new_array_from_c_array(
      0, 0, sizeof(RepIndex), EMPTY_ARRAY_OF_ELEMS(RepIndex, 0){TCCSKIP(0)});
  int idx = 0;
  for (int rep_i = 0; rep_i < vals.len; rep_i += 2) {

    string rep = (*(string *)array_get(vals, rep_i));
    string with = (*(string *)array_get(vals, rep_i + 1));
    while (1) {
      idx = string_index_after(s, rep, idx);
      if (idx == -1) {
        break;
      };
      _PUSH(&idxs,
            (/*typ = array_RepIndex   tmp_typ=RepIndex*/ (RepIndex){
                .idx = idx, .val_idx = rep_i}),
            tmp15, RepIndex);
      idx++;
      new_len += with.len - rep.len;
    };
  };
  if (idxs.len == 0) {
    return s;
  };
  array_RepIndex_sort(&/* ? */ idxs);
  byte *b = v_malloc(new_len + 1);
  int idx_pos = 0;
  RepIndex cur_idx = (*(RepIndex *)array_get(idxs, idx_pos));
  int b_i = 0;
  for (int i = 0; i < s.len; i++) {

    if (i == cur_idx.idx) {
      string rep = (*(string *)array_get(vals, cur_idx.val_idx));
      string with = (*(string *)array_get(vals, cur_idx.val_idx + 1));
      int tmp22 = 0;
      ;
      for (int tmp23 = tmp22; tmp23 < with.len; tmp23++) {
        int j = tmp23;

        b[/*ptr!*/ b_i] /*rbyte 1*/ = with.str[j] /*rbyte 0*/;
        b_i++;
      };
      i += rep.len - 1;
      idx_pos++;
      if (idx_pos < idxs.len) {
        cur_idx = (*(RepIndex *)array_get(idxs, idx_pos));
      };
    } else {
      b[/*ptr!*/ b_i] /*rbyte 1*/ = s.str[/*ptr!*/ i] /*rbyte 0*/;
      b_i++;
    };
  };
  b[/*ptr!*/ new_len] /*rbyte 1*/ = '\0';
  return tos(b, new_len);
}
bool string_bool(string s) {
  return string_eq(s, tos3("true")) || string_eq(s, tos3("t"));
}
int v_string_int(string s) {
  return ((int)(strconv__common_parse_int(s, 0, 32, 0, 0)));
}
i64 string_i64(string s) { return strconv__common_parse_int(s, 0, 64, 0, 0); }
i8 string_i8(string s) {
  return ((i8)(strconv__common_parse_int(s, 0, 8, 0, 0)));
}
i16 string_i16(string s) {
  return ((i16)(strconv__common_parse_int(s, 0, 16, 0, 0)));
}
f32 string_f32(string s) { return ((f32)(strconv__atof64(s))); }
f64 string_f64(string s) { return strconv__atof64(s); }
u16 string_u16(string s) {
  return ((u16)(strconv__common_parse_uint(s, 0, 16, 0, 0)));
}
u32 string_u32(string s) {
  return ((u32)(strconv__common_parse_uint(s, 0, 32, 0, 0)));
}
u64 string_u64(string s) { return strconv__common_parse_uint(s, 0, 64, 0, 0); }
bool string_eq(string s, string a) {
  if (isnil(s.str)) {
    v_panic(tos3("string.eq(): nil string"));
    return false;
    ;
  };
  if (s.len != a.len) {
    return 0;
  };
  int tmp26 = 0;
  ;
  for (int tmp27 = tmp26; tmp27 < s.len; tmp27++) {
    int i = tmp27;

    if (s.str[i] /*rbyte 0*/ != a.str[i] /*rbyte 0*/) {
      return 0;
    };
  };
  return 1;
}
bool string_ne(string s, string a) { return !string_eq(s, a); }
bool string_lt(string s, string a) {
  int tmp28 = 0;
  ;
  for (int tmp29 = tmp28; tmp29 < s.len; tmp29++) {
    int i = tmp29;

    if (i >= a.len || s.str[i] /*rbyte 0*/ > a.str[i] /*rbyte 0*/) {
      return 0;
    } else if (s.str[i] /*rbyte 0*/ < a.str[i] /*rbyte 0*/) {
      return 1;
    };
  };
  if (s.len < a.len) {
    return 1;
  };
  return 0;
}
bool string_le(string s, string a) {
  return string_lt(s, a) || string_eq(s, a);
}
bool string_gt(string s, string a) { return !string_le(s, a); }
bool string_ge(string s, string a) { return !string_lt(s, a); }
string string_add(string s, string a) {
  int new_len = a.len + s.len;
  string res = (string){.len = new_len, .str = v_malloc(new_len + 1)};
  int tmp30 = 0;
  ;
  for (int tmp31 = tmp30; tmp31 < s.len; tmp31++) {
    int j = tmp31;

    res.str[j] /*rbyte 1*/ = s.str[j] /*rbyte 0*/;
  };
  int tmp32 = 0;
  ;
  for (int tmp33 = tmp32; tmp33 < a.len; tmp33++) {
    int j = tmp33;

    res.str[s.len + j] /*rbyte 1*/ = a.str[j] /*rbyte 0*/;
  };
  res.str[/*ptr!*/ new_len] /*rbyte 1*/ = '\0';
  return res;
}
array_string string_split(string s, string delim) {
  return string_split_nth(s, delim, 0);
}
array_string string_split_nth(string s, string delim, int nth) {
  array_string res = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  int i = 0;
  if (delim.len == 0) {
    i = 1;
    string tmp34 = s;
    ;
    for (int tmp35 = 0; tmp35 < tmp34.len; tmp35++) {
      byte ch = tmp34.str[tmp35];

      if (nth > 0 && i >= nth) {
        _PUSH(&res,
              (/*typ = array_string   tmp_typ=string*/ string_substr(s, i,
                                                                     s.len)),
              tmp36, string);
        break;
      };
      _PUSH(&res, (/*typ = array_string   tmp_typ=string*/ byte_str(ch)), tmp37,
            string);
      i++;
    };
    return res;
  };
  int start = 0;
  int nth_1 = nth - 1;
  while (i <= s.len) {

    bool is_delim = s.str[i] /*rbyte 0*/ == delim.str[0] /*rbyte 0*/;
    int j = 0;
    while (is_delim && j < delim.len) {

      is_delim =
          is_delim && s.str[i + j] /*rbyte 0*/ == delim.str[j] /*rbyte 0*/;
      j++;
    };
    bool last = i == s.len - 1;
    if (is_delim || last) {
      if (!is_delim && last) {
        i++;
      };
      string val = string_substr(s, start, i);
      if (string_starts_with(val, delim)) {
        val = string_right(val, delim.len);
      };
      bool was_last = nth > 0 && res.len == nth_1;
      if (was_last) {
        _PUSH(&res,
              (/*typ = array_string   tmp_typ=string*/ string_right(s, start)),
              tmp38, string);
        break;
      };
      _PUSH(&res, (/*typ = array_string   tmp_typ=string*/ val), tmp39, string);
      start = i + delim.len;
    };
    i++;
  };
  if (string_ends_with(s, delim) && (nth < 1 || res.len < nth)) {
    _PUSH(&res, (/*typ = array_string   tmp_typ=string*/ tos3("")), tmp40,
          string);
  };
  return res;
}
array_string string_split_into_lines(string s) {
  array_string res = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  if (s.len == 0) {
    return res;
  };
  int start = 0;
  for (int i = 0; i < s.len; i++) {

    bool is_lf = s.str[i] /*rbyte 0*/ == '\n';
    bool is_crlf = i != s.len - 1 && s.str[i] /*rbyte 0*/ == '\r' &&
                   s.str[i + 1] /*rbyte 0*/ == '\n';
    bool is_eol = is_lf || is_crlf;
    bool is_last = ((is_crlf) ? (i == s.len - 2) : (i == s.len - 1));
    if (is_eol || is_last) {
      if (is_last && !is_eol) {
        i++;
      };
      string line = string_substr(s, start, i);
      _PUSH(&res, (/*typ = array_string   tmp_typ=string*/ line), tmp41,
            string);
      if (is_crlf) {
        i++;
      };
      start = i + 1;
    };
  };
  return res;
}
string string_left(string s, int n) {
  if (n >= s.len) {
    return s;
  };
  return string_substr(s, 0, n);
}
string string_right(string s, int n) {
  if (n >= s.len) {
    return tos3("");
  };
  return string_substr(s, n, s.len);
}
string string_substr2(string s, int start, int _end, bool end_max) {
  int end = ((end_max) ? (s.len) : (_end));
  return string_substr(s, start, end);
}
string string_substr(string s, int start, int end) {
#ifndef CUSTOM_DEFINE_no_bounds_checking
  if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
    v_panic(_STR("substr(%d, %d) out of bounds (len=%d)", start, end, s.len));
  };
#endif
  ;
  int len = end - start;
  string res = (string){.len = len, .str = v_malloc(len + 1)};
  int tmp42 = 0;
  ;
  for (int tmp43 = tmp42; tmp43 < len; tmp43++) {
    int i = tmp43;

    res.str[/*ptr!*/ i] /*rbyte 1*/ = s.str[/*ptr!*/ start + i] /*rbyte 0*/;
  };
  res.str[/*ptr!*/ len] /*rbyte 1*/ = '\0';
  return res;
}
int string_index_old(string s, string p) {
  if (p.len > s.len || p.len == 0) {
    return -1;
  };
  int i = 0;
  while (i < s.len) {

    int j = 0;
    while (j < p.len && s.str[i + j] /*rbyte 0*/ == p.str[j] /*rbyte 0*/) {

      j++;
    };
    if (j == p.len) {
      return i;
    };
    i++;
  };
  return -1;
}
Option_int string_index(string s, string p) {
  if (p.len > s.len || p.len == 0) {
    return opt_none();
  };
  int i = 0;
  while (i < s.len) {

    int j = 0;
    while (j < p.len && s.str[i + j] /*rbyte 0*/ == p.str[j] /*rbyte 0*/) {

      j++;
    };
    if (j == p.len) {
      int tmp44 = OPTION_CAST(int)(i);
      return opt_ok(&tmp44, sizeof(int));
    };
    i++;
  };
  return opt_none();
}
int string_index_kmp(string s, string p) {
  if (p.len > s.len) {
    return -1;
  };
  array_int prefix =
      array_repeat(new_array_from_c_array(1, 1, sizeof(int),
                                          EMPTY_ARRAY_OF_ELEMS(int, 1){0}),
                   p.len);
  int j = 0;
  for (int i = 1; i < p.len; i++) {

    while (p.str[j] /*rbyte 0*/ != p.str[i] /*rbyte 0*/ && j > 0) {

      j = (*(int *)array_get(prefix, j - 1));
    };
    if (p.str[j] /*rbyte 0*/ == p.str[i] /*rbyte 0*/) {
      j++;
    };
    array_set(&/*q*/ prefix, i, &(int[]){j});
  };
  j = 0;
  int tmp47 = 0;
  ;
  for (int tmp48 = tmp47; tmp48 < s.len; tmp48++) {
    int i = tmp48;

    while (p.str[j] /*rbyte 0*/ != s.str[i] /*rbyte 0*/ && j > 0) {

      j = (*(int *)array_get(prefix, j - 1));
    };
    if (p.str[j] /*rbyte 0*/ == s.str[i] /*rbyte 0*/) {
      j++;
    };
    if (j == p.len) {
      return i - p.len + 1;
    };
  };
  return -1;
}
int string_index_any(string s, string chars) {
  string tmp51 = chars;
  ;
  for (int tmp52 = 0; tmp52 < tmp51.len; tmp52++) {
    byte c = tmp51.str[tmp52];

    Option_int tmp53 = string_index(s, byte_str(c));
    int index;
    if (!tmp53.ok) {
      string err = tmp53.error;
      int errcode = tmp53.ecode;
      continue;
    }
    index = *(int *)tmp53.data;
    ;
    return index;
  };
  return -1;
}
Option_int string_last_index(string s, string p) {
  if (p.len > s.len || p.len == 0) {
    return opt_none();
  };
  int i = s.len - p.len;
  while (i >= 0) {

    int j = 0;
    while (j < p.len && s.str[i + j] /*rbyte 0*/ == p.str[j] /*rbyte 0*/) {

      j++;
    };
    if (j == p.len) {
      int tmp54 = OPTION_CAST(int)(i);
      return opt_ok(&tmp54, sizeof(int));
    };
    i--;
  };
  return opt_none();
}
int string_index_after(string s, string p, int start) {
  if (p.len > s.len) {
    return -1;
  };
  int strt = start;
  if (start < 0) {
    strt = 0;
  };
  if (start >= s.len) {
    return -1;
  };
  int i = strt;
  while (i < s.len) {

    int j = 0;
    int ii = i;
    while (j < p.len && s.str[ii] /*rbyte 0*/ == p.str[j] /*rbyte 0*/) {

      j++;
      ii++;
    };
    if (j == p.len) {
      return i;
    };
    i++;
  };
  return -1;
}
int string_index_byte(string s, byte c) {
  int tmp55 = 0;
  ;
  for (int tmp56 = tmp55; tmp56 < s.len; tmp56++) {
    int i = tmp56;

    if (s.str[i] /*rbyte 0*/ == c) {
      return i;
    };
  };
  return -1;
}
int string_last_index_byte(string s, byte c) {
  for (int i = s.len - 1; i >= 0; i--) {

    if (s.str[i] /*rbyte 0*/ == c) {
      return i;
    };
  };
  return -1;
}
int string_count(string s, string substr) {
  if (s.len == 0 || substr.len == 0) {
    return 0;
  };
  if (substr.len > s.len) {
    return 0;
  };
  int n = 0;
  int i = 0;
  while (1) {
    i = string_index_after(s, substr, i);
    if (i == -1) {
      return n;
    };
    i += substr.len;
    n++;
  };
  return 0;
}
bool string_contains(string s, string p) {
  Option_int tmp57 = string_index(s, p);
  if (!tmp57.ok) {
    string err = tmp57.error;
    int errcode = tmp57.ecode;
    return 0;
  };
  return 1;
}
bool string_starts_with(string s, string p) {
  if (p.len > s.len) {
    return 0;
  };
  int tmp58 = 0;
  ;
  for (int tmp59 = tmp58; tmp59 < p.len; tmp59++) {
    int i = tmp59;

    if (s.str[i] /*rbyte 0*/ != p.str[i] /*rbyte 0*/) {
      return 0;
    };
  };
  return 1;
}
bool string_ends_with(string s, string p) {
  if (p.len > s.len) {
    return 0;
  };
  int tmp60 = 0;
  ;
  for (int tmp61 = tmp60; tmp61 < p.len; tmp61++) {
    int i = tmp61;

    if (p.str[i] /*rbyte 0*/ != s.str[s.len - p.len + i] /*rbyte 0*/) {
      return 0;
    };
  };
  return 1;
}
string string_to_lower(string s) {
  byte *b = v_malloc(s.len + 1);
  int tmp62 = 0;
  ;
  for (int tmp63 = tmp62; tmp63 < s.len; tmp63++) {
    int i = tmp63;

    b[/*ptr!*/ i] /*rbyte 1*/ = tolower(s.str[/*ptr!*/ i] /*rbyte 0*/);
  };
  return tos(b, s.len);
}
string string_to_upper(string s) {
  byte *b = v_malloc(s.len + 1);
  int tmp64 = 0;
  ;
  for (int tmp65 = tmp64; tmp65 < s.len; tmp65++) {
    int i = tmp65;

    b[/*ptr!*/ i] /*rbyte 1*/ = toupper(s.str[/*ptr!*/ i] /*rbyte 0*/);
  };
  return tos(b, s.len);
}
string string_capitalize(string s) {
  if (s.len == 0) {
    return tos3("");
  };
  string sl = string_to_lower(s);
  string cap = string_add(string_to_upper(byte_str(sl.str[0] /*rbyte 0*/)),
                          string_right(sl, 1));
  return cap;
}
string string_title(string s) {
  array_string words = string_split(s, tos3(" "));
  array_string tit = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_string tmp66 = words;
  for (int tmp67 = 0; tmp67 < tmp66.len; tmp67++) {
    string word = ((string *)tmp66.data)[tmp67];

    _PUSH(&tit,
          (/*typ = array_string   tmp_typ=string*/ string_capitalize(word)),
          tmp68, string);
  };
  string title = array_string_join(tit, tos3(" "));
  return title;
}
string string_find_between(string s, string start, string end) {
  Option_int tmp69 = string_index(s, start);
  int start_pos;
  if (!tmp69.ok) {
    string err = tmp69.error;
    int errcode = tmp69.ecode;
    return tos3("");
  }
  start_pos = *(int *)tmp69.data;
  ;
  string val = string_right(s, start_pos + start.len);
  Option_int tmp70 = string_index(val, end);
  int end_pos;
  if (!tmp70.ok) {
    string err = tmp70.error;
    int errcode = tmp70.ecode;
    return val;
  }
  end_pos = *(int *)tmp70.data;
  ;
  return string_left(val, end_pos);
}
bool array_string_contains(array_string ar, string val) {
  array_string tmp71 = ar;
  for (int tmp72 = 0; tmp72 < tmp71.len; tmp72++) {
    string s = ((string *)tmp71.data)[tmp72];

    if (string_eq(s, val)) {
      return 1;
    };
  };
  return 0;
}
bool array_int_contains(array_int ar, int val) {
  array_int tmp73 = ar;
  for (int i = 0; i < tmp73.len; i++) {
    int s = ((int *)tmp73.data)[i];

    if (s == val) {
      return 1;
    };
  };
  return 0;
}
bool byte_is_space(byte c) {
  return (c == ' ' || c == '\n' || c == '\t' || c == '\v' || c == '\f' ||
          c == '\r' || c == 0x85 || c == 0xa0);
}
string string_trim_space(string s) {
  return string_trim(s, tos3(" \n\t\v\f\r"));
}
string string_trim(string s, string cutset) {
  if (s.len < 1 || cutset.len < 1) {
    return s;
  };
  array_byte cs_arr = string_bytes(cutset);
  int pos_left = 0;
  int pos_right = s.len - 1;
  bool cs_match = 1;
  while (pos_left <= s.len && pos_right >= -1 && cs_match) {

    cs_match = 0;
    if ((_IN(byte, (s.str[pos_left] /*rbyte 0*/), cs_arr))) {
      pos_left++;
      cs_match = 1;
    };
    if ((_IN(byte, (s.str[pos_right] /*rbyte 0*/), cs_arr))) {
      pos_right--;
      cs_match = 1;
    };
    if (pos_left > pos_right) {
      return tos3("");
    };
  };
  return string_substr(s, pos_left, pos_right + 1);
}
string string_trim_left(string s, string cutset) {
  if (s.len < 1 || cutset.len < 1) {
    return s;
  };
  array_byte cs_arr = string_bytes(cutset);
  int pos = 0;
  while (pos <= s.len && (_IN(byte, (s.str[pos] /*rbyte 0*/), cs_arr))) {

    pos++;
  };
  return string_right(s, pos);
}
string string_trim_right(string s, string cutset) {
  if (s.len < 1 || cutset.len < 1) {
    return s;
  };
  array_byte cs_arr = string_bytes(cutset);
  int pos = s.len - 1;
  while (pos >= -1 && (_IN(byte, (s.str[pos] /*rbyte 0*/), cs_arr))) {

    pos--;
  };
  return string_left(s, pos + 1);
}
int compare_strings(string *a, string *b) {
  if (string_lt(*a, *b)) {
    return -1;
  };
  if (string_gt(*a, *b)) {
    return 1;
  };
  return 0;
}
int compare_strings_by_len(string *a, string *b) {
  if (a->len < b->len) {
    return -1;
  };
  if (a->len > b->len) {
    return 1;
  };
  return 0;
}
int compare_lower_strings(string *a, string *b) {
  string aa = string_to_lower(*a);
  string bb = string_to_lower(*b);
  return compare_strings(&/*114*/ aa, &/*114*/ bb);
}
void array_string_sort(array_string *s) {
  array_sort_with_compare(
      s, &/*112 e="void*" g="fn (string*,string*) int" */ compare_strings);
}
void array_string_sort_ignore_case(array_string *s) {
  array_sort_with_compare(
      s,
      &/*112 e="void*" g="fn (string*,string*) int" */ compare_lower_strings);
}
void array_string_sort_by_len(array_string *s) {
  array_sort_with_compare(
      s,
      &/*112 e="void*" g="fn (string*,string*) int" */ compare_strings_by_len);
}
ustring string_ustring(string s) {
  ustring res =
      (ustring){.s = s, .runes = new_array(0, s.len, sizeof(int)), .len = 0};
  for (int i = 0; i < s.len; i++) {

    int char_len = utf8_char_len(s.str[/*ptr!*/ i] /*rbyte 0*/);
    _PUSH(&res.runes, (/*typ = array_int   tmp_typ=int*/ i), tmp74, int);
    i += char_len - 1;
    res.len++;
  };
  return res;
}
ustring string_ustring_tmp(string s) {
  if (g_ustring_runes.len == 0) {
    g_ustring_runes = new_array(0, 128, sizeof(int));
  };
  ustring res =
      (ustring){.s = s, .runes = new_array(0, 1, sizeof(int)), .len = 0};
  res.runes = g_ustring_runes;
  res.runes.len = s.len;
  int j = 0;
  for (int i = 0; i < s.len; i++) {

    int char_len = utf8_char_len(s.str[/*ptr!*/ i] /*rbyte 0*/);
    array_set(&/*q*/ res.runes, j, &(int[]){i});
    j++;
    i += char_len - 1;
    res.len++;
  };
  return res;
}
bool ustring_eq(ustring u, ustring a) {
  if (u.len != a.len || string_ne(u.s, a.s)) {
    return 0;
  };
  return 1;
}
bool ustring_ne(ustring u, ustring a) { return !ustring_eq(u, a); }
bool ustring_lt(ustring u, ustring a) { return string_lt(u.s, a.s); }
bool ustring_le(ustring u, ustring a) {
  return ustring_lt(u, a) || ustring_eq(u, a);
}
bool ustring_gt(ustring u, ustring a) { return !ustring_le(u, a); }
bool ustring_ge(ustring u, ustring a) { return !ustring_lt(u, a); }
ustring ustring_add(ustring u, ustring a) {
  ustring res = (ustring){.s = string_add(u.s, a.s),
                          .runes = new_array(0, u.s.len + a.s.len, sizeof(int)),
                          .len = 0};
  int j = 0;
  for (int i = 0; i < u.s.len; i++) {

    int char_len = utf8_char_len(u.s.str[/*ptr!*/ i] /*rbyte 0*/);
    _PUSH(&res.runes, (/*typ = array_int   tmp_typ=int*/ j), tmp75, int);
    i += char_len - 1;
    j += char_len;
    res.len++;
  };
  for (int i = 0; i < a.s.len; i++) {

    int char_len = utf8_char_len(a.s.str[/*ptr!*/ i] /*rbyte 0*/);
    _PUSH(&res.runes, (/*typ = array_int   tmp_typ=int*/ j), tmp76, int);
    i += char_len - 1;
    j += char_len;
    res.len++;
  };
  return res;
}
int ustring_index_after(ustring u, ustring p, int start) {
  if (p.len > u.len) {
    return -1;
  };
  int strt = start;
  if (start < 0) {
    strt = 0;
  };
  if (start > u.len) {
    return -1;
  };
  int i = strt;
  while (i < u.len) {

    int j = 0;
    int ii = i;
    while (j < p.len && string_eq(ustring_at(u, ii), ustring_at(p, j))) {

      j++;
      ii++;
    };
    if (j == p.len) {
      return i;
    };
    i++;
  };
  return -1;
}
int ustring_count(ustring u, ustring substr) {
  if (u.len == 0 || substr.len == 0) {
    return 0;
  };
  if (substr.len > u.len) {
    return 0;
  };
  int n = 0;
  int i = 0;
  while (1) {
    i = ustring_index_after(u, substr, i);
    if (i == -1) {
      return n;
    };
    i += substr.len;
    n++;
  };
  return 0;
}
string ustring_substr(ustring u, int _start, int _end) {
#ifndef CUSTOM_DEFINE_no_bounds_checking
  if (_start > _end || _start > u.len || _end > u.len || _start < 0 ||
      _end < 0) {
    v_panic(_STR("substr(%d, %d) out of bounds (len=%d)", _start, _end, u.len));
  };
#endif
  ;
  int end =
      ((_end >= u.len) ? (u.s.len) : ((*(int *)array_get(u.runes, _end))));
  return string_substr(u.s, (*(int *)array_get(u.runes, _start)), end);
}
string ustring_left(ustring u, int pos) {
  if (pos >= u.len) {
    return u.s;
  };
  return ustring_substr(u, 0, pos);
}
string ustring_right(ustring u, int pos) {
  if (pos >= u.len) {
    return tos3("");
  };
  return ustring_substr(u, pos, u.len);
}
byte string_at(string s, int idx) {
#ifndef CUSTOM_DEFINE_no_bounds_checking
  if (idx < 0 || idx >= s.len) {
    v_panic(_STR("string index out of range: %d / %d", idx, s.len));
  };
#endif
  ;
  return s.str[/*ptr!*/ idx] /*rbyte 0*/;
}
string ustring_at(ustring u, int idx) {
#ifndef CUSTOM_DEFINE_no_bounds_checking
  if (idx < 0 || idx >= u.len) {
    v_panic(_STR("string index out of range: %d / %d", idx, u.runes.len));
  };
#endif
  ;
  return ustring_substr(u, idx, idx + 1);
}
void v_ustring_free(ustring u) { v_array_free(u.runes); }
bool byte_is_digit(byte c) { return c >= '0' && c <= '9'; }
bool byte_is_hex_digit(byte c) {
  return byte_is_digit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
bool byte_is_oct_digit(byte c) { return c >= '0' && c <= '7'; }
bool byte_is_bin_digit(byte c) { return c == '0' || c == '1'; }
bool byte_is_letter(byte c) {
  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}
void v_string_free(string s) { v_free(s.str); }
string string_all_before(string s, string dot) {
  Option_int tmp81 = string_index(s, dot);
  int pos;
  if (!tmp81.ok) {
    string err = tmp81.error;
    int errcode = tmp81.ecode;
    return s;
  }
  pos = *(int *)tmp81.data;
  ;
  return string_left(s, pos);
}
string string_all_before_last(string s, string dot) {
  Option_int tmp82 = string_last_index(s, dot);
  int pos;
  if (!tmp82.ok) {
    string err = tmp82.error;
    int errcode = tmp82.ecode;
    return s;
  }
  pos = *(int *)tmp82.data;
  ;
  return string_left(s, pos);
}
string string_all_after(string s, string dot) {
  Option_int tmp83 = string_last_index(s, dot);
  int pos;
  if (!tmp83.ok) {
    string err = tmp83.error;
    int errcode = tmp83.ecode;
    return s;
  }
  pos = *(int *)tmp83.data;
  ;
  return string_right(s, pos + dot.len);
}
string string_after(string s, string dot) { return string_all_after(s, dot); }
string array_string_join(array_string a, string del) {
  if (a.len == 0) {
    return tos3("");
  };
  int len = 0;
  array_string tmp84 = a;
  for (int i = 0; i < tmp84.len; i++) {
    string val = ((string *)tmp84.data)[i];

    len += val.len + del.len;
  };
  len -= del.len;
  string res = tos3("");
  res.len = len;
  res.str = v_malloc(res.len + 1);
  int idx = 0;
  array_string tmp85 = a;
  for (int i = 0; i < tmp85.len; i++) {
    string val = ((string *)tmp85.data)[i];

    int tmp86 = 0;
    ;
    for (int tmp87 = tmp86; tmp87 < val.len; tmp87++) {
      int j = tmp87;

      byte c = val.str[j] /*rbyte 0*/;
      res.str[/*ptr!*/ idx] /*rbyte 1*/ = val.str[/*ptr!*/ j] /*rbyte 0*/;
      idx++;
    };
    if (i != a.len - 1) {
      int tmp88 = 0;
      ;
      for (int tmp89 = tmp88; tmp89 < del.len; tmp89++) {
        int k = tmp89;

        res.str[/*ptr!*/ idx] /*rbyte 1*/ = del.str[/*ptr!*/ k] /*rbyte 0*/;
        idx++;
      };
    };
  };
  res.str[/*ptr!*/ res.len] /*rbyte 1*/ = '\0';
  return res;
}
string array_string_join_lines(array_string s) {
  return array_string_join(s, tos3("\n"));
}
string string_reverse(string s) {
  if (s.len == 0 || s.len == 1) {
    return s;
  };
  string res = (string){.len = s.len, .str = v_malloc(s.len)};
  for (int i = s.len - 1; i >= 0; i--) {

    res.str[/*ptr!*/ s.len - i - 1] /*rbyte 1*/ = s.str[i] /*rbyte 0*/;
  };
  return res;
}
string string_limit(string s, int max) {
  ustring u = string_ustring(s);
  if (u.len <= max) {
    return s;
  };
  return ustring_substr(u, 0, max);
}
bool byte_is_white(byte c) {
  v_panic(tos3("Use `string.is_space` instead of `string.is_white"));
  return false;
  ;
}
int string_hash(string s) {
  int h = 0;
  if (h == 0 && s.len > 0) {
    string tmp90 = s;
    ;
    for (int tmp91 = 0; tmp91 < tmp90.len; tmp91++) {
      byte c = tmp90.str[tmp91];

      h = h * 31 + ((int)(c));
    };
  };
  return h;
}
array_byte string_bytes(string s) {
  if (s.len == 0) {
    return new_array_from_c_array(0, 0, sizeof(byte),
                                  EMPTY_ARRAY_OF_ELEMS(byte, 0){TCCSKIP(0)});
  };
  array_byte buf = array_repeat(
      new_array_from_c_array(1, 1, sizeof(byte),
                             EMPTY_ARRAY_OF_ELEMS(byte, 1){((byte)(0))}),
      s.len);
  memcpy(buf.data, (char *)s.str, s.len);
  return buf;
}
string string_repeat(string s, int count) {
  if (count < 0) {
    v_panic(_STR("string.repeat: count is negative: %d", count));
  } else if (count == 0) {
    return tos3("");
  } else if (count == 1) {
    return s;
  };
  byte *ret = v_malloc(s.len * count + 1);
  int tmp92 = 0;
  ;
  for (int tmp93 = tmp92; tmp93 < count; tmp93++) {
    int i = tmp93;

    int tmp94 = 0;
    ;
    for (int tmp95 = tmp94; tmp95 < s.len; tmp95++) {
      int j = tmp95;

      ret[/*ptr!*/ i * s.len + j] /*rbyte 1*/ = s.str[j] /*rbyte 0*/;
    };
  };
  ret[/*ptr!*/ s.len * count] /*rbyte 1*/ = 0;
  return (tos2((byte *)ret));
}
string string_strip_margin(string s, varg_byte *del) {
  byte sep = '|';
  if (del->len >= 1) {
    for (int tmp97 = 0; tmp97 < del->len; tmp97++) {
      byte d = ((byte *)del->args)[tmp97];

      if (byte_is_space(d)) {
        eprintln(tos3(
            "Warning: `strip_margin` cannot use white-space as a delimiter"));
        eprintln(tos3("    Defaulting to `|`"));
      } else {
        sep = d;
      };
      break;
    };
    if (del->len != 1) {
      eprintln(
          tos3("Warning: `strip_margin` only uses the first argument given"));
    };
  };
  byte *ret = v_malloc(s.len + 1);
  int count = 0;
  for (int i = 0; i < s.len; i++) {

    if (((s.str[i] /*rbyte 0*/ == '\n' || s.str[i] /*rbyte 0*/ == '\r'))) {
#ifdef _WIN32
      ret[/*ptr!*/ count] /*rbyte 1*/ = '\r';
      ret[/*ptr!*/ count + 1] /*rbyte 1*/ = '\n';
      count += 2;
#else
      ret[/*ptr!*/ count] /*rbyte 1*/ = s.str[i] /*rbyte 0*/;
      count++;
#endif
      ;
      while (s.str[i] /*rbyte 0*/ != sep) {

        i++;
        if (i >= s.len) {
          break;
        };
      };
    } else {
      ret[/*ptr!*/ count] /*rbyte 1*/ = s.str[i] /*rbyte 0*/;
      count++;
    };
  };
  ret[/*ptr!*/ count] /*rbyte 1*/ = 0;
  return (tos2((byte *)ret));
}
int utf8_char_len(byte b) {
  return ((0xe5000000 >> ((b >> 3) & 0x1e)) & 3) + 1;
}
string utf32_to_str(u32 code) {
  int icode = ((int)(code));
  byte *buffer = v_malloc(5);
  if (icode <= 127) {
    buffer[/*ptr!*/ 0] /*rbyte 1*/ = icode;
    return tos(buffer, 1);
  };
  if ((icode <= 2047)) {
    buffer[/*ptr!*/ 0] /*rbyte 1*/ = 192 | (icode >> 6);
    buffer[/*ptr!*/ 1] /*rbyte 1*/ = 128 | (icode & 63);
    return tos(buffer, 2);
  };
  if ((icode <= 65535)) {
    buffer[/*ptr!*/ 0] /*rbyte 1*/ = 224 | (icode >> 12);
    buffer[/*ptr!*/ 1] /*rbyte 1*/ = 128 | ((icode >> 6) & 63);
    buffer[/*ptr!*/ 2] /*rbyte 1*/ = 128 | (icode & 63);
    return tos(buffer, 3);
  };
  if ((icode <= 1114111)) {
    buffer[/*ptr!*/ 0] /*rbyte 1*/ = 240 | (icode >> 18);
    buffer[/*ptr!*/ 1] /*rbyte 1*/ = 128 | ((icode >> 12) & 63);
    buffer[/*ptr!*/ 2] /*rbyte 1*/ = 128 | ((icode >> 6) & 63);
    buffer[/*ptr!*/ 3] /*rbyte 1*/ = 128 | (icode & 63);
    return tos(buffer, 4);
  };
  return tos3("");
}
string utf32_to_str_no_malloc(u32 code, void *buf) {
  int icode = ((int)(code));
  byteptr buffer = ((byteptr)(buf));
  if (icode <= 127) {
    buffer[/*ptr!*/ 0] /*rbyteptr 1*/ = icode;
    return tos(buffer, 1);
  };
  if ((icode <= 2047)) {
    buffer[/*ptr!*/ 0] /*rbyteptr 1*/ = 192 | (icode >> 6);
    buffer[/*ptr!*/ 1] /*rbyteptr 1*/ = 128 | (icode & 63);
    return tos(buffer, 2);
  };
  if ((icode <= 65535)) {
    buffer[/*ptr!*/ 0] /*rbyteptr 1*/ = 224 | (icode >> 12);
    buffer[/*ptr!*/ 1] /*rbyteptr 1*/ = 128 | ((icode >> 6) & 63);
    buffer[/*ptr!*/ 2] /*rbyteptr 1*/ = 128 | (icode & 63);
    return tos(buffer, 3);
  };
  if ((icode <= 1114111)) {
    buffer[/*ptr!*/ 0] /*rbyteptr 1*/ = 240 | (icode >> 18);
    buffer[/*ptr!*/ 1] /*rbyteptr 1*/ = 128 | ((icode >> 12) & 63);
    buffer[/*ptr!*/ 2] /*rbyteptr 1*/ = 128 | ((icode >> 6) & 63);
    buffer[/*ptr!*/ 3] /*rbyteptr 1*/ = 128 | (icode & 63);
    return tos(buffer, 4);
  };
  return tos3("");
}
int string_utf32_code(string _rune) {
  if (_rune.len == 0) {
    return 0;
  };
  if (_rune.len == 1) {
    return ((int)(_rune.str[0] /*rbyte 0*/));
  };
  byte b = ((byte)(((int)(_rune.str[0] /*rbyte 0*/))));
  b = b << _rune.len;
  int res = ((int)(b));
  int shift = 6 - _rune.len;
  for (int i = 1; i < _rune.len; i++) {

    int c = ((int)(_rune.str[i] /*rbyte 0*/));
    res = res << shift;
    res |= c & 63;
    shift = 6;
  };
  return res;
}
u16 *string_to_wide(string _str) {
#ifdef _WIN32
  int num_chars = (MultiByteToWideChar(builtin__CP_UTF8, 0, (char *)_str.str,
                                       _str.len, 0, 0));
  u16 *wstr = ((u16 *)(v_malloc((num_chars + 1) * 2)));
  if (!isnil(wstr)) {
    MultiByteToWideChar(builtin__CP_UTF8, 0, (char *)_str.str, _str.len, wstr,
                        num_chars);
    memset((char *)(byte *)((byte *)(wstr)) + num_chars * 2, 0, 2);
  };
  return wstr;
#else
  return 0;
#endif
  ;
}
string string_from_wide(u16 *_wstr) {
#ifdef _WIN32
  int wstr_len = wcslen(_wstr);
  return string_from_wide2(_wstr, wstr_len);
#else
  return tos3("");
#endif
  ;
}
string string_from_wide2(u16 *_wstr, int len) {
#ifdef _WIN32
  int num_chars =
      WideCharToMultiByte(builtin__CP_UTF8, 0, _wstr, len, 0, 0, 0, 0);
  byte *str_to = v_malloc(num_chars + 1);
  if (!isnil(str_to)) {
    WideCharToMultiByte(builtin__CP_UTF8, 0, _wstr, len, (char *)str_to,
                        num_chars, 0, 0);
    memset((char *)(byte *)str_to + num_chars, 0, 1);
  };
  return tos2(str_to);
#else
  return tos3("");
#endif
  ;
}
int utf8_len(byte c) {
  int b = 0;
  byte x = c;
  if (((x & 240) != 0)) {
    x >>= 4;
  } else {
    b += 4;
  };
  if (((x & 12) != 0)) {
    x >>= 2;
  } else {
    b += 2;
  };
  if (((x & 2) == 0)) {
    b++;
  };
  return b;
}
int utf8_getchar() {
  int c = getchar();
  int len = utf8_len(~c);
  if (c < 0) {
    return 0;
  } else if (len == 0) {
    return c;
  } else if (len == 1) {
    return -1;
  } else {
    int uc = c & ((1 << (7 - len)) - 1);
    for (int i = 0; i + 1 < len; i++) {

      int c2 = getchar();
      if (c2 != -1 && (c2 >> 6) == 2) {
        uc <<= 6;
        uc |= (c2 & 63);
      } else if (c2 == -1) {
        return 0;
      } else {
        return -1;
      };
    };
    return uc;
  };
}
strings__Builder strings__new_builder(int initial_size) {
  return (strings__Builder){
      .buf = make(0, initial_size, 1),
      .initial_size = initial_size,
      .len = 0,
  };
}
void strings__Builder_write_bytes(strings__Builder *b, byte *bytes,
                                  int howmany) {
  array_push_many(&/* ? */ b->buf, bytes, howmany);
  b->len += howmany;
}
void strings__Builder_write_b(strings__Builder *b, byte data) {
  _PUSH(&b->buf, (/*typ = array_byte   tmp_typ=byte*/ data), tmp1, byte);
  b->len++;
}
void strings__Builder_write(strings__Builder *b, string s) {
  if (string_eq(s, tos3(""))) {

    return;
  };
  array_push_many(&/* ? */ b->buf, s.str, s.len);
  b->len += s.len;
}
void strings__Builder_go_back(strings__Builder *b, int n) {
  array_trim(&/* ? */ b->buf, b->buf.len - n);
  b->len -= n;
}
void strings__Builder_writeln(strings__Builder *b, string s) {
  array_push_many(&/* ? */ b->buf, s.str, s.len);
  _PUSH(&b->buf, (/*typ = array_byte   tmp_typ=byte*/ '\n'), tmp2, byte);
  b->len += s.len + 1;
}
string strings__Builder_str(strings__Builder *b) {
  _PUSH(&b->buf, (/*typ = array_byte   tmp_typ=byte*/ '\0'), tmp3, byte);
  return (tos((byte *)b->buf.data, b->len));
}
void strings__Builder_free(strings__Builder *b) {
  { v_free(b->buf.data); };
  b->buf = make(0, b->initial_size, 1);
  b->len = 0;
}
int strings__levenshtein_distance(string a, string b) {
  array_int f =
      array_repeat(new_array_from_c_array(1, 1, sizeof(int),
                                          EMPTY_ARRAY_OF_ELEMS(int, 1){0}),
                   b.len + 1);
  int tmp1 = 0;
  ;
  for (int tmp2 = tmp1; tmp2 < f.len; tmp2++) {
    int j = tmp2;

    array_set(&/*q*/ f, j, &(int[]){j});
  };
  string tmp3 = a;
  ;
  for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
    byte ca = tmp3.str[tmp4];

    int j = 1;
    int fj1 = (*(int *)array_get(f, 0));
    (*(int *)array_get(f, 0))++;
    string tmp9 = b;
    ;
    for (int tmp10 = 0; tmp10 < tmp9.len; tmp10++) {
      byte cb = tmp9.str[tmp10];

      int mn =
          (((*(int *)array_get(f, j)) + 1 <= (*(int *)array_get(f, j - 1)) + 1)
               ? ((*(int *)array_get(f, j)) + 1)
               : ((*(int *)array_get(f, j - 1)) + 1));
      if (cb != ca) {
        mn = ((mn <= fj1 + 1) ? (mn) : (fj1 + 1));
      } else {
        mn = ((mn <= fj1) ? (mn) : (fj1));
      };
      fj1 = (*(int *)array_get(f, j));
      array_set(&/*q*/ f, j, &(int[]){mn});
      j++;
    };
  };
  return (*(int *)array_get(f, f.len - 1));
}
f32 strings__levenshtein_distance_percentage(string a, string b) {
  int d = strings__levenshtein_distance(a, b);
  int l = ((a.len >= b.len) ? (a.len) : (b.len));
  return (1.00 - ((f32)(d)) / ((f32)(l))) * 100.00;
}
f32 strings__dice_coefficient(string s1, string s2) {
  if (s1.len == 0 || s2.len == 0) {
    return 0.0;
  };
  if (string_eq(s1, s2)) {
    return 1.0;
  };
  if (s1.len < 2 || s2.len < 2) {
    return 0.0;
  };
  string a = ((s1.len > s2.len) ? (s1) : (s2));
  string b = ((string_eq(a, s1)) ? (s2) : (s1));
  map_int first_bigrams = new_map(1, sizeof(int));
  int tmp23 = 0;
  ;
  for (int tmp24 = tmp23; tmp24 < a.len - 1; tmp24++) {
    int i = tmp24;

    string bigram = string_substr2(a, i, i + 2, false);
    int tmp27 = 0;
    bool tmp28 = map_get(/*similarity.v : 55*/ first_bigrams, bigram, &tmp27);

    int q = (((_IN_MAP((bigram), first_bigrams))) ? (tmp27 + 1) : (1));
    map_set(&first_bigrams, bigram, &(int[]){q});
  };
  int intersection_size = 0;
  int tmp29 = 0;
  ;
  for (int tmp30 = tmp29; tmp30 < b.len - 1; tmp30++) {
    int i = tmp30;

    string bigram = string_substr2(b, i, i + 2, false);
    int tmp33 = 0;
    bool tmp34 = map_get(/*similarity.v : 61*/ first_bigrams, bigram, &tmp33);

    int count = (((_IN_MAP((bigram), first_bigrams))) ? (tmp33) : (0));
    if (count > 0) {
      map_set(&first_bigrams, bigram, &(int[]){count - 1});
      intersection_size++;
    };
  };
  return (2.0 * intersection_size) / (((f32)(a.len)) + ((f32)(b.len)) - 2);
}
string strings__repeat(byte c, int n) {
  if (n <= 0) {
    return tos3("");
  };
  byte *bytes = ((byte *)(0));
  { bytes = v_malloc(n + 1); };
  memset((char *)bytes, c, n);
  bytes[/*ptr!*/ n] /*rbyte 1*/ = '0';
  return (tos((byte *)bytes, n));
}
string strings__repeat_string(string s, int n) {
  if (n <= 0 || s.len == 0) {
    return tos3("");
  };
  int slen = s.len;
  int blen = slen * n;
  byte *bytes = ((byte *)(0));
  { bytes = v_malloc(blen + 1); };
  int tmp1 = 0;
  ;
  for (int tmp2 = tmp1; tmp2 < n; tmp2++) {
    int bi = tmp2;

    int bislen = bi * slen;
    int tmp3 = 0;
    ;
    for (int tmp4 = tmp3; tmp4 < slen; tmp4++) {
      int si = tmp4;

      bytes[/*ptr!*/ bislen + si] /*rbyte 1*/ = string_at(s, si);
    };
  };
  bytes[/*ptr!*/ blen] /*rbyte 1*/ = '0';
  return (tos((byte *)bytes, blen));
}
u64 hash_dot_wyhash__rand_u64(u64 *seed) { return 0; }
static inline u64 hash_dot_wyhash__wyhash_c(byte *key, u64 len, u64 seed) {
  return wyhash((char *)key, len, seed);
}
static inline u64 hash_dot_wyhash__sum64_string(string key, u64 seed) {
  return hash_dot_wyhash__wyhash64(key.str, ((u64)(key.len)), seed);
}
static inline u64 hash_dot_wyhash__sum64(array_byte key, u64 seed) {
  return hash_dot_wyhash__wyhash64(key.data, ((u64)(key.len)), seed);
}
static inline u64 hash_dot_wyhash__wyhash64(byte *key, u64 len, u64 seed_) {
  if (len == 0) {
    return 0;
  };
  byte *p = &key[/*ptr!*/ 0] /*rbyte 0*/;
  u64 seed = seed_;
  u64 i = len & 63;
  if (i < 4) {
    seed = hash_dot_wyhash__wymum(hash_dot_wyhash__wyr3(p, i) ^ seed ^
                                      hash_dot_wyhash__wyp0,
                                  seed ^ hash_dot_wyhash__wyp1);
  } else if (i <= 8) {
    seed = hash_dot_wyhash__wymum(
        hash_dot_wyhash__wyr4(p) ^ seed ^ hash_dot_wyhash__wyp0,
        hash_dot_wyhash__wyr4((byte *)(byte *)p + i - 4) ^ seed ^
            hash_dot_wyhash__wyp1);
  } else if (i <= 16) {
    seed = hash_dot_wyhash__wymum(
        hash_dot_wyhash__wyr8(p) ^ seed ^ hash_dot_wyhash__wyp0,
        hash_dot_wyhash__wyr8((byte *)(byte *)p + i - 8) ^ seed ^
            hash_dot_wyhash__wyp1);
  } else if (i <= 24) {
    seed = hash_dot_wyhash__wymum(hash_dot_wyhash__wyr8(p) ^ seed ^
                                      hash_dot_wyhash__wyp0,
                                  hash_dot_wyhash__wyr8((byte *)p + 8) ^ seed ^
                                      hash_dot_wyhash__wyp1) ^
           hash_dot_wyhash__wymum(
               hash_dot_wyhash__wyr8((byte *)(byte *)p + i - 8) ^ seed ^
                   hash_dot_wyhash__wyp2,
               seed ^ hash_dot_wyhash__wyp3);
  } else if (i <= 32) {
    seed = hash_dot_wyhash__wymum(hash_dot_wyhash__wyr8(p) ^ seed ^
                                      hash_dot_wyhash__wyp0,
                                  hash_dot_wyhash__wyr8((byte *)p + 8) ^ seed ^
                                      hash_dot_wyhash__wyp1) ^
           hash_dot_wyhash__wymum(
               hash_dot_wyhash__wyr8((byte *)p + 16) ^ seed ^
                   hash_dot_wyhash__wyp2,
               hash_dot_wyhash__wyr8((byte *)(byte *)p + i - 8) ^ seed ^
                   hash_dot_wyhash__wyp3);
  } else {
    seed = hash_dot_wyhash__wymum(hash_dot_wyhash__wyr8(p) ^ seed ^
                                      hash_dot_wyhash__wyp0,
                                  hash_dot_wyhash__wyr8((byte *)p + 8) ^ seed ^
                                      hash_dot_wyhash__wyp1) ^
           hash_dot_wyhash__wymum(hash_dot_wyhash__wyr8((byte *)p + 16) ^ seed ^
                                      hash_dot_wyhash__wyp2,
                                  hash_dot_wyhash__wyr8((byte *)p + 24) ^ seed ^
                                      hash_dot_wyhash__wyp3) ^
           hash_dot_wyhash__wymum(
               hash_dot_wyhash__wyr8((byte *)(byte *)p + i - 32) ^ seed ^
                   hash_dot_wyhash__wyp1,
               hash_dot_wyhash__wyr8((byte *)(byte *)p + i - 24) ^ seed ^
                   hash_dot_wyhash__wyp2) ^
           hash_dot_wyhash__wymum(
               hash_dot_wyhash__wyr8((byte *)(byte *)p + i - 16) ^ seed ^
                   hash_dot_wyhash__wyp3,
               hash_dot_wyhash__wyr8((byte *)(byte *)p + i - 8) ^ seed ^
                   hash_dot_wyhash__wyp0);
  };
  if (i == len) {
    return hash_dot_wyhash__wymum(seed, len ^ hash_dot_wyhash__wyp4);
  };
  u64 see1 = seed;
  u64 see2 = seed;
  u64 see3 = seed;
  p = (byte *)p + i;
  for (i = len - i; i >= 64; i -= 64) {

    seed = hash_dot_wyhash__wymum(
        hash_dot_wyhash__wyr8(p) ^ seed ^ hash_dot_wyhash__wyp0,
        hash_dot_wyhash__wyr8((byte *)p + 8) ^ seed ^ hash_dot_wyhash__wyp1);
    see1 = hash_dot_wyhash__wymum(
        hash_dot_wyhash__wyr8((byte *)p + 16) ^ see1 ^ hash_dot_wyhash__wyp2,
        hash_dot_wyhash__wyr8((byte *)p + 24) ^ see1 ^ hash_dot_wyhash__wyp3);
    see2 = hash_dot_wyhash__wymum(
        hash_dot_wyhash__wyr8((byte *)p + 32) ^ see2 ^ hash_dot_wyhash__wyp1,
        hash_dot_wyhash__wyr8((byte *)p + 40) ^ see2 ^ hash_dot_wyhash__wyp2);
    see3 = hash_dot_wyhash__wymum(
        hash_dot_wyhash__wyr8((byte *)p + 48) ^ see3 ^ hash_dot_wyhash__wyp3,
        hash_dot_wyhash__wyr8((byte *)p + 56) ^ see3 ^ hash_dot_wyhash__wyp0);
    p = (byte *)p + 64;
  };
  return hash_dot_wyhash__wymum(seed ^ see1 ^ see2,
                                see3 ^ len ^ hash_dot_wyhash__wyp4);
}
static inline u64 hash_dot_wyhash__wyrotr(u64 v, u32 k) {
  return (v >> k) | (v << (64 - k));
}
static inline u64 hash_dot_wyhash__wymum(u64 a, u64 b) {
  u32 mask32 = ((u32)(4294967295));
  u64 x0 = a & mask32;
  u64 x1 = a >> 32;
  u64 y0 = b & mask32;
  u64 y1 = b >> 32;
  u64 w0 = x0 * y0;
  u64 t = x1 * y0 + (w0 >> 32);
  u64 w1 = t & mask32;
  u64 w2 = t >> 32;
  w1 += x0 * y1;
  u64 hi = x1 * y1 + w2 + (w1 >> 32);
  u64 lo = a * b;
  return hi ^ lo;
}
static inline u64 hash_dot_wyhash__wyr3(byte *p, u64 k) {
  return (((u64)(p[/*ptr!*/ 0] /*rbyte 0*/)) << 16) |
         (((u64)(p[/*ptr!*/ k >> 1] /*rbyte 0*/)) << 8) |
         ((u64)(p[/*ptr!*/ k - 1] /*rbyte 0*/));
}
static inline u64 hash_dot_wyhash__wyr4(byte *p) {
  return ((u32)(p[/*ptr!*/ 0] /*rbyte 0*/)) |
         (((u32)(p[/*ptr!*/ 1] /*rbyte 0*/)) << ((u32)(8))) |
         (((u32)(p[/*ptr!*/ 2] /*rbyte 0*/)) << ((u32)(16))) |
         (((u32)(p[/*ptr!*/ 3] /*rbyte 0*/)) << ((u32)(24)));
}
static inline u64 hash_dot_wyhash__wyr8(byte *p) {
  return ((u64)(p[/*ptr!*/ 0] /*rbyte 0*/)) |
         (((u64)(p[/*ptr!*/ 1] /*rbyte 0*/)) << 8) |
         (((u64)(p[/*ptr!*/ 2] /*rbyte 0*/)) << 16) |
         (((u64)(p[/*ptr!*/ 3] /*rbyte 0*/)) << 24) |
         (((u64)(p[/*ptr!*/ 4] /*rbyte 0*/)) << 32) |
         (((u64)(p[/*ptr!*/ 5] /*rbyte 0*/)) << 40) |
         (((u64)(p[/*ptr!*/ 6] /*rbyte 0*/)) << 48) |
         (((u64)(p[/*ptr!*/ 7] /*rbyte 0*/)) << 56);
}
_V_MulRet_u32_V_u32_V_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0) {
  u32 r0 = ((u32)(0));
  u32 r1 = ((u32)(0));
  u32 r2 = ((u32)(0));
  r0 = (s0 >> 1) | ((s1 & ((u32)(1))) << 31);
  r1 = (s1 >> 1) | ((s2 & ((u32)(1))) << 31);
  r2 = s2 >> 1;
  return (_V_MulRet_u32_V_u32_V_u32){.var_0 = r2, .var_1 = r1, .var_2 = r0};
}
_V_MulRet_u32_V_u32_V_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0) {
  u32 r0 = ((u32)(0));
  u32 r1 = ((u32)(0));
  u32 r2 = ((u32)(0));
  r2 = (s2 << 1) | ((s1 & (((u32)(1)) << 31)) >> 31);
  r1 = (s1 << 1) | ((s0 & (((u32)(1)) << 31)) >> 31);
  r0 = s0 << 1;
  return (_V_MulRet_u32_V_u32_V_u32){.var_0 = r2, .var_1 = r1, .var_2 = r0};
}
_V_MulRet_u32_V_u32_V_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1,
                                         u32 d0) {
  u64 w = ((u64)(0));
  u32 r0 = ((u32)(0));
  u32 r1 = ((u32)(0));
  u32 r2 = ((u32)(0));
  w = ((u64)(s0)) + ((u64)(d0));
  r0 = ((u32)(w));
  w >>= 32;
  w += ((u64)(s1)) + ((u64)(d1));
  r1 = ((u32)(w));
  w >>= 32;
  w += ((u64)(s2)) + ((u64)(d2));
  r2 = ((u32)(w));
  return (_V_MulRet_u32_V_u32_V_u32){.var_0 = r2, .var_1 = r1, .var_2 = r0};
}
_V_MulRet_u32_V_u32_V_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1,
                                         u32 d0) {
  u64 w = ((u64)(0));
  u32 r0 = ((u32)(0));
  u32 r1 = ((u32)(0));
  u32 r2 = ((u32)(0));
  w = ((u64)(s0)) - ((u64)(d0));
  r0 = ((u32)(w));
  w >>= 32;
  w += ((u64)(s1)) - ((u64)(d1));
  r1 = ((u32)(w));
  w >>= 32;
  w += ((u64)(s2)) - ((u64)(d2));
  r2 = ((u32)(w));
  return (_V_MulRet_u32_V_u32_V_u32){.var_0 = r2, .var_1 = r1, .var_2 = r0};
}
bool strconv__is_digit(byte x) {
  return (x >= strconv__ZERO && x <= strconv__NINE) == 1;
}
bool strconv__is_space(byte x) {
  return ((x >= 0x89 && x <= 0x13) || x == 0x20) == 1;
}
bool strconv__is_exp(byte x) { return (x == 'E' || x == 'e') == 1; }
_V_MulRet_int_V_strconv__PrepNumber strconv__parser(string s) {
  int state = strconv__fsm_a;
  int digx = 0;
  byte c = ' ';
  int result = strconv__parser_ok;
  bool expneg = 0;
  int expexp = 0;
  int i = 0;
  strconv__PrepNumber pn = (strconv__PrepNumber){
      .negative = 0, .exponent = 0, .mantissa = ((u64)(0))};
  while (state != strconv__FSM_STOP) {

    int tmp1 = state;

    if (tmp1 == strconv__fsm_a) {
      if (strconv__is_space(c) == 1) {
        c = string_at(s, i++);
      } else {
        state = strconv__fsm_b;
      };
    } else if (tmp1 == strconv__fsm_b) {
      state = strconv__fsm_c;
      if (c == strconv__PLUS) {
        c = string_at(s, i++);
      } else if (c == strconv__MINUS) {
        pn.negative = 1;
        c = string_at(s, i++);
      } else if (strconv__is_digit(c)) {
      } else if (c == strconv__DPOINT) {
      } else {
        state = strconv__FSM_STOP;
      };
    } else if (tmp1 == strconv__fsm_c) {
      if (c == strconv__ZERO) {
        c = string_at(s, i++);
      } else if (c == strconv__DPOINT) {
        c = string_at(s, i++);
        state = strconv__fsm_d;
      } else {
        state = strconv__fsm_e;
      };
    } else if (tmp1 == strconv__fsm_d) {
      if (c == strconv__ZERO) {
        c = string_at(s, i++);
        if (pn.exponent > -2147483647) {
          pn.exponent--;
        };
      } else {
        state = strconv__fsm_f;
      };
    } else if (tmp1 == strconv__fsm_e) {
      if (strconv__is_digit(c)) {
        if (digx < strconv__DIGITS) {
          pn.mantissa *= 10;
          pn.mantissa += ((u64)(c - strconv__ZERO));
          digx++;
        } else if (pn.exponent < 2147483647) {
          pn.exponent++;
        };
        c = string_at(s, i++);
      } else if (c == strconv__DPOINT) {
        c = string_at(s, i++);
        state = strconv__fsm_f;
      } else {
        state = strconv__fsm_f;
      };
    } else if (tmp1 == strconv__fsm_f) {
      if (strconv__is_digit(c)) {
        if (digx < strconv__DIGITS) {
          pn.mantissa *= 10;
          pn.mantissa += ((u64)(c - strconv__ZERO));
          pn.exponent--;
          digx++;
        };
        c = string_at(s, i++);
      } else if (strconv__is_exp(c)) {
        c = string_at(s, i++);
        state = strconv__fsm_g;
      } else {
        state = strconv__fsm_g;
      };
    } else if (tmp1 == strconv__fsm_g) {
      if (c == strconv__PLUS) {
        c = string_at(s, i++);
      } else if (c == strconv__MINUS) {
        expneg = 1;
        c = string_at(s, i++);
      };
      state = strconv__fsm_h;
    } else if (tmp1 == strconv__fsm_h) {
      if (c == strconv__ZERO) {
        c = string_at(s, i++);
      } else {
        state = strconv__fsm_i;
      };
    } else if (tmp1 == strconv__fsm_i) {
      if (strconv__is_digit(c)) {
        if (expexp < 214748364) {
          expexp *= 10;
          expexp += ((int)(c - strconv__ZERO));
        };
        c = string_at(s, i++);
      } else {
        state = strconv__FSM_STOP;
      };
    } else // default:
    {
    };
    if (i >= s.len) {
      state = strconv__FSM_STOP;
    };
  };
  if (expneg) {
    expexp = -expexp;
  };
  pn.exponent += expexp;
  if (pn.mantissa == 0) {
    if (pn.negative) {
      result = strconv__parser_mzero;
    } else {
      result = strconv__parser_pzero;
    };
  } else if ((pn.exponent > 309)) {
    if (pn.negative) {
      result = strconv__parser_minf;
    } else {
      result = strconv__parser_pinf;
    };
  } else if (pn.exponent < -328) {
    if (pn.negative) {
      result = strconv__parser_mzero;
    } else {
      result = strconv__parser_pzero;
    };
  };
  return (_V_MulRet_int_V_strconv__PrepNumber){.var_0 = result, .var_1 = pn};
}
u64 strconv__converter(strconv__PrepNumber *pn) {
  int binexp = 92;
  u32 s2 = ((u32)(0));
  u32 s1 = ((u32)(0));
  u32 s0 = ((u32)(0));
  u32 q2 = ((u32)(0));
  u32 q1 = ((u32)(0));
  u32 q0 = ((u32)(0));
  u32 r2 = ((u32)(0));
  u32 r1 = ((u32)(0));
  u32 r0 = ((u32)(0));
  u32 mask28 = ((u32)(0xF << 28));
  u64 result = ((u64)(0));
  s0 = ((u32)(pn->mantissa & ((u64)(0x00000000FFFFFFFF))));
  s1 = ((u32)(pn->mantissa >> 32));
  s2 = ((u32)(0));
  while (pn->exponent > 0) {

    _V_MulRet_u32_V_u32_V_u32 _V_mret_1328_q2_q1_q0 =
        strconv__lsl96(s2, s1, s0);
    q2 = _V_mret_1328_q2_q1_q0.var_0;
    q1 = _V_mret_1328_q2_q1_q0.var_1;
    q0 = _V_mret_1328_q2_q1_q0.var_2;
    _V_MulRet_u32_V_u32_V_u32 _V_mret_1342_r2_r1_r0 =
        strconv__lsl96(q2, q1, q0);
    r2 = _V_mret_1342_r2_r1_r0.var_0;
    r1 = _V_mret_1342_r2_r1_r0.var_1;
    r0 = _V_mret_1342_r2_r1_r0.var_2;
    _V_MulRet_u32_V_u32_V_u32 _V_mret_1356_s2_s1_s0 =
        strconv__lsl96(r2, r1, r0);
    s2 = _V_mret_1356_s2_s1_s0.var_0;
    s1 = _V_mret_1356_s2_s1_s0.var_1;
    s0 = _V_mret_1356_s2_s1_s0.var_2;
    _V_MulRet_u32_V_u32_V_u32 _V_mret_1370_s2_s1_s0 =
        strconv__add96(s2, s1, s0, q2, q1, q0);
    s2 = _V_mret_1370_s2_s1_s0.var_0;
    s1 = _V_mret_1370_s2_s1_s0.var_1;
    s0 = _V_mret_1370_s2_s1_s0.var_2;
    pn->exponent--;
    while ((s2 & mask28) != 0) {

      _V_MulRet_u32_V_u32_V_u32 _V_mret_1403_q2_q1_q0 =
          strconv__lsr96(s2, s1, s0);
      q2 = _V_mret_1403_q2_q1_q0.var_0;
      q1 = _V_mret_1403_q2_q1_q0.var_1;
      q0 = _V_mret_1403_q2_q1_q0.var_2;
      binexp++;
      s2 = q2;
      s1 = q1;
      s0 = q0;
    };
  };
  while (pn->exponent < 0) {

    while (!((s2 & (((u32)(1)) << 31)) != 0)) {

      _V_MulRet_u32_V_u32_V_u32 _V_mret_1456_q2_q1_q0 =
          strconv__lsl96(s2, s1, s0);
      q2 = _V_mret_1456_q2_q1_q0.var_0;
      q1 = _V_mret_1456_q2_q1_q0.var_1;
      q0 = _V_mret_1456_q2_q1_q0.var_2;
      binexp--;
      s2 = q2;
      s1 = q1;
      s0 = q0;
    };
    q2 = s2 / strconv__TEN;
    r1 = s2 % strconv__TEN;
    r2 = (s1 >> 8) | (r1 << 24);
    q1 = r2 / strconv__TEN;
    r1 = r2 % strconv__TEN;
    r2 = ((s1 & ((u32)(0xFF))) << 16) | (s0 >> 16) | (r1 << 24);
    r0 = r2 / strconv__TEN;
    r1 = r2 % strconv__TEN;
    q1 = (q1 << 8) | ((r0 & ((u32)(0x00FF0000))) >> 16);
    q0 = r0 << 16;
    r2 = (s0 & ((u32)(0xFFFF))) | (r1 << 16);
    q0 |= r2 / strconv__TEN;
    s2 = q2;
    s1 = q1;
    s0 = q0;
    pn->exponent++;
  };
  if (s2 != 0 || s1 != 0 || s0 != 0) {
    while ((s2 & mask28) == 0) {

      _V_MulRet_u32_V_u32_V_u32 _V_mret_1633_q2_q1_q0 =
          strconv__lsl96(s2, s1, s0);
      q2 = _V_mret_1633_q2_q1_q0.var_0;
      q1 = _V_mret_1633_q2_q1_q0.var_1;
      q0 = _V_mret_1633_q2_q1_q0.var_2;
      binexp--;
      s2 = q2;
      s1 = q1;
      s0 = q0;
    };
  };
  int nbit = 7;
  u32 check_round_bit = ((u32)(1)) << ((u32)(nbit));
  u32 check_round_mask = ((u32)(0xFFFFFFFF)) << ((u32)(nbit));
  if ((s1 & check_round_bit) != 0) {
    if ((s1 & ~check_round_mask) != 0) {
      _V_MulRet_u32_V_u32_V_u32 _V_mret_1704_s2_s1_s0 =
          strconv__add96(s2, s1, s0, 0, check_round_bit, 0);
      s2 = _V_mret_1704_s2_s1_s0.var_0;
      s1 = _V_mret_1704_s2_s1_s0.var_1;
      s0 = _V_mret_1704_s2_s1_s0.var_2;
    } else {
      if ((s1 & (check_round_bit << ((u32)(1)))) != 0) {
        _V_MulRet_u32_V_u32_V_u32 _V_mret_1743_s2_s1_s0 =
            strconv__add96(s2, s1, s0, 0, check_round_bit, 0);
        s2 = _V_mret_1743_s2_s1_s0.var_0;
        s1 = _V_mret_1743_s2_s1_s0.var_1;
        s0 = _V_mret_1743_s2_s1_s0.var_2;
      };
    };
    s1 = s1 & check_round_mask;
    s0 = ((u32)(0));
    if ((s2 & (mask28 << ((u32)(1)))) != 0) {
      _V_MulRet_u32_V_u32_V_u32 _V_mret_1790_q2_q1_q0 =
          strconv__lsr96(s2, s1, s0);
      q2 = _V_mret_1790_q2_q1_q0.var_0;
      q1 = _V_mret_1790_q2_q1_q0.var_1;
      q0 = _V_mret_1790_q2_q1_q0.var_2;
      binexp--;
      s2 = q2;
      s1 = q1;
      s0 = q0;
    };
  };
  binexp += 1023;
  if (binexp > 2046) {
    if (pn->negative) {
      result = strconv__DOUBLE_MINUS_INFINITY;
    } else {
      result = strconv__DOUBLE_PLUS_INFINITY;
    };
  } else if (binexp < 1) {
    if (pn->negative) {
      result = strconv__DOUBLE_MINUS_ZERO;
    } else {
      result = strconv__DOUBLE_PLUS_ZERO;
    };
  } else if (s2 != 0) {
    u64 q = ((u64)(0));
    u64 binexs2 = ((u64)(binexp)) << 52;
    q = (((u64)(s2 & ~mask28)) << 24) | ((((u64)(s1)) + ((u64)(128))) >> 8) |
        binexs2;
    if (pn->negative) {
      q |= (((u64)(1)) << 63);
    };
    result = q;
  };
  return result;
}
f64 strconv__atof64(string s) {
  strconv__PrepNumber pn = (strconv__PrepNumber){
      .negative = 0, .exponent = 0, .mantissa = ((u64)(0))};
  int res_parsing = 0;
  strconv__Float64u res = (strconv__Float64u){.f = 0.0, .u = ((u64)(0))};
  _V_MulRet_int_V_strconv__PrepNumber _V_mret_1961_res_parsing_pn =
      strconv__parser(string_add(s, tos3(" ")));
  res_parsing = _V_mret_1961_res_parsing_pn.var_0;
  pn = _V_mret_1961_res_parsing_pn.var_1;
  int tmp30 = res_parsing;

  if (tmp30 == strconv__parser_ok) {
    res.u = strconv__converter(&/*114*/ pn);
  } else if (tmp30 == strconv__parser_pzero) {
    res.u = strconv__DOUBLE_PLUS_ZERO;
  } else if (tmp30 == strconv__parser_mzero) {
    res.u = strconv__DOUBLE_MINUS_ZERO;
  } else if (tmp30 == strconv__parser_pinf) {
    res.u = strconv__DOUBLE_PLUS_INFINITY;
  } else if (tmp30 == strconv__parser_minf) {
    res.u = strconv__DOUBLE_MINUS_INFINITY;
  } else // default:
  {
  };
  return res.f;
}
byte strconv__byte_to_lower(byte c) { return c | ('x' - 'X'); }
u64 strconv__common_parse_uint(string s, int _base, int _bit_size,
                               bool error_on_non_digit,
                               bool error_on_high_digit) {
  int bit_size = _bit_size;
  int base = _base;
  if (s.len < 1 || !strconv__underscore_ok(s)) {
    return ((u64)(0));
  };
  bool base0 = base == 0;
  int start_index = 0;
  if (2 <= base && base <= 36) {
  } else if (base == 0) {
    base = 10;
    if (string_at(s, 0) == '0') {
      if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'b') {
        base = 2;
        start_index += 2;
      } else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'o') {
        base = 8;
        start_index += 2;
      } else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'x') {
        base = 16;
        start_index += 2;
      } else if (s.len >= 2 &&
                 (string_at(s, 1) >= '0' && string_at(s, 1) <= '9')) {
        base = 10;
        start_index++;
      } else {
        base = 8;
        start_index++;
      };
    };
  } else {
    return ((u64)(0));
  };
  if (bit_size == 0) {
    bit_size = strconv__int_size;
  } else if (bit_size < 0 || bit_size > 64) {
    return ((u64)(0));
  };
  u64 cutoff = strconv__max_u64 / ((u64)(base)) + ((u64)(1));
  u64 max_val =
      ((bit_size == 64) ? (strconv__max_u64)
                        : ((((u64)(1)) << ((u64)(bit_size))) - ((u64)(1))));
  bool underscores = 0;
  u64 n = ((u64)(0));
  int tmp13 = start_index;
  ;
  for (int tmp14 = tmp13; tmp14 < s.len; tmp14++) {
    int i = tmp14;

    byte c = string_at(s, i);
    byte cl = strconv__byte_to_lower(c);
    byte d = ((byte)(0));
    if (c == '_' && base0) {
      underscores = 1;
      continue;
    } else if ('0' <= c && c <= '9') {
      d = c - '0';
    } else if ('a' <= cl && cl <= 'z') {
      d = cl - 'a' + 10;
    } else {
      if (error_on_non_digit) {
        return ((u64)(0));
      } else {
        break;
      };
    };
    if (d >= ((byte)(base))) {
      if (error_on_high_digit) {
        return ((u64)(0));
      } else {
        break;
      };
    };
    if (n >= cutoff) {
      return max_val;
    };
    n *= ((u64)(base));
    u64 n1 = n + ((u64)(d));
    if (n1 < n || n1 > max_val) {
      return max_val;
    };
    n = n1;
  };
  if (underscores && !strconv__underscore_ok(s)) {
    return ((u64)(0));
  };
  return n;
}
u64 strconv__parse_uint(string s, int _base, int _bit_size) {
  return strconv__common_parse_uint(s, _base, _bit_size, 1, 1);
}
i64 strconv__common_parse_int(string _s, int base, int _bit_size,
                              bool error_on_non_digit,
                              bool error_on_high_digit) {
  string s = _s;
  int bit_size = _bit_size;
  if (s.len < 1) {
    return ((i64)(0));
  };
  bool neg = 0;
  if (string_at(s, 0) == '+') {
    s = string_substr2(s, 1, -1, true);
  } else if (string_at(s, 0) == '-') {
    neg = 1;
    s = string_substr2(s, 1, -1, true);
  };
  u64 un = strconv__common_parse_uint(s, base, bit_size, error_on_non_digit,
                                      error_on_high_digit);
  if (un == 0) {
    return ((i64)(0));
  };
  if (bit_size == 0) {
    bit_size = strconv__int_size;
  };
  u64 cutoff = ((u64)(1)) << ((u64)(bit_size - 1));
  if (!neg && un >= cutoff) {
    return ((i64)(cutoff - ((u64)(1))));
  };
  if (neg && un > cutoff) {
    return -((i64)(cutoff));
  };
  return ((neg) ? (-((i64)(un))) : (((i64)(un))));
}
i64 strconv__parse_int(string _s, int base, int _bit_size) {
  return strconv__common_parse_int(_s, base, _bit_size, 1, 1);
}
int strconv__atoi(string s) {
  if ((strconv__int_size == 32 && (0 < s.len && s.len < 10)) ||
      (strconv__int_size == 64 && (0 < s.len && s.len < 19))) {
    int start_idx = 0;
    if (string_at(s, 0) == '-' || string_at(s, 0) == '+') {
      start_idx++;
      if (s.len - start_idx < 1) {
        return 0;
      };
    };
    int n = 0;
    int tmp29 = start_idx;
    ;
    for (int tmp30 = tmp29; tmp30 < s.len; tmp30++) {
      int i = tmp30;

      byte ch = string_at(s, i) - '0';
      if (ch > 9) {
        return 0;
      };
      n = n * 10 + ((int)(ch));
    };
    return ((string_at(s, 0) == '-') ? (-n) : (n));
  };
  i64 int64 = strconv__parse_int(s, 10, 0);
  return ((int)(int64));
}
bool strconv__underscore_ok(string s) {
  byte saw = '^';
  int i = 0;
  if (s.len >= 1 && (string_at(s, 0) == '-' || string_at(s, 0) == '+')) {
    i++;
  };
  bool hex = 0;
  if (s.len - i >= 2 && string_at(s, i) == '0' &&
      (strconv__byte_to_lower(string_at(s, i + 1)) == 'b' ||
       strconv__byte_to_lower(string_at(s, i + 1)) == 'o' ||
       strconv__byte_to_lower(string_at(s, i + 1)) == 'x')) {
    saw = '0';
    hex = strconv__byte_to_lower(string_at(s, i + 1)) == 'x';
    i += 2;
  };
  for (; i < s.len; i++) {

    if (('0' <= string_at(s, i) && string_at(s, i) <= '9') ||
        (hex && 'a' <= strconv__byte_to_lower(string_at(s, i)) &&
         strconv__byte_to_lower(string_at(s, i)) <= 'f')) {
      saw = '0';
      continue;
    };
    if (string_at(s, i) == '_') {
      if (saw != '0') {
        return 0;
      };
      saw = '_';
      continue;
    };
    if (saw == '_') {
      return 0;
    };
    saw = '!';
  };
  return saw != '_';
}
f64 math__inf(int sign) {
  u64 v = ((sign >= 0) ? (math__uvinf) : (math__uvneginf));
  return math__f64_from_bits(v);
}
f64 math__nan() { return math__f64_from_bits(math__uvnan); }
bool math__is_nan(f64 f) { return f64_ne(f, f); }
bool math__is_inf(f64 f, int sign) {
  return (sign >= 0 && macro_f64_gt(f, math__max_f64)) ||
         (sign <= 0 && macro_f64_lt(f, -math__max_f64));
}
f64 math__abs(f64 a) { return fabs(a); }
f64 math__acos(f64 a) { return acos(a); }
f64 math__asin(f64 a) { return asin(a); }
f64 math__atan(f64 a) { return atan(a); }
f64 math__atan2(f64 a, f64 b) { return atan2(a, b); }
f64 math__cbrt(f64 a) { return cbrt(a); }
f64 math__ceil(f64 a) { return ceil(a); }
f64 math__cos(f64 a) { return cos(a); }
f32 math__cosf(f32 a) { return cosf(a); }
f64 math__cosh(f64 a) { return cosh(a); }
f64 math__degrees(f64 radians) { return radians * (180.0 / math__pi); }
f64 math__exp(f64 a) { return exp(a); }
array_int math__digits(int _n, int base) {
  if (base < 2) {
    v_panic(_STR("digits: Cannot find digits of n with base %d", base));
  };
  int n = _n;
  int sign = 1;
  if (n < 0) {
    sign = -1;
    n = -n;
  };
  array_int res = new_array_from_c_array(
      0, 0, sizeof(int), EMPTY_ARRAY_OF_ELEMS(int, 0){TCCSKIP(0)});
  while (n != 0) {

    _PUSH(&res, (/*typ = array_int   tmp_typ=int*/ (n % base) * sign), tmp1,
          int);
    n /= base;
  };
  return res;
}
f64 math__erf(f64 a) { return erf(a); }
f64 math__erfc(f64 a) { return erfc(a); }
f64 math__exp2(f64 a) { return exp2(a); }
f64 math__floor(f64 a) { return floor(a); }
f64 math__fmod(f64 a, f64 b) { return fmod(a, b); }
f64 math__gamma(f64 a) { return tgamma(a); }
i64 math__gcd(i64 a_, i64 b_) {
  i64 a = a_;
  i64 b = b_;
  if (a < 0) {
    a = -a;
  };
  if (b < 0) {
    b = -b;
  };
  while (b != 0) {

    a %= b;
    if (a == 0) {
      return b;
    };
    b %= a;
  };
  return a;
}
f64 math__hypot(f64 a, f64 b) { return hypot(a, b); }
i64 math__lcm(i64 a, i64 b) {
  if (a == 0) {
    return a;
  };
  i64 res = a * (b / math__gcd(b, a));
  if (res < 0) {
    return -res;
  };
  return res;
}
f64 math__log(f64 a) { return log(a); }
f64 math__log2(f64 a) { return log2(a); }
f64 math__log10(f64 a) { return log10(a); }
f64 math__log_gamma(f64 a) { return lgamma(a); }
f64 math__log_n(f64 a, f64 b) { return log(a) / log(b); }
f64 math__max(f64 a, f64 b) {
  if (macro_f64_gt(a, b)) {
    return a;
  };
  return b;
}
f64 math__min(f64 a, f64 b) {
  if (macro_f64_lt(a, b)) {
    return a;
  };
  return b;
}
f64 math__pow(f64 a, f64 b) { return pow(a, b); }
f32 math__powf(f32 a, f32 b) { return powf(a, b); }
f64 math__radians(f64 degrees) { return degrees * (math__pi / 180.0); }
f64 math__round(f64 f) { return round(f); }
f64 math__sin(f64 a) { return sin(a); }
f32 math__sinf(f32 a) { return sinf(a); }
f64 math__sinh(f64 a) { return sinh(a); }
f64 math__sqrt(f64 a) { return sqrt(a); }
f32 math__sqrtf(f32 a) { return sqrtf(a); }
f64 math__tan(f64 a) { return tan(a); }
f32 math__tanf(f32 a) { return tanf(a); }
f64 math__tanh(f64 a) { return tanh(a); }
f64 math__trunc(f64 a) { return trunc(a); }
f64 math__aprox_sin(f64 a) {
  f32 a0 = 1.91059300966915117e-31;
  f32 a1 = 1.00086760103908896;
  f32 a2 = -1.21276126894734565e-2;
  f32 a3 = -1.38078780785773762e-1;
  f32 a4 = -2.67353392911981221e-2;
  f32 a5 = 2.08026600266304389e-2;
  f32 a6 = -3.03996055049204407e-3;
  f32 a7 = 1.38235642404333740e-4;
  return a0 +
         a * (a1 +
              a * (a2 + a * (a3 + a * (a4 + a * (a5 + a * (a6 + a * a7))))));
}
f64 math__aprox_cos(f64 a) {
  f32 a0 = 9.9995999154986614e-1;
  f32 a1 = 1.2548995793001028e-3;
  f32 a2 = -5.0648546280678015e-1;
  f32 a3 = 1.2942246466519995e-2;
  f32 a4 = 2.8668384702547972e-2;
  f32 a5 = 7.3726485210586547e-3;
  f32 a6 = -3.8510875386947414e-3;
  f32 a7 = 4.7196604604366623e-4;
  f32 a8 = -1.8776444013090451e-5;
  return a0 +
         a * (a1 +
              a * (a2 +
                   a * (a3 +
                        a * (a4 + a * (a5 + a * (a6 + a * (a7 + a * a8)))))));
}
u32 math__f32_bits(f32 f) {
  u32 *p = ((u32 *)(&f));
  return *p;
}
f32 math__f32_from_bits(u32 b) {
  f32 *p = ((f32 *)(&b));
  return *p;
}
u64 math__f64_bits(f64 f) {
  u64 *p = ((u64 *)(&f));
  return *p;
}
f64 math__f64_from_bits(u64 b) {
  f64 *p = ((f64 *)(&b));
  return *p;
}
int math_dot_bits__leading_zeros_8(byte x) {
  return 8 - math_dot_bits__len_8(x);
}
int math_dot_bits__leading_zeros_16(u16 x) {
  return 16 - math_dot_bits__len_16(x);
}
int math_dot_bits__leading_zeros_32(u32 x) {
  return 32 - math_dot_bits__len_32(x);
}
int math_dot_bits__leading_zeros_64(u64 x) {
  return 64 - math_dot_bits__len_64(x);
}
int math_dot_bits__trailing_zeros_8(byte x) {
  return ((int)((*(byte *)array_get(math_dot_bits__ntz_8_tab, x))));
}
int math_dot_bits__trailing_zeros_16(u16 x) {
  if (x == 0) {
    return 16;
  };
  return ((int)((*(byte *)array_get(
      math_dot_bits__de_bruijn32tab,
      ((u32)(x & -x)) * math_dot_bits__de_bruijn32 >> (32 - 5)))));
}
int math_dot_bits__trailing_zeros_32(u32 x) {
  if (x == 0) {
    return 32;
  };
  return ((int)((
      *(byte *)array_get(math_dot_bits__de_bruijn32tab,
                         (x & -x) * math_dot_bits__de_bruijn32 >> (32 - 5)))));
}
int math_dot_bits__trailing_zeros_64(u64 x) {
  if (x == 0) {
    return 64;
  };
  return ((int)((
      *(byte *)array_get(math_dot_bits__de_bruijn64tab,
                         (x & -x) * math_dot_bits__de_bruijn64 >> (64 - 6)))));
}
int math_dot_bits__ones_count_8(byte x) {
  return ((int)((*(byte *)array_get(math_dot_bits__pop_8_tab, x))));
}
int math_dot_bits__ones_count_16(u16 x) {
  return (
      (int)((*(byte *)array_get(math_dot_bits__pop_8_tab, x >> 8)) +
            (*(byte *)array_get(math_dot_bits__pop_8_tab, x & ((u16)(0xff))))));
}
int math_dot_bits__ones_count_32(u32 x) {
  return (
      (int)((*(byte *)array_get(math_dot_bits__pop_8_tab, x >> 24)) +
            (*(byte *)array_get(math_dot_bits__pop_8_tab, x >> 16 & 0xff)) +
            (*(byte *)array_get(math_dot_bits__pop_8_tab, x >> 8 & 0xff)) +
            (*(byte *)array_get(math_dot_bits__pop_8_tab, x & ((u32)(0xff))))));
}
int math_dot_bits__ones_count_64(u64 x) {
  u64 y = (x >> ((u64)(1)) & (math_dot_bits__m0 & math_dot_bits__max_u64)) +
          (x & (math_dot_bits__m0 & math_dot_bits__max_u64));
  y = (y >> ((u64)(2)) & (math_dot_bits__m1 & math_dot_bits__max_u64)) +
      (y & (math_dot_bits__m1 & math_dot_bits__max_u64));
  y = ((y >> 4) + y) & (math_dot_bits__m2 & math_dot_bits__max_u64);
  y += y >> 8;
  y += y >> 16;
  y += y >> 32;
  return ((int)(y)) & ((1 << 7) - 1);
}
static inline byte math_dot_bits__rotate_left_8(byte x, int k) {
  byte n = ((byte)(8));
  byte s = ((byte)(k)) & (n - ((byte)(1)));
  return ((x << s) | (x >> (n - s)));
}
static inline u16 math_dot_bits__rotate_left_16(u16 x, int k) {
  u16 n = ((u16)(16));
  u16 s = ((u16)(k)) & (n - ((u16)(1)));
  return ((x << s) | (x >> (n - s)));
}
static inline u32 math_dot_bits__rotate_left_32(u32 x, int k) {
  u32 n = ((u32)(32));
  u32 s = ((u32)(k)) & (n - ((u32)(1)));
  return ((x << s) | (x >> (n - s)));
}
static inline u64 math_dot_bits__rotate_left_64(u64 x, int k) {
  u64 n = ((u64)(64));
  u64 s = ((u64)(k)) & (n - ((u64)(1)));
  return ((x << s) | (x >> (n - s)));
}
static inline byte math_dot_bits__reverse_8(byte x) {
  return (*(byte *)array_get(math_dot_bits__rev_8_tab, x));
}
static inline u16 math_dot_bits__reverse_16(u16 x) {
  return ((u16)((*(byte *)array_get(math_dot_bits__rev_8_tab, x >> 8)))) |
         (((u16)((
              *(byte *)array_get(math_dot_bits__rev_8_tab, x & ((u16)(0xff))))))
          << 8);
}
static inline u32 math_dot_bits__reverse_32(u32 x) {
  u32 y = ((x >> ((u32)(1)) & (math_dot_bits__m0 & math_dot_bits__max_u32)) |
           ((x & (math_dot_bits__m0 & math_dot_bits__max_u32)) << 1));
  y = ((y >> ((u32)(2)) & (math_dot_bits__m1 & math_dot_bits__max_u32)) |
       ((y & (math_dot_bits__m1 & math_dot_bits__max_u32)) << ((u32)(2))));
  y = ((y >> ((u32)(4)) & (math_dot_bits__m2 & math_dot_bits__max_u32)) |
       ((y & (math_dot_bits__m2 & math_dot_bits__max_u32)) << ((u32)(4))));
  return math_dot_bits__reverse_bytes_32(y);
}
static inline u64 math_dot_bits__reverse_64(u64 x) {
  u64 y = ((x >> ((u64)(1)) & (math_dot_bits__m0 & math_dot_bits__max_u64)) |
           ((x & (math_dot_bits__m0 & math_dot_bits__max_u64)) << 1));
  y = ((y >> ((u64)(2)) & (math_dot_bits__m1 & math_dot_bits__max_u64)) |
       ((y & (math_dot_bits__m1 & math_dot_bits__max_u64)) << 2));
  y = ((y >> ((u64)(4)) & (math_dot_bits__m2 & math_dot_bits__max_u64)) |
       ((y & (math_dot_bits__m2 & math_dot_bits__max_u64)) << 4));
  return math_dot_bits__reverse_bytes_64(y);
}
static inline u16 math_dot_bits__reverse_bytes_16(u16 x) {
  return (x >> 8) | (x << 8);
}
static inline u32 math_dot_bits__reverse_bytes_32(u32 x) {
  u32 y = ((x >> ((u32)(8)) & (math_dot_bits__m3 & math_dot_bits__max_u32)) |
           ((x & (math_dot_bits__m3 & math_dot_bits__max_u32)) << ((u32)(8))));
  return (y >> 16) | (y << 16);
}
static inline u64 math_dot_bits__reverse_bytes_64(u64 x) {
  u64 y = ((x >> ((u64)(8)) & (math_dot_bits__m3 & math_dot_bits__max_u64)) |
           ((x & (math_dot_bits__m3 & math_dot_bits__max_u64)) << ((u64)(8))));
  y = ((y >> ((u64)(16)) & (math_dot_bits__m4 & math_dot_bits__max_u64)) |
       ((y & (math_dot_bits__m4 & math_dot_bits__max_u64)) << ((u64)(16))));
  return (y >> 32) | (y << 32);
}
int math_dot_bits__len_8(byte x) {
  return ((int)((*(byte *)array_get(math_dot_bits__len_8_tab, x))));
}
int math_dot_bits__len_16(u16 x) {
  u16 y = x;
  int n = 0;
  if (y >= 1 << 8) {
    y >>= 8;
    n = 8;
  };
  return n + ((int)((*(byte *)array_get(math_dot_bits__len_8_tab, y))));
}
int math_dot_bits__len_32(u32 x) {
  u32 y = x;
  int n = 0;
  if (y >= 1 << 16) {
    y >>= 16;
    n = 16;
  };
  if (y >= 1 << 8) {
    y >>= 8;
    n += 8;
  };
  return n + ((int)((*(byte *)array_get(math_dot_bits__len_8_tab, y))));
}
int math_dot_bits__len_64(u64 x) {
  u64 y = x;
  int n = 0;
  if (y >= ((u64)(1)) << ((u64)(32))) {
    y >>= 32;
    n = 32;
  };
  if (y >= ((u64)(1)) << ((u64)(16))) {
    y >>= 16;
    n += 16;
  };
  if (y >= ((u64)(1)) << ((u64)(8))) {
    y >>= 8;
    n += 8;
  };
  return n + ((int)((*(byte *)array_get(math_dot_bits__len_8_tab, y))));
}
_V_MulRet_u32_V_u32 math_dot_bits__add_32(u32 x, u32 y, u32 carry) {
  u64 sum64 = ((u64)(x)) + ((u64)(y)) + ((u64)(carry));
  u32 sum = ((u32)(sum64));
  u32 carry_out = ((u32)(sum64 >> 32));
  return (_V_MulRet_u32_V_u32){.var_0 = sum, .var_1 = carry_out};
}
_V_MulRet_u64_V_u64 math_dot_bits__add_64(u64 x, u64 y, u64 carry) {
  u64 sum = x + y + carry;
  u64 carry_out = ((x & y) | ((x | y) & ~sum)) >> 63;
  return (_V_MulRet_u64_V_u64){.var_0 = sum, .var_1 = carry_out};
}
_V_MulRet_u32_V_u32 math_dot_bits__sub_32(u32 x, u32 y, u32 borrow) {
  u32 diff = x - y - borrow;
  u32 borrow_out = ((~x & y) | (~(x ^ y) & diff)) >> 31;
  return (_V_MulRet_u32_V_u32){.var_0 = diff, .var_1 = borrow_out};
}
_V_MulRet_u64_V_u64 math_dot_bits__sub_64(u64 x, u64 y, u64 borrow) {
  u64 diff = x - y - borrow;
  u64 borrow_out = ((~x & y) | (~(x ^ y) & diff)) >> 63;
  return (_V_MulRet_u64_V_u64){.var_0 = diff, .var_1 = borrow_out};
}
_V_MulRet_u32_V_u32 math_dot_bits__mul_32(u32 x, u32 y) {
  u64 tmp = ((u64)(x)) * ((u64)(y));
  u32 hi = ((u32)(tmp >> 32));
  u32 lo = ((u32)(tmp));
  return (_V_MulRet_u32_V_u32){.var_0 = hi, .var_1 = lo};
}
_V_MulRet_u64_V_u64 math_dot_bits__mul_64(u64 x, u64 y) {
  u64 x0 = x & math_dot_bits__mask32;
  u64 x1 = x >> 32;
  u64 y0 = y & math_dot_bits__mask32;
  u64 y1 = y >> 32;
  u64 w0 = x0 * y0;
  u64 t = x1 * y0 + (w0 >> 32);
  u64 w1 = t & math_dot_bits__mask32;
  u64 w2 = t >> 32;
  w1 += x0 * y1;
  u64 hi = x1 * y1 + w2 + (w1 >> 32);
  u64 lo = x * y;
  return (_V_MulRet_u64_V_u64){.var_0 = hi, .var_1 = lo};
}
_V_MulRet_u32_V_u32 math_dot_bits__div_32(u32 hi, u32 lo, u32 y) {
  if (y != 0 && y <= hi) {
    v_panic(math_dot_bits__overflow_error);
  };
  u64 z = (((u64)(hi)) << 32) | ((u64)(lo));
  u32 quo = ((u32)(z / ((u64)(y))));
  u32 rem = ((u32)(z % ((u64)(y))));
  return (_V_MulRet_u32_V_u32){.var_0 = quo, .var_1 = rem};
}
_V_MulRet_u64_V_u64 math_dot_bits__div_64(u64 hi, u64 lo, u64 y1) {
  u64 y = y1;
  if (y == 0) {
    v_panic(math_dot_bits__overflow_error);
  };
  if (y <= hi) {
    v_panic(math_dot_bits__overflow_error);
  };
  u32 s = ((u32)(math_dot_bits__leading_zeros_64(y)));
  y <<= s;
  u64 yn1 = y >> 32;
  u64 yn0 = y & math_dot_bits__mask32;
  u64 un32 = (hi << s) | (lo >> (64 - s));
  u64 un10 = lo << s;
  u64 un1 = un10 >> 32;
  u64 un0 = un10 & math_dot_bits__mask32;
  u64 q1 = un32 / yn1;
  u64 rhat = un32 - q1 * yn1;
  while (q1 >= math_dot_bits__two32 ||
         q1 * yn0 > math_dot_bits__two32 * rhat + un1) {

    q1--;
    rhat += yn1;
    if (rhat >= math_dot_bits__two32) {
      break;
    };
  };
  u64 un21 = un32 * math_dot_bits__two32 + un1 - q1 * y;
  u64 q0 = un21 / yn1;
  rhat = un21 - q0 * yn1;
  while (q0 >= math_dot_bits__two32 ||
         q0 * yn0 > math_dot_bits__two32 * rhat + un0) {

    q0--;
    rhat += yn1;
    if (rhat >= math_dot_bits__two32) {
      break;
    };
  };
  return (_V_MulRet_u64_V_u64){
      .var_0 = q1 * math_dot_bits__two32 + q0,
      .var_1 = (un21 * math_dot_bits__two32 + un0 - q0 * y) >> s};
}
u32 math_dot_bits__rem_32(u32 hi, u32 lo, u32 y) {
  return ((u32)((((u64)(hi)) << 32 | ((u64)(lo))) % ((u64)(y))));
}
u64 math_dot_bits__rem_64(u64 hi, u64 lo, u64 y) {
  _V_MulRet_u64_V_u64 _V_mret_2270___rem = math_dot_bits__div_64(hi % y, lo, y);
  u64 rem = _V_mret_2270___rem.var_1;
  return rem;
}
string time__Time_format(time__Time t) {
  return time__Time_get_fmt_str(t, time__time__FormatDelimiter_hyphen,
                                time__time__FormatTime_hhmm24,
                                time__time__FormatDate_yyyymmdd);
}
string time__Time_format_ss(time__Time t) {
  return time__Time_get_fmt_str(t, time__time__FormatDelimiter_hyphen,
                                time__time__FormatTime_hhmmss24,
                                time__time__FormatDate_yyyymmdd);
}
string time__Time_hhmm(time__Time t) {
  return time__Time_get_fmt_time_str(t, time__time__FormatTime_hhmm24);
}
string time__Time_hhmmss(time__Time t) {
  return time__Time_get_fmt_time_str(t, time__time__FormatTime_hhmmss24);
}
string time__Time_hhmm12(time__Time t) {
  return time__Time_get_fmt_time_str(t, time__time__FormatTime_hhmm12);
}
string time__Time_ymmdd(time__Time t) {
  return time__Time_get_fmt_date_str(t, time__time__FormatDelimiter_hyphen,
                                     time__time__FormatDate_yyyymmdd);
}
string time__Time_ddmmy(time__Time t) {
  return time__Time_get_fmt_date_str(t, time__time__FormatDelimiter_dot,
                                     time__time__FormatDate_ddmmyyyy);
}
string time__Time_md(time__Time t) {
  return time__Time_get_fmt_date_str(t, time__time__FormatDelimiter_space,
                                     time__time__FormatDate_mmmd);
}
string time__Time_clean(time__Time t) {
  time__Time now = time__now();
  if (t.month == now.month && t.year == now.year && t.day == now.day) {
    return time__Time_get_fmt_time_str(t, time__time__FormatTime_hhmm24);
  };
  if (t.year == now.year) {
    return time__Time_get_fmt_str(t, time__time__FormatDelimiter_space,
                                  time__time__FormatTime_hhmm24,
                                  time__time__FormatDate_mmmd);
  };
  return time__Time_format(t);
}
string time__Time_clean12(time__Time t) {
  time__Time now = time__now();
  if (t.month == now.month && t.year == now.year && t.day == now.day) {
    return time__Time_get_fmt_time_str(t, time__time__FormatTime_hhmm12);
  };
  if (t.year == now.year) {
    return time__Time_get_fmt_str(t, time__time__FormatDelimiter_space,
                                  time__time__FormatTime_hhmm12,
                                  time__time__FormatDate_mmmd);
  };
  return time__Time_format(t);
}
string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time) {
  if (fmt_time == time__time__FormatTime_no_time) {
    return tos3("");
  };
  string tp = ((t.hour > 11) ? (tos3("p.m.")) : (tos3("a.m.")));
  int hour =
      ((t.hour > 12) ? (t.hour - 12) : (((t.hour == 0) ? (12) : (t.hour))));
  time__FormatTime tmp1 = fmt_time;

  return (
      (tmp1 == time__time__FormatTime_hhmm12)
          ? (_STR("%d:%02d %.*s", hour, t.minute, tp.len, tp.str))
          : ((tmp1 == time__time__FormatTime_hhmm24)
                 ? (_STR("%02d:%02d", t.hour, t.minute))
                 : ((tmp1 == time__time__FormatTime_hhmmss12)
                        ? (_STR("%d:%02d:%02d %.*s", hour, t.minute, t.second,
                                tp.len, tp.str))
                        : ((tmp1 == time__time__FormatTime_hhmmss24)
                               ? (_STR("%02d:%02d:%02d", t.hour, t.minute,
                                       t.second))
                               : (_STR("unknown enumeration %d", fmt_time))))));
}
string time__Time_get_fmt_date_str(time__Time t,
                                   time__FormatDelimiter fmt_dlmtr,
                                   time__FormatDate fmt_date) {
  if (fmt_date == time__time__FormatDate_no_date) {
    return tos3("");
  };
  string month =
      _STR("%.*s", time__Time_smonth(t).len, time__Time_smonth(t).str);
  string year = string_substr2(int_str(t.year), 2, -1, true);
  time__FormatDate tmp4 = fmt_date;

  time__FormatDelimiter tmp5 = fmt_dlmtr;

  return string_replace(
      ((tmp4 == time__time__FormatDate_ddmmyy)
           ? (_STR("%02d|%02d|%.*s", t.day, t.month, year.len, year.str))
           : ((tmp4 == time__time__FormatDate_ddmmyyyy)
                  ? (_STR("%02d|%02d|%d", t.day, t.month, t.year))
                  : ((tmp4 == time__time__FormatDate_mmddyy)
                         ? (_STR("%02d|%02d|%.*s", t.month, t.day, year.len,
                                 year.str))
                         : ((tmp4 == time__time__FormatDate_mmddyyyy)
                                ? (_STR("%02d|%02d|%d", t.month, t.day, t.year))
                                : ((tmp4 == time__time__FormatDate_mmmd)
                                       ? (_STR("%.*s|%d", month.len, month.str,
                                               t.day))
                                       : ((tmp4 == time__time__FormatDate_mmmdd)
                                              ? (_STR("%.*s|%02d", month.len,
                                                      month.str, t.day))
                                              : ((tmp4 ==
                                                  time__time__FormatDate_mmmddyyyy)
                                                     ? (_STR("%.*s|%02d|%d",
                                                             month.len,
                                                             month.str, t.day,
                                                             t.year))
                                                     : ((tmp4 ==
                                                         time__time__FormatDate_yyyymmdd)
                                                            ? (_STR("%d|%02d|%"
                                                                    "02d",
                                                                    t.year,
                                                                    t.month,
                                                                    t.day))
                                                            : (_STR(
                                                                  "unknown "
                                                                  "enumeration "
                                                                  "%d",
                                                                  fmt_date)))))))))),
      tos3("|"),
      ((tmp5 == time__time__FormatDelimiter_dot)
           ? (tos3("."))
           : ((tmp5 == time__time__FormatDelimiter_hyphen)
                  ? (tos3("-"))
                  : ((tmp5 == time__time__FormatDelimiter_slash)
                         ? (tos3("/"))
                         : ((tmp5 == time__time__FormatDelimiter_space)
                                ? (tos3(" "))
                                : (_STR("unknown enumeration %d",
                                        fmt_dlmtr)))))));
}
string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr,
                              time__FormatTime fmt_time,
                              time__FormatDate fmt_date) {
  if (fmt_date == time__time__FormatDate_no_date) {
    if (fmt_time == time__time__FormatTime_no_time) {
      return tos3("");
    } else {
      return time__Time_get_fmt_time_str(t, fmt_time);
    };
  } else {
    if (fmt_time != time__time__FormatTime_no_time) {
      return string_add(
          string_add(time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date),
                     tos3(" ")),
          time__Time_get_fmt_time_str(t, fmt_time));
    } else {
      return time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date);
    };
  };
}
Option_time__Time time__parse(string s) {
  Option_int tmp1 = string_index(s, tos3(" "));
  int pos;
  if (!tmp1.ok) {
    string err = tmp1.error;
    int errcode = tmp1.ecode;
    return v_error(_STR("Invalid time format: %.*s", s.len, s.str));
  }
  pos = *(int *)tmp1.data;
  ;
  string symd = string_substr2(s, 0, pos, false);
  array_string ymd = string_split(symd, tos3("-"));
  if (ymd.len != 3) {
    return v_error(_STR("Invalid time format: %.*s", s.len, s.str));
  };
  string shms = string_substr2(s, pos, -1, true);
  array_string hms = string_split(shms, tos3(":"));
  string hour = string_substr2((*(string *)array_get(hms, 0)), 1, -1, true);
  string minute = (*(string *)array_get(hms, 1));
  string second = (*(string *)array_get(hms, 2));
  time__Time tmp20 = OPTION_CAST(time__Time)(time__new_time(
      (time__Time){.year = v_string_int((*(string *)array_get(ymd, 0))),
                   .month = v_string_int((*(string *)array_get(ymd, 1))),
                   .day = v_string_int((*(string *)array_get(ymd, 2))),
                   .hour = v_string_int(hour),
                   .minute = v_string_int(minute),
                   .second = v_string_int(second),
                   .v_unix = 0}));
  return opt_ok(&tmp20, sizeof(time__Time));
}
Option_time__Time time__parse_rfc2822(string s) {
  array_string fields = string_split(s, tos3(" "));
  if (fields.len < 5) {
    return v_error(_STR("Invalid time format: %.*s", s.len, s.str));
  };
  Option_int tmp23 =
      string_index(time__months_string, (*(string *)array_get(fields, 2)));
  int pos;
  if (!tmp23.ok) {
    string err = tmp23.error;
    int errcode = tmp23.ecode;
    return v_error(_STR("Invalid time format: %.*s", s.len, s.str));
  }
  pos = *(int *)tmp23.data;
  ;
  int mm = pos / 3 + 1;
  byteptr tmstr = ((byteptr)(0));
  { tmstr = v_malloc(s.len * 2); };
  int count = sprintf(((charptr)(tmstr)), (char *)tos3("%s-%02d-%s %s").str,
                      (char *)(*(string *)array_get(fields, 3)).str, mm,
                      (char *)(*(string *)array_get(fields, 1)).str,
                      (char *)(*(string *)array_get(fields, 4)).str);
  Option_time__Time tmp30 = time__parse(tos(tmstr, count));
  time__Time t;
  if (!tmp30.ok) {
    string err = tmp30.error;
    int errcode = tmp30.ecode;
    return v_error(_STR("Invalid time format: %.*s", s.len, s.str));
  }
  t = *(time__Time *)tmp30.data;
  ;
  time__Time tmp31 = OPTION_CAST(time__Time)(t);
  return opt_ok(&tmp31, sizeof(time__Time));
}
time__Time time__now() {
  time_t t = time(0);
  struct /*C.Foo(0)*/

      tm *now = 0;
  now = localtime(&t);
  return time__convert_ctime(*now);
}
string time__Time_smonth(time__Time t) {
  int i = t.month - 1;
  return string_substr2(time__months_string, i * 3, (i + 1) * 3, false);
}
time__Time time__new_time(time__Time t) {
  return (time__Time){.year = t.year,
                      .month = t.month,
                      .day = t.day,
                      .hour = t.hour,
                      .minute = t.minute,
                      .second = t.second,
                      .v_unix = time__Time_calc_unix(&/* ? */ t)};
}
int time__Time_calc_unix(time__Time *t) {
  if (t->v_unix != 0) {
    return t->v_unix;
  }

  struct /*TM*/ tm tt = (struct tm){.tm_sec = t->second,
                                    .tm_min = t->minute,
                                    .tm_hour = t->hour,
                                    .tm_mday = t->day,
                                    .tm_mon = t->month - 1,
                                    .tm_year = t->year - 1900};
  return time__make_unix_time(tt);
}
time__Time time__Time_add_seconds(time__Time t, int seconds) {
  return time__unix(t.v_unix + seconds);
}
time__Time time__Time_add_days(time__Time t, int days) {
  return time__unix(t.v_unix + days * 3600 * 24);
}
int time__since(time__Time t) { return 0; }
string time__Time_relative(time__Time t) {
  time__Time now = time__now();
  int secs = now.v_unix - t.v_unix;
  if (secs <= 30) {
    return tos3("now");
  };
  if (secs < 60) {
    return tos3("1m");
  };
  if (secs < 3600) {
    return _STR("%dm", secs / 60);
  };
  if (secs < 3600 * 24) {
    return _STR("%dh", secs / 3600);
  };
  if (secs < 3600 * 24 * 5) {
    return _STR("%dd", secs / 3600 / 24);
  };
  if (secs > 3600 * 24 * 10000) {
    return tos3("");
  };
  return time__Time_md(t);
}
int time__day_of_week(int y, int m, int d) {
  array_int t = new_array_from_c_array(
      12, 12, sizeof(int),
      EMPTY_ARRAY_OF_ELEMS(int, 12){0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4});
  int sy = y;
  if ((m < 3)) {
    sy = sy - 1;
  };
  return (sy + sy / 4 - sy / 100 + sy / 400 + (*(int *)array_get(t, m - 1)) +
          d - 1) %
             7 +
         1;
}
int time__Time_day_of_week(time__Time t) {
  return time__day_of_week(t.year, t.month, t.day);
}
string time__Time_weekday_str(time__Time t) {
  int i = time__Time_day_of_week(t) - 1;
  return string_substr2(time__days_string, i * 3, (i + 1) * 3, false);
}
i64 time__ticks() {
#ifdef _WIN32
  return GetTickCount();
#else
  struct /*c struct init*/

      timeval ts;
  gettimeofday(&ts, 0);
  return ((i64)(ts.tv_sec * ((u64)(1000)) + (ts.tv_usec / ((u64)(1000)))));
#endif
  ;
}
void time__sleep(int seconds) {
#ifdef _WIN32
  Sleep(seconds * 1000);
#else
  sleep(seconds);
#endif
  ;
}
void time__sleep_ms(int milliseconds) {
#ifdef _WIN32
  Sleep(milliseconds);
#else
  usleep(milliseconds * 1000);
#endif
  ;
}
void time__usleep(int microseconds) {
#ifdef _WIN32
  int milliseconds = microseconds / 1000;
  Sleep(milliseconds);
#else
  usleep(microseconds);
#endif
  ;
}
bool time__is_leap_year(int year) {
  return (year % 4 == 0) && (year % 100 != 0 || year % 400 == 0);
}
Option_int time__days_in_month(int month, int year) {
  if (month > 12 || month < 1) {
    return v_error(_STR("Invalid month: %d", month));
  };
  int extra = ((month == 2 && time__is_leap_year(year)) ? (1) : (0));
  int res = (*(int *)array_get(time__month_days, month - 1)) + extra;
  int tmp9 = OPTION_CAST(int)(res);
  return opt_ok(&tmp9, sizeof(int));
}
string time__Time_str(time__Time t) { return time__Time_format_ss(t); }
time__Time time__convert_ctime(struct /*TM*/ tm t) {
  return (time__Time){.year = t.tm_year + 1900,
                      .month = t.tm_mon + 1,
                      .day = t.tm_mday,
                      .hour = t.tm_hour,
                      .minute = t.tm_min,
                      .second = t.tm_sec,
                      .v_unix = time__make_unix_time(t)};
}
int time__make_unix_time(struct /*TM*/ tm t) { return ((int)(_mkgmtime(&t))); }
time__Time time__unix(int abs) {
  int day_offset = abs / time__seconds_per_day;
  if (abs % time__seconds_per_day < 0) {
    day_offset--;
  };
  _V_MulRet_int_V_int_V_int _V_mret_34_year_month_day =
      time__calculate_date_from_offset(day_offset);
  int year = _V_mret_34_year_month_day.var_0;
  int month = _V_mret_34_year_month_day.var_1;
  int day = _V_mret_34_year_month_day.var_2;
  _V_MulRet_int_V_int_V_int _V_mret_44_hr_min_sec =
      time__calculate_time_from_offset(abs % time__seconds_per_day);
  int hr = _V_mret_44_hr_min_sec.var_0;
  int min = _V_mret_44_hr_min_sec.var_1;
  int sec = _V_mret_44_hr_min_sec.var_2;
  return (time__Time){.year = year,
                      .month = month,
                      .day = day,
                      .hour = hr,
                      .minute = min,
                      .second = sec,
                      .v_unix = abs};
}
static inline _V_MulRet_int_V_int_V_int
time__calculate_date_from_offset(int day_offset_) {
  int day_offset = day_offset_;
  int year = 2001;
  day_offset -= 31 * 365 + 8;
  year += (day_offset / time__days_per_400_years) * 400;
  day_offset %= time__days_per_400_years;
  if (day_offset == time__days_per_100_years * 4) {
    year += 300;
    day_offset -= time__days_per_100_years * 3;
  } else {
    year += (day_offset / time__days_per_100_years) * 100;
    day_offset %= time__days_per_100_years;
  };
  if (day_offset == time__days_per_4_years * 25) {
    year += 96;
    day_offset -= time__days_per_4_years * 24;
  } else {
    year += (day_offset / time__days_per_4_years) * 4;
    day_offset %= time__days_per_4_years;
  };
  if (day_offset == 365 * 4) {
    year += 3;
    day_offset -= 365 * 3;
  } else {
    year += (day_offset / 365);
    day_offset %= 365;
  };
  if (day_offset < 0) {
    year--;
    if (time__is_leap_year(year)) {
      day_offset += 366;
    } else {
      day_offset += 365;
    };
  };
  if (time__is_leap_year(year)) {
    if (day_offset > 31 + 29 - 1) {
      day_offset--;
    } else if (day_offset == 31 + 29 - 1) {
      return (_V_MulRet_int_V_int_V_int){
          .var_0 = year, .var_1 = 2, .var_2 = 29};
    };
  };
  int estimated_month = day_offset / 31;
  while (day_offset >=
         (*(int *)array_get(time__days_before, estimated_month + 1))) {

    estimated_month++;
  };
  while (day_offset < (*(int *)array_get(time__days_before, estimated_month))) {

    if (estimated_month == 0) {
      break;
    };
    estimated_month--;
  };
  day_offset -= (*(int *)array_get(time__days_before, estimated_month));
  return (_V_MulRet_int_V_int_V_int){
      .var_0 = year, .var_1 = estimated_month + 1, .var_2 = day_offset + 1};
}
static inline _V_MulRet_int_V_int_V_int
time__calculate_time_from_offset(int second_offset_) {
  int second_offset = second_offset_;
  if (second_offset < 0) {
    second_offset += time__seconds_per_day;
  };
  int hour = second_offset / time__seconds_per_hour;
  second_offset %= time__seconds_per_hour;
  int min = second_offset / time__seconds_per_minute;
  second_offset %= time__seconds_per_minute;
  return (_V_MulRet_int_V_int_V_int){
      .var_0 = hour, .var_1 = min, .var_2 = second_offset};
}
array_string os_dot_cmdline__options(array_string args, string param) {
  array_string flags = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_string tmp1 = args;
  for (int i = 0; i < tmp1.len; i++) {
    string v = ((string *)tmp1.data)[i];

    if (string_eq(v, param)) {
      if (i + 1 < args.len) {
        _PUSH(&flags,
              (/*typ = array_string   tmp_typ=string*/ (
                  *(string *)array_get(args, i + 1))),
              tmp2, string);
      };
    };
  };
  return flags;
}
string os_dot_cmdline__option(array_string args, string param, string def) {
  bool found = 0;
  array_string tmp5 = args;
  for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
    string arg = ((string *)tmp5.data)[tmp6];

    if (found) {
      return arg;
    } else if (string_eq(param, arg)) {
      found = 1;
    };
  };
  return def;
}
array_string os_dot_cmdline__options_before(array_string args,
                                            array_string what) {
  bool found = 0;
  array_string args_before = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_string tmp7 = args;
  for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
    string a = ((string *)tmp7.data)[tmp8];

    if ((_IN(string, (a), what))) {
      found = 1;
      break;
    };
    _PUSH(&args_before, (/*typ = array_string   tmp_typ=string*/ a), tmp9,
          string);
  };
  return args_before;
}
array_string os_dot_cmdline__options_after(array_string args,
                                           array_string what) {
  bool found = 0;
  array_string args_after = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_string tmp10 = args;
  for (int tmp11 = 0; tmp11 < tmp10.len; tmp11++) {
    string a = ((string *)tmp10.data)[tmp11];

    if ((_IN(string, (a), what))) {
      found = 1;
      continue;
    };
    if (found) {
      _PUSH(&args_after, (/*typ = array_string   tmp_typ=string*/ a), tmp12,
            string);
    };
  };
  return args_after;
}
array_string os_dot_cmdline__only_non_options(array_string args) {

  array_string tmp13 = new_array(0, args.len, sizeof(string));
  for (int i = 0; i < args.len; i++) {
    string it = ((string *)args.data)[i];
    if (!string_starts_with(it, tos3("-")))
      array_push(&tmp13, &it);
  }
  return tmp13;
}
array_string os_dot_cmdline__only_options(array_string args) {

  array_string tmp14 = new_array(0, args.len, sizeof(string));
  for (int i = 0; i < args.len; i++) {
    string it = ((string *)args.data)[i];
    if (string_starts_with(it, tos3("-")))
      array_push(&tmp14, &it);
  }
  return tmp14;
}
static inline v_dot_token__Position
v_dot_token__Token_position(v_dot_token__Token *tok) {
  return (v_dot_token__Position){.line_nr = tok->line_nr - 1, .pos = tok->pos};
}
map_int v_dot_token__build_keys() {
  map_int res = new_map(1, sizeof(int));
  for (int t = ((int)(v_dot_token__v_dot_token__Kind_keyword_beg)) + 1;
       t < ((int)(v_dot_token__v_dot_token__Kind_keyword_end)); t++) {

    string key = (*(string *)array_get(v_dot_token__token_str, t));
    map_set(&res, key, &(int[]){t});
  };
  return res;
}
array_string v_dot_token__build_token_str() {
  array_string s = array_repeat(
      new_array_from_c_array(1, 1, sizeof(string),
                             EMPTY_ARRAY_OF_ELEMS(string, 1){tos3("")}),
      v_dot_token__nr_tokens);
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_keyword_beg,
            &(string[]){tos3("")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_keyword_end,
            &(string[]){tos3("")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_eof,
            &(string[]){tos3("eof")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_name,
            &(string[]){tos3("name")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_number,
            &(string[]){tos3("number")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_string,
            &(string[]){tos3("STR")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_chartoken,
            &(string[]){tos3("char")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_plus,
            &(string[]){tos3("+")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_minus,
            &(string[]){tos3("-")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_mul,
            &(string[]){tos3("*")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_div,
            &(string[]){tos3("/")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_mod,
            &(string[]){tos3("%")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_xor,
            &(string[]){tos3("^")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_bit_not,
            &(string[]){tos3("~")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_pipe,
            &(string[]){tos3("|")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_hash,
            &(string[]){tos3("#")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_amp,
            &(string[]){tos3("&")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_inc,
            &(string[]){tos3("++")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_dec,
            &(string[]){tos3("--")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_and,
            &(string[]){tos3("&&")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_logical_or,
            &(string[]){tos3("||")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_not,
            &(string[]){tos3("!")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_dot,
            &(string[]){tos3(".")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_dotdot,
            &(string[]){tos3("..")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_ellipsis,
            &(string[]){tos3("...")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_comma,
            &(string[]){tos3(",")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_semicolon,
            &(string[]){tos3(";")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_colon,
            &(string[]){tos3(":")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_arrow,
            &(string[]){tos3("=>")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_assign,
            &(string[]){tos3("=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_decl_assign,
            &(string[]){tos3(":=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_plus_assign,
            &(string[]){tos3("+=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_minus_assign,
            &(string[]){tos3("-=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_mult_assign,
            &(string[]){tos3("*=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_div_assign,
            &(string[]){tos3("/=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_xor_assign,
            &(string[]){tos3("^=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_mod_assign,
            &(string[]){tos3("%=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_or_assign,
            &(string[]){tos3("|=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_and_assign,
            &(string[]){tos3("&=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_right_shift_assign,
            &(string[]){tos3(">>=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_left_shift_assign,
            &(string[]){tos3("<<=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_lcbr,
            &(string[]){tos3("{")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_rcbr,
            &(string[]){tos3("}")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_lpar,
            &(string[]){tos3("(")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_rpar,
            &(string[]){tos3(")")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_lsbr,
            &(string[]){tos3("[")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_rsbr,
            &(string[]){tos3("]")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_eq,
            &(string[]){tos3("==")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_ne,
            &(string[]){tos3("!=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_gt,
            &(string[]){tos3(">")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_lt,
            &(string[]){tos3("<")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_ge,
            &(string[]){tos3(">=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_le,
            &(string[]){tos3("<=")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_question,
            &(string[]){tos3("?")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_left_shift,
            &(string[]){tos3("<<")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_right_shift,
            &(string[]){tos3(">>")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_line_comment,
            &(string[]){tos3("// line comment")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_mline_comment,
            &(string[]){tos3("/* mline comment */")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_nl,
            &(string[]){tos3("NLL")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_dollar,
            &(string[]){tos3("$")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_str_dollar,
            &(string[]){tos3("$2")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_assert,
            &(string[]){tos3("assert")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_struct,
            &(string[]){tos3("struct")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_if,
            &(string[]){tos3("if")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_else,
            &(string[]){tos3("else")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_asm,
            &(string[]){tos3("asm")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_return,
            &(string[]){tos3("return")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_module,
            &(string[]){tos3("module")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_sizeof,
            &(string[]){tos3("sizeof")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_go,
            &(string[]){tos3("go")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_goto,
            &(string[]){tos3("goto")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_const,
            &(string[]){tos3("const")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_mut,
            &(string[]){tos3("mut")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_type,
            &(string[]){tos3("type")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_for,
            &(string[]){tos3("for")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_switch,
            &(string[]){tos3("switch")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_fn,
            &(string[]){tos3("fn")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_true,
            &(string[]){tos3("true")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_false,
            &(string[]){tos3("false")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_continue,
            &(string[]){tos3("continue")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_break,
            &(string[]){tos3("break")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_import,
            &(string[]){tos3("import")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_embed,
            &(string[]){tos3("embed")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_unsafe,
            &(string[]){tos3("unsafe")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_enum,
            &(string[]){tos3("enum")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_interface,
            &(string[]){tos3("interface")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_pub,
            &(string[]){tos3("pub")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_import_const,
            &(string[]){tos3("import_const")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_in,
            &(string[]){tos3("in")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_atomic,
            &(string[]){tos3("atomic")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_orelse,
            &(string[]){tos3("or")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_global,
            &(string[]){tos3("__global")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_union,
            &(string[]){tos3("union")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_static,
            &(string[]){tos3("static")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_as,
            &(string[]){tos3("as")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_defer,
            &(string[]){tos3("defer")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_match,
            &(string[]){tos3("match")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_select,
            &(string[]){tos3("select")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_none,
            &(string[]){tos3("none")});
  array_set(&/*q*/ s, v_dot_token__v_dot_token__Kind_key_offsetof,
            &(string[]){tos3("__offsetof")});
  return s;
}
v_dot_token__Kind v_dot_token__key_to_token(string key) {
  int tmp3 = 0;
  bool tmp4 = map_get(/*token.v : 257*/ v_dot_token__keywords, key, &tmp3);

  v_dot_token__Kind a = ((v_dot_token__Kind)(tmp3));
  return a;
}
bool v_dot_token__is_key(string key) {
  return ((int)(v_dot_token__key_to_token(key))) > 0;
}
bool v_dot_token__is_decl(v_dot_token__Kind t) {
  return (t == v_dot_token__v_dot_token__Kind_key_enum ||
          t == v_dot_token__v_dot_token__Kind_key_interface ||
          t == v_dot_token__v_dot_token__Kind_key_fn ||
          t == v_dot_token__v_dot_token__Kind_key_struct ||
          t == v_dot_token__v_dot_token__Kind_key_type ||
          t == v_dot_token__v_dot_token__Kind_key_const ||
          t == v_dot_token__v_dot_token__Kind_key_import_const ||
          t == v_dot_token__v_dot_token__Kind_key_pub ||
          t == v_dot_token__v_dot_token__Kind_eof);
}
bool v_dot_token__Kind_is_assign(v_dot_token__Kind t) {
  return (_IN(v_dot_token__Kind, (t), v_dot_token__assign_tokens));
}
bool array_v_dot_token__Kind_contains(array_v_dot_token__Kind t,
                                      v_dot_token__Kind val) {
  array_v_dot_token__Kind tmp5 = t;
  for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
    v_dot_token__Kind tt = ((v_dot_token__Kind *)tmp5.data)[tmp6];

    if (tt == val) {
      return 1;
    };
  };
  return 0;
}
string v_dot_token__Kind_str(v_dot_token__Kind t) {
  if (t == v_dot_token__v_dot_token__Kind_number) {
    return tos3("number");
  };
  if (t == v_dot_token__v_dot_token__Kind_chartoken) {
    return tos3("char");
  };
  if (t == v_dot_token__v_dot_token__Kind_string) {
    return tos3("str");
  };
  return (*(string *)array_get(v_dot_token__token_str, ((int)(t))));
}
string v_dot_token__Token_str(v_dot_token__Token t) {
  return _STR("%.*s \"%.*s\"", v_dot_token__Kind_str(t.kind).len,
              v_dot_token__Kind_str(t.kind).str, t.lit.len, t.lit.str);
}
array_v_dot_token__Precedence v_dot_token__build_precedences() {
  array_v_dot_token__Precedence p = new_array_from_c_array(
      0, 0, sizeof(v_dot_token__Precedence),
      EMPTY_ARRAY_OF_ELEMS(v_dot_token__Precedence, 0){TCCSKIP(0)});
  p = make(100, 100, sizeof(v_dot_token__Precedence));
  array_set(&/*q*/ p, v_dot_token__v_dot_token__Kind_assign,
            &(v_dot_token__Precedence[]){
                v_dot_token__v_dot_token__Precedence_assign});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_eq,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_eq});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_ne,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_eq});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_lt,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_eq});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_gt,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_eq});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_le,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_eq});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_ge,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_eq});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_plus,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_sum});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_plus_assign,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_sum});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_minus,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_sum});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_minus_assign,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_sum});
  array_set(&/*q*/ p, v_dot_token__v_dot_token__Kind_div,
            &(v_dot_token__Precedence[]){
                v_dot_token__v_dot_token__Precedence_product});
  array_set(&/*q*/ p, v_dot_token__v_dot_token__Kind_div_assign,
            &(v_dot_token__Precedence[]){
                v_dot_token__v_dot_token__Precedence_product});
  array_set(&/*q*/ p, v_dot_token__v_dot_token__Kind_mul,
            &(v_dot_token__Precedence[]){
                v_dot_token__v_dot_token__Precedence_product});
  array_set(&/*q*/ p, v_dot_token__v_dot_token__Kind_mult_assign,
            &(v_dot_token__Precedence[]){
                v_dot_token__v_dot_token__Precedence_product});
  array_set(&/*q*/ p, v_dot_token__v_dot_token__Kind_mod,
            &(v_dot_token__Precedence[]){
                v_dot_token__v_dot_token__Precedence_product});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_and,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_cond});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_logical_or,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_cond});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_lpar,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_call});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_dot,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_call});
  array_set(
      &/*q*/ p, v_dot_token__v_dot_token__Kind_lsbr,
      &(v_dot_token__Precedence[]){v_dot_token__v_dot_token__Precedence_index});
  return p;
}
int v_dot_token__Token_precedence(v_dot_token__Token tok) {
  v_dot_token__Kind tmp9 = tok.kind;

  if (tmp9 == v_dot_token__v_dot_token__Kind_lsbr) {
    return ((int)(v_dot_token__v_dot_token__Precedence_index));
  } else if (tmp9 == v_dot_token__v_dot_token__Kind_dot) {
    return ((int)(v_dot_token__v_dot_token__Precedence_call));
  } else if ((tmp9 == v_dot_token__v_dot_token__Kind_inc) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_dec)) {
    return ((int)(v_dot_token__v_dot_token__Precedence_postfix));
  } else if ((tmp9 == v_dot_token__v_dot_token__Kind_mul) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_div) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_mod) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_left_shift) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_right_shift) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_amp)) {
    return ((int)(v_dot_token__v_dot_token__Precedence_product));
  } else if ((tmp9 == v_dot_token__v_dot_token__Kind_plus) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_minus) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_pipe) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_xor)) {
    return ((int)(v_dot_token__v_dot_token__Precedence_sum));
  } else if ((tmp9 == v_dot_token__v_dot_token__Kind_eq) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_ne) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_lt) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_le) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_gt) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_ge)) {
    return ((int)(v_dot_token__v_dot_token__Precedence_eq));
  } else if ((tmp9 == v_dot_token__v_dot_token__Kind_assign) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_plus_assign) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_minus_assign) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_div_assign) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_mod_assign) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_or_assign) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_and_assign) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_left_shift_assign) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_right_shift_assign) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_mult_assign)) {
    return ((int)(v_dot_token__v_dot_token__Precedence_assign));
  } else if ((tmp9 == v_dot_token__v_dot_token__Kind_key_in) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_key_as)) {
    return ((int)(v_dot_token__v_dot_token__Precedence_in_as));
  } else if ((tmp9 == v_dot_token__v_dot_token__Kind_logical_or) ||
             (tmp9 == v_dot_token__v_dot_token__Kind_and)) {
    return ((int)(v_dot_token__v_dot_token__Precedence_cond));
  } else // default:
  {
    return ((int)(v_dot_token__v_dot_token__Precedence_lowest));
  };
}
bool v_dot_token__Token_is_scalar(v_dot_token__Token tok) {
  return (tok.kind == v_dot_token__v_dot_token__Kind_number ||
          tok.kind == v_dot_token__v_dot_token__Kind_string);
}
bool v_dot_token__Token_is_unary(v_dot_token__Token tok) {
  return (tok.kind == v_dot_token__v_dot_token__Kind_plus ||
          tok.kind == v_dot_token__v_dot_token__Kind_minus ||
          tok.kind == v_dot_token__v_dot_token__Kind_not ||
          tok.kind == v_dot_token__v_dot_token__Kind_bit_not ||
          tok.kind == v_dot_token__v_dot_token__Kind_mul ||
          tok.kind == v_dot_token__v_dot_token__Kind_amp);
}
bool v_dot_token__Kind_is_relational(v_dot_token__Kind tok) {
  return (tok == v_dot_token__v_dot_token__Kind_lt ||
          tok == v_dot_token__v_dot_token__Kind_le ||
          tok == v_dot_token__v_dot_token__Kind_gt ||
          tok == v_dot_token__v_dot_token__Kind_ge ||
          tok == v_dot_token__v_dot_token__Kind_eq ||
          tok == v_dot_token__v_dot_token__Kind_ne);
}
bool v_dot_token__Kind_is_start_of_type(v_dot_token__Kind k) {
  return (k == v_dot_token__v_dot_token__Kind_name ||
          k == v_dot_token__v_dot_token__Kind_lpar ||
          k == v_dot_token__v_dot_token__Kind_amp ||
          k == v_dot_token__v_dot_token__Kind_lsbr ||
          k == v_dot_token__v_dot_token__Kind_question);
}
bool v_dot_token__Kind_is_infix(v_dot_token__Kind kind) {
  return (kind == v_dot_token__v_dot_token__Kind_plus ||
          kind == v_dot_token__v_dot_token__Kind_minus ||
          kind == v_dot_token__v_dot_token__Kind_mod ||
          kind == v_dot_token__v_dot_token__Kind_mul ||
          kind == v_dot_token__v_dot_token__Kind_div ||
          kind == v_dot_token__v_dot_token__Kind_eq ||
          kind == v_dot_token__v_dot_token__Kind_ne ||
          kind == v_dot_token__v_dot_token__Kind_gt ||
          kind == v_dot_token__v_dot_token__Kind_lt ||
          kind == v_dot_token__v_dot_token__Kind_key_in ||
          kind == v_dot_token__v_dot_token__Kind_key_as ||
          kind == v_dot_token__v_dot_token__Kind_ge ||
          kind == v_dot_token__v_dot_token__Kind_le ||
          kind == v_dot_token__v_dot_token__Kind_logical_or ||
          kind == v_dot_token__v_dot_token__Kind_xor ||
          kind == v_dot_token__v_dot_token__Kind_and ||
          kind == v_dot_token__v_dot_token__Kind_dot ||
          kind == v_dot_token__v_dot_token__Kind_pipe ||
          kind == v_dot_token__v_dot_token__Kind_amp ||
          kind == v_dot_token__v_dot_token__Kind_left_shift ||
          kind == v_dot_token__v_dot_token__Kind_right_shift);
}
void v_dot_depgraph__OrderedDepMap_set(v_dot_depgraph__OrderedDepMap *o,
                                       string name, array_string deps) {
  if (!((_IN_MAP((name), o->data)))) {
    _PUSH(&o->keys, (/*typ = array_string   tmp_typ=string*/ name), tmp1,
          string);
  };
  map_set(&o->data, name, &(array_string[]){deps});
}
void v_dot_depgraph__OrderedDepMap_add(v_dot_depgraph__OrderedDepMap *o,
                                       string name, array_string deps) {
  array_string tmp2 = new_array(0, 1, sizeof(string));
  bool tmp3 = map_get(/*depgraph.v : 34*/ o->data, name, &tmp2);

  array_string d = tmp2;
  array_string tmp4 = deps;
  for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
    string dep = ((string *)tmp4.data)[tmp5];

    if (!((_IN(string, (dep), d)))) {
      _PUSH(&d, (/*typ = array_string   tmp_typ=string*/ dep), tmp6, string);
    };
  };
  v_dot_depgraph__OrderedDepMap_set(o, name, d);
}
array_string v_dot_depgraph__OrderedDepMap_get(v_dot_depgraph__OrderedDepMap *o,
                                               string name) {
  array_string tmp7 = new_array(0, 1, sizeof(string));
  bool tmp8 = map_get(/*depgraph.v : 44*/ o->data, name, &tmp7);

  return tmp7;
}
void v_dot_depgraph__OrderedDepMap_delete(v_dot_depgraph__OrderedDepMap *o,
                                          string name) {
  if (!((_IN_MAP((name), o->data)))) {
    v_panic(_STR("delete: no such key: %.*s", name.len, name.str));
  };
  array_string tmp9 = o->keys;
  for (int i = 0; i < tmp9.len; i++) {

    if (string_eq((*(string *)array_get(o->keys, i)), name)) {
      v_array_delete(&/* ? */ o->keys, i);
      break;
    };
  };
  v_map_delete(&/* ? */ o->data, name);
}
void v_dot_depgraph__OrderedDepMap_apply_diff(v_dot_depgraph__OrderedDepMap *o,
                                              string name, array_string deps) {
  array_string diff = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_string tmp13 = new_array(0, 1, sizeof(string));
  bool tmp14 = map_get(/*depgraph.v : 61*/ o->data, name, &tmp13);

  array_string tmp12 = tmp13;
  for (int tmp15 = 0; tmp15 < tmp12.len; tmp15++) {
    string dep = ((string *)tmp12.data)[tmp15];

    if (!((_IN(string, (dep), deps)))) {
      _PUSH(&diff, (/*typ = array_string   tmp_typ=string*/ dep), tmp16,
            string);
    };
  };
  v_dot_depgraph__OrderedDepMap_set(o, name, diff);
}
int v_dot_depgraph__OrderedDepMap_size(v_dot_depgraph__OrderedDepMap *o) {
  return o->data.size;
}
v_dot_depgraph__DepGraph *v_dot_depgraph__new_dep_graph() {
  return (v_dot_depgraph__DepGraph *)memdup(
      &(v_dot_depgraph__DepGraph){
          .acyclic = 1,
          .nodes = new_array(0, 1, sizeof(v_dot_depgraph__DepGraphNode))},
      sizeof(v_dot_depgraph__DepGraph));
}
void v_dot_depgraph__DepGraph_add(v_dot_depgraph__DepGraph *graph, string mod,
                                  array_string deps) {
  _PUSH(&graph->nodes,
        (/*typ = array_v_dot_depgraph__DepGraphNode
            tmp_typ=v_dot_depgraph__DepGraphNode*/
         (v_dot_depgraph__DepGraphNode){.name = mod,
                                        .deps = array_clone(&/* ? */ deps)}),
        tmp17, v_dot_depgraph__DepGraphNode);
}
v_dot_depgraph__DepGraph *
v_dot_depgraph__DepGraph_resolve(v_dot_depgraph__DepGraph *graph) {
  v_dot_depgraph__OrderedDepMap node_names =
      (v_dot_depgraph__OrderedDepMap){.keys = new_array(0, 1, sizeof(string)),
                                      .data = new_map(1, sizeof(array_string))};
  array_v_dot_depgraph__DepGraphNode tmp18 = graph->nodes;
  for (int tmp19 = 0; tmp19 < tmp18.len; tmp19++) {
    v_dot_depgraph__DepGraphNode node =
        ((v_dot_depgraph__DepGraphNode *)tmp18.data)[tmp19];

    v_dot_depgraph__OrderedDepMap_add(&/* ? */ node_names, node.name,
                                      node.deps);
  };
  v_dot_depgraph__OrderedDepMap node_deps = node_names;
  v_dot_depgraph__DepGraph *resolved = v_dot_depgraph__new_dep_graph();
  while (v_dot_depgraph__OrderedDepMap_size(&/* ? */ node_deps) != 0) {

    array_string ready_set = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    array_string tmp20 = node_deps.keys;
    for (int tmp21 = 0; tmp21 < tmp20.len; tmp21++) {
      string name = ((string *)tmp20.data)[tmp21];

      array_string tmp22 = new_array(0, 1, sizeof(string));
      bool tmp23 = map_get(/*depgraph.v : 97*/ node_deps.data, name, &tmp22);

      array_string deps = tmp22;
      if (deps.len == 0) {
        _PUSH(&ready_set, (/*typ = array_string   tmp_typ=string*/ name), tmp24,
              string);
      };
    };
    if (ready_set.len == 0) {
      v_dot_depgraph__DepGraph *g = v_dot_depgraph__new_dep_graph();
      g->acyclic = 0;
      array_string tmp25 = node_deps.keys;
      for (int tmp26 = 0; tmp26 < tmp25.len; tmp26++) {
        string name = ((string *)tmp25.data)[tmp26];

        array_string tmp27 = new_array(0, 1, sizeof(string));
        bool tmp28 =
            map_get(/*depgraph.v : 105*/ node_names.data, name, &tmp27);

        v_dot_depgraph__DepGraph_add(g, name, tmp27);
      };
      return g;
    };
    array_string tmp29 = ready_set;
    for (int tmp30 = 0; tmp30 < tmp29.len; tmp30++) {
      string name = ((string *)tmp29.data)[tmp30];

      v_dot_depgraph__OrderedDepMap_delete(&/* ? */ node_deps, name);
      array_string tmp31 = new_array(0, 1, sizeof(string));
      bool tmp32 = map_get(/*depgraph.v : 111*/ node_names.data, name, &tmp31);

      v_dot_depgraph__DepGraph_add(resolved, name, tmp31);
    };
    array_string tmp33 = node_deps.keys;
    for (int tmp34 = 0; tmp34 < tmp33.len; tmp34++) {
      string name = ((string *)tmp33.data)[tmp34];

      v_dot_depgraph__OrderedDepMap_apply_diff(&/* ? */ node_deps, name,
                                               ready_set);
    };
  };
  return resolved;
}
v_dot_depgraph__DepGraphNode
v_dot_depgraph__DepGraph_last_node(v_dot_depgraph__DepGraph *graph) {
  return (*(v_dot_depgraph__DepGraphNode *)array_get(graph->nodes,
                                                     graph->nodes.len - 1));
}
string v_dot_depgraph__DepGraph_display(v_dot_depgraph__DepGraph *graph) {
  string out = tos3("\n");
  array_v_dot_depgraph__DepGraphNode tmp37 = graph->nodes;
  for (int tmp38 = 0; tmp38 < tmp37.len; tmp38++) {
    v_dot_depgraph__DepGraphNode node =
        ((v_dot_depgraph__DepGraphNode *)tmp37.data)[tmp38];

    array_string tmp39 = node.deps;
    for (int tmp40 = 0; tmp40 < tmp39.len; tmp40++) {
      string dep = ((string *)tmp39.data)[tmp40];

      out = string_add(out, _STR(" * %.*s -> %.*s\n", node.name.len,
                                 node.name.str, dep.len, dep.str));
    };
  };
  return out;
}
string
v_dot_depgraph__DepGraph_display_cycles(v_dot_depgraph__DepGraph *graph) {
  map_v_dot_depgraph__DepGraphNode node_names =
      new_map(1, sizeof(v_dot_depgraph__DepGraphNode));
  array_v_dot_depgraph__DepGraphNode tmp41 = graph->nodes;
  for (int tmp42 = 0; tmp42 < tmp41.len; tmp42++) {
    v_dot_depgraph__DepGraphNode node =
        ((v_dot_depgraph__DepGraphNode *)tmp41.data)[tmp42];

    map_set(&node_names, node.name, &(v_dot_depgraph__DepGraphNode[]){node});
  };
  string out = tos3("\n");
  array_v_dot_depgraph__DepGraphNode tmp43 = graph->nodes;
  for (int tmp44 = 0; tmp44 < tmp43.len; tmp44++) {
    v_dot_depgraph__DepGraphNode node =
        ((v_dot_depgraph__DepGraphNode *)tmp43.data)[tmp44];

    array_string tmp45 = node.deps;
    for (int tmp46 = 0; tmp46 < tmp45.len; tmp46++) {
      string dep = ((string *)tmp45.data)[tmp46];

      if (!((_IN_MAP((dep), node_names)))) {
        continue;
      };
      v_dot_depgraph__DepGraphNode tmp47 = {0};
      bool tmp48 = map_get(/*depgraph.v : 146*/ node_names, dep, &tmp47);

      v_dot_depgraph__DepGraphNode dn = tmp47;
      if ((_IN(string, (node.name), dn.deps))) {
        out = string_add(out, _STR(" * %.*s -> %.*s\n", node.name.len,
                                   node.name.str, dep.len, dep.str));
      };
    };
  };
  return out;
}
string strconv_dot_ftoa__Dec32_get_string_32(strconv_dot_ftoa__Dec32 d,
                                             bool neg, int n_digit) {
  u32 out = d.m;
  int out_len = strconv_dot_ftoa__decimal_len_32(out);
  array_byte buf = array_repeat(
      new_array_from_c_array(1, 1, sizeof(byte),
                             EMPTY_ARRAY_OF_ELEMS(byte, 1){((byte)(0))}),
      out_len + 5 + 1 + 1);
  int i = 0;
  if (n_digit > 0 && out_len > n_digit) {
    out_len = n_digit + 1;
  };
  if (neg) {
    array_set(&/*q*/ buf, i, &(byte[]){'-'});
    i++;
  };
  int disp = 0;
  if (out_len <= 1) {
    disp = 1;
  };
  int y = i + out_len;
  int x = 0;
  while (x < (out_len - disp - 1)) {

    array_set(&/*q*/ buf, y - x, &(byte[]){'0' + ((byte)(out % 10))});
    out /= 10;
    i++;
    x++;
  };
  if (out_len >= 1) {
    array_set(&/*q*/ buf, y - x, &(byte[]){'.'});
    x++;
    i++;
  };
  if (y - x >= 0) {
    array_set(&/*q*/ buf, y - x, &(byte[]){'0' + ((byte)(out % 10))});
    i++;
  };
  array_set(&/*q*/ buf, i, &(byte[]){'e'});
  i++;
  int exp = d.e + out_len - 1;
  if (exp < 0) {
    array_set(&/*q*/ buf, i, &(byte[]){'-'});
    i++;
    exp = -exp;
  } else {
    array_set(&/*q*/ buf, i, &(byte[]){'+'});
    i++;
  };
  int d1 = exp % 10;
  int d0 = exp / 10;
  array_set(&/*q*/ buf, i, &(byte[]){'0' + ((byte)(d0))});
  i++;
  array_set(&/*q*/ buf, i, &(byte[]){'0' + ((byte)(d1))});
  i++;
  array_set(&/*q*/ buf, i, &(byte[]){0});
  return tos(((byteptr)(&(*(byte *)array_get(buf, 0)))), i);
}
_V_MulRet_strconv_dot_ftoa__Dec32_V_bool
strconv_dot_ftoa__f32_to_decimal_exact_int(u32 i_mant, u32 exp) {
  strconv_dot_ftoa__Dec32 d =
      (strconv_dot_ftoa__Dec32){.m = ((u32)(0)), .e = 0};
  u32 e = exp - strconv_dot_ftoa__bias32;
  if (e > strconv_dot_ftoa__mantbits32) {
    return (_V_MulRet_strconv_dot_ftoa__Dec32_V_bool){.var_0 = d, .var_1 = 0};
  };
  u32 shift = strconv_dot_ftoa__mantbits32 - e;
  u32 mant = i_mant | 0x00800000;
  d.m = mant >> shift;
  if ((d.m << shift) != mant) {
    return (_V_MulRet_strconv_dot_ftoa__Dec32_V_bool){.var_0 = d, .var_1 = 0};
  };
  while ((d.m % 10) == 0) {

    d.m /= 10;
    d.e++;
  };
  return (_V_MulRet_strconv_dot_ftoa__Dec32_V_bool){.var_0 = d, .var_1 = 1};
}
strconv_dot_ftoa__Dec32 strconv_dot_ftoa__f32_to_decimal(u32 mant, u32 exp) {
  int e2 = 0;
  u32 m2 = ((u32)(0));
  if (exp == 0) {
    e2 = 1 - strconv_dot_ftoa__bias32 - strconv_dot_ftoa__mantbits32 - 2;
    m2 = mant;
  } else {
    e2 = ((int)(exp)) - strconv_dot_ftoa__bias32 -
         strconv_dot_ftoa__mantbits32 - 2;
    m2 = (((u32)(1)) << strconv_dot_ftoa__mantbits32) | mant;
  };
  bool even = (m2 & 1) == 0;
  bool accept_bounds = even;
  u32 mv = ((u32)(4 * m2));
  u32 mp = ((u32)(4 * m2 + 2));
  u32 mm_shift = strconv_dot_ftoa__bool_to_u32(mant != 0 || exp <= 1);
  u32 mm = ((u32)(4 * m2 - 1 - mm_shift));
  u32 vr = ((u32)(0));
  u32 vp = ((u32)(0));
  u32 vm = ((u32)(0));
  int e10 = 0;
  bool vm_is_trailing_zeros = 0;
  bool vr_is_trailing_zeros = 0;
  byte last_removed_digit = ((byte)(0));
  if (e2 >= 0) {
    u32 q = strconv_dot_ftoa__log10_pow2(e2);
    e10 = ((int)(q));
    int k = strconv_dot_ftoa__pow5_inv_num_bits_32 +
            strconv_dot_ftoa__pow5_bits(((int)(q))) - 1;
    int i = -e2 + ((int)(q)) + k;
    vr = strconv_dot_ftoa__mul_pow5_invdiv_pow2(mv, q, i);
    vp = strconv_dot_ftoa__mul_pow5_invdiv_pow2(mp, q, i);
    vm = strconv_dot_ftoa__mul_pow5_invdiv_pow2(mm, q, i);
    if (q != 0 && (vp - 1) / 10 <= vm / 10) {
      int l = strconv_dot_ftoa__pow5_inv_num_bits_32 +
              strconv_dot_ftoa__pow5_bits(((int)(q - 1))) - 1;
      last_removed_digit = ((byte)(strconv_dot_ftoa__mul_pow5_invdiv_pow2(
                                       mv, q - 1, -e2 + ((int)(q - 1)) + l) %
                                   10));
    };
    if (q <= 9) {
      if (mv % 5 == 0) {
        vr_is_trailing_zeros =
            strconv_dot_ftoa__multiple_of_power_of_five_32(mv, q);
      } else if (accept_bounds) {
        vm_is_trailing_zeros =
            strconv_dot_ftoa__multiple_of_power_of_five_32(mm, q);
      } else if (strconv_dot_ftoa__multiple_of_power_of_five_32(mp, q)) {
        vp--;
      };
    };
  } else {
    u32 q = strconv_dot_ftoa__log10_pow5(-e2);
    e10 = ((int)(q)) + e2;
    int i = -e2 - ((int)(q));
    int k = strconv_dot_ftoa__pow5_bits(i) - strconv_dot_ftoa__pow5_num_bits_32;
    int j = ((int)(q)) - k;
    vr = strconv_dot_ftoa__mul_pow5_div_pow2(mv, ((u32)(i)), j);
    vp = strconv_dot_ftoa__mul_pow5_div_pow2(mp, ((u32)(i)), j);
    vm = strconv_dot_ftoa__mul_pow5_div_pow2(mm, ((u32)(i)), j);
    if (q != 0 && ((vp - 1) / 10) <= vm / 10) {
      j = ((int)(q)) - 1 -
          (strconv_dot_ftoa__pow5_bits(i + 1) -
           strconv_dot_ftoa__pow5_num_bits_32);
      last_removed_digit = ((byte)(
          strconv_dot_ftoa__mul_pow5_div_pow2(mv, ((u32)(i + 1)), j) % 10));
    };
    if (q <= 1) {
      vr_is_trailing_zeros = 1;
      if (accept_bounds) {
        vm_is_trailing_zeros = mm_shift == 1;
      } else {
        vp--;
      };
    } else if (q < 31) {
      vr_is_trailing_zeros =
          strconv_dot_ftoa__multiple_of_power_of_two_32(mv, q - 1);
    };
  };
  int removed = 0;
  u32 out = ((u32)(0));
  if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
    while (vp / 10 > vm / 10) {

      vm_is_trailing_zeros = vm_is_trailing_zeros && (vm % 10) == 0;
      vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
      last_removed_digit = ((byte)(vr % 10));
      vr /= 10;
      vp /= 10;
      vm /= 10;
      removed++;
    };
    if (vm_is_trailing_zeros) {
      while (vm % 10 == 0) {

        vr_is_trailing_zeros =
            vr_is_trailing_zeros && (last_removed_digit == 0);
        last_removed_digit = ((byte)(vr % 10));
        vr /= 10;
        vp /= 10;
        vm /= 10;
        removed++;
      };
    };
    if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2) == 0) {
      last_removed_digit = 4;
    };
    out = vr;
    if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) ||
        last_removed_digit >= 5) {
      out++;
    };
  } else {
    while (vp / 10 > vm / 10) {

      last_removed_digit = ((byte)(vr % 10));
      vr /= 10;
      vp /= 10;
      vm /= 10;
      removed++;
    };
    out =
        vr + strconv_dot_ftoa__bool_to_u32(vr == vm || last_removed_digit >= 5);
  };
  return (strconv_dot_ftoa__Dec32){.m = out, .e = e10 + removed};
}
string strconv_dot_ftoa__f32_to_str(f32 f, int n_digit) {
  strconv_dot_ftoa__Uf32 u1 = (strconv_dot_ftoa__Uf32){.f = ((f32)(0)), .u = 0};
  u1.f = f;
  u32 u = u1.u;
  bool neg =
      (u >> (strconv_dot_ftoa__mantbits32 + strconv_dot_ftoa__expbits32)) != 0;
  u32 mant = u & ((((u32)(1)) << strconv_dot_ftoa__mantbits32) - ((u32)(1)));
  u32 exp = (u >> strconv_dot_ftoa__mantbits32) &
            ((((u32)(1)) << strconv_dot_ftoa__expbits32) - ((u32)(1)));
  if ((exp == strconv_dot_ftoa__maxexp32) || (exp == 0 && mant == 0)) {
    return strconv_dot_ftoa__get_string_special(neg, exp == 0, mant == 0);
  };
  _V_MulRet_strconv_dot_ftoa__Dec32_V_bool _V_mret_1289_d_ok =
      strconv_dot_ftoa__f32_to_decimal_exact_int(mant, exp);
  strconv_dot_ftoa__Dec32 d = _V_mret_1289_d_ok.var_0;
  bool ok = _V_mret_1289_d_ok.var_1;
  if (!ok) {
    d = strconv_dot_ftoa__f32_to_decimal(mant, exp);
  };
  return strconv_dot_ftoa__Dec32_get_string_32(d, neg, n_digit);
}
string strconv_dot_ftoa__Dec64_get_string_64(strconv_dot_ftoa__Dec64 d,
                                             bool neg, int n_digit) {
  u64 out = d.m;
  int out_len = strconv_dot_ftoa__decimal_len_64(out);
  array_byte buf = array_repeat(
      new_array_from_c_array(1, 1, sizeof(byte),
                             EMPTY_ARRAY_OF_ELEMS(byte, 1){((byte)(0))}),
      out_len + 6 + 1 + 1);
  int i = 0;
  if (n_digit > 0 && out_len > n_digit) {
    out_len = n_digit + 1;
  };
  if (neg) {
    array_set(&/*q*/ buf, i, &(byte[]){'-'});
    i++;
  };
  int disp = 0;
  if (out_len <= 1) {
    disp = 1;
  };
  int y = i + out_len;
  int x = 0;
  while (x < (out_len - disp - 1)) {

    array_set(&/*q*/ buf, y - x, &(byte[]){'0' + ((byte)(out % 10))});
    out /= 10;
    i++;
    x++;
  };
  if (out_len >= 1) {
    array_set(&/*q*/ buf, y - x, &(byte[]){'.'});
    x++;
    i++;
  };
  if (y - x >= 0) {
    array_set(&/*q*/ buf, y - x, &(byte[]){'0' + ((byte)(out % 10))});
    i++;
  };
  array_set(&/*q*/ buf, i, &(byte[]){'e'});
  i++;
  int exp = d.e + out_len - 1;
  if (exp < 0) {
    array_set(&/*q*/ buf, i, &(byte[]){'-'});
    i++;
    exp = -exp;
  } else {
    array_set(&/*q*/ buf, i, &(byte[]){'+'});
    i++;
  };
  int d2 = exp % 10;
  exp /= 10;
  int d1 = exp % 10;
  int d0 = exp / 10;
  if (d0 > 0) {
    array_set(&/*q*/ buf, i, &(byte[]){'0' + ((byte)(d0))});
    i++;
  };
  array_set(&/*q*/ buf, i, &(byte[]){'0' + ((byte)(d1))});
  i++;
  array_set(&/*q*/ buf, i, &(byte[]){'0' + ((byte)(d2))});
  i++;
  array_set(&/*q*/ buf, i, &(byte[]){0});
  return tos(((byteptr)(&(*(byte *)array_get(buf, 0)))), i);
}
_V_MulRet_strconv_dot_ftoa__Dec64_V_bool
strconv_dot_ftoa__f64_to_decimal_exact_int(u64 i_mant, u64 exp) {
  strconv_dot_ftoa__Dec64 d =
      (strconv_dot_ftoa__Dec64){.m = ((u64)(0)), .e = 0};
  u64 e = exp - strconv_dot_ftoa__bias64;
  if (e > strconv_dot_ftoa__mantbits64) {
    return (_V_MulRet_strconv_dot_ftoa__Dec64_V_bool){.var_0 = d, .var_1 = 0};
  };
  u32 shift = strconv_dot_ftoa__mantbits64 - e;
  u64 mant = i_mant | 0x0010000000000000;
  d.m = mant >> shift;
  if ((d.m << shift) != mant) {
    return (_V_MulRet_strconv_dot_ftoa__Dec64_V_bool){.var_0 = d, .var_1 = 0};
  };
  while ((d.m % 10) == 0) {

    d.m /= 10;
    d.e++;
  };
  return (_V_MulRet_strconv_dot_ftoa__Dec64_V_bool){.var_0 = d, .var_1 = 1};
}
strconv_dot_ftoa__Dec64 strconv_dot_ftoa__f64_to_decimal(u64 mant, u64 exp) {
  int e2 = 0;
  u64 m2 = ((u64)(0));
  if (exp == 0) {
    e2 = 1 - strconv_dot_ftoa__bias64 - strconv_dot_ftoa__mantbits64 - 2;
    m2 = mant;
  } else {
    e2 = ((int)(exp)) - strconv_dot_ftoa__bias64 -
         strconv_dot_ftoa__mantbits64 - 2;
    m2 = (((u64)(1)) << strconv_dot_ftoa__mantbits64) | mant;
  };
  bool even = (m2 & 1) == 0;
  bool accept_bounds = even;
  u64 mv = ((u64)(4 * m2));
  u64 mm_shift = strconv_dot_ftoa__bool_to_u64(mant != 0 || exp <= 1);
  u64 vr = ((u64)(0));
  u64 vp = ((u64)(0));
  u64 vm = ((u64)(0));
  int e10 = 0;
  bool vm_is_trailing_zeros = 0;
  bool vr_is_trailing_zeros = 0;
  if (e2 >= 0) {
    u32 q = strconv_dot_ftoa__log10_pow2(e2) -
            strconv_dot_ftoa__bool_to_u32(e2 > 3);
    e10 = ((int)(q));
    int k = strconv_dot_ftoa__pow5_inv_num_bits_64 +
            strconv_dot_ftoa__pow5_bits(((int)(q))) - 1;
    int i = -e2 + ((int)(q)) + k;
    strconv_dot_ftoa__Uint128 mul = (*(strconv_dot_ftoa__Uint128 *)array_get(
        strconv_dot_ftoa__pow5_inv_split_64, q));
    vr = strconv_dot_ftoa__mul_shift_64(((u64)(4)) * m2, mul, i);
    vp = strconv_dot_ftoa__mul_shift_64(((u64)(4)) * m2 + ((u64)(2)), mul, i);
    vm = strconv_dot_ftoa__mul_shift_64(((u64)(4)) * m2 - ((u64)(1)) - mm_shift,
                                        mul, i);
    if (q <= 21) {
      if (mv % 5 == 0) {
        vr_is_trailing_zeros =
            strconv_dot_ftoa__multiple_of_power_of_five_64(mv, q);
      } else if (accept_bounds) {
        vm_is_trailing_zeros = strconv_dot_ftoa__multiple_of_power_of_five_64(
            mv - 1 - mm_shift, q);
      } else if (strconv_dot_ftoa__multiple_of_power_of_five_64(mv + 2, q)) {
        vp--;
      };
    };
  } else {
    u32 q = strconv_dot_ftoa__log10_pow5(-e2) -
            strconv_dot_ftoa__bool_to_u32(-e2 > 1);
    e10 = ((int)(q)) + e2;
    int i = -e2 - ((int)(q));
    int k = strconv_dot_ftoa__pow5_bits(i) - strconv_dot_ftoa__pow5_num_bits_64;
    int j = ((int)(q)) - k;
    strconv_dot_ftoa__Uint128 mul = (*(strconv_dot_ftoa__Uint128 *)array_get(
        strconv_dot_ftoa__pow5_split_64, i));
    vr = strconv_dot_ftoa__mul_shift_64(((u64)(4)) * m2, mul, j);
    vp = strconv_dot_ftoa__mul_shift_64(((u64)(4)) * m2 + ((u64)(2)), mul, j);
    vm = strconv_dot_ftoa__mul_shift_64(((u64)(4)) * m2 - ((u64)(1)) - mm_shift,
                                        mul, j);
    if (q <= 1) {
      vr_is_trailing_zeros = 1;
      if (accept_bounds) {
        vm_is_trailing_zeros = (mm_shift == 1);
      } else {
        vp--;
      };
    } else if (q < 63) {
      vr_is_trailing_zeros =
          strconv_dot_ftoa__multiple_of_power_of_two_64(mv, q - 1);
    };
  };
  int removed = 0;
  byte last_removed_digit = ((byte)(0));
  u64 out = ((u64)(0));
  if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
    while (1) {
      u64 vp_div_10 = vp / 10;
      u64 vm_div_10 = vm / 10;
      if (vp_div_10 <= vm_div_10) {
        break;
      };
      u64 vm_mod_10 = vm % 10;
      u64 vr_div_10 = vr / 10;
      u64 vr_mod_10 = vr % 10;
      vm_is_trailing_zeros = vm_is_trailing_zeros && vm_mod_10 == 0;
      vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
      last_removed_digit = ((byte)(vr_mod_10));
      vr = vr_div_10;
      vp = vp_div_10;
      vm = vm_div_10;
      removed++;
    };
    if (vm_is_trailing_zeros) {
      while (1) {
        u64 vm_div_10 = vm / 10;
        u64 vm_mod_10 = vm % 10;
        if (vm_mod_10 != 0) {
          break;
        };
        u64 vp_div_10 = vp / 10;
        u64 vr_div_10 = vr / 10;
        u64 vr_mod_10 = vr % 10;
        vr_is_trailing_zeros =
            vr_is_trailing_zeros && (last_removed_digit == 0);
        last_removed_digit = ((byte)(vr_mod_10));
        vr = vr_div_10;
        vp = vp_div_10;
        vm = vm_div_10;
        removed++;
      };
    };
    if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2) == 0) {
      last_removed_digit = 4;
    };
    out = vr;
    if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) ||
        last_removed_digit >= 5) {
      out++;
    };
  } else {
    bool round_up = 0;
    while (vp / 100 > vm / 100) {

      round_up = (vr % 100) >= 50;
      vr /= 100;
      vp /= 100;
      vm /= 100;
      removed += 2;
    };
    while (vp / 10 > vm / 10) {

      round_up = (vr % 10) >= 5;
      vr /= 10;
      vp /= 10;
      vm /= 10;
      removed++;
    };
    out = vr + strconv_dot_ftoa__bool_to_u64(vr == vm || round_up);
  };
  return (strconv_dot_ftoa__Dec64){.m = out, .e = e10 + removed};
}
string strconv_dot_ftoa__f64_to_str(f64 f, int n_digit) {
  strconv_dot_ftoa__Uf64 u1 = (strconv_dot_ftoa__Uf64){.f = ((f64)(0)), .u = 0};
  u1.f = f;
  u64 u = u1.u;
  bool neg =
      (u >> (strconv_dot_ftoa__mantbits64 + strconv_dot_ftoa__expbits64)) != 0;
  u64 mant = u & ((((u64)(1)) << strconv_dot_ftoa__mantbits64) - ((u64)(1)));
  u64 exp = (u >> strconv_dot_ftoa__mantbits64) &
            ((((u64)(1)) << strconv_dot_ftoa__expbits64) - ((u64)(1)));
  if ((exp == strconv_dot_ftoa__maxexp64) || (exp == 0 && mant == 0)) {
    return strconv_dot_ftoa__get_string_special(neg, exp == 0, mant == 0);
  };
  _V_MulRet_strconv_dot_ftoa__Dec64_V_bool _V_mret_1353_d_ok =
      strconv_dot_ftoa__f64_to_decimal_exact_int(mant, exp);
  strconv_dot_ftoa__Dec64 d = _V_mret_1353_d_ok.var_0;
  bool ok = _V_mret_1353_d_ok.var_1;
  if (!ok) {
    d = strconv_dot_ftoa__f64_to_decimal(mant, exp);
  };
  return strconv_dot_ftoa__Dec64_get_string_64(d, neg, n_digit);
}
static inline string strconv_dot_ftoa__ftoa_64(f64 f) {
  return strconv_dot_ftoa__f64_to_str(f, 17);
}
static inline string strconv_dot_ftoa__ftoa_long_64(f64 f) {
  return strconv_dot_ftoa__f64_to_str_l(f);
}
static inline string strconv_dot_ftoa__ftoa_32(f32 f) {
  return strconv_dot_ftoa__f32_to_str(f, 8);
}
static inline string strconv_dot_ftoa__ftoa_long_32(f32 f) {
  return strconv_dot_ftoa__f32_to_str_l(f);
}
void strconv_dot_ftoa__assert1(bool t, string msg) {
  if (!t) {
    v_panic(msg);
  };
}
static inline int strconv_dot_ftoa__bool_to_int(bool b) {
  if (b) {
    return 1;
  };
  return 0;
}
static inline u32 strconv_dot_ftoa__bool_to_u32(bool b) {
  if (b) {
    return ((u32)(1));
  };
  return ((u32)(0));
}
static inline u64 strconv_dot_ftoa__bool_to_u64(bool b) {
  if (b) {
    return ((u64)(1));
  };
  return ((u64)(0));
}
string strconv_dot_ftoa__get_string_special(bool neg, bool expZero,
                                            bool mantZero) {
  if (!mantZero) {
    return tos3("nan");
  };
  if (!expZero) {
    if (neg) {
      return tos3("-inf");
    } else {
      return tos3("+inf");
    };
  };
  if (neg) {
    return tos3("-0e+00");
  };
  return tos3("0e+00");
}
int strconv_dot_ftoa__decimal_len_32(u32 u) {
  strconv_dot_ftoa__assert1(u < 1000000000, tos3("too big"));
  if (u >= 100000000) {
    return 9;
  } else if (u >= 10000000) {
    return 8;
  } else if (u >= 1000000) {
    return 7;
  } else if (u >= 100000) {
    return 6;
  } else if (u >= 10000) {
    return 5;
  } else if (u >= 1000) {
    return 4;
  } else if (u >= 100) {
    return 3;
  } else if (u >= 10) {
    return 2;
  };
  return 1;
}
u32 strconv_dot_ftoa__mul_shift_32(u32 m, u64 mul, int ishift) {
  bool tmp1 = ishift > 32;

  /// sline: ""
  if (!tmp1) {
    g_test_fails++;
    eprintln(tos3("/tmp/gen_vc/v/vlib/strconv/ftoa/utilities.v:100: FAILED: "
                  "strconv_dot_ftoa__mul_shift_32()"));
    eprintln(tos3("Source: "));
    v_panic(tos3("An assertion failed."));
    exit(1);
  } else {
    g_test_oks++;
  }

  ;
  _V_MulRet_u64_V_u64 _V_mret_259_hi_lo =
      math_dot_bits__mul_64(((u64)(m)), mul);
  u64 hi = _V_mret_259_hi_lo.var_0;
  u64 lo = _V_mret_259_hi_lo.var_1;
  u64 shifted_sum = (lo >> ((u64)(ishift))) + (hi << ((u64)(64 - ishift)));
  strconv_dot_ftoa__assert1(shifted_sum <= math__max_u32,
                            tos3("shiftedSum <= math.max_u32"));
  return ((u32)(shifted_sum));
}
u32 strconv_dot_ftoa__mul_pow5_invdiv_pow2(u32 m, u32 q, int j) {
  return strconv_dot_ftoa__mul_shift_32(
      m, (*(u64 *)array_get(strconv_dot_ftoa__pow5_inv_split_32, q)), j);
}
u32 strconv_dot_ftoa__mul_pow5_div_pow2(u32 m, u32 i, int j) {
  return strconv_dot_ftoa__mul_shift_32(
      m, (*(u64 *)array_get(strconv_dot_ftoa__pow5_split_32, i)), j);
}
u32 strconv_dot_ftoa__pow5_factor_32(u32 i_v) {
  u32 v = i_v;
  for (u32 n = ((u32)(0));; n++) {

    u32 q = v / 5;
    u32 r = v % 5;
    if (r != 0) {
      return n;
    };
    v = q;
  };
  return v;
}
bool strconv_dot_ftoa__multiple_of_power_of_five_32(u32 v, u32 p) {
  return strconv_dot_ftoa__pow5_factor_32(v) >= p;
}
bool strconv_dot_ftoa__multiple_of_power_of_two_32(u32 v, u32 p) {
  return ((u32)(math_dot_bits__trailing_zeros_32(v))) >= p;
}
u32 strconv_dot_ftoa__log10_pow2(int e) {
  strconv_dot_ftoa__assert1(e >= 0, tos3("e >= 0"));
  strconv_dot_ftoa__assert1(e <= 1650, tos3("e <= 1650"));
  return (((u32)(e)) * 78913) >> 18;
}
u32 strconv_dot_ftoa__log10_pow5(int e) {
  strconv_dot_ftoa__assert1(e >= 0, tos3("e >= 0"));
  strconv_dot_ftoa__assert1(e <= 2620, tos3("e <= 2620"));
  return (((u32)(e)) * 732923) >> 20;
}
int strconv_dot_ftoa__pow5_bits(int e) {
  strconv_dot_ftoa__assert1(e >= 0, tos3("e >= 0"));
  strconv_dot_ftoa__assert1(e <= 3528, tos3("e <= 3528"));
  return ((int)(((((u32)(e)) * 1217359) >> 19) + 1));
}
int strconv_dot_ftoa__decimal_len_64(u64 u) {
  int log2 = 64 - math_dot_bits__leading_zeros_64(u) - 1;
  int t = (log2 + 1) * 1233 >> 12;
  return t -
         strconv_dot_ftoa__bool_to_int(
             u < (*(u64 *)array_get(strconv_dot_ftoa__powers_of_10, t))) +
         1;
}
u64 strconv_dot_ftoa__shift_right_128(strconv_dot_ftoa__Uint128 v, int shift) {
  strconv_dot_ftoa__assert1(shift < 64, tos3("shift < 64"));
  return (v.hi << ((u64)(64 - shift))) | (v.lo >> ((u32)(shift)));
}
u64 strconv_dot_ftoa__mul_shift_64(u64 m, strconv_dot_ftoa__Uint128 mul,
                                   int shift) {
  _V_MulRet_u64_V_u64 _V_mret_676_hihi_hilo = math_dot_bits__mul_64(m, mul.hi);
  u64 hihi = _V_mret_676_hihi_hilo.var_0;
  u64 hilo = _V_mret_676_hihi_hilo.var_1;
  _V_MulRet_u64_V_u64 _V_mret_690_lohi__ = math_dot_bits__mul_64(m, mul.lo);
  u64 lohi = _V_mret_690_lohi__.var_0;
  strconv_dot_ftoa__Uint128 sum =
      (strconv_dot_ftoa__Uint128){.hi = hihi, .lo = lohi + hilo};
  if (sum.lo < lohi) {
    sum.hi++;
  };
  return strconv_dot_ftoa__shift_right_128(sum, shift - 64);
}
u32 strconv_dot_ftoa__pow5_factor_64(u64 v_i) {
  u64 v = v_i;
  for (u32 n = ((u32)(0));; n++) {

    u64 q = v / 5;
    u64 r = v % 5;
    if (r != 0) {
      return n;
    };
    v = q;
  };
  return ((u32)(0));
}
bool strconv_dot_ftoa__multiple_of_power_of_five_64(u64 v, u32 p) {
  return strconv_dot_ftoa__pow5_factor_64(v) >= p;
}
bool strconv_dot_ftoa__multiple_of_power_of_two_64(u64 v, u32 p) {
  return ((u32)(math_dot_bits__trailing_zeros_64(v))) >= p;
}
string strconv_dot_ftoa__f32_to_str_l(f64 f) {
  return strconv_dot_ftoa__f64_to_str_l(((f32)(f)));
}
string strconv_dot_ftoa__f64_to_str_l(f64 f) {
  string s = strconv_dot_ftoa__f64_to_str(f, 18);
  if (s.len > 2 && (string_at(s, 0) == 'N' || string_at(s, 1) == 'i')) {
    return s;
  };
  bool m_sgn_flag = 0;
  int sgn = 1;
  byte b[26] = {0};
  int d_pos = 1;
  int i = 0;
  int i1 = 0;
  int exp = 0;
  int exp_sgn = 1;
  string tmp12 = s;
  ;
  for (int tmp13 = 0; tmp13 < tmp12.len; tmp13++) {
    byte c = tmp12.str[tmp13];

    if (c == '-') {
      sgn = -1;
      i++;
    } else if (c == '+') {
      sgn = 1;
      i++;
    } else if (c >= '0' && c <= '9') {
      b[i1++] /*rbyte 1*/ = c;
      i++;
    } else if (c == '.') {
      if (sgn > 0) {
        d_pos = i;
      } else {
        d_pos = i - 1;
      };
      i++;
    } else if (c == 'e') {
      i++;
      break;
    } else {
      return tos3("Float conversion error!!");
    };
  };
  b[i1] /*rbyte 1*/ = 0;
  if (string_at(s, i) == '-') {
    exp_sgn = -1;
    i++;
  } else if (string_at(s, i) == '+') {
    exp_sgn = 1;
    i++;
  };
  string tmp18 = string_substr2(s, i, -1, true);
  ;
  for (int tmp21 = 0; tmp21 < tmp18.len; tmp21++) {
    byte c = tmp18.str[tmp21];

    exp = exp * 10 + ((int)(c - '0'));
  };
  array_byte res =
      array_repeat(new_array_from_c_array(1, 1, sizeof(byte),
                                          EMPTY_ARRAY_OF_ELEMS(byte, 1){'0'}),
                   exp + 32);
  int r_i = 0;
  if (sgn == 1) {
    if (m_sgn_flag) {
      array_set(&/*q*/ res, r_i++, &(byte[]){'+'});
    };
  } else {
    array_set(&/*q*/ res, r_i++, &(byte[]){'-'});
  };
  i = 0;
  if (exp_sgn >= 0) {
    while (b[i] /*rbyte 1*/ != 0) {

      array_set(&/*q*/ res, r_i++, &(byte[]){b[i] /*rbyte 1*/});
      i++;
      if (i >= d_pos && exp >= 0) {
        if (exp == 0) {
          array_set(&/*q*/ res, r_i++, &(byte[]){'.'});
        };
        exp--;
      };
    };
    while (exp >= 0) {

      array_set(&/*q*/ res, r_i++, &(byte[]){'0'});
      exp--;
    };
  } else {
    bool dot_p = 1;
    while (exp > 0) {

      array_set(&/*q*/ res, r_i++, &(byte[]){'0'});
      exp--;
      if (dot_p) {
        array_set(&/*q*/ res, r_i++, &(byte[]){'.'});
        dot_p = 0;
      };
    };
    while (b[i] /*rbyte 1*/ != 0) {

      array_set(&/*q*/ res, r_i++, &(byte[]){b[i] /*rbyte 1*/});
      i++;
    };
  };
  array_set(&/*q*/ res, r_i, &(byte[]){0});
  return tos(&(*(byte *)array_get(res, 0)), r_i);
}
string os__getenv(string key) {
#ifdef _WIN32
  void *s = _wgetenv(string_to_wide(key));
  if (s == 0) {
    return tos3("");
  };
  return string_from_wide(s);
#else
  char *s = getenv((char *)key.str);
  if (s == 0) {
    return tos3("");
  };
  return cstring_to_vstring(((byteptr)(s)));
#endif
  ;
}
int os__setenv(string name, string value, bool overwrite) {
#ifdef _WIN32
  string format = _STR("%.*s=%.*s", name.len, name.str, value.len, value.str);
  if (overwrite) {
    return _putenv((char *)format.str);
  };
  return -1;
#else
  return setenv((char *)name.str, (char *)value.str, overwrite);
#endif
  ;
}
int os__unsetenv(string name) {
#ifdef _WIN32
  string format = _STR("%.*s=", name.len, name.str);
  return _putenv((char *)format.str);
#else
  return unsetenv((char *)name.str);
#endif
  ;
}
map_string os__environ() {
  map_string res = new_map(1, sizeof(string));
#ifdef _WIN32
  u16 *estrings = GetEnvironmentStringsW();
  string eline = tos3("");
  for (u16 *c = estrings; *c != 0; c = (u16 *)(u16 *)c + eline.len + 1) {

    eline = string_from_wide(c);
    int eq_index = string_index_byte(eline, '=');
    if (eq_index > 0) {
      map_set(&res, string_substr2(eline, 0, eq_index, false),
              &(string[]){string_substr2(eline, eq_index + 1, -1, true)});
    };
  };
  FreeEnvironmentStringsW(estrings);
#else
  byteptr *e = ((byteptr *)(environ));
  for (int i = 0; !isnil(e[/*ptr!*/ i] /*rbyteptr 0*/); i++) {

    string eline = cstring_to_vstring(e[/*ptr!*/ i] /*rbyteptr 0*/);
    int eq_index = string_index_byte(eline, '=');
    if (eq_index > 0) {
      map_set(&res, string_substr2(eline, 0, eq_index, false),
              &(string[]){string_substr2(eline, eq_index + 1, -1, true)});
    };
  };
#endif
  ;
  return res;
}
bool os__File_is_opened(os__File f) { return f.opened; }
array_byte os__File_read_bytes(os__File *f, int size) {
  return os__File_read_bytes_at(&/* ? */ *f, size, 0);
}
array_byte os__File_read_bytes_at(os__File *f, int size, int pos) {
  array_byte arr =
      array_repeat(new_array_from_c_array(1, 1, sizeof(byte),
                                          EMPTY_ARRAY_OF_ELEMS(byte, 1){'0'}),
                   size);
  fseek(f->cfile, pos, SEEK_SET);
  int nreadbytes = fread(arr.data, 1, size, f->cfile);
  fseek(f->cfile, 0, SEEK_SET);
  return array_slice2(arr, 0, nreadbytes, false);
}
Option_array_byte os__read_bytes(string path) {
  FILE *fp = os__vfopen(path, tos3("rb"));
  if (isnil(fp)) {
    return v_error(_STR("failed to open file \"%.*s\"", path.len, path.str));
  };
  fseek(fp, 0, SEEK_END);
  int fsize = ftell(fp);
  rewind(fp);
  array_byte res =
      array_repeat(new_array_from_c_array(1, 1, sizeof(byte),
                                          EMPTY_ARRAY_OF_ELEMS(byte, 1){'0'}),
                   fsize);
  int nr_read_elements = fread(res.data, fsize, 1, fp);
  fclose(fp);
  array_byte tmp5 = OPTION_CAST(array_byte)(
      array_slice2(res, 0, nr_read_elements * fsize, false));
  return opt_ok(&tmp5, sizeof(array_byte));
}
Option_string os__read_file(string path) {
  string mode = tos3("rb");
  FILE *fp = os__vfopen(path, mode);
  if (isnil(fp)) {
    return v_error(_STR("failed to open file \"%.*s\"", path.len, path.str));
  };
  fseek(fp, 0, SEEK_END);
  int fsize = ftell(fp);
  rewind(fp);
  byte *str = ((byte *)(0));
  { str = v_malloc(fsize + 1); };
  fread((char *)str, fsize, 1, fp);
  str[/*ptr!*/ fsize] /*rbyte 1*/ = 0;
  string tmp6 = OPTION_CAST(string)((tos((byte *)str, fsize)));
  { fclose(fp); }
  return opt_ok(&tmp6, sizeof(string));
  { fclose(fp); }
}
int os__file_size(string path) {
  struct /*c struct init*/

      stat s;
#ifdef _WIN32
  _wstat(string_to_wide(path), ((voidptr)(&s)));
#else
  stat(((charptr)(path.str)), &s);
#endif
  ;
  return s.st_size;
}
void os__mv(string old, string new) {
#ifdef _WIN32
  _wrename(string_to_wide(old), string_to_wide(new));
#else
  rename(((charptr)(old.str)), ((charptr)(new.str)));
#endif
  ;
}
Option_bool os__cp(string old, string new) {
#ifdef _WIN32
  string _old = string_replace(old, tos3("/"), tos3("\\"));
  string _new = string_replace(new, tos3("/"), tos3("\\"));
  CopyFile(string_to_wide(_old), string_to_wide(_new), 0);
  u32 result = GetLastError();
  if (result == 0) {
    bool tmp7 = OPTION_CAST(bool)(1);
    return opt_ok(&tmp7, sizeof(bool));
  } else {
    return error_with_code(
        _STR("failed to copy %.*s to %.*s", old.len, old.str, new.len, new.str),
        ((int)(result)));
  };
#else
  os__system(_STR("cp %.*s %.*s", old.len, old.str, new.len, new.str));
  bool tmp8 = OPTION_CAST(bool)(1);
  return opt_ok(&tmp8, sizeof(bool));
#endif
  ;
}
Option_bool os__cp_r(string osource_path, string odest_path, bool overwrite) {
  v_panic(tos3("Use `os.cp_all` instead of `os.cp_r`"));
}
Option_bool os__cp_all(string osource_path, string odest_path, bool overwrite) {
  string source_path = os__realpath(osource_path);
  string dest_path = os__realpath(odest_path);
  if (!os__exists(source_path)) {
    return v_error(tos3("Source path doesn\'t exist"));
  };
  if (!os__is_dir(source_path)) {
    string adjasted_path =
        ((os__is_dir(dest_path))
             ? (os__join_path(dest_path, &(varg_string){.len = 1,
                                                        .args = {os__filename(
                                                            source_path)}}))
             : (dest_path));
    if (os__exists(adjasted_path)) {
      if (overwrite) {
        os__rm(adjasted_path);
      } else {
        return v_error(tos3("Destination file path already exist"));
      };
    };
    Option_bool tmp9 = os__cp(source_path, adjasted_path);
    if (!tmp9.ok) {
      string err = tmp9.error;
      int errcode = tmp9.ecode;
      return v_error(err);
    };
    bool tmp10 = OPTION_CAST(bool)(1);
    return opt_ok(&tmp10, sizeof(bool));
  };
  if (!os__is_dir(dest_path)) {
    return v_error(tos3("Destination path is not a valid directory"));
  };
  Option_array_string tmp11 = os__ls(source_path);
  array_string files;
  if (!tmp11.ok) {
    string err = tmp11.error;
    int errcode = tmp11.ecode;
    return v_error(err);
  }
  files = *(array_string *)tmp11.data;
  ;
  array_string tmp12 = files;
  for (int tmp13 = 0; tmp13 < tmp12.len; tmp13++) {
    string file = ((string *)tmp12.data)[tmp13];

    string sp =
        os__join_path(source_path, &(varg_string){.len = 1, .args = {file}});
    string dp =
        os__join_path(dest_path, &(varg_string){.len = 1, .args = {file}});
    if (os__is_dir(sp)) {
      Option_bool tmp14 = os__mkdir(dp);
      if (!tmp14.ok) {
        string err = tmp14.error;
        int errcode = tmp14.ecode;
        v_panic(err);
      };
    };
    Option_bool tmp15 = os__cp_all(sp, dp, overwrite);
    if (!tmp15.ok) {
      string err = tmp15.error;
      int errcode = tmp15.ecode;
      os__rmdir(dp);
      v_panic(err);
    };
  };
  bool tmp16 = OPTION_CAST(bool)(1);
  return opt_ok(&tmp16, sizeof(bool));
}
Option_bool os__mv_by_cp(string source, string target) {
  Option_bool tmp17 = os__cp(source, target);
  if (!tmp17.ok) {
    string err = tmp17.error;
    int errcode = tmp17.ecode;
    return v_error(err);
  };
  os__rm(source);
  bool tmp18 = OPTION_CAST(bool)(1);
  return opt_ok(&tmp18, sizeof(bool));
}
FILE *os__vfopen(string path, string mode) {
#ifdef _WIN32
  return _wfopen(string_to_wide(path), string_to_wide(mode));
#else
  return fopen(((charptr)(path.str)), ((charptr)(mode.str)));
#endif
  ;
}
Option_array_string os__read_lines(string path) {
  Option_string tmp19 = os__read_file(path);
  string buf;
  if (!tmp19.ok) {
    string err = tmp19.error;
    int errcode = tmp19.ecode;
    string tmp20 = OPTION_CAST(string)(err);
    return opt_ok(&tmp20, sizeof(string));
  }
  buf = *(string *)tmp19.data;
  ;
  array_string tmp21 = OPTION_CAST(array_string)(string_split_into_lines(buf));
  return opt_ok(&tmp21, sizeof(array_string));
}
Option_array_ustring os__read_ulines(string path) {
  Option_array_string tmp22 = os__read_lines(path);
  array_string lines;
  if (!tmp22.ok) {
    string err = tmp22.error;
    int errcode = tmp22.ecode;
    string tmp23 = OPTION_CAST(string)(err);
    return opt_ok(&tmp23, sizeof(string));
  }
  lines = *(array_string *)tmp22.data;
  ;
  array_ustring ulines = new_array_from_c_array(
      0, 0, sizeof(ustring), EMPTY_ARRAY_OF_ELEMS(ustring, 0){TCCSKIP(0)});
  array_string tmp24 = lines;
  for (int tmp25 = 0; tmp25 < tmp24.len; tmp25++) {
    string myline = ((string *)tmp24.data)[tmp25];

    _PUSH(&ulines,
          (/*typ = array_ustring   tmp_typ=ustring*/ string_ustring(myline)),
          tmp26, ustring);
  };
  array_ustring tmp27 = OPTION_CAST(array_ustring)(ulines);
  return opt_ok(&tmp27, sizeof(array_ustring));
}
Option_os__File os__open_append(string path) {
  os__File file = (os__File){.cfile = 0, .fd = 0, .opened = 0};
#ifdef _WIN32
  u16 *wpath = string_to_wide(string_replace(path, tos3("/"), tos3("\\")));
  string mode = tos3("ab");
  file = (os__File){
      .cfile = _wfopen(wpath, string_to_wide(mode)), .fd = 0, .opened = 0};
#else
  byte *cpath = path.str;
  file = (os__File){
      .cfile = fopen(((charptr)(cpath)), "ab"), .fd = 0, .opened = 0};
#endif
  ;
  if (isnil(file.cfile)) {
    return v_error(
        _STR("failed to create(append) file \"%.*s\"", path.len, path.str));
  };
  file.opened = 1;
  os__File tmp28 = OPTION_CAST(os__File)(file);
  return opt_ok(&tmp28, sizeof(os__File));
}
Option_os__File os__open_file(string path, string mode, varg_int *options) {
  int flags = 0;
  string tmp29 = mode;
  ;
  for (int tmp30 = 0; tmp30 < tmp29.len; tmp30++) {
    byte m = tmp29.str[tmp30];

    byte tmp31 = m;

    if (tmp31 == 'r') {
      flags |= os__O_RDONLY;
    } else if (tmp31 == 'w') {
      flags |= os__O_CREATE | os__O_TRUNC;
    } else if (tmp31 == 'a') {
      flags |= os__O_CREATE | os__O_APPEND;
    } else if (tmp31 == 's') {
      flags |= os__O_SYNC;
    } else if (tmp31 == 'n') {
      flags |= os__O_NONBLOCK;
    } else if (tmp31 == 'c') {
      flags |= os__O_NOCTTY;
    } else if (tmp31 == '+') {
      flags |= os__O_RDWR;
    } else // default:
    {
    };
  };
  int permission = 0666;
  if (options->len > 0) {
    permission = options->args[0];
  };
#ifdef _WIN32
  if (permission < 0600) {
    permission = 0x0100;
  } else {
    permission = 0x0100 | 0x0080;
  };
#endif
  ;
  string p = path;
#ifdef _WIN32
  p = string_replace(path, tos3("/"), tos3("\\"));
#endif
  ;
  int fd = open(((charptr)(p.str)), flags, permission);
  if (fd == -1) {
    return v_error(os__posix_get_error_msg(errno));
  };
  void *cfile = fdopen(fd, ((charptr)(mode.str)));
  if (isnil(cfile)) {
    return v_error(
        _STR("Failed to open or create file \"%.*s\"", path.len, path.str));
  };
  os__File tmp32 =
      OPTION_CAST(os__File)((os__File){.cfile = cfile, .fd = fd, .opened = 1});
  return opt_ok(&tmp32, sizeof(os__File));
}
void os__File_write_bytes_at(os__File *f, void *data, int size, int pos) {
  fseek(f->cfile, pos, SEEK_SET);
  fwrite(data, 1, size, f->cfile);
  fseek(f->cfile, 0, SEEK_END);
}
void os__File_flush(os__File *f) {
  if (!f->opened) {

    return;
  };
  fflush(f->cfile);
}
void *os__vpopen(string path) {
#ifdef _WIN32
  string mode = tos3("rb");
  u16 *wpath = string_to_wide(path);
  return _wpopen(wpath, string_to_wide(mode));
#else
  byte *cpath = path.str;
  return popen((char *)cpath, "r");
#endif
  ;
}
_V_MulRet_int_V_bool os__posix_wait4_to_exit_status(int waitret) {
#ifdef _WIN32
  return (_V_MulRet_int_V_bool){.var_0 = waitret, .var_1 = 0};
#else
  int ret = 0;
  bool is_signaled = 1;
  if (WIFEXITED(waitret)) {
    ret = WEXITSTATUS(waitret);
    is_signaled = 0;
  } else if (WIFSIGNALED(waitret)) {
    ret = WTERMSIG(waitret);
    is_signaled = 1;
  };
  return (_V_MulRet_int_V_bool){.var_0 = ret, .var_1 = is_signaled};
#endif
  ;
}
string os__posix_get_error_msg(int code) {
  charptr ptr_text = strerror(code);
  if (ptr_text == 0) {
    return tos3("");
  };
  return tos3(ptr_text);
}
int os__vpclose(void *f) {
#ifdef _WIN32
  return _pclose(f);
#else
  _V_MulRet_int_V_bool _V_mret_1761_ret__ =
      os__posix_wait4_to_exit_status(pclose(f));
  int ret = _V_mret_1761_ret__.var_0;
  return ret;
#endif
  ;
}
int os__system(string cmd) {
  int ret = 0;
#ifdef _WIN32
  string wcmd =
      ((cmd.len > 1 && string_at(cmd, 0) == '"' && string_at(cmd, 1) != '"')
           ? (_STR("\"%.*s\"", cmd.len, cmd.str))
           : (cmd));
  ret = _wsystem(string_to_wide(wcmd));
#else
  ret = system((char *)cmd.str);
#endif
  ;
  if (ret == -1) {
    os__print_c_errno();
  };
#ifndef _WIN32
#endif
  ;
  return ret;
}
string os__sigint_to_signal_name(int si) {
  int tmp37 = si;

  if (tmp37 == 1) {
    return tos3("SIGHUP");
  } else if (tmp37 == 2) {
    return tos3("SIGINT");
  } else if (tmp37 == 3) {
    return tos3("SIGQUIT");
  } else if (tmp37 == 4) {
    return tos3("SIGILL");
  } else if (tmp37 == 6) {
    return tos3("SIGABRT");
  } else if (tmp37 == 8) {
    return tos3("SIGFPE");
  } else if (tmp37 == 9) {
    return tos3("SIGKILL");
  } else if (tmp37 == 11) {
    return tos3("SIGSEGV");
  } else if (tmp37 == 13) {
    return tos3("SIGPIPE");
  } else if (tmp37 == 14) {
    return tos3("SIGALRM");
  } else if (tmp37 == 15) {
    return tos3("SIGTERM");
  } else // default:
  {
  };
#ifdef __linux__
#endif
  ;
  return tos3("unknown");
}
bool os__exists(string path) {
#ifdef _WIN32
  string p = string_replace(path, tos3("/"), tos3("\\"));
  return _waccess(string_to_wide(p), os__F_OK) != -1;
#else
  return access((char *)path.str, os__F_OK) != -1;
#endif
  ;
}
bool os__is_executable(string path) {
#ifdef _WIN32
  string p = os__realpath(path);
  return (os__exists(p) && string_ends_with(p, tos3(".exe")));
#else
  return access((char *)path.str, os__X_OK) != -1;
#endif
  ;
}
bool os__is_writable(string path) {
#ifdef _WIN32
  string p = string_replace(path, tos3("/"), tos3("\\"));
  return _waccess(string_to_wide(p), os__W_OK) != -1;
#else
  return access((char *)path.str, os__W_OK) != -1;
#endif
  ;
}
bool os__is_readable(string path) {
#ifdef _WIN32
  string p = string_replace(path, tos3("/"), tos3("\\"));
  return _waccess(string_to_wide(p), os__R_OK) != -1;
#else
  return access((char *)path.str, os__R_OK) != -1;
#endif
  ;
}
bool os__file_exists(string _path) {
  v_panic(tos3("Use `os.exists` instead of `os.file_exists`"));
  return false;
  ;
}
void os__rm(string path) {
#ifdef _WIN32
  _wremove(string_to_wide(path));
#else
  remove((char *)path.str);
#endif
  ;
}
void os__rmdir(string path) {
#ifndef _WIN32
#else
  RemoveDirectory(string_to_wide(path));
#endif
  ;
}
void os__rmdir_recursive(string path) {
  v_panic(tos3("Use `os.rmdir_all` instead of `os.rmdir_recursive`"));
}
void os__rmdir_all(string path) {
  Option_array_string tmp38 = os__ls(path);
  array_string items;
  if (!tmp38.ok) {
    string err = tmp38.error;
    int errcode = tmp38.ecode;

    return;
  }
  items = *(array_string *)tmp38.data;
  ;
  array_string tmp39 = items;
  for (int tmp40 = 0; tmp40 < tmp39.len; tmp40++) {
    string item = ((string *)tmp39.data)[tmp40];

    if (os__is_dir(
            os__join_path(path, &(varg_string){.len = 1, .args = {item}}))) {
      os__rmdir_all(
          os__join_path(path, &(varg_string){.len = 1, .args = {item}}));
    };
    os__rm(os__join_path(path, &(varg_string){.len = 1, .args = {item}}));
  };
  os__rmdir(path);
}
bool os__is_dir_empty(string path) {
  Option_array_string tmp41 = os__ls(path);
  array_string items;
  if (!tmp41.ok) {
    string err = tmp41.error;
    int errcode = tmp41.ecode;
    return 1;
  }
  items = *(array_string *)tmp41.data;
  ;
  return items.len == 0;
}
void os__print_c_errno() {
  int e = errno;
  string se = tos_clone(((byteptr)(strerror(errno))));
  printf("errno=%d err=%.*s\n", e, se.len, se.str);
}
string os__ext(string path) {
  Option_int tmp42 = string_last_index(path, tos3("."));
  int pos;
  if (!tmp42.ok) {
    string err = tmp42.error;
    int errcode = tmp42.ecode;
    return tos3("");
  }
  pos = *(int *)tmp42.data;
  ;
  return string_substr2(path, pos, -1, true);
}
string os__dir(string path) {
  Option_int tmp45 = string_last_index(path, os__path_separator);
  int pos;
  if (!tmp45.ok) {
    string err = tmp45.error;
    int errcode = tmp45.ecode;
    return tos3(".");
  }
  pos = *(int *)tmp45.data;
  ;
  return string_substr2(path, 0, pos, false);
}
string os__base_dir(string path) {
  Option_int tmp48 = string_last_index(path, os__path_separator);
  int posx;
  if (!tmp48.ok) {
    string err = tmp48.error;
    int errcode = tmp48.ecode;
    return path;
  }
  posx = *(int *)tmp48.data;
  ;
  return string_substr2(path, 0, posx, false);
}
string os__filename(string path) {
  return string_all_after(path, os__path_separator);
}
string os__get_line() {
  string str = os__get_raw_line();
#ifdef _WIN32
  return string_trim_right(str, tos3("\r\n"));
#else
  return string_trim_right(str, tos3("\n"));
#endif
  ;
}
string os__get_raw_line() {
#ifdef _WIN32
  {
    int max_line_chars = 256;
    byte *buf = v_malloc(max_line_chars * 2);
    void *h_input = GetStdHandle(os__STD_INPUT_HANDLE);
    int bytes_read = 0;
    if (is_atty(0) > 0) {
      ReadConsole(h_input, (char *)buf, max_line_chars * 2, &bytes_read, 0);
      return string_from_wide2(((u16 *)(buf)), bytes_read);
    };
    int offset = 0;
    while (1) {
      byte *pos = (byte *)buf + offset;
      bool res = ReadFile(h_input, (char *)pos, 1, &bytes_read, 0);
      if (!res || bytes_read == 0) {
        break;
      };
      if (*pos == '\n' || *pos == '\r') {
        offset++;
        break;
      };
      offset++;
    };
    return (tos((byte *)buf, offset));
  };
#else
  size_t max = ((size_t)(0));
  charptr buf = ((charptr)(0));
  int nr_chars = getline(&buf, &max, stdin);
  if (nr_chars == 0 || nr_chars == -1) {
    return tos3("");
  };
  return tos3(buf);
#endif
  ;
}
array_string os__get_lines() {
  string line = tos3("");
  array_string inputstr = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  while (1) {
    line = os__get_line();
    if ((line.len <= 0)) {
      break;
    };
    line = string_trim_space(line);
    _PUSH(&inputstr, (/*typ = array_string   tmp_typ=string*/ line), tmp51,
          string);
  };
  return inputstr;
}
string os__get_lines_joined() {
  string line = tos3("");
  string inputstr = tos3("");
  while (1) {
    line = os__get_line();
    if (line.len <= 0) {
      break;
    };
    line = string_trim_space(line);
    inputstr = string_add(inputstr, line);
  };
  return inputstr;
}
string os__user_os() {
#ifdef __linux__
#endif
  ;
#ifdef __APPLE__
#endif
  ;
#ifdef _WIN32
  return tos3("windows");
#endif
  ;
#ifdef __FreeBSD__
#endif
  ;
#ifdef __OpenBSD__
#endif
  ;
#ifdef __NetBSD__
#endif
  ;
#ifdef __DragonFly__
#endif
  ;
#ifdef __ANDROID__
#endif
  ;
#ifdef __sun
#endif
  ;
#ifdef __haiku__
#endif
  ;
  return tos3("unknown");
}
string os__home_dir() {
#ifdef _WIN32
  return string_add(os__getenv(tos3("USERPROFILE")), os__path_separator);
#else
  return string_add(os__getenv(tos3("HOME")), os__path_separator);
#endif
  ;
}
void os__write_file(string path, string text) {
  Option_os__File tmp52 = os__create(path);
  os__File f;
  if (!tmp52.ok) {
    string err = tmp52.error;
    int errcode = tmp52.ecode;

    return;
  }
  f = *(os__File *)tmp52.data;
  ;
  os__File_write(&/* ? */ f, text);
  os__File_close(&/* ? */ f);
}
void os__clear() {
#ifndef _WIN32
#endif
  ;
}
void os__on_segfault(void *f) {
#ifdef _WIN32

  return;
#endif
  ;
#ifdef __APPLE__
#endif
  ;
}
string os__executable() {
#ifdef __linux__
#endif
  ;
#ifdef _WIN32
  int max = 512;
  u16 *result = ((u16 *)(vcalloc(max * 2)));
  int len = GetModuleFileName(0, result, max);
  return string_from_wide2(result, len);
#endif
  ;
#ifdef __APPLE__
#endif
  ;
#ifdef __FreeBSD__
#endif
  ;
#ifdef __OpenBSD__
#endif
  ;
#ifdef __sun
#endif
  ;
#ifdef __haiku__
#endif
  ;
#ifdef __NetBSD__
#endif
  ;
#ifdef __DragonFly__
#endif
  ;
  return os__executable_fallback();
}
string os__executable_fallback() {
  string exepath = (*(string *)array_get(os__args, 0));
  if (!os__is_abs_path(exepath)) {
    if (string_contains(exepath, os__path_separator)) {
      exepath = os__join_path(os__wd_at_startup,
                              &(varg_string){.len = 1, .args = {exepath}});
    } else {
      Option_string tmp55 = os__find_abs_path_of_executable(exepath);
      string foundpath;
      if (!tmp55.ok) {
        string err = tmp55.error;
        int errcode = tmp55.ecode;
      }
      if (tmp55.ok) {
        foundpath = *(string *)tmp55.data;
      } else {
        foundpath = tos3("");
      };
      if (foundpath.len > 0) {
        exepath = foundpath;
      };
    };
  };
  exepath = os__realpath(exepath);
  return exepath;
}
Option_string os__find_abs_path_of_executable(string exepath) {
  if (os__is_abs_path(exepath)) {
    string tmp56 = OPTION_CAST(string)(exepath);
    return opt_ok(&tmp56, sizeof(string));
  };
  string res = tos3("");
  string env_path_delimiter =
      ((string_eq(os__user_os(), tos3("windows"))) ? (tos3(";")) : (tos3(":")));
  array_string paths =
      string_split(os__getenv(tos3("PATH")), env_path_delimiter);
  array_string tmp57 = paths;
  for (int tmp58 = 0; tmp58 < tmp57.len; tmp58++) {
    string p = ((string *)tmp57.data)[tmp58];

    string found_abs_path =
        os__join_path(p, &(varg_string){.len = 1, .args = {exepath}});
    if (os__exists(found_abs_path) && os__is_executable(found_abs_path)) {
      res = found_abs_path;
      break;
    };
  };
  if (res.len > 0) {
    string tmp59 = OPTION_CAST(string)(res);
    return opt_ok(&tmp59, sizeof(string));
  };
  return v_error(tos3("failed to find executable"));
}
bool os__dir_exists(string path) {
  v_panic(tos3("Use `os.is_dir` instead of `os.dir_exists`"));
  return false;
  ;
}
bool os__is_dir(string path) {
#ifdef _WIN32
  string _path = string_replace(path, tos3("/"), tos3("\\"));
  u32 attr = GetFileAttributesW(string_to_wide(_path));
  if (attr == ((u32)(INVALID_FILE_ATTRIBUTES))) {
    return 0;
  };
  if ((((int)(attr)) & FILE_ATTRIBUTE_DIRECTORY) != 0) {
    return 1;
  };
  return 0;
#else
  struct /*c struct init*/

      stat statbuf;
  if (stat((char *)path.str, &statbuf) != 0) {
    return 0;
  };
  return (((int)(statbuf.st_mode)) & os__S_IFMT) == os__S_IFDIR;
#endif
  ;
}
bool os__is_link(string path) {
#ifdef _WIN32
  return 0;
#else
  struct /*c struct init*/

      stat statbuf;
  if (lstat((char *)path.str, &statbuf) != 0) {
    return 0;
  };
  return (((int)(statbuf.st_mode)) & os__S_IFMT) == os__S_IFLNK;
#endif
  ;
}
void os__chdir(string path) {
#ifdef _WIN32
  _wchdir(string_to_wide(path));
#else
  chdir((char *)path.str);
#endif
  ;
}
string os__getwd() {
#ifdef _WIN32
  int max = 512;
  u16 *buf = ((u16 *)(vcalloc(max * 2)));
  if (_wgetcwd(buf, max) == 0) {
    return tos3("");
  };
  return string_from_wide(buf);
#else
  byte *buf = vcalloc(512);
  if (getcwd((char *)buf, 512) == 0) {
    return tos3("");
  };
  return (tos2((byte *)buf));
#endif
  ;
}
string os__realpath(string fpath) {
  byte *fullpath = vcalloc(os__MAX_PATH);
  charptr ret = ((charptr)(0));
#ifdef _WIN32
  ret = _fullpath((char *)fullpath, (char *)fpath.str, os__MAX_PATH);
  if (ret == 0) {
    return fpath;
  };
#else
  ret = realpath((char *)fpath.str, (char *)fullpath);
  if (ret == 0) {
    return fpath;
  };
#endif
  ;
  return (tos2((byte *)fullpath));
}
bool os__is_abs_path(string path) {
#ifdef _WIN32
  return string_at(path, 0) == '/' ||
         (byte_is_letter(string_at(path, 0)) && string_at(path, 1) == ':');
#endif
  ;
  return string_at(path, 0) == '/';
}
string os__join_path(string base, varg_string *dirs) {
  array_string result = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  _PUSH(&result,
        (/*typ = array_string   tmp_typ=string*/ string_trim_right(
            base, tos3("\\/"))),
        tmp68, string);
  for (int tmp70 = 0; tmp70 < dirs->len; tmp70++) {
    string d = ((string *)dirs->args)[tmp70];

    _PUSH(&result, (/*typ = array_string   tmp_typ=string*/ d), tmp71, string);
  };
  return array_string_join(result, os__path_separator);
}
array_string os__walk_ext(string path, string ext) {
  if (!os__is_dir(path)) {
    return new_array_from_c_array(0, 0, sizeof(string),
                                  EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  };
  Option_array_string tmp72 = os__ls(path);
  array_string files;
  if (!tmp72.ok) {
    string err = tmp72.error;
    int errcode = tmp72.ecode;
    return new_array_from_c_array(0, 0, sizeof(string),
                                  EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  }
  files = *(array_string *)tmp72.data;
  ;
  array_string res = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  string separator =
      ((string_ends_with(path, os__path_separator)) ? (tos3(""))
                                                    : (os__path_separator));
  array_string tmp73 = files;
  for (int i = 0; i < tmp73.len; i++) {
    string file = ((string *)tmp73.data)[i];

    if (string_starts_with(file, tos3("."))) {
      continue;
    };
    string p = string_add(string_add(path, separator), file);
    if (os__is_dir(p) && !os__is_link(p)) {
      _PUSH_MANY(&res,
                 (/*typ = array_string   tmp_typ=string*/ os__walk_ext(p, ext)),
                 tmp74, array_string);
    } else if (string_ends_with(file, ext)) {
      _PUSH(&res, (/*typ = array_string   tmp_typ=string*/ p), tmp75, string);
    };
  };
  return res;
}
void os__walk(string path, void (*f)(string path /*FFF*/)) {
  if (!os__is_dir(path)) {

    return;
  };
  Option_array_string tmp76 = os__ls(path);
  array_string files;
  if (!tmp76.ok) {
    string err = tmp76.error;
    int errcode = tmp76.ecode;

    return;
  }
  files = *(array_string *)tmp76.data;
  ;
  array_string tmp77 = files;
  for (int tmp78 = 0; tmp78 < tmp77.len; tmp78++) {
    string file = ((string *)tmp77.data)[tmp78];

    string p = string_add(string_add(path, os__path_separator), file);
    if (os__is_dir(p) && !os__is_link(p)) {
      os__walk(p, f);
    } else if (os__exists(p)) {
      f(p);
    };
  };

  return;
}
void os__signal(int signum, void *handler) { signal(signum, handler); }
int os__fork() {
  int pid = -1;
#ifndef _WIN32
#endif
  ;
#ifdef _WIN32
  v_panic(tos3("os.fork not supported in windows"));
#endif
  ;
  return pid;
}
int os__wait() {
  int pid = -1;
#ifndef _WIN32
#endif
  ;
#ifdef _WIN32
  v_panic(tos3("os.wait not supported in windows"));
#endif
  ;
  return pid;
}
int os__file_last_mod_unix(string path) {
  struct /*c struct init*/

      stat attr;
  stat((char *)path.str, &attr);
  return attr.st_mtime;
}
void os__log(string s) { println(string_add(tos3("os.log: "), s)); }
void os__flush_stdout() {
  v_panic(tos3("Use `os.flush` instead of `os.flush_stdout`"));
}
void os__flush() { fflush(stdout); }
void os__mkdir_all(string path) {
  string p =
      ((string_starts_with(path, os__path_separator)) ? (os__path_separator)
                                                      : (tos3("")));
  array_string tmp79 = string_split(path, os__path_separator);
  for (int tmp80 = 0; tmp80 < tmp79.len; tmp80++) {
    string subdir = ((string *)tmp79.data)[tmp80];

    p = string_add(p, string_add(subdir, os__path_separator));
    if (!os__is_dir(p)) {
      Option_bool tmp81 = os__mkdir(p);
      if (!tmp81.ok) {
        string err = tmp81.error;
        int errcode = tmp81.ecode;
        v_panic(err);
      };
    };
  };
}
string os__cache_dir() {
#ifndef _WIN32
#endif
  ;
  string cdir = string_add(os__home_dir(), tos3(".cache"));
  if (!os__is_dir(cdir) && !os__is_link(cdir)) {
    Option_bool tmp82 = os__mkdir(cdir);
    if (!tmp82.ok) {
      string err = tmp82.error;
      int errcode = tmp82.ecode;
      v_panic(err);
    };
  };
  return cdir;
}
string os__temp_dir() {
  string path = os__getenv(tos3("TMPDIR"));
#ifdef _WIN32
  if (string_eq(path, tos3(""))) {
    path = os__getenv(tos3("TEMP"));
    if (string_eq(path, tos3(""))) {
      path = os__getenv(tos3("TMP"));
    };
    if (string_eq(path, tos3(""))) {
      path = tos3("C:/tmp");
    };
  };
#endif
  ;
  if (string_eq(path, tos3(""))) {
    path = os__cache_dir();
  };
  if (string_eq(path, tos3(""))) {
    path = tos3("/tmp");
  };
  return path;
}
void os__chmod(string path, int mode) { chmod((char *)path.str, mode); }
string os__resource_abs_path(string path) {
  string base_path = os__realpath(os__dir(os__executable()));
  string vresource = os__getenv(tos3("V_RESOURCE_PATH"));
  if (vresource.len != 0) {
    base_path = vresource;
  };
  return os__realpath(
      os__join_path(base_path, &(varg_string){.len = 1, .args = {path}}));
}
array_string os__init_os_args_wide(int argc, byteptr *argv) {
  array_string args = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  int tmp1 = 0;
  ;
  for (int tmp2 = tmp1; tmp2 < argc; tmp2++) {
    int i = tmp2;

    _PUSH(&args,
          (/*typ = array_string   tmp_typ=string*/ string_from_wide(
              ((u16 *)(argv[/*ptr!*/ i] /*rbyteptr 0*/)))),
          tmp3, string);
  };
  return args;
}
Option_array_string os__ls(string path) {
  os__Win32finddata find_file_data = (os__Win32finddata){.dwFileAttributes = 0,
                                                         .nFileSizeHigh = 0,
                                                         .nFileSizeLow = 0,
                                                         .dwReserved0 = 0,
                                                         .dwReserved1 = 0,
                                                         .dwFileType = 0,
                                                         .dwCreatorType = 0,
                                                         .wFinderFlags = 0};
  array_string dir_files = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  if (!os__is_dir(path)) {
    return v_error(
        _STR("ls() couldnt open dir \"%.*s\": directory does not exist",
             path.len, path.str));
  };
  string path_files = _STR("%.*s\\*", path.len, path.str);
  void *h_find_files =
      FindFirstFile(string_to_wide(path_files), ((voidptr)(&find_file_data)));
  string first_filename = string_from_wide(((u16 *)(find_file_data.cFileName)));
  if (string_ne(first_filename, tos3(".")) &&
      string_ne(first_filename, tos3(".."))) {
    _PUSH(&dir_files, (/*typ = array_string   tmp_typ=string*/ first_filename),
          tmp4, string);
  };
  while (FindNextFile(h_find_files, ((voidptr)(&find_file_data)))) {

    string filename = string_from_wide(((u16 *)(find_file_data.cFileName)));
    if (string_ne(filename, tos3(".")) && string_ne(filename, tos3(".."))) {
      _PUSH(&dir_files,
            (/*typ = array_string   tmp_typ=string*/ string_clone(filename)),
            tmp5, string);
    };
  };
  FindClose(h_find_files);
  array_string tmp6 = OPTION_CAST(array_string)(dir_files);
  return opt_ok(&tmp6, sizeof(array_string));
}
Option_os__File os__open(string path) {
  os__File file = (os__File){
      .cfile = _wfopen(string_to_wide(path), string_to_wide(tos3("rb"))),
      .opened = 1,
      .fd = 0,
  };
  if (isnil(file.cfile)) {
    return v_error(_STR("failed to open file \"%.*s\"", path.len, path.str));
  };
  os__File tmp7 = OPTION_CAST(os__File)(file);
  return opt_ok(&tmp7, sizeof(os__File));
}
Option_os__File os__create(string path) {
  os__File file = (os__File){
      .cfile = _wfopen(string_to_wide(path), string_to_wide(tos3("wb"))),
      .opened = 1,
      .fd = 0,
  };
  if (isnil(file.cfile)) {
    return v_error(_STR("failed to create file \"%.*s\"", path.len, path.str));
  };
  os__File tmp8 = OPTION_CAST(os__File)(file);
  return opt_ok(&tmp8, sizeof(os__File));
}
void os__File_write(os__File *f, string s) {
  if (!f->opened) {

    return;
  };
  fputs((char *)s.str, f->cfile);
}
void os__File_writeln(os__File *f, string s) {
  if (!f->opened) {

    return;
  };
  fputs((char *)s.str, f->cfile);
  fputs("\n", f->cfile);
}
Option_bool os__mkdir(string path) {
  if (string_eq(path, tos3("."))) {
    bool tmp9 = OPTION_CAST(bool)(1);
    return opt_ok(&tmp9, sizeof(bool));
  };
  string apath = os__realpath(path);
  if (!CreateDirectory(string_to_wide(apath), 0)) {
    return v_error(string_add(
        _STR("mkdir failed for \"%.*s\", because CreateDirectory returned ",
             apath.len, apath.str),
        os__get_error_msg(((int)(GetLastError())))));
  };
  bool tmp10 = OPTION_CAST(bool)(1);
  return opt_ok(&tmp10, sizeof(bool));
}
os__HANDLE os__get_file_handle(string path) {
  string mode = tos3("rb");
  void *_fd = _wfopen(string_to_wide(path), string_to_wide(mode));
  if (_fd == 0) {
    return ((os__HANDLE)(os__INVALID_HANDLE_VALUE));
  };
  os__HANDLE _handle = ((os__HANDLE)(_get_osfhandle(_fileno(_fd))));
  return _handle;
}
Option_string os__get_module_filename(os__HANDLE handle) {
  {
    int sz = 4096;
    u16 *buf = ((u16 *)(v_malloc(4096)));
    while (1) {
      int status = ((int)(GetModuleFileNameW(handle, ((voidptr)(&buf)), sz)));
      int tmp11 = status;

      if (tmp11 == os__SUCCESS) {
        string _filename = string_from_wide2(buf, sz);
        string tmp12 = OPTION_CAST(string)(_filename);
        return opt_ok(&tmp12, sizeof(string));
      } else // default:
      {
        return v_error(tos3("Cannot get file name from handle"));
      };
    };
  };
  v_panic(tos3("this should be unreachable"));
}
void *os__ptr_win_get_error_msg(u32 code) {
  voidptr buf = ((voidptr)(0));
  if (code > ((u32)(os__MAX_ERROR_CODE))) {
    return buf;
  };
  FormatMessage(os__FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    os__FORMAT_MESSAGE_FROM_SYSTEM |
                    os__FORMAT_MESSAGE_IGNORE_INSERTS,
                0, code, MAKELANGID(os__LANG_NEUTRAL, os__SUBLANG_DEFAULT),
                ((voidptr)(&buf)), 0, 0);
  return buf;
}
string os__get_error_msg(int code) {
  if (code < 0) {
    return tos3("");
  };
  void *_ptr_text = os__ptr_win_get_error_msg(((u32)(code)));
  if (_ptr_text == 0) {
    return tos3("");
  };
  return string_from_wide(_ptr_text);
}
Option_os__Result os__exec(string cmd) {
  if (string_contains(cmd, tos3(";")) || string_contains(cmd, tos3("&&")) ||
      string_contains(cmd, tos3("||")) || string_contains(cmd, tos3("\n"))) {
    return v_error(tos3(";, &&, || and \\n are not allowed in shell commands"));
  };
  u32 *child_stdin = ((u32 *)(0));
  u32 *child_stdout_read = ((u32 *)(0));
  u32 *child_stdout_write = ((u32 *)(0));
  os__SecurityAttributes sa = (os__SecurityAttributes){
      .nLength = 0, .lpSecurityDescriptor = 0, .bInheritHandle = 0};
  sa.nLength = sizeof(SECURITY_ATTRIBUTES);
  sa.bInheritHandle = 1;
  bool create_pipe_ok =
      CreatePipe(((voidptr)(&child_stdout_read)),
                 ((voidptr)(&child_stdout_write)), ((voidptr)(&sa)), 0);
  if (!create_pipe_ok) {
    string error_msg = os__get_error_msg(((int)(GetLastError())));
    return v_error(
        _STR("exec failed (CreatePipe): %.*s", error_msg.len, error_msg.str));
  };
  bool set_handle_info_ok =
      SetHandleInformation(child_stdout_read, HANDLE_FLAG_INHERIT, 0);
  if (!set_handle_info_ok) {
    string error_msg = os__get_error_msg(((int)(GetLastError())));
    v_panic(_STR("exec failed (SetHandleInformation): %.*s", error_msg.len,
                 error_msg.str));
  };
  os__ProcessInformation proc_info = (os__ProcessInformation){
      .hProcess = 0, .hThread = 0, .dwProcessId = 0, .dwThreadId = 0};
  os__StartupInfo start_info = (os__StartupInfo){.cb = 0,
                                                 .lpReserved = 0,
                                                 .lpDesktop = 0,
                                                 .lpTitle = 0,
                                                 .dwX = 0,
                                                 .dwY = 0,
                                                 .dwXSize = 0,
                                                 .dwYSize = 0,
                                                 .dwXCountChars = 0,
                                                 .dwYCountChars = 0,
                                                 .dwFillAttribute = 0,
                                                 .dwFlags = 0,
                                                 .wShowWindow = 0,
                                                 .cbReserved2 = 0,
                                                 .lpReserved2 = 0,
                                                 .hStdInput = 0,
                                                 .hStdOutput = 0,
                                                 .hStdError = 0};
  start_info.cb = sizeof(PROCESS_INFORMATION);
  start_info.hStdInput = child_stdin;
  start_info.hStdOutput = child_stdout_write;
  start_info.hStdError = child_stdout_write;
  start_info.dwFlags = ((u32)(STARTF_USESTDHANDLES));
  u16 command_line[32768] = {0};
  ExpandEnvironmentStringsW(string_to_wide(cmd), ((voidptr)(&command_line)),
                            32768);
  bool create_process_ok =
      CreateProcessW(0, command_line, 0, 0, TRUE, 0, 0, 0,
                     ((voidptr)(&start_info)), ((voidptr)(&proc_info)));
  if (!create_process_ok) {
    string error_msg = os__get_error_msg(((int)(GetLastError())));
    return v_error(_STR("exec failed (CreateProcess): %.*s", error_msg.len,
                        error_msg.str));
  };
  CloseHandle(child_stdin);
  CloseHandle(child_stdout_write);
  byte buf[4096] = {0};
  u32 bytes_read = ((u32)(0));
  strings__Builder read_data = strings__new_builder(1024);
  while (1) {
    bool readfile_result =
        ReadFile(child_stdout_read, buf, 1000, ((voidptr)(&bytes_read)), 0);
    strings__Builder_write_bytes(&/* ? */ read_data, buf, ((int)(bytes_read)));
    if (readfile_result == 0 || ((int)(bytes_read)) == 0) {
      break;
    };
  };
  string soutput = string_trim_space(strings__Builder_str(&/* ? */ read_data));
  strings__Builder_free(&/* ? */ read_data);
  u32 exit_code = ((u32)(0));
  WaitForSingleObject(proc_info.hProcess, INFINITE);
  GetExitCodeProcess(proc_info.hProcess, ((voidptr)(&exit_code)));
  CloseHandle(proc_info.hProcess);
  CloseHandle(proc_info.hThread);
  os__Result tmp13 = OPTION_CAST(os__Result)(
      (os__Result){.output = soutput, .exit_code = ((int)(exit_code))});
  return opt_ok(&tmp13, sizeof(os__Result));
}
Option_bool os__symlink(string origin, string target) {
  int flags = ((os__is_dir(origin)) ? (1) : (0));
  if (CreateSymbolicLinkW(string_to_wide(origin), string_to_wide(target),
                          ((u32)(flags))) != 0) {
    bool tmp14 = OPTION_CAST(bool)(1);
    return opt_ok(&tmp14, sizeof(bool));
  };
  return v_error(os__get_error_msg(((int)(GetLastError()))));
}
void os__File_write_bytes(os__File *f, void *data, int size) {
  fwrite(data, 1, size, f->cfile);
}
void os__File_close(os__File *f) {
  if (!f->opened) {

    return;
  };
  f->opened = 0;
  fflush(f->cfile);
  fclose(f->cfile);
}
void v_dot_pref__Preferences_fill_with_defaults(v_dot_pref__Preferences *p) {
  if (string_eq(p->vroot, tos3(""))) {
    p->vroot = os__dir(v_dot_pref__vexe_path());
  };
  string vlib_path =
      os__join_path(p->vroot, &(varg_string){.len = 1, .args = {tos3("vlib")}});
  if (p->lookup_path.len == 0) {
    p->lookup_path = new_array_from_c_array(
        2, 2, sizeof(string),
        EMPTY_ARRAY_OF_ELEMS(string, 2){tos3("@vlib"), tos3("@vmodules")});
  };
  array_string tmp1 = p->lookup_path;
  for (int i = 0; i < tmp1.len; i++) {
    string path = ((string *)tmp1.data)[i];

    array_set(&/*q*/ p->lookup_path, i,
              &(string[]){string_replace(
                  string_replace(path, tos3("@vlib"), vlib_path),
                  tos3("@vmodules"), v_dot_pref__default_module_path)});
  };
  string rpath = os__realpath(p->path);
  if (string_eq(p->out_name, tos3(""))) {
    string filename = string_trim_space(os__filename(rpath));
    string base = string_all_before_last(filename, tos3("."));
    if (string_eq(base, tos3(""))) {
      base = filename;
    };
    string target_dir = ((os__is_dir(rpath)) ? (rpath) : (os__dir(rpath)));
    p->out_name =
        os__join_path(target_dir, &(varg_string){.len = 1, .args = {base}});
    if (string_eq(rpath, _STR("%.*s/cmd/v", p->vroot.len, p->vroot.str)) &&
        os__is_dir(tos3("vlib/compiler"))) {
      println(tos3("Saving the resulting V executable in `./v2`"));
      println(
          string_add(tos3("Use `v -o v cmd/v` if you want to replace current "),
                     tos3("V executable.")));
      p->out_name = tos3("v2");
    };
  };
  string rpath_name = os__filename(rpath);
  p->building_v = !p->is_repl && (string_eq(rpath_name, tos3("v")) ||
                                  string_eq(rpath_name, tos3("vfmt.v")));
  if (p->os == v_dot_pref__v_dot_pref__OS__auto) {
    p->os = v_dot_pref__get_host_os();
  };
  if (string_eq(p->ccompiler, tos3(""))) {
    p->ccompiler = v_dot_pref__default_c_compiler();
  };
  p->is_test = string_ends_with(p->path, tos3("_test.v"));
  p->is_script = string_ends_with(p->path, tos3(".v")) ||
                 string_ends_with(p->path, tos3(".vsh"));
  if (string_eq(p->third_party_option, tos3(""))) {
    p->third_party_option = p->cflags;
#ifndef _WIN32
#endif
    ;
  };
}
string v_dot_pref__default_c_compiler() {
#ifdef _WIN32
  return tos3("gcc");
#endif
  ;
  return tos3("cc");
}
string v_dot_pref__vexe_path() {
  string vexe = os__getenv(tos3("VEXE"));
  if (string_ne(vexe, tos3(""))) {
    return vexe;
  };
  string real_vexe_path = os__realpath(os__executable());
  os__setenv(tos3("VEXE"), real_vexe_path, 1);
  return real_vexe_path;
}
Option_v_dot_pref__OS v_dot_pref__os_from_string(string os_str) {
  string tmp1 = os_str;

  if (string_eq(tmp1, tos3("linux"))) {
    v_dot_pref__OS tmp2 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS_linux);
    return opt_ok(&tmp2, sizeof(v_dot_pref__OS));
  } else if (string_eq(tmp1, tos3("windows"))) {
    v_dot_pref__OS tmp3 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS_windows);
    return opt_ok(&tmp3, sizeof(v_dot_pref__OS));
  } else if (string_eq(tmp1, tos3("mac"))) {
    v_dot_pref__OS tmp4 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS_mac);
    return opt_ok(&tmp4, sizeof(v_dot_pref__OS));
  } else if (string_eq(tmp1, tos3("macos"))) {
    v_dot_pref__OS tmp5 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS_mac);
    return opt_ok(&tmp5, sizeof(v_dot_pref__OS));
  } else if (string_eq(tmp1, tos3("freebsd"))) {
    v_dot_pref__OS tmp6 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS_freebsd);
    return opt_ok(&tmp6, sizeof(v_dot_pref__OS));
  } else if (string_eq(tmp1, tos3("openbsd"))) {
    v_dot_pref__OS tmp7 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS_openbsd);
    return opt_ok(&tmp7, sizeof(v_dot_pref__OS));
  } else if (string_eq(tmp1, tos3("netbsd"))) {
    v_dot_pref__OS tmp8 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS_netbsd);
    return opt_ok(&tmp8, sizeof(v_dot_pref__OS));
  } else if (string_eq(tmp1, tos3("dragonfly"))) {
    v_dot_pref__OS tmp9 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS_dragonfly);
    return opt_ok(&tmp9, sizeof(v_dot_pref__OS));
  } else if (string_eq(tmp1, tos3("js"))) {
    v_dot_pref__OS tmp10 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS_js);
    return opt_ok(&tmp10, sizeof(v_dot_pref__OS));
  } else if (string_eq(tmp1, tos3("solaris"))) {
    v_dot_pref__OS tmp11 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS_solaris);
    return opt_ok(&tmp11, sizeof(v_dot_pref__OS));
  } else if (string_eq(tmp1, tos3("android"))) {
    v_dot_pref__OS tmp12 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS_android);
    return opt_ok(&tmp12, sizeof(v_dot_pref__OS));
  } else if (string_eq(tmp1, tos3("haiku"))) {
    v_dot_pref__OS tmp13 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS_haiku);
    return opt_ok(&tmp13, sizeof(v_dot_pref__OS));
  } else if (string_eq(tmp1, tos3("linux_or_macos"))) {
    v_dot_pref__OS tmp14 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS_linux);
    return opt_ok(&tmp14, sizeof(v_dot_pref__OS));
  } else if (string_eq(tmp1, tos3(""))) {
    v_dot_pref__OS tmp15 =
        OPTION_CAST(v_dot_pref__OS)(v_dot_pref__v_dot_pref__OS__auto);
    return opt_ok(&tmp15, sizeof(v_dot_pref__OS));
  } else // default:
  {
    return v_error(_STR("bad OS %.*s", os_str.len, os_str.str));
  };
}
string v_dot_pref__OS_str(v_dot_pref__OS o) {
  v_dot_pref__OS tmp16 = o;

  if (tmp16 == v_dot_pref__v_dot_pref__OS__auto) {
    return tos3("RESERVED: AUTO");
  } else if (tmp16 == v_dot_pref__v_dot_pref__OS_mac) {
    return tos3("MacOS");
  } else if (tmp16 == v_dot_pref__v_dot_pref__OS_linux) {
    return tos3("Linux");
  } else if (tmp16 == v_dot_pref__v_dot_pref__OS_windows) {
    return tos3("Windows");
  } else if (tmp16 == v_dot_pref__v_dot_pref__OS_freebsd) {
    return tos3("FreeBSD");
  } else if (tmp16 == v_dot_pref__v_dot_pref__OS_openbsd) {
    return tos3("OpenBSD");
  } else if (tmp16 == v_dot_pref__v_dot_pref__OS_netbsd) {
    return tos3("NetBSD");
  } else if (tmp16 == v_dot_pref__v_dot_pref__OS_dragonfly) {
    return tos3("Dragonfly");
  } else if (tmp16 == v_dot_pref__v_dot_pref__OS_js) {
    return tos3("JavaScript");
  } else if (tmp16 == v_dot_pref__v_dot_pref__OS_android) {
    return tos3("Android");
  } else if (tmp16 == v_dot_pref__v_dot_pref__OS_solaris) {
    return tos3("Solaris");
  } else if (tmp16 == v_dot_pref__v_dot_pref__OS_haiku) {
    return tos3("Haiku");
  } else // default:
  {
    v_panic(_STR("unknown OS enum type: %d", o));
  };
}
v_dot_pref__OS v_dot_pref__get_host_os() {
#ifdef __linux__
#endif
  ;
#ifdef __APPLE__
#endif
  ;
#ifdef _WIN32
  return v_dot_pref__v_dot_pref__OS_windows;
#endif
  ;
#ifdef __FreeBSD__
#endif
  ;
#ifdef __OpenBSD__
#endif
  ;
#ifdef __NetBSD__
#endif
  ;
#ifdef __DragonFly__
#endif
  ;
#ifdef __sun
#endif
  ;
#ifdef __haiku__
#endif
  ;
  v_panic(tos3("unknown host OS"));
}
Option_v_dot_pref__Backend v_dot_pref__backend_from_string(string s) {
  string tmp1 = s;

  if (string_eq(tmp1, tos3("c"))) {
    v_dot_pref__Backend tmp2 =
        OPTION_CAST(v_dot_pref__Backend)(v_dot_pref__v_dot_pref__Backend_c);
    return opt_ok(&tmp2, sizeof(v_dot_pref__Backend));
  } else if (string_eq(tmp1, tos3("js"))) {
    v_dot_pref__Backend tmp3 =
        OPTION_CAST(v_dot_pref__Backend)(v_dot_pref__v_dot_pref__Backend_js);
    return opt_ok(&tmp3, sizeof(v_dot_pref__Backend));
  } else if ((string_eq(tmp1, tos3("experimental"))) ||
             (string_eq(tmp1, tos3("v2")))) {
    v_dot_pref__Backend tmp4 = OPTION_CAST(v_dot_pref__Backend)(
        v_dot_pref__v_dot_pref__Backend_experimental);
    return opt_ok(&tmp4, sizeof(v_dot_pref__Backend));
  } else if (string_eq(tmp1, tos3("x64"))) {
    v_dot_pref__Backend tmp5 =
        OPTION_CAST(v_dot_pref__Backend)(v_dot_pref__v_dot_pref__Backend_x64);
    return opt_ok(&tmp5, sizeof(v_dot_pref__Backend));
  } else // default:
  {
    return v_error(_STR("Unknown backend type %.*s", s.len, s.str));
  };
}
static inline bool
v_dot_pref__VerboseLevel_is_higher_or_equal(v_dot_pref__VerboseLevel v,
                                            v_dot_pref__VerboseLevel other) {
  return ((int)(v)) >= ((int)(other));
}
bool array_v_dot_table__Type_contains(array_v_dot_table__Type types,
                                      v_dot_table__Type typ) {
  array_v_dot_table__Type tmp1 = types;
  for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
    v_dot_table__Type t = ((v_dot_table__Type *)tmp1.data)[tmp2];

    if (((int)(typ)) == ((int)(t))) {
      return 1;
    };
  };
  return 0;
}
static inline int v_dot_table__type_idx(v_dot_table__Type t) {
  return ((u16)(t)) & 0xffff;
}
static inline int v_dot_table__type_nr_muls(v_dot_table__Type t) {
  return (((int)(t)) >> 16) & 0xff;
}
static inline bool v_dot_table__type_is_ptr(v_dot_table__Type t) {
  return v_dot_table__type_nr_muls(t) > 0;
}
static inline v_dot_table__Type
v_dot_table__type_set_nr_muls(v_dot_table__Type t, int nr_muls) {
  if (nr_muls < 0 || nr_muls > 255) {
    v_panic(tos3("typ_set_nr_muls: nr_muls must be between 0 & 255"));
  };
  return (((int)(v_dot_table__type_extra(t))) << 24) | (nr_muls << 16) |
         ((u16)(v_dot_table__type_idx(t)));
}
static inline v_dot_table__Type v_dot_table__type_to_ptr(v_dot_table__Type t) {
  int nr_muls = v_dot_table__type_nr_muls(t);
  if (nr_muls == 255) {
    v_panic(tos3("type_to_pre: nr_muls is already at max of 255"));
  };
  return (((int)(v_dot_table__type_extra(t))) << 24) | ((nr_muls + 1) << 16) |
         ((u16)(v_dot_table__type_idx(t)));
}
static inline v_dot_table__Type v_dot_table__type_deref(v_dot_table__Type t) {
  int nr_muls = v_dot_table__type_nr_muls(t);
  if (nr_muls == 0) {
    v_panic(_STR("deref: type `%d` is not a pointer", t));
  };
  return (((int)(v_dot_table__type_extra(t))) << 24) | ((nr_muls - 1) << 16) |
         ((u16)(v_dot_table__type_idx(t)));
}
static inline v_dot_table__Type
v_dot_table__type_clear_extra(v_dot_table__Type t) {
  return v_dot_table__type_set_extra(t,
                                     v_dot_table__v_dot_table__TypeExtra_unset);
}
static inline v_dot_table__TypeExtra
v_dot_table__type_extra(v_dot_table__Type t) {
  return (((int)(t)) >> 24) & 0xff;
}
static inline v_dot_table__Type
v_dot_table__type_set_extra(v_dot_table__Type t, v_dot_table__TypeExtra extra) {
  return (((int)(extra)) << 24) | (v_dot_table__type_nr_muls(t) << 16) |
         ((u16)(v_dot_table__type_idx(t)));
}
static inline bool v_dot_table__type_is_optional(v_dot_table__Type t) {
  return v_dot_table__type_extra(t) ==
         v_dot_table__v_dot_table__TypeExtra_optional;
}
static inline v_dot_table__Type
v_dot_table__type_to_optional(v_dot_table__Type t) {
  return v_dot_table__type_set_extra(
      t, v_dot_table__v_dot_table__TypeExtra_optional);
}
static inline bool v_dot_table__type_is_variadic(v_dot_table__Type t) {
  return v_dot_table__type_extra(t) ==
         v_dot_table__v_dot_table__TypeExtra_variadic;
}
static inline v_dot_table__Type
v_dot_table__type_to_variadic(v_dot_table__Type t) {
  return v_dot_table__type_set_extra(
      t, v_dot_table__v_dot_table__TypeExtra_variadic);
}
static inline v_dot_table__Type v_dot_table__new_type(int idx) {
  if (idx < 1 || idx > 65536) {
    v_panic(tos3("new_type_id: idx must be between 1 & 65536"));
  };
  return idx;
}
static inline v_dot_table__Type v_dot_table__new_type_ptr(int idx,
                                                          int nr_muls) {
  if (idx < 1 || idx > 65536) {
    v_panic(tos3("typ_ptr: idx must be between 1 & 65536"));
  };
  if (nr_muls < 0 || nr_muls > 255) {
    v_panic(tos3("typ_ptr: nr_muls must be between 0 & 255"));
  };
  return (nr_muls << 16) | ((u16)(idx));
}
string v_dot_table__TypeSymbol_str(v_dot_table__TypeSymbol *t) {
  return string_replace(t->name, tos3("array_"), tos3("[]"));
}
static inline v_dot_table__Enum
v_dot_table__TypeSymbol_enum_info(v_dot_table__TypeSymbol *t) {
  v_dot_table__TypeInfo tmp3 = t->info;

  if (tmp3.typ == SumType_v_dot_table__TypeInfo_Enum) {
    v_dot_table__Enum *it = (v_dot_table__Enum *)tmp3.obj;
    return *it;
  } else // default:
  {
    v_panic(_STR("TypeSymbol.enum_info(): no enum info for type: %.*s",
                 t->name.len, t->name.str));
  };
}
static inline v_dot_table__MultiReturn
v_dot_table__TypeSymbol_mr_info(v_dot_table__TypeSymbol *t) {
  v_dot_table__TypeInfo tmp4 = t->info;

  if (tmp4.typ == SumType_v_dot_table__TypeInfo_MultiReturn) {
    v_dot_table__MultiReturn *it = (v_dot_table__MultiReturn *)tmp4.obj;
    return *it;
  } else // default:
  {
    v_panic(_STR("TypeSymbol.mr_info(): no multi return info for type: %.*s",
                 t->name.len, t->name.str));
  };
}
static inline v_dot_table__Array
v_dot_table__TypeSymbol_array_info(v_dot_table__TypeSymbol *t) {
  v_dot_table__TypeInfo tmp5 = t->info;

  if (tmp5.typ == SumType_v_dot_table__TypeInfo_Array) {
    v_dot_table__Array *it = (v_dot_table__Array *)tmp5.obj;
    return *it;
  } else // default:
  {
    v_panic(_STR("TypeSymbol.array_info(): no array info for type: %.*s",
                 t->name.len, t->name.str));
  };
}
static inline v_dot_table__ArrayFixed
v_dot_table__TypeSymbol_array_fixed_info(v_dot_table__TypeSymbol *t) {
  v_dot_table__TypeInfo tmp6 = t->info;

  if (tmp6.typ == SumType_v_dot_table__TypeInfo_ArrayFixed) {
    v_dot_table__ArrayFixed *it = (v_dot_table__ArrayFixed *)tmp6.obj;
    return *it;
  } else // default:
  {
    v_panic(_STR("TypeSymbol.array_fixed(): no array fixed info for type: %.*s",
                 t->name.len, t->name.str));
  };
}
static inline v_dot_table__Map
v_dot_table__TypeSymbol_map_info(v_dot_table__TypeSymbol *t) {
  v_dot_table__TypeInfo tmp7 = t->info;

  if (tmp7.typ == SumType_v_dot_table__TypeInfo_Map) {
    v_dot_table__Map *it = (v_dot_table__Map *)tmp7.obj;
    return *it;
  } else // default:
  {
    v_panic(_STR("TypeSymbol.map_info(): no map info for type: %.*s",
                 t->name.len, t->name.str));
  };
}
void v_dot_table__Table_register_builtin_type_symbols(v_dot_table__Table *t) {
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_placeholder,
             .name = tos3("reserved_0"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_void,
             .name = tos3("void"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_voidptr,
             .name = tos3("voidptr"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_byteptr,
             .name = tos3("byteptr"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_charptr,
             .name = tos3("charptr"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_i8,
             .name = tos3("i8"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_i16,
             .name = tos3("i16"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_int,
             .name = tos3("int"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_i64,
             .name = tos3("i64"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_byte,
             .name = tos3("byte"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_u16,
             .name = tos3("u16"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_u32,
             .name = tos3("u32"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_u64,
             .name = tos3("u64"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_f32,
             .name = tos3("f32"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_f64,
             .name = tos3("f64"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_char,
             .name = tos3("char"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_bool,
             .name = tos3("bool"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_none_,
             .name = tos3("none"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_string,
             .name = tos3("string"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_array,
             .name = tos3("array"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_map,
             .name = tos3("map"),
             .parent_idx = 0,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  int map_string_string_idx = v_dot_table__Table_find_or_register_map(
      t, v_dot_table__string_type, v_dot_table__string_type);
  int map_string_int_idx = v_dot_table__Table_find_or_register_map(
      t, v_dot_table__string_type, v_dot_table__int_type);
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_alias,
             .name = tos3("map_string"),
             .parent_idx = map_string_string_idx,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  v_dot_table__Table_register_type_symbol(
      t, (v_dot_table__TypeSymbol){
             .kind = v_dot_table__v_dot_table__Kind_alias,
             .name = tos3("map_int"),
             .parent_idx = map_string_int_idx,
             .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
}
static inline bool v_dot_table__TypeSymbol_is_int(v_dot_table__TypeSymbol *t) {
  return (t->kind == v_dot_table__v_dot_table__Kind_i8 ||
          t->kind == v_dot_table__v_dot_table__Kind_i16 ||
          t->kind == v_dot_table__v_dot_table__Kind_int ||
          t->kind == v_dot_table__v_dot_table__Kind_i64 ||
          t->kind == v_dot_table__v_dot_table__Kind_byte ||
          t->kind == v_dot_table__v_dot_table__Kind_u16 ||
          t->kind == v_dot_table__v_dot_table__Kind_u32 ||
          t->kind == v_dot_table__v_dot_table__Kind_u64);
}
static inline bool
v_dot_table__TypeSymbol_is_float(v_dot_table__TypeSymbol *t) {
  return (t->kind == v_dot_table__v_dot_table__Kind_f32 ||
          t->kind == v_dot_table__v_dot_table__Kind_f64);
}
static inline bool
v_dot_table__TypeSymbol_is_number(v_dot_table__TypeSymbol *t) {
  return v_dot_table__TypeSymbol_is_int(&/* ? */ *t) ||
         v_dot_table__TypeSymbol_is_float(&/* ? */ *t);
}
string v_dot_table__Kind_str(v_dot_table__Kind k) {
  v_dot_table__Kind tmp8 = k;

  string k_str =
      ((tmp8 == v_dot_table__v_dot_table__Kind_placeholder) ? (tos3("placeholde"
                                                                    "r"))
                                                            : ((tmp8 == v_dot_table__v_dot_table__Kind_void) ? (tos3(
                                                                                                                   "void"))
                                                                                                             : ((tmp8 == v_dot_table__v_dot_table__Kind_voidptr) ? (tos3(
                                                                                                                                                                       "voidptr"))
                                                                                                                                                                 : (
                                                                                                                                                                       (tmp8 == v_dot_table__v_dot_table__Kind_charptr) ? (tos3(
                                                                                                                                                                                                                              "charptr"))
                                                                                                                                                                                                                        : (
                                                                                                                                                                                                                              (tmp8 == v_dot_table__v_dot_table__Kind_byteptr) ? (tos3(
                                                                                                                                                                                                                                                                                     "byteptr"))
                                                                                                                                                                                                                                                                               : ((tmp8 ==
                                                                                                                                                                                                                                                                                   v_dot_table__v_dot_table__Kind_struct_)
                                                                                                                                                                                                                                                                                      ? (tos3(
                                                                                                                                                                                                                                                                                            "struct"))
                                                                                                                                                                                                                                                                                      : ((tmp8 ==
                                                                                                                                                                                                                                                                                          v_dot_table__v_dot_table__Kind_int)
                                                                                                                                                                                                                                                                                             ? (tos3(
                                                                                                                                                                                                                                                                                                   "int"))
                                                                                                                                                                                                                                                                                             : ((tmp8 ==
                                                                                                                                                                                                                                                                                                 v_dot_table__v_dot_table__Kind_i8)
                                                                                                                                                                                                                                                                                                    ? (tos3(
                                                                                                                                                                                                                                                                                                          "i8"))
                                                                                                                                                                                                                                                                                                    : ((tmp8 ==
                                                                                                                                                                                                                                                                                                        v_dot_table__v_dot_table__Kind_i16)
                                                                                                                                                                                                                                                                                                           ? (
                                                                                                                                                                                                                                                                                                                 tos3(
                                                                                                                                                                                                                                                                                                                     "i16"))
                                                                                                                                                                                                                                                                                                           : ((tmp8 == v_dot_table__v_dot_table__Kind_i64) ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                 "i64"))
                                                                                                                                                                                                                                                                                                                                                           : ((tmp8 == v_dot_table__v_dot_table__Kind_byte) ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                  "byte"))
                                                                                                                                                                                                                                                                                                                                                                                                            : (
                                                                                                                                                                                                                                                                                                                                                                                                                  (tmp8 == v_dot_table__v_dot_table__Kind_u16) ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "u16"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                               : (
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (tmp8 == v_dot_table__v_dot_table__Kind_u32) ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "u32"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  : ((tmp8 == v_dot_table__v_dot_table__Kind_u64) ? (tos3("u64"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  : ((tmp8 ==
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      v_dot_table__v_dot_table__Kind_f32)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "f32"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         : ((tmp8 == v_dot_table__v_dot_table__Kind_f64) ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "f64"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         : (
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               (tmp8 == v_dot_table__v_dot_table__Kind_string)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         "string"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   : (
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (tmp8 == v_dot_table__v_dot_table__Kind_char) ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "char"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       : (
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             (tmp8 == v_dot_table__v_dot_table__Kind_bool) ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "bool"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           : (
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     tmp8 == v_dot_table__v_dot_table__Kind_none_)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "none"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     : (
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               tmp8 == v_dot_table__v_dot_table__Kind_array)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "array"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               : (
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (tmp8 == v_dot_table__v_dot_table__Kind_array_fixed) ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "array_fixed"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          : (
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (tmp8 == v_dot_table__v_dot_table__Kind_map) ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   "map"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             : (
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (tmp8 == v_dot_table__v_dot_table__Kind_multi_return)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "multi_return"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       : (
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             (tmp8 == v_dot_table__v_dot_table__Kind_sum_type) ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "sum_type"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               : (
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (tmp8 == v_dot_table__v_dot_table__Kind_alias)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               "alias"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         : ((tmp8 ==
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             v_dot_table__v_dot_table__Kind_enum_)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ? (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "enum"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                : (tos3(
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "unknown")))))))))))))))))))))))))))));
  return k_str;
}
string array_v_dot_table__Kind_str(array_v_dot_table__Kind kinds) {
  string kinds_str = tos3("");
  array_v_dot_table__Kind tmp9 = kinds;
  for (int i = 0; i < tmp9.len; i++) {
    v_dot_table__Kind k = ((v_dot_table__Kind *)tmp9.data)[i];

    kinds_str = string_add(kinds_str, v_dot_table__Kind_str(k));
    if (i < kinds.len - 1) {
      kinds_str = string_add(kinds_str, tos3("_"));
    };
  };
  return kinds_str;
}
string v_dot_table__Table_type_to_str(v_dot_table__Table *table,
                                      v_dot_table__Type t) {
  v_dot_table__TypeSymbol *sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *table, t);
  if (sym->kind == v_dot_table__v_dot_table__Kind_multi_return) {
    string res = tos3("(");
    v_dot_table__MultiReturn mr_info =
        *(v_dot_table__MultiReturn *)sym->info.obj;
    array_v_dot_table__Type tmp10 = mr_info.types;
    for (int i = 0; i < tmp10.len; i++) {
      v_dot_table__Type typ = ((v_dot_table__Type *)tmp10.data)[i];

      res =
          string_add(res, v_dot_table__Table_type_to_str(&/* ? */ *table, typ));
      if (i < mr_info.types.len - 1) {
        res = string_add(res, tos3(", "));
      };
    };
    res = string_add(res, tos3(")"));
    return res;
  };
  string res = sym->name;
  if (sym->kind == v_dot_table__v_dot_table__Kind_array) {
    res = string_replace(res, tos3("array_"), tos3("[]"));
  } else if (sym->kind == v_dot_table__v_dot_table__Kind_map) {
    res = string_replace(res, tos3("map_string_"), tos3("map[string]"));
  };
  if (string_contains(res, tos3("."))) {
    array_string vals = string_split(res, tos3("."));
    if (vals.len > 2) {
      res = string_add(
          string_add((*(string *)array_get(vals, vals.len - 2)), tos3(".")),
          (*(string *)array_get(vals, vals.len - 1)));
    };
  };
  if (v_dot_table__type_is_optional(t)) {
    res = string_add(tos3("?"), res);
  };
  int nr_muls = v_dot_table__type_nr_muls(t);
  if (nr_muls > 0) {
    res = string_add(strings__repeat('&', nr_muls), res);
  };
  return res;
}
v_dot_table__Table *v_dot_table__new_table() {
  v_dot_table__Table *t = (v_dot_table__Table *)memdup(
      &(v_dot_table__Table){
          .types = new_array(0, 1, sizeof(v_dot_table__TypeSymbol)),
          .type_idxs = new_map(1, sizeof(int)),
          .fns = new_map(1, sizeof(v_dot_table__Fn)),
          .consts = new_map(1, sizeof(v_dot_table__Var)),
          .imports = new_array(0, 1, sizeof(string)),
          .modules = new_array(0, 1, sizeof(string))},
      sizeof(v_dot_table__Table));
  v_dot_table__Table_register_builtin_type_symbols(t);
  return t;
}
void v_dot_table__Table_register_const(v_dot_table__Table *t,
                                       v_dot_table__Var v) {
  map_set(&t->consts, v.name, &(v_dot_table__Var[]){v});
}
void v_dot_table__Table_register_global(v_dot_table__Table *t, string name,
                                        v_dot_table__Type typ) {
  map_set(&t->consts, name,
          &(v_dot_table__Var[]){(v_dot_table__Var){
              .name = name,
              .typ = typ,
              .is_const = 1,
              .is_global = 1,
              .is_mut = 0,
          }});
}
string v_dot_table__Fn_signature(v_dot_table__Fn *f) {
  string sig = tos3("");
  array_v_dot_table__Arg tmp1 = f->args;
  for (int i = 0; i < tmp1.len; i++) {
    v_dot_table__Arg arg = ((v_dot_table__Arg *)tmp1.data)[i];

    v_dot_table__Type typ = v_dot_table__type_set_nr_muls(arg.typ, 0);
    sig = string_add(sig, _STR("%d", typ));
    if (i < f->args.len - 1) {
      sig = string_add(sig, tos3("_"));
    };
  };
  sig = string_add(sig, _STR("_%d", f->return_type));
  return sig;
}
Option_v_dot_table__Fn v_dot_table__Table_find_fn(v_dot_table__Table *t,
                                                  string name) {
  v_dot_table__Fn tmp2 = {0};
  bool tmp3 = map_get(/*table.v : 90*/ t->fns, name, &tmp2);

  v_dot_table__Fn f = tmp2;
  if (f.name.str != 0) {
    v_dot_table__Fn tmp4 = OPTION_CAST(v_dot_table__Fn)(f);
    return opt_ok(&tmp4, sizeof(v_dot_table__Fn));
  };
  return opt_none();
}
Option_v_dot_table__Var v_dot_table__Table_find_const(v_dot_table__Table *t,
                                                      string name) {
  v_dot_table__Var tmp5 = {0};
  bool tmp6 = map_get(/*table.v : 99*/ t->consts, name, &tmp5);

  v_dot_table__Var f = tmp5;
  if (f.name.str != 0) {
    v_dot_table__Var tmp7 = OPTION_CAST(v_dot_table__Var)(f);
    return opt_ok(&tmp7, sizeof(v_dot_table__Var));
  };
  return opt_none();
}
void v_dot_table__Table_register_fn(v_dot_table__Table *t,
                                    v_dot_table__Fn new_fn) {
  map_set(&t->fns, new_fn.name, &(v_dot_table__Fn[]){new_fn});
}
void v_dot_table__TypeSymbol_register_method(v_dot_table__TypeSymbol *t,
                                             v_dot_table__Fn new_fn) {
  _PUSH(&t->methods,
        (/*typ = array_v_dot_table__Fn   tmp_typ=v_dot_table__Fn*/ new_fn),
        tmp8, v_dot_table__Fn);
}
bool v_dot_table__TypeSymbol_has_method(v_dot_table__TypeSymbol *t,
                                        string name) {
  Option_v_dot_table__Fn tmp9 =
      v_dot_table__TypeSymbol_find_method(&/* ? */ *t, name);
  if (!tmp9.ok) {
    string err = tmp9.error;
    int errcode = tmp9.ecode;
    return 0;
  };
  return 1;
}
Option_v_dot_table__Fn
v_dot_table__TypeSymbol_find_method(v_dot_table__TypeSymbol *t, string name) {
  array_v_dot_table__Fn tmp10 = t->methods;
  for (int tmp11 = 0; tmp11 < tmp10.len; tmp11++) {
    v_dot_table__Fn method = ((v_dot_table__Fn *)tmp10.data)[tmp11];

    if (string_eq(method.name, name)) {
      v_dot_table__Fn tmp12 = OPTION_CAST(v_dot_table__Fn)(method);
      return opt_ok(&tmp12, sizeof(v_dot_table__Fn));
    };
  };
  return opt_none();
}
bool v_dot_table__TypeSymbol_has_field(v_dot_table__TypeSymbol *s,
                                       string name) {
  Option_v_dot_table__Field tmp13 =
      v_dot_table__TypeSymbol_find_field(&/* ? */ *s, name);
  if (!tmp13.ok) {
    string err = tmp13.error;
    int errcode = tmp13.ecode;
    return 0;
  };
  return 1;
}
Option_v_dot_table__Field
v_dot_table__TypeSymbol_find_field(v_dot_table__TypeSymbol *s, string name) {
  v_dot_table__TypeInfo tmp14 = s->info;

  if (tmp14.typ == SumType_v_dot_table__TypeInfo_Struct) {
    v_dot_table__Struct *it = (v_dot_table__Struct *)tmp14.obj;
    array_v_dot_table__Field tmp15 = it->fields;
    for (int tmp16 = 0; tmp16 < tmp15.len; tmp16++) {
      v_dot_table__Field field = ((v_dot_table__Field *)tmp15.data)[tmp16];

      if (string_eq(field.name, name)) {
        v_dot_table__Field tmp17 = OPTION_CAST(v_dot_table__Field)(field);
        return opt_ok(&tmp17, sizeof(v_dot_table__Field));
      };
    };
  } else // default:
  {
  };
  return opt_none();
}
bool v_dot_table__Table_type_has_method(v_dot_table__Table *t,
                                        v_dot_table__TypeSymbol *s,
                                        string name) {
  Option_v_dot_table__Fn tmp18 =
      v_dot_table__Table_type_find_method(&/* ? */ *t, s, name);

  if (tmp18.ok) {
    v_dot_table__Fn _ = *(v_dot_table__Fn *)tmp18.data;
    return 1;
  };
  return 0;
}
Option_v_dot_table__Fn
v_dot_table__Table_type_find_method(v_dot_table__Table *t,
                                    v_dot_table__TypeSymbol *s, string name) {
  v_dot_table__TypeSymbol *ts = s;
  while (1) {
    Option_v_dot_table__Fn tmp19 =
        v_dot_table__TypeSymbol_find_method(&/* ? */ *ts, name);

    if (tmp19.ok) {
      v_dot_table__Fn method = *(v_dot_table__Fn *)tmp19.data;
      v_dot_table__Fn tmp20 = OPTION_CAST(v_dot_table__Fn)(method);
      return opt_ok(&tmp20, sizeof(v_dot_table__Fn));
    };
    if (ts->parent_idx == 0) {
      break;
    };
    ts = &(*(v_dot_table__TypeSymbol *)array_get(t->types, ts->parent_idx));
  };
  return opt_none();
}
bool v_dot_table__Table_struct_has_field(v_dot_table__Table *t,
                                         v_dot_table__TypeSymbol *s,
                                         string name) {
  Option_v_dot_table__Field tmp23 =
      v_dot_table__Table_struct_find_field(&/* ? */ *t, s, name);

  if (tmp23.ok) {
    v_dot_table__Field _ = *(v_dot_table__Field *)tmp23.data;
    return 1;
  };
  return 0;
}
Option_v_dot_table__Field
v_dot_table__Table_struct_find_field(v_dot_table__Table *t,
                                     v_dot_table__TypeSymbol *s, string name) {
  v_dot_table__TypeSymbol *ts = s;
  while (1) {
    Option_v_dot_table__Field tmp24 =
        v_dot_table__TypeSymbol_find_field(&/* ? */ *ts, name);

    if (tmp24.ok) {
      v_dot_table__Field field = *(v_dot_table__Field *)tmp24.data;
      v_dot_table__Field tmp25 = OPTION_CAST(v_dot_table__Field)(field);
      return opt_ok(&tmp25, sizeof(v_dot_table__Field));
    };
    if (ts->parent_idx == 0) {
      break;
    };
    ts = &(*(v_dot_table__TypeSymbol *)array_get(t->types, ts->parent_idx));
  };
  return opt_none();
}
static inline int v_dot_table__Table_find_type_idx(v_dot_table__Table *t,
                                                   string name) {
  int tmp28 = 0;
  bool tmp29 = map_get(/*table.v : 203*/ t->type_idxs, name, &tmp28);

  return tmp28;
}
static inline Option_v_dot_table__TypeSymbol
v_dot_table__Table_find_type(v_dot_table__Table *t, string name) {
  int tmp30 = 0;
  bool tmp31 = map_get(/*table.v : 208*/ t->type_idxs, name, &tmp30);

  int idx = tmp30;
  if (idx > 0) {
    v_dot_table__TypeSymbol tmp34 = OPTION_CAST(v_dot_table__TypeSymbol)(
        (*(v_dot_table__TypeSymbol *)array_get(t->types, idx)));
    return opt_ok(&tmp34, sizeof(v_dot_table__TypeSymbol));
  };
  return opt_none();
}
static inline v_dot_table__TypeSymbol *
v_dot_table__Table_get_type_symbol(v_dot_table__Table *t,
                                   v_dot_table__Type typ) {
  int idx = v_dot_table__type_idx(typ);
  if (idx > 0) {
    return &(*(v_dot_table__TypeSymbol *)array_get(t->types, idx));
  };
  v_panic(_STR(
      "get_type_symbol: invalid type (typ=%d idx=%d). This should neer happen",
      typ, idx));
}
static inline int
v_dot_table__Table_register_builtin_type_symbol(v_dot_table__Table *t,
                                                v_dot_table__TypeSymbol typ) {
  int tmp37 = 0;
  bool tmp38 = map_get(/*table.v : 231*/ t->type_idxs, typ.name, &tmp37);

  int existing_idx = tmp37;
  if (existing_idx > 0) {
    if (existing_idx >= v_dot_table__string_type_idx) {
      if (existing_idx == v_dot_table__string_type_idx) {
        v_dot_table__TypeSymbol *existing_type =
            &(*(v_dot_table__TypeSymbol *)array_get(t->types, existing_idx));
        array_set(&/*q*/ t->types, existing_idx,
                  &(v_dot_table__TypeSymbol[]){(v_dot_table__TypeSymbol){
                      .kind = existing_type->kind,
                      .parent_idx = typ.parent_idx,
                      .info = typ.info,
                      .name = typ.name,
                      .methods = typ.methods,
                  }});
      } else {
        array_set(&/*q*/ t->types, existing_idx,
                  &(v_dot_table__TypeSymbol[]){typ});
      };
    };
    return existing_idx;
  };
  return v_dot_table__Table_register_type_symbol(t, typ);
}
static inline int
v_dot_table__Table_register_type_symbol(v_dot_table__Table *t,
                                        v_dot_table__TypeSymbol typ) {
  int tmp41 = 0;
  bool tmp42 = map_get(/*table.v : 253*/ t->type_idxs, typ.name, &tmp41);

  int existing_idx = tmp41;
  if (existing_idx > 0) {
    v_dot_table__TypeSymbol ex_type =
        (*(v_dot_table__TypeSymbol *)array_get(t->types, existing_idx));
    v_dot_table__Kind tmp45 = ex_type.kind;

    if (tmp45 == v_dot_table__v_dot_table__Kind_placeholder) {
      array_set(&/*q*/ t->types, existing_idx,
                &(v_dot_table__TypeSymbol[]){(v_dot_table__TypeSymbol){
                    .methods = ex_type.methods,
                    .parent_idx = typ.parent_idx,
                    .info = typ.info,
                    .kind = typ.kind,
                    .name = typ.name,
                }});
      return existing_idx;
    } else // default:
    {
      if (ex_type.kind == typ.kind) {
        return existing_idx;
      };
      return -1;
    };
  };
  int typ_idx = t->types.len;
  _PUSH(
      &t->types,
      (/*typ = array_v_dot_table__TypeSymbol   tmp_typ=v_dot_table__TypeSymbol*/
       typ),
      tmp46, v_dot_table__TypeSymbol);
  map_set(&t->type_idxs, typ.name, &(int[]){typ_idx});
  return typ_idx;
}
bool v_dot_table__Table_known_type(v_dot_table__Table *t, string name) {
  Option_v_dot_table__TypeSymbol tmp47 =
      v_dot_table__Table_find_type(&/* ? */ *t, name);
  if (!tmp47.ok) {
    string err = tmp47.error;
    int errcode = tmp47.ecode;
    return 0;
  };
  return 1;
}
static inline string v_dot_table__Table_array_name(v_dot_table__Table *t,
                                                   v_dot_table__Type elem_type,
                                                   int nr_dims) {
  v_dot_table__TypeSymbol *elem_type_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *t, elem_type);
  return string_add(
      string_add(
          _STR("array_%.*s", elem_type_sym->name.len, elem_type_sym->name.str),
          ((v_dot_table__type_is_ptr(elem_type)) ? (tos3("_ptr"))
                                                 : (tos3("")))),
      ((nr_dims > 1) ? (_STR("_%dd", nr_dims)) : (tos3(""))));
}
static inline string v_dot_table__Table_array_fixed_name(
    v_dot_table__Table *t, v_dot_table__Type elem_type, int size, int nr_dims) {
  v_dot_table__TypeSymbol *elem_type_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *t, elem_type);
  return string_add(
      string_add(_STR("array_fixed_%.*s_%d", elem_type_sym->name.len,
                      elem_type_sym->name.str, size),
                 ((v_dot_table__type_is_ptr(elem_type)) ? (tos3("_ptr"))
                                                        : (tos3("")))),
      ((nr_dims > 1) ? (_STR("_%dd", nr_dims)) : (tos3(""))));
}
static inline string v_dot_table__Table_map_name(v_dot_table__Table *t,
                                                 v_dot_table__Type key_type,
                                                 v_dot_table__Type value_type) {
  v_dot_table__TypeSymbol *key_type_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *t, key_type);
  v_dot_table__TypeSymbol *value_type_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *t, value_type);
  string suffix =
      ((v_dot_table__type_is_ptr(value_type)) ? (tos3("_ptr")) : (tos3("")));
  return string_add(_STR("map_%.*s_%.*s", key_type_sym->name.len,
                         key_type_sym->name.str, value_type_sym->name.len,
                         value_type_sym->name.str),
                    suffix);
}
int v_dot_table__Table_find_or_register_map(v_dot_table__Table *t,
                                            v_dot_table__Type key_type,
                                            v_dot_table__Type value_type) {
  string name = v_dot_table__Table_map_name(&/* ? */ *t, key_type, value_type);
  int tmp48 = 0;
  bool tmp49 = map_get(/*table.v : 312*/ t->type_idxs, name, &tmp48);

  int existing_idx = tmp48;
  if (existing_idx > 0) {
    return existing_idx;
  };
  v_dot_table__TypeSymbol map_typ = (v_dot_table__TypeSymbol){
      .parent_idx = v_dot_table__map_type_idx,
      .kind = v_dot_table__v_dot_table__Kind_map,
      .name = name,
      .info = /*SUM TYPE CAST2*/ (
          v_dot_table__TypeInfo){.obj = memdup(
                                     &(v_dot_table__Map[]){(v_dot_table__Map){
                                         .key_type = key_type,
                                         .value_type = value_type}},
                                     sizeof(v_dot_table__Map)),
                                 .typ = SumType_v_dot_table__TypeInfo_Map},
      .methods = new_array(0, 1, sizeof(v_dot_table__Fn))};
  return v_dot_table__Table_register_type_symbol(t, map_typ);
}
int v_dot_table__Table_find_or_register_array(v_dot_table__Table *t,
                                              v_dot_table__Type elem_type,
                                              int nr_dims) {
  string name = v_dot_table__Table_array_name(&/* ? */ *t, elem_type, nr_dims);
  int tmp50 = 0;
  bool tmp51 = map_get(/*table.v : 332*/ t->type_idxs, name, &tmp50);

  int existing_idx = tmp50;
  if (existing_idx > 0) {
    return existing_idx;
  };
  v_dot_table__TypeSymbol array_type = (v_dot_table__TypeSymbol){
      .parent_idx = v_dot_table__array_type_idx,
      .kind = v_dot_table__v_dot_table__Kind_array,
      .name = name,
      .info = /*SUM TYPE CAST2*/ (
          v_dot_table__TypeInfo){.obj = memdup(&(v_dot_table__Array[]){(
                                                   v_dot_table__Array){
                                                   .elem_type = elem_type,
                                                   .nr_dims = nr_dims}},
                                               sizeof(v_dot_table__Array)),
                                 .typ = SumType_v_dot_table__TypeInfo_Array},
      .methods = new_array(0, 1, sizeof(v_dot_table__Fn))};
  return v_dot_table__Table_register_type_symbol(t, array_type);
}
int v_dot_table__Table_find_or_register_array_fixed(v_dot_table__Table *t,
                                                    v_dot_table__Type elem_type,
                                                    int size, int nr_dims) {
  string name = v_dot_table__Table_array_fixed_name(&/* ? */ *t, elem_type,
                                                    size, nr_dims);
  int tmp52 = 0;
  bool tmp53 = map_get(/*table.v : 352*/ t->type_idxs, name, &tmp52);

  int existing_idx = tmp52;
  if (existing_idx > 0) {
    return existing_idx;
  };
  v_dot_table__TypeSymbol array_fixed_type = (v_dot_table__TypeSymbol){
      .kind = v_dot_table__v_dot_table__Kind_array_fixed,
      .name = name,
      .info = /*SUM TYPE CAST2*/ (
          v_dot_table__TypeInfo){.obj = memdup(&(v_dot_table__ArrayFixed[]){(
                                                   v_dot_table__ArrayFixed){
                                                   .elem_type = elem_type,
                                                   .size = size,
                                                   .nr_dims = nr_dims}},
                                               sizeof(v_dot_table__ArrayFixed)),
                                 .typ =
                                     SumType_v_dot_table__TypeInfo_ArrayFixed},
      .parent_idx = 0,
      .methods = new_array(0, 1, sizeof(v_dot_table__Fn))};
  return v_dot_table__Table_register_type_symbol(t, array_fixed_type);
}
int v_dot_table__Table_find_or_register_multi_return(
    v_dot_table__Table *t, array_v_dot_table__Type mr_typs) {
  string name = tos3("multi_return");
  array_v_dot_table__Type tmp54 = mr_typs;
  for (int tmp55 = 0; tmp55 < tmp54.len; tmp55++) {
    v_dot_table__Type mr_typ = ((v_dot_table__Type *)tmp54.data)[tmp55];

    v_dot_table__TypeSymbol *mr_type_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *t, mr_typ);
    name = string_add(
        name, _STR("_%.*s", mr_type_sym->name.len, mr_type_sym->name.str));
  };
  int tmp56 = 0;
  bool tmp57 = map_get(/*table.v : 376*/ t->type_idxs, name, &tmp56);

  int existing_idx = tmp56;
  if (existing_idx > 0) {
    return existing_idx;
  };
  v_dot_table__TypeSymbol mr_type = (v_dot_table__TypeSymbol){
      .kind = v_dot_table__v_dot_table__Kind_multi_return,
      .name = name,
      .info = /*SUM TYPE CAST2*/ (
          v_dot_table__TypeInfo){.obj =
                                     memdup(&(v_dot_table__MultiReturn[]){(
                                                v_dot_table__MultiReturn){
                                                .types = mr_typs,
                                                .name = tos3(""),
                                            }},
                                            sizeof(v_dot_table__MultiReturn)),
                                 .typ =
                                     SumType_v_dot_table__TypeInfo_MultiReturn},
      .parent_idx = 0,
      .methods = new_array(0, 1, sizeof(v_dot_table__Fn))};
  return v_dot_table__Table_register_type_symbol(t, mr_type);
}
int v_dot_table__Table_find_or_register_fn_type(v_dot_table__Table *t,
                                                v_dot_table__Fn f) {
  string name =
      ((f.name.len > 0)
           ? (f.name)
           : (_STR("anon_%.*s", v_dot_table__Fn_signature(&/* ? */ f).len,
                   v_dot_table__Fn_signature(&/* ? */ f).str)));
  return v_dot_table__Table_register_type_symbol(
      t,
      (v_dot_table__TypeSymbol){
          .kind = v_dot_table__v_dot_table__Kind_function,
          .name = name,
          .info = /*SUM TYPE CAST2*/ (
              v_dot_table__TypeInfo){.obj = memdup(&(v_dot_table__Fn[]){f},
                                                   sizeof(v_dot_table__Fn)),
                                     .typ = SumType_v_dot_table__TypeInfo_Fn},
          .parent_idx = 0,
          .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
}
int v_dot_table__Table_add_placeholder_type(v_dot_table__Table *t,
                                            string name) {
  v_dot_table__TypeSymbol ph_type = (v_dot_table__TypeSymbol){
      .kind = v_dot_table__v_dot_table__Kind_placeholder,
      .name = name,
      .parent_idx = 0,
      .methods = new_array(0, 1, sizeof(v_dot_table__Fn))};
  return v_dot_table__Table_register_type_symbol(t, ph_type);
}
bool v_dot_table__Table_check(v_dot_table__Table *t, v_dot_table__Type got,
                              v_dot_table__Type expected) {
  v_dot_table__TypeSymbol *got_type_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *t, got);
  v_dot_table__TypeSymbol *exp_type_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *t, expected);
  int got_idx = v_dot_table__type_idx(got);
  int exp_idx = v_dot_table__type_idx(expected);
  bool exp_is_ptr = v_dot_table__type_is_ptr(expected);
  if (got_type_sym->kind == v_dot_table__v_dot_table__Kind_none_) {
    return 1;
  };
  if (exp_type_sym->kind == v_dot_table__v_dot_table__Kind_voidptr) {
    return 1;
  };
  if ((got_type_sym->kind == v_dot_table__v_dot_table__Kind_voidptr ||
       got_type_sym->kind == v_dot_table__v_dot_table__Kind_byteptr ||
       got_type_sym->kind == v_dot_table__v_dot_table__Kind_charptr ||
       got_type_sym->kind == v_dot_table__v_dot_table__Kind_int) &&
      (exp_type_sym->kind == v_dot_table__v_dot_table__Kind_voidptr ||
       exp_type_sym->kind == v_dot_table__v_dot_table__Kind_byteptr ||
       exp_type_sym->kind == v_dot_table__v_dot_table__Kind_charptr)) {
    return 1;
  };
  if (v_dot_table__TypeSymbol_is_int(&/* ? */ *got_type_sym) &&
      v_dot_table__TypeSymbol_is_int(&/* ? */ *exp_type_sym)) {
    return 1;
  };
  if (exp_is_ptr && got_idx == v_dot_table__int_type_idx) {
    return 1;
  };
  if ((v_dot_table__TypeSymbol_is_int(&/* ? */ *got_type_sym) &&
       exp_type_sym->kind == v_dot_table__v_dot_table__Kind_enum_) ||
      (v_dot_table__TypeSymbol_is_int(&/* ? */ *exp_type_sym) &&
       got_type_sym->kind == v_dot_table__v_dot_table__Kind_enum_)) {
    return 1;
  };
  if (v_dot_table__TypeSymbol_is_number(&/* ? */ *got_type_sym) &&
      v_dot_table__TypeSymbol_is_number(&/* ? */ *exp_type_sym)) {
    return 1;
  };
  if ((got_type_sym->kind == v_dot_table__v_dot_table__Kind_byte &&
       exp_type_sym->kind == v_dot_table__v_dot_table__Kind_byteptr) ||
      (exp_type_sym->kind == v_dot_table__v_dot_table__Kind_byte &&
       got_type_sym->kind == v_dot_table__v_dot_table__Kind_byteptr)) {
    return 1;
  };
  if (got_type_sym->kind == v_dot_table__v_dot_table__Kind_array_fixed &&
      exp_type_sym->kind == v_dot_table__v_dot_table__Kind_byteptr) {
    v_dot_table__ArrayFixed info =
        *(v_dot_table__ArrayFixed *)got_type_sym->info.obj;
    if (v_dot_table__type_idx(info.elem_type) == v_dot_table__byte_type_idx) {
      return 1;
    };
  };
  if (string_eq(exp_type_sym->name, tos3("array")) ||
      string_eq(got_type_sym->name, tos3("array"))) {
    return 1;
  };
  if (got_type_sym->kind == v_dot_table__v_dot_table__Kind_array &&
      string_eq(got_type_sym->name, tos3("array_void")) &&
      exp_type_sym->kind == v_dot_table__v_dot_table__Kind_array) {
    return 1;
  };
  if ((got_type_sym->kind == v_dot_table__v_dot_table__Kind_alias &&
       got_type_sym->parent_idx == exp_idx) ||
      (exp_type_sym->kind == v_dot_table__v_dot_table__Kind_alias &&
       exp_type_sym->parent_idx == got_idx)) {
    return 1;
  };
  if (got_type_sym->kind == v_dot_table__v_dot_table__Kind_sum_type) {
    v_dot_table__SumType sum_info =
        *(v_dot_table__SumType *)got_type_sym->info.obj;
    if ((_IN(v_dot_table__Type, (expected), sum_info.variants))) {
      return 1;
    };
  };
  if (exp_type_sym->kind == v_dot_table__v_dot_table__Kind_sum_type) {
    v_dot_table__SumType sum_info =
        *(v_dot_table__SumType *)exp_type_sym->info.obj;
    if ((_IN(v_dot_table__Type, (got), sum_info.variants))) {
      return 1;
    };
  };
  if (got_type_sym->kind == v_dot_table__v_dot_table__Kind_function &&
      exp_type_sym->kind == v_dot_table__v_dot_table__Kind_function) {
    v_dot_table__Fn got_fn = *(v_dot_table__Fn *)got_type_sym->info.obj;
    v_dot_table__Fn exp_fn = *(v_dot_table__Fn *)exp_type_sym->info.obj;
    if (string_eq(v_dot_table__Fn_signature(&/* ? */ got_fn),
                  v_dot_table__Fn_signature(&/* ? */ exp_fn))) {
      return 1;
    };
  };
  if (got_idx != exp_idx) {
    return 0;
  };
  return 1;
}
string v_dot_table__Table_qualify_module(v_dot_table__Table *table, string mod,
                                         string file_path) {
  array_string tmp58 = table->imports;
  for (int tmp59 = 0; tmp59 < tmp58.len; tmp59++) {
    string m = ((string *)tmp58.data)[tmp59];

    if (string_contains(m, tos3(".")) && string_contains(m, mod)) {
      array_string m_parts = string_split(m, tos3("."));
      string m_path = array_string_join(m_parts, os__path_separator);
      if (string_eq(mod, (*(string *)array_get(m_parts, m_parts.len - 1))) &&
          string_contains(file_path, m_path)) {
        return m;
      };
    };
  };
  return mod;
}
string term__format(string msg, string open, string close) {
  return string_add(
      string_add(
          string_add(
              string_add(string_add(string_add(tos3("\x1b["), open), tos3("m")),
                         msg),
              tos3("\x1b[")),
          close),
      tos3("m"));
}
string term__format_rgb(int r, int g, int b, string msg, string open,
                        string close) {
  return string_add(
      string_add(
          string_add(
              string_add(
                  string_add(
                      string_add(
                          string_add(
                              string_add(
                                  string_add(
                                      string_add(
                                          string_add(
                                              string_add(tos3("\x1b["), open),
                                              tos3(";2;")),
                                          int_str(r)),
                                      tos3(";")),
                                  int_str(g)),
                              tos3(";")),
                          int_str(b)),
                      tos3("m")),
                  msg),
              tos3("\x1b[")),
          close),
      tos3("m"));
}
string term__rgb(int r, int g, int b, string msg) {
  return term__format_rgb(r, g, b, msg, tos3("38"), tos3("39"));
}
string term__bg_rgb(int r, int g, int b, string msg) {
  return term__format_rgb(r, g, b, msg, tos3("48"), tos3("49"));
}
string term__hex(int hex, string msg) {
  return term__format_rgb(hex >> 16, hex >> 8 & 0xFF, hex & 0xFF, msg,
                          tos3("38"), tos3("39"));
}
string term__bg_hex(int hex, string msg) {
  return term__format_rgb(hex >> 16, hex >> 8 & 0xFF, hex & 0xFF, msg,
                          tos3("48"), tos3("49"));
}
string term__bg_black(string msg) {
  return term__format(msg, tos3("40"), tos3("49"));
}
string term__bright_bg_black(string msg) {
  return term__format(msg, tos3("100"), tos3("49"));
}
string term__bg_blue(string msg) {
  return term__format(msg, tos3("44"), tos3("49"));
}
string term__bright_bg_blue(string msg) {
  return term__format(msg, tos3("104"), tos3("49"));
}
string term__bg_cyan(string msg) {
  return term__format(msg, tos3("46"), tos3("49"));
}
string term__bright_bg_cyan(string msg) {
  return term__format(msg, tos3("106"), tos3("49"));
}
string term__bg_green(string msg) {
  return term__format(msg, tos3("42"), tos3("49"));
}
string term__bright_bg_green(string msg) {
  return term__format(msg, tos3("102"), tos3("49"));
}
string term__bg_magenta(string msg) {
  return term__format(msg, tos3("45"), tos3("49"));
}
string term__bright_bg_magenta(string msg) {
  return term__format(msg, tos3("105"), tos3("49"));
}
string term__bg_red(string msg) {
  return term__format(msg, tos3("41"), tos3("49"));
}
string term__bright_bg_red(string msg) {
  return term__format(msg, tos3("101"), tos3("49"));
}
string term__bg_white(string msg) {
  return term__format(msg, tos3("47"), tos3("49"));
}
string term__bright_bg_white(string msg) {
  return term__format(msg, tos3("107"), tos3("49"));
}
string term__bg_yellow(string msg) {
  return term__format(msg, tos3("43"), tos3("49"));
}
string term__bright_bg_yellow(string msg) {
  return term__format(msg, tos3("103"), tos3("49"));
}
string term__black(string msg) {
  return term__format(msg, tos3("30"), tos3("39"));
}
string term__bright_black(string msg) {
  return term__format(msg, tos3("90"), tos3("39"));
}
string term__blue(string msg) {
  return term__format(msg, tos3("34"), tos3("39"));
}
string term__bright_blue(string msg) {
  return term__format(msg, tos3("94"), tos3("39"));
}
string term__bold(string msg) {
  return term__format(msg, tos3("1"), tos3("22"));
}
string term__cyan(string msg) {
  return term__format(msg, tos3("36"), tos3("39"));
}
string term__bright_cyan(string msg) {
  return term__format(msg, tos3("96"), tos3("39"));
}
string term__dim(string msg) {
  return term__format(msg, tos3("2"), tos3("22"));
}
string term__green(string msg) {
  return term__format(msg, tos3("32"), tos3("39"));
}
string term__bright_green(string msg) {
  return term__format(msg, tos3("92"), tos3("39"));
}
string term__gray(string msg) { return term__bright_black(msg); }
string term__hidden(string msg) {
  return term__format(msg, tos3("8"), tos3("28"));
}
string term__italic(string msg) {
  return term__format(msg, tos3("3"), tos3("23"));
}
string term__inverse(string msg) {
  return term__format(msg, tos3("7"), tos3("27"));
}
string term__magenta(string msg) {
  return term__format(msg, tos3("35"), tos3("39"));
}
string term__bright_magenta(string msg) {
  return term__format(msg, tos3("95"), tos3("39"));
}
string term__reset(string msg) {
  return term__format(msg, tos3("0"), tos3("0"));
}
string term__red(string msg) {
  return term__format(msg, tos3("31"), tos3("39"));
}
string term__bright_red(string msg) {
  return term__format(msg, tos3("91"), tos3("39"));
}
string term__strikethrough(string msg) {
  return term__format(msg, tos3("9"), tos3("29"));
}
string term__underline(string msg) {
  return term__format(msg, tos3("4"), tos3("24"));
}
string term__white(string msg) {
  return term__format(msg, tos3("37"), tos3("39"));
}
string term__bright_white(string msg) {
  return term__format(msg, tos3("97"), tos3("39"));
}
string term__yellow(string msg) {
  return term__format(msg, tos3("33"), tos3("39"));
}
string term__bright_yellow(string msg) {
  return term__format(msg, tos3("93"), tos3("39"));
}
void term__set_cursor_position(int x, int y) {
  print(string_add(_STR("\x1b[%d;%d", y, x), tos3("H")));
}
void term__move(int n, string direction) {
  print(_STR("\x1b[%d%.*s", n, direction.len, direction.str));
}
void term__cursor_up(int n) { term__move(n, tos3("A")); }
void term__cursor_down(int n) { term__move(n, tos3("B")); }
void term__cursor_forward(int n) { term__move(n, tos3("C")); }
void term__cursor_back(int n) { term__move(n, tos3("D")); }
void term__erase_display(string t) {
  print(string_add(string_add(tos3("\x1b["), t), tos3("J")));
}
void term__erase_toend() { term__erase_display(tos3("0")); }
void term__erase_tobeg() { term__erase_display(tos3("1")); }
void term__erase_clear() { term__erase_display(tos3("2")); }
void term__erase_del_clear() { term__erase_display(tos3("3")); }
void term__erase_line(string t) {
  print(string_add(string_add(tos3("\x1b["), t), tos3("K")));
}
void term__erase_line_toend() { term__erase_line(tos3("0")); }
void term__erase_line_tobeg() { term__erase_line(tos3("1")); }
void term__erase_line_clear() { term__erase_line(tos3("2")); }
void term__show_cursor() { print(tos3("\x1b[?25h")); }
void term__hide_cursor() { print(tos3("\x1b[?25l")); }
bool term__can_show_color_on_stdout() {
  return term__supports_escape_sequences(1);
}
bool term__can_show_color_on_stderr() {
  return term__supports_escape_sequences(2);
}
string term__ok_message(string s) {
  return ((term__can_show_color_on_stdout()) ? (term__green(s)) : (s));
}
string term__fail_message(string s) {
  return ((term__can_show_color_on_stdout()) ? (term__red(s)) : (s));
}
string term__h_divider(string divider) {
  _V_MulRet_int_V_int _V_mret_103_cols__ = term__get_terminal_size();
  int cols = _V_mret_103_cols__.var_0;
  string result = string_repeat(divider, 1 + (cols / divider.len));
  return string_substr2(result, 0, cols, false);
}
string term__header(string text, string divider) {
  if (text.len == 0) {
    return term__h_divider(divider);
  };
  _V_MulRet_int_V_int _V_mret_158_cols__ = term__get_terminal_size();
  int cols = _V_mret_158_cols__.var_0;
  int tlimit =
      ((cols > text.len + 2 + 2 * divider.len) ? (text.len)
                                               : (cols - 3 - 2 * divider.len));
  int tlimit_alligned =
      (((tlimit % 2) != (cols % 2)) ? (tlimit + 1) : (tlimit));
  int tstart = (cols - tlimit_alligned) / 2;
  string ln = string_substr2(string_repeat(divider, 1 + cols / divider.len), 0,
                             cols, false);
  return string_add(
      string_add(string_add(string_add(string_substr2(ln, 0, tstart, false),
                                       tos3(" ")),
                            string_substr2(text, 0, tlimit, false)),
                 tos3(" ")),
      string_substr2(ln, tstart + tlimit + 2, cols, false));
}
bool term__supports_escape_sequences(int fd) {
#ifdef _WIN32
  return (is_atty(fd) & 0x0004) > 0 &&
         string_ne(os__getenv(tos3("TERM")), tos3("dumb"));
#else
  return is_atty(fd) > 0 && string_ne(os__getenv(tos3("TERM")), tos3("dumb"));
#endif
  ;
}
_V_MulRet_int_V_int term__get_terminal_size() {
  if (is_atty(1) > 0 && string_ne(os__getenv(tos3("TERM")), tos3("dumb"))) {
    CONSOLE_SCREEN_BUFFER_INFO info =
        (CONSOLE_SCREEN_BUFFER_INFO){EMPTY_STRUCT_INITIALIZATION};
    if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info)) {
      int columns = ((int)(info.srWindow.Right - info.srWindow.Left + 1));
      int rows = ((int)(info.srWindow.Bottom - info.srWindow.Top + 1));
      return (_V_MulRet_int_V_int){.var_0 = columns, .var_1 = rows};
    };
  };
  return (_V_MulRet_int_V_int){.var_0 = term__default_columns_size,
                               .var_1 = term__default_rows_size};
}
string vweb_dot_tmpl__compile_template(string path) {
  Option_string tmp1 = os__read_file(path);
  string html;
  if (!tmp1.ok) {
    string err = tmp1.error;
    int errcode = tmp1.ecode;
    v_panic(tos3("html failed"));
  }
  html = *(string *)tmp1.data;
  ;
  string header = tos3("");
  if (os__exists(tos3("header.html")) &&
      string_contains(html, tos3("@header"))) {
    Option_string tmp2 = os__read_file(tos3("header.html"));
    string h;
    if (!tmp2.ok) {
      string err = tmp2.error;
      int errcode = tmp2.ecode;
      v_panic(tos3("reading file header.html failed"));
    }
    h = *(string *)tmp2.data;
    ;
    header = string_replace(h, tos3("\'"), tos3("\""));
    html = string_add(header, html);
  };
  array_string lines = string_split_into_lines(html);
  strings__Builder s = strings__new_builder(1000);
  strings__Builder_writeln(
      &/* ? */ s, _STR("\nmut sb := strings.new_builder(%d)\nheader := \' \' "
                       "// TODO remove\n_ = header\n//footer := \'footer\'\n",
                       lines.len * 30));
  strings__Builder_writeln(&/* ? */ s, vweb_dot_tmpl__STR_START);
  bool in_css = 1;
  array_string tmp3 = lines;
  for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
    string _line = ((string *)tmp3.data)[tmp4];

    string line = string_trim_space(_line);
    if (string_eq(line, tos3("<style>"))) {
      in_css = 1;
    } else if (string_eq(line, tos3("</style>"))) {
    };
    if (string_contains(line, tos3("@if "))) {
      strings__Builder_writeln(&/* ? */ s, vweb_dot_tmpl__STR_END);
      Option_int tmp5 = string_index(line, tos3("@if"));
      int pos;
      if (!tmp5.ok) {
        string err = tmp5.error;
        int errcode = tmp5.ecode;
        continue;
      }
      pos = *(int *)tmp5.data;
      ;
      strings__Builder_writeln(
          &/* ? */ s,
          string_add(
              string_add(tos3("if "), string_substr2(line, pos + 4, -1, true)),
              tos3("{")));
      strings__Builder_writeln(&/* ? */ s, vweb_dot_tmpl__STR_START);
    } else if (string_contains(line, tos3("@end"))) {
      strings__Builder_writeln(&/* ? */ s, vweb_dot_tmpl__STR_END);
      strings__Builder_writeln(&/* ? */ s, tos3("}"));
      strings__Builder_writeln(&/* ? */ s, vweb_dot_tmpl__STR_START);
    } else if (string_contains(line, tos3("@else"))) {
      strings__Builder_writeln(&/* ? */ s, vweb_dot_tmpl__STR_END);
      strings__Builder_writeln(&/* ? */ s, tos3(" } else { "));
      strings__Builder_writeln(&/* ? */ s, vweb_dot_tmpl__STR_START);
    } else if (string_contains(line, tos3("@for"))) {
      strings__Builder_writeln(&/* ? */ s, vweb_dot_tmpl__STR_END);
      Option_int tmp8 = string_index(line, tos3("@for"));
      int pos;
      if (!tmp8.ok) {
        string err = tmp8.error;
        int errcode = tmp8.ecode;
        continue;
      }
      pos = *(int *)tmp8.data;
      ;
      strings__Builder_writeln(
          &/* ? */ s,
          string_add(
              string_add(tos3("for "), string_substr2(line, pos + 4, -1, true)),
              tos3("{")));
      strings__Builder_writeln(&/* ? */ s, vweb_dot_tmpl__STR_START);
    } else if (!in_css && string_contains(line, tos3(".")) &&
               string_ends_with(line, tos3("{"))) {
      string class = string_find_between(line, tos3("."), tos3("{"));
      strings__Builder_writeln(
          &/* ? */ s, _STR("<div class=\"%.*s\">", class.len, class.str));
    } else if (!in_css && string_eq(line, tos3("}"))) {
      strings__Builder_writeln(&/* ? */ s, tos3("</div>"));
    } else {
      strings__Builder_writeln(
          &/* ? */ s,
          string_replace(string_replace(line, tos3("@"), tos3("\x24")),
                         tos3("'"), tos3("\"")));
    };
  };
  strings__Builder_writeln(&/* ? */ s, vweb_dot_tmpl__STR_END);
  strings__Builder_writeln(&/* ? */ s, tos3("tmpl_res := sb.str() }"));
  return strings__Builder_str(&/* ? */ s);
}
v_dot_scanner__Scanner *
v_dot_scanner__new_scanner_file(string file_path,
                                v_dot_scanner__CommentsMode comments_mode) {
  if (!os__exists(file_path)) {
    v_dot_scanner__verror(
        _STR("%.*s doesn't exist", file_path.len, file_path.str));
  };
  Option_string tmp1 = os__read_file(file_path);
  string raw_text;
  if (!tmp1.ok) {
    string err = tmp1.error;
    int errcode = tmp1.ecode;
    v_dot_scanner__verror(
        _STR("scanner: failed to open %.*s", file_path.len, file_path.str));
    return 0;
  }
  raw_text = *(string *)tmp1.data;
  ;
  if (raw_text.len >= 3) {
    byte *c_text = raw_text.str;
    if (c_text[/*ptr!*/ 0] /*rbyte 0*/ == 0xEF &&
        c_text[/*ptr!*/ 1] /*rbyte 0*/ == 0xBB &&
        c_text[/*ptr!*/ 2] /*rbyte 0*/ == 0xBF) {
      int offset_from_begin = 3;
      raw_text = tos(&/*114*/ c_text[/*ptr!*/ offset_from_begin] /*rbyte 0*/,
                     vstrlen(c_text) - offset_from_begin);
    };
  };
  v_dot_scanner__Scanner *s =
      v_dot_scanner__new_scanner(raw_text, comments_mode);
  s->file_path = file_path;
  return s;
}
v_dot_scanner__Scanner *
v_dot_scanner__new_scanner(string text,
                           v_dot_scanner__CommentsMode comments_mode) {
  return (v_dot_scanner__Scanner *)memdup(
      &(v_dot_scanner__Scanner){
          .text = text,
          .print_line_on_error = 1,
          .print_colored_error = 1,
          .print_rel_paths_on_error = 1,
          .is_fmt = v_dot_scanner__is_fmt,
          .comments_mode = comments_mode,
          .file_path = tos3(""),
          .pos = 0,
          .line_nr = 0,
          .last_nl_pos = 0,
          .inside_string = 0,
          .inter_start = 0,
          .inter_end = 0,
          .debug = 0,
          .line_comment = tos3(""),
          .started = 0,
          .fn_name = tos3(""),
          .quote = 0,
          .line_ends = new_array(0, 1, sizeof(int)),
          .nr_lines = 0,
          .is_vh = 0,
      },
      sizeof(v_dot_scanner__Scanner));
}
v_dot_token__Token v_dot_scanner__Scanner_scan_res(v_dot_scanner__Scanner *s,
                                                   v_dot_token__Kind tok_kind,
                                                   string lit) {
  return (v_dot_token__Token){
      .kind = tok_kind, .lit = lit, .line_nr = s->line_nr + 1, .pos = s->pos};
}
string v_dot_scanner__Scanner_ident_name(v_dot_scanner__Scanner *s) {
  int start = s->pos;
  s->pos++;
  while (s->pos < s->text.len &&
         (v_dot_scanner__is_name_char(string_at(s->text, s->pos)) ||
          byte_is_digit(string_at(s->text, s->pos)))) {

    s->pos++;
  };
  string name = string_substr2(s->text, start, s->pos, false);
  s->pos--;
  return name;
}
string v_dot_scanner__filter_num_sep(byte *txt, int start, int end) {
  {
    byte *b = v_malloc(end - start + 1);
    int i = start;
    int i1 = 0;
    while (i < end) {

      if (txt[/*ptr!*/ i] /*rbyte 0*/ != v_dot_scanner__num_sep &&
          txt[/*ptr!*/ i] /*rbyte 0*/ != 'o') {
        b[/*ptr!*/ i1] /*rbyte 1*/ = txt[/*ptr!*/ i] /*rbyte 0*/;
        i1++;
      };
      i++;
    };
    b[/*ptr!*/ i1] /*rbyte 1*/ = 0;
    return (string){.str = b, .len = i1};
  };
}
string v_dot_scanner__Scanner_ident_bin_number(v_dot_scanner__Scanner *s) {
  bool has_wrong_digit = 0;
  byte first_wrong_digit = '\0';
  int start_pos = s->pos;
  s->pos += 2;
  while (s->pos < s->text.len) {

    byte c = string_at(s->text, s->pos);
    if (!byte_is_bin_digit(c) && c != v_dot_scanner__num_sep) {
      if ((!byte_is_digit(c) && !byte_is_letter(c)) || s->inside_string) {
        break;
      } else if (!has_wrong_digit) {
        has_wrong_digit = 1;
        first_wrong_digit = c;
      };
    };
    s->pos++;
  };
  if (start_pos + 2 == s->pos) {
    v_dot_scanner__Scanner_error(
        &/* ? */ *s, tos3("number part of this binary is not provided"));
  } else if (has_wrong_digit) {
    v_dot_scanner__Scanner_error(
        &/* ? */ *s,
        _STR("this binary number has unsuitable digit `%.*s`",
             byte_str(first_wrong_digit).len, byte_str(first_wrong_digit).str));
  };
  string number = v_dot_scanner__filter_num_sep(s->text.str, start_pos, s->pos);
  s->pos--;
  return number;
}
string v_dot_scanner__Scanner_ident_hex_number(v_dot_scanner__Scanner *s) {
  bool has_wrong_digit = 0;
  byte first_wrong_digit = '\0';
  int start_pos = s->pos;
  s->pos += 2;
  while (s->pos < s->text.len) {

    byte c = string_at(s->text, s->pos);
    if (!byte_is_hex_digit(c) && c != v_dot_scanner__num_sep) {
      if (!byte_is_letter(c) || s->inside_string) {
        break;
      } else if (!has_wrong_digit) {
        has_wrong_digit = 1;
        first_wrong_digit = c;
      };
    };
    s->pos++;
  };
  if (start_pos + 2 == s->pos) {
    v_dot_scanner__Scanner_error(
        &/* ? */ *s, tos3("number part of this hexadecimal is not provided"));
  } else if (has_wrong_digit) {
    v_dot_scanner__Scanner_error(
        &/* ? */ *s,
        _STR("this hexadecimal number has unsuitable digit `%.*s`",
             byte_str(first_wrong_digit).len, byte_str(first_wrong_digit).str));
  };
  string number = v_dot_scanner__filter_num_sep(s->text.str, start_pos, s->pos);
  s->pos--;
  return number;
}
string v_dot_scanner__Scanner_ident_oct_number(v_dot_scanner__Scanner *s) {
  bool has_wrong_digit = 0;
  byte first_wrong_digit = '\0';
  int start_pos = s->pos;
  s->pos += 2;
  while (s->pos < s->text.len) {

    byte c = string_at(s->text, s->pos);
    if (!byte_is_oct_digit(c) && c != v_dot_scanner__num_sep) {
      if ((!byte_is_digit(c) && !byte_is_letter(c)) || s->inside_string) {
        break;
      } else if (!has_wrong_digit) {
        has_wrong_digit = 1;
        first_wrong_digit = c;
      };
    };
    s->pos++;
  };
  if (start_pos + 2 == s->pos) {
    v_dot_scanner__Scanner_error(
        &/* ? */ *s, tos3("number part of this octal is not provided"));
  } else if (has_wrong_digit) {
    v_dot_scanner__Scanner_error(
        &/* ? */ *s,
        _STR("this octal number has unsuitable digit `%.*s`",
             byte_str(first_wrong_digit).len, byte_str(first_wrong_digit).str));
  };
  string number = v_dot_scanner__filter_num_sep(s->text.str, start_pos, s->pos);
  s->pos--;
  return number;
}
string v_dot_scanner__Scanner_ident_dec_number(v_dot_scanner__Scanner *s) {
  bool has_wrong_digit = 0;
  byte first_wrong_digit = '\0';
  int start_pos = s->pos;
  while (s->pos < s->text.len) {

    byte c = string_at(s->text, s->pos);
    if (!byte_is_digit(c) && c != v_dot_scanner__num_sep) {
      if (!byte_is_letter(c) || (c == 'e' || c == 'E') || s->inside_string) {
        break;
      } else if (!has_wrong_digit) {
        has_wrong_digit = 1;
        first_wrong_digit = c;
      };
    };
    s->pos++;
  };
  if (v_dot_scanner__Scanner_expect(&/* ? */ *s, tos3(".."), s->pos)) {
    string number =
        v_dot_scanner__filter_num_sep(s->text.str, start_pos, s->pos);
    s->pos--;
    return number;
  };
  if (s->pos < s->text.len && string_at(s->text, s->pos) == '.') {
    s->pos++;
    while (s->pos < s->text.len) {

      byte c = string_at(s->text, s->pos);
      if (!byte_is_digit(c)) {
        if (!byte_is_letter(c) || (c == 'e' || c == 'E') || s->inside_string) {
          break;
        } else if (!has_wrong_digit) {
          has_wrong_digit = 1;
          first_wrong_digit = c;
        };
      };
      s->pos++;
    };
  };
  bool has_exponential_part = 0;
  if (v_dot_scanner__Scanner_expect(&/* ? */ *s, tos3("e"), s->pos) ||
      v_dot_scanner__Scanner_expect(&/* ? */ *s, tos3("E"), s->pos)) {
    s->pos++;
    int exp_start_pos = s->pos;
    if (s->pos < s->text.len && (string_at(s->text, s->pos) == '-' ||
                                 string_at(s->text, s->pos) == '+')) {
      s->pos++;
    };
    while (s->pos < s->text.len) {

      byte c = string_at(s->text, s->pos);
      if (!byte_is_digit(c)) {
        if (!byte_is_letter(c) || s->inside_string) {
          break;
        } else if (!has_wrong_digit) {
          has_wrong_digit = 1;
          first_wrong_digit = c;
        };
      };
      s->pos++;
    };
    if (exp_start_pos == s->pos) {
      v_dot_scanner__Scanner_error(&/* ? */ *s, tos3("exponent has no digits"));
    };
    has_exponential_part = 1;
  };
  if (s->pos < s->text.len && string_at(s->text, s->pos) == '.') {
    if (has_exponential_part) {
      v_dot_scanner__Scanner_error(&/* ? */ *s,
                                   tos3("exponential part should be integer"));
    } else {
      v_dot_scanner__Scanner_error(&/* ? */ *s,
                                   tos3("too many decimal points in number"));
    };
  };
  if (has_wrong_digit) {
    v_dot_scanner__Scanner_error(&/* ? */ *s,
                                 _STR("this number has unsuitable digit `%.*s`",
                                      byte_str(first_wrong_digit).len,
                                      byte_str(first_wrong_digit).str));
  };
  string number = v_dot_scanner__filter_num_sep(s->text.str, start_pos, s->pos);
  s->pos--;
  return number;
}
string v_dot_scanner__Scanner_ident_number(v_dot_scanner__Scanner *s) {
  if (v_dot_scanner__Scanner_expect(&/* ? */ *s, tos3("0b"), s->pos)) {
    return v_dot_scanner__Scanner_ident_bin_number(s);
  } else if (v_dot_scanner__Scanner_expect(&/* ? */ *s, tos3("0x"), s->pos)) {
    return v_dot_scanner__Scanner_ident_hex_number(s);
  } else if (v_dot_scanner__Scanner_expect(&/* ? */ *s, tos3("0o"), s->pos)) {
    return v_dot_scanner__Scanner_ident_oct_number(s);
  } else {
    return v_dot_scanner__Scanner_ident_dec_number(s);
  };
}
void v_dot_scanner__Scanner_skip_whitespace(v_dot_scanner__Scanner *s) {
  while (s->pos < s->text.len && byte_is_space(string_at(s->text, s->pos))) {

    if (v_dot_scanner__is_nl(string_at(s->text, s->pos)) && s->is_vh) {

      return;
    };
    if (v_dot_scanner__is_nl(string_at(s->text, s->pos)) &&
        !v_dot_scanner__Scanner_expect(&/* ? */ *s, tos3("\r\n"), s->pos - 1)) {
      v_dot_scanner__Scanner_inc_line_number(s);
    };
    s->pos++;
  };
}
v_dot_token__Token
v_dot_scanner__Scanner_end_of_file(v_dot_scanner__Scanner *s) {
  s->pos = s->text.len;
  v_dot_scanner__Scanner_inc_line_number(s);
  return v_dot_scanner__Scanner_scan_res(
      &/* ? */ *s, v_dot_token__v_dot_token__Kind_eof, tos3(""));
}
v_dot_token__Token v_dot_scanner__Scanner_scan(v_dot_scanner__Scanner *s) {
  if (s->started) {
    s->pos++;
  };
  s->started = 1;
  if (s->pos >= s->text.len) {
    return v_dot_scanner__Scanner_end_of_file(s);
  };
  if (!s->inside_string) {
    v_dot_scanner__Scanner_skip_whitespace(s);
  };
  if (s->inter_end) {
    if (string_at(s->text, s->pos) == s->quote) {
      s->inter_end = 0;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_string, tos3(""));
    };
    s->inter_end = 0;
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_string,
        v_dot_scanner__Scanner_ident_string(s));
  };
  v_dot_scanner__Scanner_skip_whitespace(s);
  if (s->pos >= s->text.len) {
    return v_dot_scanner__Scanner_end_of_file(s);
  };
  byte c = string_at(s->text, s->pos);
  byte nextc = '\0';
  if (s->pos + 1 < s->text.len) {
    nextc = string_at(s->text, s->pos + 1);
  };
  if (v_dot_scanner__is_name_char(c)) {
    string name = v_dot_scanner__Scanner_ident_name(s);
    byte next_char =
        ((s->pos + 1 < s->text.len) ? (string_at(s->text, s->pos + 1))
                                    : ('\0'));
    if (v_dot_token__is_key(name)) {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__key_to_token(name), tos3(""));
    };
    if (s->inside_string) {
      if (next_char == s->quote) {
        s->inter_end = 1;
        s->inter_start = 0;
        s->inside_string = 0;
      };
    };
    if (s->inter_start && next_char != '.' && next_char != '(') {
      s->inter_end = 1;
      s->inter_start = 0;
    };
    if (s->pos == 0 && next_char == ' ') {
      s->pos++;
    };
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_name, name);
  } else if (byte_is_digit(c) || (c == '.' && byte_is_digit(nextc))) {
    if (!s->inside_string) {
      int start_pos = s->pos;
      while (start_pos < s->text.len && string_at(s->text, start_pos) == '0') {

        start_pos++;
      };
      int prefix_zero_num = start_pos - s->pos;
      if (start_pos == s->text.len ||
          (c == '0' && !byte_is_digit(string_at(s->text, start_pos)))) {
        prefix_zero_num--;
      };
      s->pos += prefix_zero_num;
    };
    string num = v_dot_scanner__Scanner_ident_number(s);
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_number, num);
  };
  if (c == ')' && s->inter_start) {
    s->inter_end = 1;
    s->inter_start = 0;
    byte next_char =
        ((s->pos + 1 < s->text.len) ? (string_at(s->text, s->pos + 1))
                                    : ('\0'));
    if (next_char == s->quote) {
      s->inside_string = 0;
    };
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_rpar, tos3(""));
  };
  byte tmp46 = c;

  if (tmp46 == '+') {
    if (nextc == '+') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_inc, tos3(""));
    } else if (nextc == '=') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_plus_assign, tos3(""));
    };
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_plus, tos3(""));
  } else if (tmp46 == '-') {
    if (nextc == '-') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_dec, tos3(""));
    } else if (nextc == '=') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_minus_assign, tos3(""));
    };
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_minus, tos3(""));
  } else if (tmp46 == '*') {
    if (nextc == '=') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_mult_assign, tos3(""));
    };
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_mul, tos3(""));
  } else if (tmp46 == '^') {
    if (nextc == '=') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_xor_assign, tos3(""));
    };
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_xor, tos3(""));
  } else if (tmp46 == '%') {
    if (nextc == '=') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_mod_assign, tos3(""));
    };
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_mod, tos3(""));
  } else if (tmp46 == '?') {
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_question, tos3(""));
  } else if ((tmp46 == v_dot_scanner__single_quote) ||
             (tmp46 == v_dot_scanner__double_quote)) {
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_string,
        v_dot_scanner__Scanner_ident_string(s));
  } else if (tmp46 == '`') {
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_chartoken,
        v_dot_scanner__Scanner_ident_char(s));
  } else if (tmp46 == '(') {
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_lpar, tos3(""));
  } else if (tmp46 == ')') {
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_rpar, tos3(""));
  } else if (tmp46 == '[') {
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_lsbr, tos3(""));
  } else if (tmp46 == ']') {
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_rsbr, tos3(""));
  } else if (tmp46 == '{') {
    if (s->inside_string) {
      return v_dot_scanner__Scanner_scan(s);
    };
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_lcbr, tos3(""));
  } else if (tmp46 == '$') {
    if (s->inside_string) {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_str_dollar, tos3(""));
    } else {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_dollar, tos3(""));
    };
  } else if (tmp46 == '}') {
    if (s->inside_string) {
      s->pos++;
      if (string_at(s->text, s->pos) == s->quote) {
        s->inside_string = 0;
        return v_dot_scanner__Scanner_scan_res(
            &/* ? */ *s, v_dot_token__v_dot_token__Kind_string, tos3(""));
      };
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_string,
          v_dot_scanner__Scanner_ident_string(s));
    } else {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_rcbr, tos3(""));
    };
  } else if (tmp46 == '&') {
    if (nextc == '=') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_and_assign, tos3(""));
    };
    if (nextc == '&') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_and, tos3(""));
    };
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_amp, tos3(""));
  } else if (tmp46 == '|') {
    if (nextc == '|') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_logical_or, tos3(""));
    };
    if (nextc == '=') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_or_assign, tos3(""));
    };
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_pipe, tos3(""));
  } else if (tmp46 == ',') {
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_comma, tos3(""));
  } else if (tmp46 == '@') {
    s->pos++;
    string name = v_dot_scanner__Scanner_ident_name(s);
    if (string_eq(name, tos3("FN"))) {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_string, s->fn_name);
    };
    if (string_eq(name, tos3("FILE"))) {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_string,
          v_dot_scanner__cescaped_path(os__realpath(s->file_path)));
    };
    if (string_eq(name, tos3("LINE"))) {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_string,
          int_str((s->line_nr + 1)));
    };
    if (string_eq(name, tos3("COLUMN"))) {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_string,
          int_str((v_dot_scanner__Scanner_current_column(&/* ? */ *s))));
    };
    if (string_eq(name, tos3("VHASH"))) {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_string,
          v_dot_scanner__vhash());
    };
    if (!v_dot_token__is_key(name)) {
      v_dot_scanner__Scanner_error(
          &/* ? */ *s,
          tos3("@ must be used before keywords (e.g. `@type string`)"));
    };
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_name, name);
  } else if (tmp46 == '.') {
    if (nextc == '.') {
      s->pos++;
      if (string_at(s->text, s->pos + 1) == '.') {
        s->pos++;
        return v_dot_scanner__Scanner_scan_res(
            &/* ? */ *s, v_dot_token__v_dot_token__Kind_ellipsis, tos3(""));
      };
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_dotdot, tos3(""));
    };
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_dot, tos3(""));
  } else if (tmp46 == '#') {
    int start = s->pos + 1;
    v_dot_scanner__Scanner_ignore_line(s);
    if (nextc == '!') {
      s->line_comment =
          string_trim_space(string_substr2(s->text, start + 1, s->pos, false));
      return v_dot_scanner__Scanner_scan(s);
    };
    string hash = string_substr2(s->text, start, s->pos, false);
    return v_dot_scanner__Scanner_scan_res(&/* ? */ *s,
                                           v_dot_token__v_dot_token__Kind_hash,
                                           string_trim_space(hash));
  } else if (tmp46 == '>') {
    if (nextc == '=') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_ge, tos3(""));
    } else if (nextc == '>') {
      if (s->pos + 2 < s->text.len && string_at(s->text, s->pos + 2) == '=') {
        s->pos += 2;
        return v_dot_scanner__Scanner_scan_res(
            &/* ? */ *s, v_dot_token__v_dot_token__Kind_right_shift_assign,
            tos3(""));
      };
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_right_shift, tos3(""));
    } else {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_gt, tos3(""));
    };
  } else if (tmp46 == 0xE2) {
    if (nextc == 0x89 && string_at(s->text, s->pos + 2) == 0xA0) {
      s->pos += 2;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_ne, tos3(""));
    } else if (nextc == 0x89 && string_at(s->text, s->pos + 2) == 0xBD) {
      s->pos += 2;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_le, tos3(""));
    } else if (nextc == 0xA9 && string_at(s->text, s->pos + 2) == 0xBE) {
      s->pos += 2;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_ge, tos3(""));
    };
  } else if (tmp46 == '<') {
    if (nextc == '=') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_le, tos3(""));
    } else if (nextc == '<') {
      if (s->pos + 2 < s->text.len && string_at(s->text, s->pos + 2) == '=') {
        s->pos += 2;
        return v_dot_scanner__Scanner_scan_res(
            &/* ? */ *s, v_dot_token__v_dot_token__Kind_left_shift_assign,
            tos3(""));
      };
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_left_shift, tos3(""));
    } else {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_lt, tos3(""));
    };
  } else if (tmp46 == '=') {
    if (nextc == '=') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_eq, tos3(""));
    } else if (nextc == '>') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_arrow, tos3(""));
    } else {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_assign, tos3(""));
    };
  } else if (tmp46 == ':') {
    if (nextc == '=') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_decl_assign, tos3(""));
    } else {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_colon, tos3(""));
    };
  } else if (tmp46 == ';') {
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_semicolon, tos3(""));
  } else if (tmp46 == '!') {
    if (nextc == '=') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_ne, tos3(""));
    } else {
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_not, tos3(""));
    };
  } else if (tmp46 == '~') {
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_bit_not, tos3(""));
  } else if (tmp46 == '/') {
    if (nextc == '=') {
      s->pos++;
      return v_dot_scanner__Scanner_scan_res(
          &/* ? */ *s, v_dot_token__v_dot_token__Kind_div_assign, tos3(""));
    };
    if (nextc == '/') {
      int start = s->pos + 1;
      v_dot_scanner__Scanner_ignore_line(s);
      s->line_comment = string_substr2(s->text, start + 1, s->pos, false);
      string comment = string_trim_space(s->line_comment);
      if (s->comments_mode ==
          v_dot_scanner__v_dot_scanner__CommentsMode_parse_comments) {
        s->pos--;
        return v_dot_scanner__Scanner_scan_res(
            &/* ? */ *s, v_dot_token__v_dot_token__Kind_line_comment, comment);
      };
      return v_dot_scanner__Scanner_scan(s);
    };
    if (nextc == '*') {
      int start = s->pos;
      int nest_count = 1;
      while (nest_count > 0) {

        s->pos++;
        if (s->pos >= s->text.len) {
          s->line_nr--;
          v_dot_scanner__Scanner_error(&/* ? */ *s,
                                       tos3("comment not terminated"));
        };
        if (string_at(s->text, s->pos) == '\n') {
          v_dot_scanner__Scanner_inc_line_number(s);
          continue;
        };
        if (v_dot_scanner__Scanner_expect(&/* ? */ *s, tos3("/*"), s->pos)) {
          nest_count++;
          continue;
        };
        if (v_dot_scanner__Scanner_expect(&/* ? */ *s, tos3("*/"), s->pos)) {
          nest_count--;
        };
      };
      s->pos++;
      int end = s->pos + 1;
      string comment = string_substr2(s->text, start, end, false);
      if (0 && s->comments_mode ==
                   v_dot_scanner__v_dot_scanner__CommentsMode_parse_comments) {
        s->line_comment = comment;
        return v_dot_scanner__Scanner_scan_res(
            &/* ? */ *s, v_dot_token__v_dot_token__Kind_mline_comment,
            s->line_comment);
      };
      return v_dot_scanner__Scanner_scan(s);
    };
    return v_dot_scanner__Scanner_scan_res(
        &/* ? */ *s, v_dot_token__v_dot_token__Kind_div, tos3(""));
  } else // default:
  {
  };
#ifdef _WIN32
  if (c == '\0') {
    return v_dot_scanner__Scanner_end_of_file(s);
  };
#endif
  ;
  v_dot_scanner__Scanner_error(
      &/* ? */ *s,
      _STR("invalid character `%.*s`", byte_str(c).len, byte_str(c).str));
  return v_dot_scanner__Scanner_end_of_file(s);
}
int v_dot_scanner__Scanner_current_column(v_dot_scanner__Scanner *s) {
  return s->pos - s->last_nl_pos;
}
int v_dot_scanner__Scanner_count_symbol_before(v_dot_scanner__Scanner s, int p,
                                               byte sym) {
  int count = 0;
  for (int i = p; i >= 0; i--) {

    if (string_at(s.text, i) != sym) {
      break;
    };
    count++;
  };
  return count;
}
string v_dot_scanner__Scanner_ident_string(v_dot_scanner__Scanner *s) {
  byte q = string_at(s->text, s->pos);
  bool is_quote =
      q == v_dot_scanner__single_quote || q == v_dot_scanner__double_quote;
  bool is_raw = is_quote && string_at(s->text, s->pos - 1) == 'r';
  if (is_quote && !s->inside_string) {
    s->quote = q;
  };
  int start = s->pos;
  s->inside_string = 0;
  byte slash = '\\';
  while (1) {
    s->pos++;
    if (s->pos >= s->text.len) {
      break;
    };
    byte c = string_at(s->text, s->pos);
    byte prevc = string_at(s->text, s->pos - 1);
    if (c == s->quote &&
        (prevc != slash ||
         (prevc == slash && string_at(s->text, s->pos - 2) == slash))) {
      break;
    };
    if (c == '\n') {
      v_dot_scanner__Scanner_inc_line_number(s);
    };
    if (c == '0' && s->pos > 2 && string_at(s->text, s->pos - 1) == slash) {
      if (s->pos < s->text.len - 1 &&
          byte_is_digit(string_at(s->text, s->pos + 1))) {
      } else {
        v_dot_scanner__Scanner_error(&/* ? */ *s,
                                     tos3("0 character in a string literal"));
      };
    };
    if (c == '0' && s->pos > 5 &&
        v_dot_scanner__Scanner_expect(&/* ? */ *s, tos3("\\x0"), s->pos - 3)) {
      v_dot_scanner__Scanner_error(&/* ? */ *s,
                                   tos3("0 character in a string literal"));
    };
    if (c == '{' && prevc == '$' && !is_raw && !s->is_fmt &&
        v_dot_scanner__Scanner_count_symbol_before(*s, s->pos - 2, slash) % 2 ==
            0) {
      s->inside_string = 1;
      s->pos -= 2;
      break;
    };
    if (v_dot_scanner__is_name_char(c) && prevc == '$' && !s->is_fmt &&
        !is_raw &&
        v_dot_scanner__Scanner_count_symbol_before(*s, s->pos - 2, slash) % 2 ==
            0) {
      s->inside_string = 1;
      s->inter_start = 1;
      s->pos -= 2;
      break;
    };
  };
  string lit = tos3("");
  if (string_at(s->text, start) == s->quote) {
    start++;
  };
  int end = s->pos;
  if (s->inside_string) {
    end++;
  };
  if (start > s->pos) {
  } else {
    lit = string_substr2(s->text, start, end, false);
  };
  return lit;
}
string v_dot_scanner__Scanner_ident_char(v_dot_scanner__Scanner *s) {
  int start = s->pos;
  byte slash = '\\';
  int len = 0;
  while (1) {
    s->pos++;
    if (s->pos >= s->text.len) {
      break;
    };
    if (string_at(s->text, s->pos) != slash) {
      len++;
    };
    bool double_slash =
        v_dot_scanner__Scanner_expect(&/* ? */ *s, tos3("\\\\"), s->pos - 2);
    if (string_at(s->text, s->pos) == '`' &&
        (string_at(s->text, s->pos - 1) != slash || double_slash)) {
      if (double_slash) {
        len++;
      };
      break;
    };
  };
  len--;
  string c = string_substr2(s->text, start + 1, s->pos, false);
  if (len != 1) {
    ustring u = string_ustring(c);
    if (u.len != 1) {
      v_dot_scanner__Scanner_error(
          &/* ? */ *s,
          string_add(
              tos3("invalid character literal (more than one character)\n"),
              tos3("use quotes for strings, backticks for characters")));
    };
  };
  if (string_eq(c, tos3("\\`"))) {
    return tos3("`");
  };
  return ((string_eq(c, tos3("\'"))) ? (string_add(tos3("\\"), c)) : (c));
}
bool v_dot_scanner__Scanner_expect(v_dot_scanner__Scanner *s, string want,
                                   int start_pos) {
  int end_pos = start_pos + want.len;
  if (start_pos < 0 || start_pos >= s->text.len) {
    return 0;
  };
  if (end_pos < 0 || end_pos > s->text.len) {
    return 0;
  };
  int tmp99 = start_pos;
  ;
  for (int tmp100 = tmp99; tmp100 < end_pos; tmp100++) {
    int pos = tmp100;

    if (string_at(s->text, pos) != string_at(want, pos - start_pos)) {
      return 0;
    };
  };
  return 1;
}
void v_dot_scanner__Scanner_debug_tokens(v_dot_scanner__Scanner *s) {
  s->pos = 0;
  s->started = 0;
  s->debug = 1;
  string fname = string_all_after(s->file_path, os__path_separator);
  printf("\n===DEBUG TOKENS %.*s===\n", fname.len, fname.str);
  while (1) {
    v_dot_token__Token tok = v_dot_scanner__Scanner_scan(s);
    v_dot_token__Kind tok_kind = tok.kind;
    string lit = tok.lit;
    print(v_dot_token__Kind_str(tok_kind));
    if (string_ne(lit, tos3(""))) {
      printf(" `%.*s`\n", lit.len, lit.str);
    } else {
      println(tos3(""));
    };
    if (tok_kind == v_dot_token__v_dot_token__Kind_eof) {
      println(tos3("============ END OF DEBUG TOKENS =================="));
      break;
    };
  };
}
void v_dot_scanner__Scanner_ignore_line(v_dot_scanner__Scanner *s) {
  v_dot_scanner__Scanner_eat_to_end_of_line(s);
  v_dot_scanner__Scanner_inc_line_number(s);
}
void v_dot_scanner__Scanner_eat_to_end_of_line(v_dot_scanner__Scanner *s) {
  while (s->pos < s->text.len && string_at(s->text, s->pos) != '\n') {

    s->pos++;
  };
}
void v_dot_scanner__Scanner_inc_line_number(v_dot_scanner__Scanner *s) {
  s->last_nl_pos = s->pos;
  s->line_nr++;
  _PUSH(&s->line_ends, (/*typ = array_int   tmp_typ=int*/ s->pos), tmp107, int);
  if (s->line_nr > s->nr_lines) {
    s->nr_lines = s->line_nr;
  };
}
string v_dot_scanner__Scanner_line(v_dot_scanner__Scanner s, int n) {
  string res = tos3("");
  if (n >= 0 && n < s.line_ends.len) {
    int nline_start =
        ((n == 0) ? (0) : ((*(int *)array_get(s.line_ends, n - 1))));
    int nline_end = (*(int *)array_get(s.line_ends, n));
    if (nline_start <= nline_end) {
      res = string_substr2(s.text, nline_start, nline_end, false);
    };
  };
  return string_trim_left(string_trim_right(res, tos3("\r\n")), tos3("\r\n"));
}
bool v_dot_scanner__is_name_char(byte c) {
  return c == '_' || byte_is_letter(c);
}
static inline bool v_dot_scanner__is_nl(byte c) {
  return c == '\r' || c == '\n';
}
bool v_dot_scanner__contains_capital(string s) {
  string tmp114 = s;
  ;
  for (int tmp115 = 0; tmp115 < tmp114.len; tmp115++) {
    byte c = tmp114.str[tmp115];

    if (c >= 'A' && c <= 'Z') {
      return 1;
    };
  };
  return 0;
}
bool v_dot_scanner__good_type_name(string s) {
  if (s.len < 4) {
    return 1;
  };
  int tmp116 = 2;
  ;
  for (int tmp117 = tmp116; tmp117 < s.len; tmp117++) {
    int i = tmp117;

    if (byte_is_capital(string_at(s, i)) &&
        byte_is_capital(string_at(s, i - 1)) &&
        byte_is_capital(string_at(s, i - 2))) {
      return 0;
    };
  };
  return 1;
}
void v_dot_scanner__Scanner_error(v_dot_scanner__Scanner *s, string msg) {
  printf("%d : %.*s\n", s->line_nr, msg.len, msg.str);
  v_exit(1);
}
void v_dot_scanner__verror(string s) {
  printf("V error: %.*s\n", s.len, s.str);
  os__flush();
  v_exit(1);
}
string v_dot_scanner__vhash() {
  byte buf[50] = {0};
  buf[0] /*rbyte 1*/ = 0;
  snprintf(((charptr)(buf)), 50, "%s", V_COMMIT_HASH);
  return tos_clone(buf);
}
string v_dot_scanner__cescaped_path(string s) {
  return string_replace(s, tos3("\\"), tos3("\\\\"));
}
int runtime__nr_cpus() {
#ifdef _WIN32
  return runtime__nr_cpus_win();
#endif
  ;
  return runtime__nr_cpus_nix();
}
int runtime__nr_jobs() {
  int cpus = runtime__nr_cpus();
  int vjobs = v_string_int(os__getenv(tos3("VJOBS")));
  if (vjobs > 0) {
    cpus = vjobs;
  };
  return cpus;
}
bool runtime__is_32bit() {
  bool x = 0;
#ifdef TARGET_IS_32BIT
  x = 1;
#endif
  ;
  return x;
}
bool runtime__is_64bit() {
  bool x = 0;
#ifdef TARGET_IS_64BIT
  x = 1;
#endif
  ;
  return x;
}
bool runtime__is_little_endian() {
  bool x = 0;
#ifdef TARGET_ORDER_IS_LITTLE
  x = 1;
#endif
  ;
  return x;
}
bool runtime__is_big_endian() {
  bool x = 0;
#ifdef TARGET_ORDER_IS_BIG
  x = 1;
#endif
  ;
  return x;
}
int runtime__nr_cpus_win() {
  int nr = ((int)(GetCurrentProcessorNumber()));
  if (nr == 0) {
    nr = v_string_int(os__getenv(tos3("NUMBER_OF_PROCESSORS")));
  };
  return nr;
}
int runtime__nr_cpus_nix() {
  eprintln(tos3("nr_cpus_nix should be callable only for nix platforms"));
  return 1;
}
Option_array_string
internal_dot_flag__Instance_parse_impl(internal_dot_flag__Instance *p,
                                       array_string args, void *value,
                                       internal_dot_flag__void_cb callback) {
  while (p->current_pos + 1 < p->args.len) {

    p->current_pos++;
    string next = (*(string *)array_get(p->args, p->current_pos));
    if (!string_starts_with(next, tos3("-")) || string_eq(next, tos3("-"))) {
      array_string tmp5 = OPTION_CAST(array_string)(
          array_slice2(args, p->current_pos, -1, true));
      return opt_ok(&tmp5, sizeof(array_string));
    };
    if (string_eq(next, tos3("--"))) {
      array_string tmp8 = OPTION_CAST(array_string)(
          array_slice2(args, p->current_pos + 1, -1, true));
      return opt_ok(&tmp8, sizeof(array_string));
    };
    string flag_name = tos3("");
    Option_int tmp9 = string_index(next, tos3("="));

    if (tmp9.ok) {
      int idx = *(int *)tmp9.data;
      p->equal_val = string_substr2(next, idx + 1, -1, true);
      flag_name = string_substr2(next, 1, idx, false);
    } else {
      p->equal_val = tos3("");
      flag_name = string_substr2(next, 1, -1, true);
    };
    bool tmp16 = 0;
    bool tmp17 = map_get(/*flag.v : 46*/ p->encountered, flag_name, &tmp16);

    if (tmp16) {
      return v_error(
          _STR("Duplicate flag: -%.*s", flag_name.len, flag_name.str));
    };
    map_set(&p->encountered, flag_name, &(bool[]){1});
    p->current_flag = flag_name;
    callback(flag_name, p, value);
  };
  array_string tmp18 = OPTION_CAST(array_string)(new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)}));
  return opt_ok(&tmp18, sizeof(array_string));
}
Option_string
internal_dot_flag__Instance_string(internal_dot_flag__Instance *p) {
  if (string_ne(p->equal_val, tos3(""))) {
    string tmp19 = OPTION_CAST(string)(p->equal_val);
    return opt_ok(&tmp19, sizeof(string));
  };
  p->current_pos++;
  if (p->current_pos >= p->args.len) {
    return v_error(tos3("out of arguments"));
  };
  string tmp22 =
      OPTION_CAST(string)((*(string *)array_get(p->args, p->current_pos)));
  return opt_ok(&tmp22, sizeof(string));
}
Option_int internal_dot_flag__Instance_int(internal_dot_flag__Instance *p) {
  Option_string tmp23 = internal_dot_flag__Instance_string(p);
  string val;
  if (!tmp23.ok) {
    string err = tmp23.error;
    int errcode = tmp23.ecode;
    return v_error(err);
  }
  val = *(string *)tmp23.data;
  ;
  if (!byte_is_digit(string_at(val, 0))) {
    return v_error(
        _STR("an integer number was expected, but \"%.*s\" was found instead.",
             val.len, val.str));
  };
  int tmp26 = OPTION_CAST(int)(v_string_int(val));
  return opt_ok(&tmp26, sizeof(int));
}
Option_f32 internal_dot_flag__Instance_f32(internal_dot_flag__Instance *p) {
  Option_string tmp27 = internal_dot_flag__Instance_string(p);
  string val;
  if (!tmp27.ok) {
    string err = tmp27.error;
    int errcode = tmp27.ecode;
    return v_error(err);
  }
  val = *(string *)tmp27.data;
  ;
  f32 tmp28 = OPTION_CAST(f32)(string_f32(val));
  return opt_ok(&tmp28, sizeof(f32));
}
Option_f64 internal_dot_flag__Instance_f64(internal_dot_flag__Instance *p) {
  Option_string tmp29 = internal_dot_flag__Instance_string(p);
  string val;
  if (!tmp29.ok) {
    string err = tmp29.error;
    int errcode = tmp29.ecode;
    return v_error(err);
  }
  val = *(string *)tmp29.data;
  ;
  f64 tmp30 = OPTION_CAST(f64)(string_f64(val));
  return opt_ok(&tmp30, sizeof(f64));
}
Option_i64 internal_dot_flag__Instance_i64(internal_dot_flag__Instance *p) {
  Option_string tmp31 = internal_dot_flag__Instance_string(p);
  string val;
  if (!tmp31.ok) {
    string err = tmp31.error;
    int errcode = tmp31.ecode;
    return v_error(err);
  }
  val = *(string *)tmp31.data;
  ;
  i64 tmp32 = OPTION_CAST(i64)(string_i64(val));
  return opt_ok(&tmp32, sizeof(i64));
}
bool internal_dot_flag__Instance_bool(internal_dot_flag__Instance *p) {
  Option_string tmp33 = internal_dot_flag__Instance_string(p);
  string val;
  if (!tmp33.ok) {
    string err = tmp33.error;
    int errcode = tmp33.ecode;
    return 1;
  }
  val = *(string *)tmp33.data;
  ;
  if ((_IN(string, (val), internal_dot_flag__truthy))) {
    return 1;
  };
  if ((_IN(string, (val), internal_dot_flag__falsey))) {
    return 0;
  };
  p->current_pos--;
  return 1;
}
void internal_dot_flag__Instance_allow_duplicate(
    internal_dot_flag__Instance *p) {
  map_set(&p->encountered, p->current_flag, &(bool[]){0});
}
void internal_dot_flag__Instance_is_equivalent_to(
    internal_dot_flag__Instance *p, array_string flags) {
  array_string tmp34 = flags;
  for (int tmp35 = 0; tmp35 < tmp34.len; tmp35++) {
    string v = ((string *)tmp34.data)[tmp35];

    map_set(&p->encountered, v, &(bool[]){1});
  };
}
Option_array_string internal_dot_flag__parse_pref(
    array_string args,
    void (*callback)(string, internal_dot_flag__Instance *,
                     v_dot_pref__Preferences * /*FFF*/),
    v_dot_pref__Preferences *obj) {
  internal_dot_flag__Instance p =
      (internal_dot_flag__Instance){.args = args,
                                    .current_pos = 0,
                                    .current_flag = tos3(""),
                                    .equal_val = tos3(""),
                                    .encountered = new_map(1, sizeof(bool))};
  internal_dot_flag__void_cb casted_callback =
      *(((internal_dot_flag__void_cb *)(&callback)));
  Option_array_string tmp1 = internal_dot_flag__Instance_parse_impl(
      &/* ? */ p, args, ((voidptr)(obj)), casted_callback);
  array_string tmp;
  if (!tmp1.ok) {
    string err = tmp1.error;
    int errcode = tmp1.ecode;
    return v_error(err);
  }
  tmp = *(array_string *)tmp1.data;
  ;
  array_string tmp2 = OPTION_CAST(array_string)(tmp);
  return opt_ok(&tmp2, sizeof(array_string));
}
Option_array_string internal_dot_flag__parse_main_cmd(
    array_string args,
    void (*callback)(string, internal_dot_flag__Instance *,
                     internal_dot_flag__MainCmdPreferences * /*FFF*/),
    internal_dot_flag__MainCmdPreferences *obj) {
  internal_dot_flag__Instance p =
      (internal_dot_flag__Instance){.args = args,
                                    .current_pos = 0,
                                    .current_flag = tos3(""),
                                    .equal_val = tos3(""),
                                    .encountered = new_map(1, sizeof(bool))};
  internal_dot_flag__void_cb casted_callback =
      *(((internal_dot_flag__void_cb *)(&callback)));
  Option_array_string tmp3 = internal_dot_flag__Instance_parse_impl(
      &/* ? */ p, args, ((voidptr)(obj)), casted_callback);
  array_string tmp;
  if (!tmp3.ok) {
    string err = tmp3.error;
    int errcode = tmp3.ecode;
    return v_error(err);
  }
  tmp = *(array_string *)tmp3.data;
  ;
  array_string tmp4 = OPTION_CAST(array_string)(tmp);
  return opt_ok(&tmp4, sizeof(array_string));
}
void internal_dot_help__print_and_exit(string topic) {
  string vexe = v_dot_pref__vexe_path();
  string vroot = os__dir(vexe);
  string tmp1 = topic;
  ;
  for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
    byte b = tmp1.str[tmp2];

    if ((b >= 'a' && b <= 'z') || b == '-' || (b >= '0' && b <= '9')) {
      continue;
    };
    println(internal_dot_help__unknown_topic);
    v_exit(1);
  };
  string target_topic = os__join_path(
      vroot, &(varg_string){.len = 5,
                            .args = {tos3("cmd"), tos3("v"), tos3("internal"),
                                     tos3("help"),
                                     _STR("%.*s.txt", topic.len, topic.str)}});
  Option_string tmp3 = os__read_file(target_topic);
  string content;
  if (!tmp3.ok) {
    string err = tmp3.error;
    int errcode = tmp3.ecode;
    println(internal_dot_help__unknown_topic);
    v_exit(1);
  }
  content = *(string *)tmp3.data;
  ;
  println(content);
  v_exit(0);
}
benchmark__Benchmark benchmark__new_benchmark() {
  return (benchmark__Benchmark){.bench_start_time = benchmark__now(),
                                .verbose = 1,
                                .bench_end_time = 0,
                                .step_start_time = 0,
                                .step_end_time = 0,
                                .ntotal = 0,
                                .nok = 0,
                                .nfail = 0,
                                .nexpected_steps = 0,
                                .cstep = 0,
                                .bok = tos3(""),
                                .bfail = tos3("")};
}
benchmark__Benchmark *benchmark__new_benchmark_pointer() {
  return (benchmark__Benchmark *)memdup(
      &(benchmark__Benchmark){.bench_start_time = benchmark__now(),
                              .verbose = 1,
                              .bench_end_time = 0,
                              .step_start_time = 0,
                              .step_end_time = 0,
                              .ntotal = 0,
                              .nok = 0,
                              .nfail = 0,
                              .nexpected_steps = 0,
                              .cstep = 0,
                              .bok = tos3(""),
                              .bfail = tos3("")},
      sizeof(benchmark__Benchmark));
}
void benchmark__Benchmark_set_total_expected_steps(benchmark__Benchmark *b,
                                                   int n) {
  b->nexpected_steps = n;
}
void benchmark__Benchmark_stop(benchmark__Benchmark *b) {
  b->bench_end_time = benchmark__now();
}
void benchmark__Benchmark_step(benchmark__Benchmark *b) {
  b->step_start_time = benchmark__now();
  b->cstep++;
}
void benchmark__Benchmark_fail(benchmark__Benchmark *b) {
  b->step_end_time = benchmark__now();
  b->ntotal++;
  b->nfail++;
}
void benchmark__Benchmark_ok(benchmark__Benchmark *b) {
  b->step_end_time = benchmark__now();
  b->ntotal++;
  b->nok++;
}
void benchmark__Benchmark_fail_many(benchmark__Benchmark *b, int n) {
  b->step_end_time = benchmark__now();
  b->ntotal += n;
  b->nfail += n;
}
void benchmark__Benchmark_ok_many(benchmark__Benchmark *b, int n) {
  b->step_end_time = benchmark__now();
  b->ntotal += n;
  b->nok += n;
}
void benchmark__Benchmark_neither_fail_nor_ok(benchmark__Benchmark *b) {
  b->step_end_time = benchmark__now();
}
benchmark__Benchmark benchmark__start() {
  benchmark__Benchmark b = benchmark__new_benchmark();
  benchmark__Benchmark_step(&/* ? */ b);
  return b;
}
i64 benchmark__Benchmark_measure(benchmark__Benchmark *b, string label) {
  benchmark__Benchmark_ok(b);
  i64 res = b->step_end_time - b->step_start_time;
  println(benchmark__Benchmark_step_message_with_label(
      &/* ? */ *b, benchmark__BSPENT, _STR("in %.*s", label.len, label.str)));
  benchmark__Benchmark_step(b);
  return res;
}
string benchmark__Benchmark_step_message_with_label(benchmark__Benchmark *b,
                                                    string label, string msg) {
  string timed_line = tos3("");
  if (b->nexpected_steps > 0) {
    string sprogress = tos3("");
    if (b->nexpected_steps < 10) {
      sprogress = _STR("%1d/%1d", b->cstep, b->nexpected_steps);
    };
    if (b->nexpected_steps >= 10 && b->nexpected_steps < 100) {
      sprogress = _STR("%2d/%2d", b->cstep, b->nexpected_steps);
    };
    if (b->nexpected_steps >= 100 && b->nexpected_steps < 1000) {
      sprogress = _STR("%3d/%3d", b->cstep, b->nexpected_steps);
    };
    timed_line = benchmark__Benchmark_tdiff_in_ms(
        &/* ? */ *b,
        _STR("[%.*s] %.*s", sprogress.len, sprogress.str, msg.len, msg.str),
        b->step_start_time, b->step_end_time);
  } else {
    timed_line = benchmark__Benchmark_tdiff_in_ms(
        &/* ? */ *b, msg, b->step_start_time, b->step_end_time);
  };
  return _STR("%-5s%.*s", label.str, timed_line.len, timed_line.str);
}
string benchmark__Benchmark_step_message(benchmark__Benchmark *b, string msg) {
  return benchmark__Benchmark_step_message_with_label(&/* ? */ *b, tos3(""),
                                                      msg);
}
string benchmark__Benchmark_step_message_ok(benchmark__Benchmark *b,
                                            string msg) {
  return benchmark__Benchmark_step_message_with_label(&/* ? */ *b,
                                                      benchmark__BOK, msg);
}
string benchmark__Benchmark_step_message_fail(benchmark__Benchmark *b,
                                              string msg) {
  return benchmark__Benchmark_step_message_with_label(&/* ? */ *b,
                                                      benchmark__BFAIL, msg);
}
string benchmark__Benchmark_total_message(benchmark__Benchmark *b, string msg) {
  string tmsg = string_add(
      string_add(
          string_add(
              string_add(
                  string_add(_STR("%.*s\n                 ok, fail, total = ",
                                  msg.len, msg.str),
                             term__ok_message(_STR("%5d", b->nok))),
                  tos3(", ")),
              ((b->nfail > 0) ? (term__fail_message(_STR("%5d", b->nfail)))
                              : (_STR("%5d", b->nfail)))),
          tos3(", ")),
      _STR("%5d", b->ntotal));
  if (b->verbose) {
    tmsg = _STR("<=== total time spent %.*s", tmsg.len, tmsg.str);
  };
  return string_add(tos3("  "), benchmark__Benchmark_tdiff_in_ms(
                                    &/* ? */ *b, tmsg, b->bench_start_time,
                                    b->bench_end_time));
}
i64 benchmark__Benchmark_total_duration(benchmark__Benchmark *b) {
  return (b->bench_end_time - b->bench_start_time);
}
string benchmark__Benchmark_tdiff_in_ms(benchmark__Benchmark *b, string s,
                                        i64 sticks, i64 eticks) {
  if (b->verbose) {
    i64 tdiff = (eticks - sticks);
    return _STR("%6lld ms %.*s", tdiff, s.len, s.str);
  };
  return s;
}
i64 benchmark__now() { return time__ticks(); }
v_dot_ast__IdentVar v_dot_ast__Ident_var_info(v_dot_ast__Ident *i) {
  v_dot_ast__IdentInfo tmp1 = i->info;

  if (tmp1.typ == SumType_v_dot_ast__IdentInfo_IdentVar) {
    v_dot_ast__IdentVar *it = (v_dot_ast__IdentVar *)tmp1.obj;
    return *it;
  } else // default:
  {
    v_panic(tos3("Ident.var_info(): info is not IdentVar variant"));
  };
}
v_dot_ast__Scope *v_dot_ast__new_scope(v_dot_ast__Scope *parent,
                                       int start_pos) {
  return (v_dot_ast__Scope *)memdup(
      &(v_dot_ast__Scope){.parent = parent,
                          .start_pos = start_pos,
                          .children =
                              new_array(0, 1, sizeof(v_dot_ast__Scope *)),
                          .end_pos = 0,
                          .vars = new_map(1, sizeof(v_dot_ast__Var))},
      sizeof(v_dot_ast__Scope));
}
Option__V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var
v_dot_ast__Scope_find_scope_and_var(v_dot_ast__Scope *s, string name) {
  if ((_IN_MAP((name), s->vars))) {
    v_dot_ast__Var tmp1 = {0};
    bool tmp2 = map_get(/*scope.v : 25*/ s->vars, name, &tmp1);

    _V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var tmp3 =
        OPTION_CAST(_V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var)(
            (_V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var){.var_0 = s,
                                                               .var_1 = tmp1});
    return opt_ok(&tmp3,
                  sizeof(_V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var));
  };
  for (v_dot_ast__Scope *sc = s; !isnil(sc->parent); sc = sc->parent) {

    if ((_IN_MAP((name), sc->vars))) {
      v_dot_ast__Var tmp4 = {0};
      bool tmp5 = map_get(/*scope.v : 29*/ sc->vars, name, &tmp4);

      _V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var tmp6 =
          OPTION_CAST(_V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var)(
              (_V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var){
                  .var_0 = sc, .var_1 = tmp4});
      return opt_ok(&tmp6,
                    sizeof(_V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var));
    };
  };
  return opt_none();
}
Option_v_dot_ast__Var v_dot_ast__Scope_find_var(v_dot_ast__Scope *s,
                                                string name) {
  if ((_IN_MAP((name), s->vars))) {
    v_dot_ast__Var tmp7 = {0};
    bool tmp8 = map_get(/*scope.v : 37*/ s->vars, name, &tmp7);

    v_dot_ast__Var tmp9 = OPTION_CAST(v_dot_ast__Var)(tmp7);
    return opt_ok(&tmp9, sizeof(v_dot_ast__Var));
  };
  for (v_dot_ast__Scope *sc = s; !isnil(sc->parent); sc = sc->parent) {

    if ((_IN_MAP((name), sc->vars))) {
      v_dot_ast__Var tmp10 = {0};
      bool tmp11 = map_get(/*scope.v : 41*/ sc->vars, name, &tmp10);

      v_dot_ast__Var tmp12 = OPTION_CAST(v_dot_ast__Var)(tmp10);
      return opt_ok(&tmp12, sizeof(v_dot_ast__Var));
    };
  };
  return opt_none();
}
bool v_dot_ast__Scope_known_var(v_dot_ast__Scope *s, string name) {
  Option_v_dot_ast__Var tmp13 = v_dot_ast__Scope_find_var(&/* ? */ *s, name);

  if (tmp13.ok) {
    v_dot_ast__Var _ = *(v_dot_ast__Var *)tmp13.data;
    return 1;
  };
  return 0;
}
void v_dot_ast__Scope_register_var(v_dot_ast__Scope *s, v_dot_ast__Var var) {
  Option_v_dot_ast__Var tmp14 =
      v_dot_ast__Scope_find_var(&/* ? */ *s, var.name);

  if (tmp14.ok) {
    v_dot_ast__Var x = *(v_dot_ast__Var *)tmp14.data;

    return;
  };
  map_set(&s->vars, var.name, &(v_dot_ast__Var[]){var});
}
void v_dot_ast__Scope_override_var(v_dot_ast__Scope *s, v_dot_ast__Var var) {
  map_set(&s->vars, var.name, &(v_dot_ast__Var[]){var});
}
v_dot_ast__Scope *v_dot_ast__Scope_outermost(v_dot_ast__Scope *s) {
  v_dot_ast__Scope *sc = s;
  while (!isnil(sc->parent)) {

    sc = sc->parent;
  };
  return sc;
}
v_dot_ast__Scope *v_dot_ast__Scope_innermost(v_dot_ast__Scope *s, int pos) {
  if (v_dot_ast__Scope_contains(&/* ? */ *s, pos)) {
    int first = 0;
    int last = s->children.len - 1;
    int middle = last / 2;
    while (first <= last) {

      v_dot_ast__Scope *s1 =
          (*(v_dot_ast__Scope **)array_get(s->children, middle));
      if (s1->end_pos < pos) {
        first = middle + 1;
      } else if (v_dot_ast__Scope_contains(&/* ? */ *s1, pos)) {
        return v_dot_ast__Scope_innermost(&/* ? */ *s1, pos);
      } else {
        last = middle - 1;
      };
      middle = (first + last) / 2;
      if (first > last) {
        break;
      };
    };
    return s;
  };
  return s;
}
static inline bool v_dot_ast__Scope_contains(v_dot_ast__Scope *s, int pos) {
  return pos >= s->start_pos && pos <= s->end_pos;
}
string v_dot_ast__Scope_show(v_dot_ast__Scope *sc, int level) {
  string out = tos3("");
  string indent = tos3("");
  int tmp17 = 0;
  ;
  for (int tmp18 = tmp17; tmp18 < level * 4; tmp18++) {

    indent = string_add(indent, tos3(" "));
  };
  out = string_add(out, _STR("%.*s# %d - %d\n", indent.len, indent.str,
                             sc->start_pos, sc->end_pos));
  map_v_dot_ast__Var tmp19 = sc->vars;
  array_string keys_tmp19 = map_keys(&tmp19);
  for (int l = 0; l < keys_tmp19.len; l++) {
    string _ = ((string *)keys_tmp19.data)[l];
    v_dot_ast__Var var = {0};
    map_get(tmp19, _, &var);

    out = string_add(out, _STR("%.*s  * %.*s - %d\n", indent.len, indent.str,
                               var.name.len, var.name.str, var.typ));
  };
  array_ptr_v_dot_ast__Scope tmp20 = sc->children;
  for (int tmp21 = 0; tmp21 < tmp20.len; tmp21++) {
    v_dot_ast__Scope *child = ((v_dot_ast__Scope **)tmp20.data)[tmp21];

    out = string_add(out, v_dot_ast__Scope_show(&/* ? */ *child, level + 1));
  };
  return out;
}
string v_dot_ast__Scope_str(v_dot_ast__Scope *sc) {
  return v_dot_ast__Scope_show(&/* ? */ *sc, 0);
}
string v_dot_ast__FnDecl_str(v_dot_ast__FnDecl *node, v_dot_table__Table *t) {
  strings__Builder f = strings__new_builder(30);
  if (node->is_pub) {
    strings__Builder_write(&/* ? */ f, tos3("pub "));
  };
  string receiver = tos3("");
  if (node->is_method) {
    v_dot_table__TypeSymbol *sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *t, node->receiver.typ);
    string name = string_after(sym->name, tos3("."));
    string m = ((node->rec_mut) ? (tos3("mut ")) : (tos3("")));
    receiver = _STR("(%.*s %.*s%.*s) ", node->receiver.name.len,
                    node->receiver.name.str, m.len, m.str, name.len, name.str);
  };
  string name = string_after(node->name, tos3("."));
  strings__Builder_write(&/* ? */ f, _STR("fn %.*s%.*s(", receiver.len,
                                          receiver.str, name.len, name.str));
  array_v_dot_table__Arg tmp1 = node->args;
  for (int i = 0; i < tmp1.len; i++) {
    v_dot_table__Arg arg = ((v_dot_table__Arg *)tmp1.data)[i];

    if (node->is_method && i == 0) {
      continue;
    };
    bool is_last_arg = i == node->args.len - 1;
    bool should_add_type =
        is_last_arg ||
        (*(v_dot_table__Arg *)array_get(node->args, i + 1)).typ != arg.typ ||
        (node->is_variadic && i == node->args.len - 2);
    strings__Builder_write(&/* ? */ f, arg.name);
    if (should_add_type) {
      if (node->is_variadic && is_last_arg) {
        strings__Builder_write(
            &/* ? */ f, string_add(tos3(" ..."), v_dot_table__Table_type_to_str(
                                                     &/* ? */ *t, arg.typ)));
      } else {
        strings__Builder_write(
            &/* ? */ f, string_add(tos3(" "), v_dot_table__Table_type_to_str(
                                                  &/* ? */ *t, arg.typ)));
      };
    };
    if (!is_last_arg) {
      strings__Builder_write(&/* ? */ f, tos3(", "));
    };
  };
  strings__Builder_write(&/* ? */ f, tos3(")"));
  if (node->return_type != v_dot_table__void_type) {
    strings__Builder_write(
        &/* ? */ f, string_add(tos3(" "), v_dot_table__Table_type_to_str(
                                              &/* ? */ *t, node->return_type)));
  };
  return strings__Builder_str(&/* ? */ f);
}
string v_dot_ast__Expr_str(v_dot_ast__Expr x) {
  v_dot_ast__Expr tmp4 = x;

  if (tmp4.typ == SumType_v_dot_ast__Expr_InfixExpr) {
    v_dot_ast__InfixExpr *it = (v_dot_ast__InfixExpr *)tmp4.obj;
    return _STR(
        "(%.*s %.*s %.*s)", v_dot_ast__Expr_str(it->left).len,
        v_dot_ast__Expr_str(it->left).str, v_dot_token__Kind_str(it->op).len,
        v_dot_token__Kind_str(it->op).str, v_dot_ast__Expr_str(it->right).len,
        v_dot_ast__Expr_str(it->right).str);
  } else if (tmp4.typ == SumType_v_dot_ast__Expr_IntegerLiteral) {
    v_dot_ast__IntegerLiteral *it = (v_dot_ast__IntegerLiteral *)tmp4.obj;
    return int_str(it->val);
  } else if (tmp4.typ == SumType_v_dot_ast__Expr_IntegerLiteral) {
    v_dot_ast__IntegerLiteral *it = (v_dot_ast__IntegerLiteral *)tmp4.obj;
    return _STR("\"%d\"", it->val);
  } else // default:
  {
    return tos3("");
  };
}
string v_dot_ast__Stmt_str(v_dot_ast__Stmt node) {
  v_dot_ast__Stmt tmp5 = node;

  if (tmp5.typ == SumType_v_dot_ast__Stmt_AssignStmt) {
    v_dot_ast__AssignStmt *it = (v_dot_ast__AssignStmt *)tmp5.obj;
    string out = tos3("");
    array_v_dot_ast__Ident tmp6 = it->left;
    for (int i = 0; i < tmp6.len; i++) {
      v_dot_ast__Ident ident = ((v_dot_ast__Ident *)tmp6.data)[i];

      v_dot_ast__IdentVar var_info = v_dot_ast__Ident_var_info(&/* ? */ ident);
      if (var_info.is_mut) {
        out = string_add(out, tos3("mut "));
      };
      out = string_add(out, ident.name);
      if (i < it->left.len - 1) {
        out = string_add(out, tos3(","));
      };
    };
    out = string_add(out, _STR(" %.*s ", v_dot_token__Kind_str(it->op).len,
                               v_dot_token__Kind_str(it->op).str));
    array_v_dot_ast__Expr tmp7 = it->right;
    for (int i = 0; i < tmp7.len; i++) {
      v_dot_ast__Expr val = ((v_dot_ast__Expr *)tmp7.data)[i];

      out = string_add(out, v_dot_ast__Expr_str(val));
      if (i < it->right.len - 1) {
        out = string_add(out, tos3(","));
      };
    };
    return out;
  } else if (tmp5.typ == SumType_v_dot_ast__Stmt_ExprStmt) {
    v_dot_ast__ExprStmt *it = (v_dot_ast__ExprStmt *)tmp5.obj;
    return v_dot_ast__Expr_str(it->expr);
  } else if (tmp5.typ == SumType_v_dot_ast__Stmt_FnDecl) {
    v_dot_ast__FnDecl *it = (v_dot_ast__FnDecl *)tmp5.obj;
    return _STR("fn %.*s() { %d stmts }", it->name.len, it->name.str,
                it->stmts.len);
  } else // default:
  {
    return tos3("[unhandled stmt str]");
  };
}
sync__PoolProcessor *
sync__new_pool_processor(sync__PoolProcessorConfig context) {
  if (isnil(&/*112 e="void*" g="sync__ThreadCB" */ context.callback)) {
    v_panic(tos3("You need to pass a valid callback to new_pool_processor."));
  };
  runtime__nr_jobs();
  sync__PoolProcessor *pool = (sync__PoolProcessor *)memdup(
      &(sync__PoolProcessor){.items = new_array_from_c_array(
                                 0, 0, sizeof(voidptr),
                                 EMPTY_ARRAY_OF_ELEMS(voidptr, 0){TCCSKIP(0)}),
                             .results = new_array_from_c_array(
                                 0, 0, sizeof(voidptr),
                                 EMPTY_ARRAY_OF_ELEMS(voidptr, 0){TCCSKIP(0)}),
                             .shared_context = ((voidptr)(0)),
                             .thread_contexts = new_array_from_c_array(
                                 0, 0, sizeof(voidptr),
                                 EMPTY_ARRAY_OF_ELEMS(voidptr, 0){TCCSKIP(0)}),
                             .njobs = context.maxjobs,
                             .ntask = 0,
                             .ntask_mtx = sync__new_mutex(),
                             .waitgroup = sync__new_waitgroup(),
                             .thread_cb = context.callback},
      sizeof(sync__PoolProcessor));
  return pool;
}
void sync__PoolProcessor_set_max_jobs(sync__PoolProcessor *pool, int njobs) {
  pool->njobs = njobs;
}
void sync__PoolProcessor_work_on_pointers(sync__PoolProcessor *pool,
                                          array_voidptr items) {
  int njobs = runtime__nr_jobs();
  if (pool->njobs > 0) {
    njobs = pool->njobs;
  };
  pool->items = new_array_from_c_array(
      0, 0, sizeof(voidptr), EMPTY_ARRAY_OF_ELEMS(voidptr, 0){TCCSKIP(0)});
  pool->results = new_array_from_c_array(
      0, 0, sizeof(voidptr), EMPTY_ARRAY_OF_ELEMS(voidptr, 0){TCCSKIP(0)});
  pool->thread_contexts = new_array_from_c_array(
      0, 0, sizeof(voidptr), EMPTY_ARRAY_OF_ELEMS(voidptr, 0){TCCSKIP(0)});
  _PUSH_MANY(&pool->items, (/*typ = array_voidptr   tmp_typ=voidptr*/ items),
             tmp1, array_voidptr);
  pool->results = array_repeat(
      new_array_from_c_array(1, 1, sizeof(voidptr),
                             EMPTY_ARRAY_OF_ELEMS(voidptr, 1){((voidptr)(0))}),
      pool->items.len);
  _PUSH_MANY(&pool->thread_contexts,
             (/*typ = array_voidptr   tmp_typ=voidptr*/ array_repeat(
                 new_array_from_c_array(
                     1, 1, sizeof(voidptr),
                     EMPTY_ARRAY_OF_ELEMS(voidptr, 1){((voidptr)(0))}),
                 pool->items.len)),
             tmp2, array_voidptr);
  sync__WaitGroup_add(pool->waitgroup, njobs);
  for (int i = 0; i < njobs; i++) {

    thread_arg_sync__process_in_thread *tmp3 =
        malloc(sizeof(thread_arg_sync__process_in_thread));
    tmp3->pool = pool;
    tmp3->task_id = i;
    CreateThread(0, 0,
                 (LPTHREAD_START_ROUTINE)sync__process_in_thread_thread_wrapper,
                 tmp3, 0, 0);
    ;
  };
  sync__WaitGroup_wait(&/* ? */ *pool->waitgroup);
}
void sync__process_in_thread(sync__PoolProcessor *pool, int task_id) {
  sync__ThreadCB cb = ((sync__ThreadCB)(pool->thread_cb));
  int idx = 0;
  int ilen = pool->items.len;
  while (1) {
    if (pool->ntask >= ilen) {
      break;
    };
    sync__Mutex_lock(pool->ntask_mtx);
    idx = pool->ntask;
    pool->ntask++;
    sync__Mutex_unlock(pool->ntask_mtx);
    if (idx >= ilen) {
      break;
    };
    array_set(&/*q*/ pool->results, idx, &(voidptr[]){cb(pool, idx, task_id)});
  };
  sync__WaitGroup_done(pool->waitgroup);
}
string sync__PoolProcessor_get_string_item(sync__PoolProcessor *pool, int idx) {
  return *(((string *)((*(voidptr *)array_get(pool->items, idx)))));
}
int sync__PoolProcessor_get_int_item(sync__PoolProcessor *pool, int idx) {
  return *(((int *)((*(voidptr *)array_get(pool->items, idx)))));
}
void sync__PoolProcessor_set_shared_context(sync__PoolProcessor *pool,
                                            void *context) {
  pool->shared_context = context;
}
void *sync__PoolProcessor_get_shared_context(sync__PoolProcessor *pool) {
  return pool->shared_context;
}
void sync__PoolProcessor_set_thread_context(sync__PoolProcessor *pool, int idx,
                                            void *context) {
  array_set(&/*q*/ pool->thread_contexts, idx, &(voidptr[]){context});
}
void *sync__PoolProcessor_get_thread_context(sync__PoolProcessor *pool,
                                             int idx) {
  return (*(voidptr *)array_get(pool->thread_contexts, idx));
}
sync__Mutex *sync__new_mutex() {
  sync__Mutex *sm = (sync__Mutex *)memdup(
      &(sync__Mutex){
          .cycle_wait = 0, .cycle_woken = 0, .reader_sem = 0, .writer_sem = 0},
      sizeof(sync__Mutex));
  {
    sync__Mutex *m = sm;
    m->mx = CreateMutex(0, 0, 0);
    if (isnil(&/*112 e="void*" g="sync__MHANDLE" */ m->mx)) {
      m->state = sync__sync__MutexState_broken;
      return sm;
    };
  };
  return sm;
}
void sync__Mutex_lock(sync__Mutex *m) {
  if (isnil(&/*112 e="void*" g="sync__MHANDLE" */ m->mx)) {
    m->mx = CreateMutex(0, 0, 0);
    if (isnil(&/*112 e="void*" g="sync__MHANDLE" */ m->mx)) {
      m->state = sync__sync__MutexState_broken;

      return;
    };
  };
  int state = WaitForSingleObject(m->mx, sync__INFINITE);
  sync__MutexState s = sync__sync__MutexState_broken;
  if (state == sync__WAIT_ABANDONED) {
    s = sync__sync__MutexState_abandoned;
  } else if (state == sync__WAIT_OBJECT_0) {
    s = sync__sync__MutexState_waiting;
  };
  m->state = s;
}
void sync__Mutex_unlock(sync__Mutex *m) {
  if (m->state == sync__sync__MutexState_waiting) {
    if (ReleaseMutex(m->mx)) {
      m->state = sync__sync__MutexState_broken;

      return;
    };
  };
  m->state = sync__sync__MutexState_released;
}
void sync__Mutex_destroy(sync__Mutex *m) {
  if (m->state == sync__sync__MutexState_waiting) {
    sync__Mutex_unlock(m);
  };
  CloseHandle(m->mx);
  m->state = sync__sync__MutexState_destroyed;
}
sync__WaitGroup *sync__new_waitgroup() {
  return (sync__WaitGroup *)memdup(
      &(sync__WaitGroup){.mu = sync__new_mutex(), .active = 0},
      sizeof(sync__WaitGroup));
}
void sync__WaitGroup_add(sync__WaitGroup *wg, int delta) {
  sync__Mutex_lock(wg->mu);
  wg->active += delta;
  sync__Mutex_unlock(wg->mu);
  if (wg->active < 0) {
    v_panic(tos3("Negative number of jobs in waitgroup"));
  };
}
void sync__WaitGroup_done(sync__WaitGroup *wg) { sync__WaitGroup_add(wg, -1); }
void sync__WaitGroup_wait(sync__WaitGroup *wg) {
  while (wg->active > 0) {

#ifdef _WIN32
    Sleep(1);
#else
    usleep(1000);
#endif
    ;
  };
}
v_dot_ast__CompIf v_dot_parser__Parser_comp_if(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_next(p);
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_if);
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_not) {
    v_dot_parser__Parser_next(p);
  };
  v_dot_parser__Parser_check_name(p);
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_question) {
    v_dot_parser__Parser_next(p);
  };
  v_dot_parser__Parser_parse_block(p);
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_dollar &&
      p->peek_tok.kind == v_dot_token__v_dot_token__Kind_key_else) {
    v_dot_parser__Parser_next(p);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_else);
    v_dot_parser__Parser_parse_block(p);
  };
  return (v_dot_ast__CompIf){.stmts = new_array(0, 1, sizeof(v_dot_ast__Stmt)),
                             .else_stmts =
                                 new_array(0, 1, sizeof(v_dot_ast__Stmt))};
}
v_dot_ast__CallExpr v_dot_parser__Parser_call_expr(v_dot_parser__Parser *p,
                                                   bool is_c, string mod) {
  v_dot_token__Token tok = p->tok;
  string name = v_dot_parser__Parser_check_name(p);
  string fn_name =
      ((is_c)
           ? (_STR("C.%.*s", name.len, name.str))
           : (((mod.len > 0)
                   ? (_STR("%.*s.%.*s", mod.len, mod.str, name.len, name.str))
                   : (name))));
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lpar);
  array_v_dot_ast__CallArg args = v_dot_parser__Parser_call_args(p);
  array_v_dot_ast__Stmt or_stmts = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Stmt),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Stmt, 0){TCCSKIP(0)});
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_orelse) {
    v_dot_parser__Parser_next(p);
    or_stmts = v_dot_parser__Parser_parse_block(p);
  };
  v_dot_ast__CallExpr node = (v_dot_ast__CallExpr){
      .name = fn_name,
      .args = args,
      .pos = v_dot_token__Token_position(&/* ? */ tok),
      .is_c = is_c,
      .or_block = (v_dot_ast__OrExpr){.stmts = or_stmts},
      .muts = new_array(0, 1, sizeof(bool)),
  };
  return node;
}
array_v_dot_ast__CallArg
v_dot_parser__Parser_call_args(v_dot_parser__Parser *p) {
  array_v_dot_ast__CallArg args = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__CallArg),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__CallArg, 0){TCCSKIP(0)});
  while (p->tok.kind != v_dot_token__v_dot_token__Kind_rpar) {

    bool is_mut = 0;
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_mut) {
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_mut);
      is_mut = 1;
    };
    v_dot_ast__Expr e = v_dot_parser__Parser_expr(p, 0);
    _PUSH(&args,
          (/*typ = array_v_dot_ast__CallArg   tmp_typ=v_dot_ast__CallArg*/ (
              v_dot_ast__CallArg){
              .is_mut = is_mut,
              .expr = e,
          }),
          tmp1, v_dot_ast__CallArg);
    if (p->tok.kind != v_dot_token__v_dot_token__Kind_rpar) {
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_comma);
    };
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rpar);
  return args;
}
v_dot_ast__FnDecl v_dot_parser__Parser_fn_decl(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_open_scope(p);
  bool is_deprecated = string_eq(p->attr, tos3("deprecated"));
  bool is_pub = p->tok.kind == v_dot_token__v_dot_token__Kind_key_pub;
  if (is_pub) {
    v_dot_parser__Parser_next(p);
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_fn);
  bool is_c = p->tok.kind == v_dot_token__v_dot_token__Kind_name &&
              string_eq(p->tok.lit, tos3("C"));
  if (is_c) {
    v_dot_parser__Parser_next(p);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_dot);
  };
  string rec_name = tos3("");
  bool is_method = 0;
  v_dot_table__Type rec_type = v_dot_table__void_type;
  bool rec_mut = 0;
  array_v_dot_table__Arg args = new_array_from_c_array(
      0, 0, sizeof(v_dot_table__Arg),
      EMPTY_ARRAY_OF_ELEMS(v_dot_table__Arg, 0){TCCSKIP(0)});
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_lpar) {
    is_method = 1;
    v_dot_parser__Parser_next(p);
    rec_name = v_dot_parser__Parser_check_name(p);
    rec_mut = p->tok.kind == v_dot_token__v_dot_token__Kind_key_mut;
    rec_type = v_dot_parser__Parser_parse_type(p);
    _PUSH(&args,
          (/*typ = array_v_dot_table__Arg   tmp_typ=v_dot_table__Arg*/ (
              v_dot_table__Arg){
              .name = rec_name, .is_mut = rec_mut, .typ = rec_type}),
          tmp2, v_dot_table__Arg);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rpar);
  };
  string name = tos3("");
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_name) {
    name = v_dot_parser__Parser_check_name(p);
  };
  if ((p->tok.kind == v_dot_token__v_dot_token__Kind_plus ||
       p->tok.kind == v_dot_token__v_dot_token__Kind_minus ||
       p->tok.kind == v_dot_token__v_dot_token__Kind_mul ||
       p->tok.kind == v_dot_token__v_dot_token__Kind_div ||
       p->tok.kind == v_dot_token__v_dot_token__Kind_mod)) {
    name = v_dot_token__Kind_str(p->tok.kind);
    v_dot_parser__Parser_next(p);
  };
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_lt) {
    v_dot_parser__Parser_next(p);
    v_dot_parser__Parser_next(p);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_gt);
  };
  _V_MulRet_array_v_dot_table__Arg_V_bool _V_mret_535_args2_is_variadic =
      v_dot_parser__Parser_fn_args(p);
  array_v_dot_table__Arg args2 = _V_mret_535_args2_is_variadic.var_0;
  bool is_variadic = _V_mret_535_args2_is_variadic.var_1;
  _PUSH_MANY(
      &args,
      (/*typ = array_v_dot_table__Arg   tmp_typ=v_dot_table__Arg*/ args2), tmp3,
      array_v_dot_table__Arg);
  array_v_dot_table__Arg tmp4 = args;
  for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
    v_dot_table__Arg arg = ((v_dot_table__Arg *)tmp4.data)[tmp5];

    v_dot_ast__Scope_register_var(p->scope, (v_dot_ast__Var){
                                                .name = arg.name,
                                                .typ = arg.typ,
                                                .is_mut = 0,
                                            });
  };
  v_dot_table__Type return_type = v_dot_table__void_type;
  if (v_dot_token__Kind_is_start_of_type(p->tok.kind)) {
    return_type = v_dot_parser__Parser_parse_type(p);
  };
  if (is_method) {
    v_dot_table__TypeSymbol *type_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *p->table, rec_type);
    v_dot_table__TypeSymbol_register_method(
        type_sym, (v_dot_table__Fn){.name = name,
                                    .args = args,
                                    .return_type = return_type,
                                    .is_variadic = 0,
                                    .is_c = 0});
  } else {
    if (is_c) {
      name = _STR("C.%.*s", name.len, name.str);
    } else {
      name = v_dot_parser__Parser_prepend_mod(&/* ? */ *p, name);
    };
    v_dot_table__Table_register_fn(p->table,
                                   (v_dot_table__Fn){.name = name,
                                                     .args = args,
                                                     .return_type = return_type,
                                                     .is_variadic = is_variadic,
                                                     .is_c = is_c});
  };
  array_v_dot_ast__Stmt stmts = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Stmt),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Stmt, 0){TCCSKIP(0)});
  bool no_body = p->tok.kind != v_dot_token__v_dot_token__Kind_lcbr;
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_lcbr) {
    stmts = v_dot_parser__Parser_parse_block(p);
  };
  v_dot_parser__Parser_close_scope(p);
  p->attr = tos3("");
  return (v_dot_ast__FnDecl){
      .name = name,
      .stmts = stmts,
      .return_type = return_type,
      .args = args,
      .is_deprecated = is_deprecated,
      .is_pub = is_pub,
      .is_variadic = is_variadic,
      .receiver = (v_dot_ast__Field){.name = rec_name, .typ = rec_type},
      .is_method = is_method,
      .rec_mut = rec_mut,
      .is_c = is_c,
      .no_body = no_body};
}
_V_MulRet_array_v_dot_table__Arg_V_bool
v_dot_parser__Parser_fn_args(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lpar);
  array_v_dot_table__Arg args = new_array_from_c_array(
      0, 0, sizeof(v_dot_table__Arg),
      EMPTY_ARRAY_OF_ELEMS(v_dot_table__Arg, 0){TCCSKIP(0)});
  bool is_variadic = 0;
  bool types_only =
      (p->tok.kind == v_dot_token__v_dot_token__Kind_amp) ||
      (p->peek_tok.kind == v_dot_token__v_dot_token__Kind_comma &&
       v_dot_table__Table_known_type(&/* ? */ *p->table, p->tok.lit)) ||
      p->peek_tok.kind == v_dot_token__v_dot_token__Kind_rpar;
  if (types_only) {
    int arg_no = 1;
    while (p->tok.kind != v_dot_token__v_dot_token__Kind_rpar) {

      string arg_name = _STR("arg_%d", arg_no);
      bool is_mut = p->tok.kind == v_dot_token__v_dot_token__Kind_key_mut;
      if (is_mut) {
        v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_mut);
      };
      if (p->tok.kind == v_dot_token__v_dot_token__Kind_ellipsis) {
        v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_ellipsis);
        is_variadic = 1;
      };
      v_dot_table__Type arg_type = v_dot_parser__Parser_parse_type(p);
      if (is_variadic) {
        arg_type = v_dot_table__type_to_variadic(arg_type);
      };
      if (p->tok.kind == v_dot_token__v_dot_token__Kind_comma) {
        if (is_variadic) {
          v_dot_parser__Parser_error(
              &/* ? */ *p,
              _STR("cannot use ...(variadic) with non-final parameter no %d",
                   arg_no));
        };
        v_dot_parser__Parser_next(p);
      };
      _PUSH(&args,
            (/*typ = array_v_dot_table__Arg   tmp_typ=v_dot_table__Arg*/ (
                v_dot_table__Arg){
                .name = arg_name, .is_mut = is_mut, .typ = arg_type}),
            tmp6, v_dot_table__Arg);
      arg_no++;
    };
  } else {
    while (p->tok.kind != v_dot_token__v_dot_token__Kind_rpar) {

      array_string arg_names = new_array_from_c_array(
          1, 1, sizeof(string),
          EMPTY_ARRAY_OF_ELEMS(string, 1){v_dot_parser__Parser_check_name(p)});
      while (p->tok.kind == v_dot_token__v_dot_token__Kind_comma) {

        v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_comma);
        _PUSH(&arg_names,
              (/*typ = array_string   tmp_typ=string*/
               v_dot_parser__Parser_check_name(p)),
              tmp7, string);
      };
      bool is_mut = p->tok.kind == v_dot_token__v_dot_token__Kind_key_mut;
      if (p->tok.kind == v_dot_token__v_dot_token__Kind_ellipsis) {
        v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_ellipsis);
        is_variadic = 1;
      };
      v_dot_table__Type typ = v_dot_parser__Parser_parse_type(p);
      if (is_variadic) {
        typ = v_dot_table__type_to_variadic(typ);
      };
      array_string tmp8 = arg_names;
      for (int tmp9 = 0; tmp9 < tmp8.len; tmp9++) {
        string arg_name = ((string *)tmp8.data)[tmp9];

        _PUSH(&args,
              (/*typ = array_v_dot_table__Arg   tmp_typ=v_dot_table__Arg*/ (
                  v_dot_table__Arg){
                  .name = arg_name, .is_mut = is_mut, .typ = typ}),
              tmp10, v_dot_table__Arg);
        if (is_variadic &&
            p->tok.kind == v_dot_token__v_dot_token__Kind_comma) {
          v_dot_parser__Parser_error(
              &/* ? */ *p,
              _STR("cannot use ...(variadic) with non-final parameter %.*s",
                   arg_name.len, arg_name.str));
        };
      };
      if (p->tok.kind != v_dot_token__v_dot_token__Kind_rpar) {
        v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_comma);
      };
    };
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rpar);
  return (_V_MulRet_array_v_dot_table__Arg_V_bool){.var_0 = args,
                                                   .var_1 = is_variadic};
}
bool v_dot_parser__Parser_known_import(v_dot_parser__Parser *p, string mod) {
  return (_IN_MAP((mod), p->imports));
}
string v_dot_parser__Parser_prepend_mod(v_dot_parser__Parser *p, string name) {
  if (string_ne(p->expr_mod, tos3(""))) {
    return string_add(string_add(p->expr_mod, tos3(".")), name);
  };
  if (p->builtin_mod || string_eq(p->mod, tos3("main"))) {
    return name;
  };
  return _STR("%.*s.%.*s", p->mod.len, p->mod.str, name.len, name.str);
}
v_dot_table__Type
v_dot_parser__Parser_parse_array_type(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lsbr);
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_number) {
    int size = v_string_int(p->tok.lit);
    v_dot_parser__Parser_next(p);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rsbr);
    v_dot_table__Type elem_type = v_dot_parser__Parser_parse_type(p);
    int idx = v_dot_table__Table_find_or_register_array_fixed(
        p->table, elem_type, size, 1);
    return v_dot_table__new_type(idx);
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rsbr);
  v_dot_table__Type elem_type = v_dot_parser__Parser_parse_type(p);
  int nr_dims = 1;
  while (p->tok.kind == v_dot_token__v_dot_token__Kind_lsbr) {

    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lsbr);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rsbr);
    nr_dims++;
  };
  int idx =
      v_dot_table__Table_find_or_register_array(p->table, elem_type, nr_dims);
  return v_dot_table__new_type(idx);
}
v_dot_table__Type v_dot_parser__Parser_parse_map_type(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_next(p);
  if (p->tok.kind != v_dot_token__v_dot_token__Kind_lsbr) {
    return v_dot_table__map_type;
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lsbr);
  v_dot_table__Type key_type = v_dot_parser__Parser_parse_type(p);
  if (v_dot_table__type_idx(key_type) != v_dot_table__string_type_idx) {
    v_dot_parser__Parser_error(&/* ? */ *p,
                               tos3("maps can only have string keys for now"));
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rsbr);
  v_dot_table__Type value_type = v_dot_parser__Parser_parse_type(p);
  int idx =
      v_dot_table__Table_find_or_register_map(p->table, key_type, value_type);
  return v_dot_table__new_type(idx);
}
v_dot_table__Type
v_dot_parser__Parser_parse_multi_return_type(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lpar);
  array_v_dot_table__Type mr_types = new_array_from_c_array(
      0, 0, sizeof(v_dot_table__Type),
      EMPTY_ARRAY_OF_ELEMS(v_dot_table__Type, 0){TCCSKIP(0)});
  while (1) {
    v_dot_table__Type mr_type = v_dot_parser__Parser_parse_type(p);
    _PUSH(
        &mr_types,
        (/*typ = array_v_dot_table__Type   tmp_typ=v_dot_table__Type*/ mr_type),
        tmp1, v_dot_table__Type);
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_comma) {
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_comma);
    } else {
      break;
    };
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rpar);
  int idx =
      v_dot_table__Table_find_or_register_multi_return(p->table, mr_types);
  return v_dot_table__new_type(idx);
}
v_dot_table__Type v_dot_parser__Parser_parse_fn_type(v_dot_parser__Parser *p,
                                                     string name) {
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_fn);
  _V_MulRet_array_v_dot_table__Arg_V_bool _V_mret_374_args_is_variadic =
      v_dot_parser__Parser_fn_args(p);
  array_v_dot_table__Arg args = _V_mret_374_args_is_variadic.var_0;
  bool is_variadic = _V_mret_374_args_is_variadic.var_1;
  v_dot_table__Type return_type = v_dot_table__void_type;
  if (v_dot_token__Kind_is_start_of_type(p->tok.kind)) {
    return_type = v_dot_parser__Parser_parse_type(p);
  };
  v_dot_table__Fn func = (v_dot_table__Fn){.name = name,
                                           .args = args,
                                           .is_variadic = is_variadic,
                                           .return_type = return_type,
                                           .is_c = 0};
  int idx = v_dot_table__Table_find_or_register_fn_type(p->table, func);
  return v_dot_table__new_type(idx);
}
v_dot_table__Type v_dot_parser__Parser_parse_type(v_dot_parser__Parser *p) {
  bool is_optional = 0;
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_question) {
    v_dot_parser__Parser_next(p);
    is_optional = 1;
  };
  int nr_muls = 0;
  while (p->tok.kind == v_dot_token__v_dot_token__Kind_amp) {

    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_amp);
    nr_muls++;
  };
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_mut) {
    nr_muls++;
    v_dot_parser__Parser_next(p);
  };
  bool is_c = string_eq(p->tok.lit, tos3("C"));
  if (is_c) {
    v_dot_parser__Parser_next(p);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_dot);
  };
  v_dot_table__Type typ =
      v_dot_parser__Parser_parse_any_type(p, is_c, nr_muls > 0);
  if (is_optional) {
    typ = v_dot_table__type_to_optional(typ);
  };
  if (nr_muls > 0) {
    typ = v_dot_table__type_set_nr_muls(typ, nr_muls);
  };
  return typ;
}
v_dot_table__Type v_dot_parser__Parser_parse_any_type(v_dot_parser__Parser *p,
                                                      bool is_c, bool is_ptr) {
  string name = p->tok.lit;
  if (is_c) {
    name = _STR("C.%.*s", name.len, name.str);
  } else if (p->peek_tok.kind == v_dot_token__v_dot_token__Kind_dot) {
    if (!v_dot_parser__Parser_known_import(&/* ? */ *p, name)) {
      println(array_string_str(p->table->imports));
      v_dot_parser__Parser_error(
          &/* ? */ *p,
          _STR("unknown module `%.*s`", p->tok.lit.len, p->tok.lit.str));
    };
    v_dot_parser__Parser_next(p);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_dot);
    string tmp2 = tos3("");
    bool tmp3 = map_get(/*parse_type.v : 134*/ p->imports, name, &tmp2);

    if (!tmp3)
      tmp2 = tos((byte *)"", 0);

    name =
        _STR("%.*s.%.*s", tmp2.len, tmp2.str, p->tok.lit.len, p->tok.lit.str);
  } else if (string_ne(p->expr_mod, tos3(""))) {
    name = string_add(string_add(p->expr_mod, tos3(".")), name);
  } else if (!((string_eq(p->mod, tos3("builtin")) ||
                string_eq(p->mod, tos3("main")))) &&
             !((_IN(string, (name), v_dot_table__builtin_type_names)))) {
    name = string_add(string_add(p->mod, tos3(".")), name);
  };
  v_dot_token__Kind tmp4 = p->tok.kind;

  if (tmp4 == v_dot_token__v_dot_token__Kind_key_fn) {
    return v_dot_parser__Parser_parse_fn_type(p, tos3(""));
  } else if (tmp4 == v_dot_token__v_dot_token__Kind_lsbr) {
    return v_dot_parser__Parser_parse_array_type(p);
  } else if (tmp4 == v_dot_token__v_dot_token__Kind_lpar) {
    if (is_ptr) {
      v_dot_parser__Parser_error(
          &/* ? */ *p,
          tos3("parse_type: unexpected `&` before multiple returns"));
    };
    return v_dot_parser__Parser_parse_multi_return_type(p);
  } else // default:
  {
    if (string_eq(name, tos3("map"))) {
      return v_dot_parser__Parser_parse_map_type(p);
    };
    string tmp5 = name;

    if (string_eq(tmp5, tos3("voidptr"))) {
      v_dot_table__Type tmp6 = v_dot_table__voidptr_type;
      { v_dot_parser__Parser_next(p); }
      return tmp6;
      ;
    } else if (string_eq(tmp5, tos3("byteptr"))) {
      v_dot_table__Type tmp7 = v_dot_table__byteptr_type;
      { v_dot_parser__Parser_next(p); }
      return tmp7;
      ;
    } else if (string_eq(tmp5, tos3("charptr"))) {
      v_dot_table__Type tmp8 = v_dot_table__charptr_type;
      { v_dot_parser__Parser_next(p); }
      return tmp8;
      ;
    } else if (string_eq(tmp5, tos3("i8"))) {
      v_dot_table__Type tmp9 = v_dot_table__i8_type;
      { v_dot_parser__Parser_next(p); }
      return tmp9;
      ;
    } else if (string_eq(tmp5, tos3("i16"))) {
      v_dot_table__Type tmp10 = v_dot_table__i16_type;
      { v_dot_parser__Parser_next(p); }
      return tmp10;
      ;
    } else if (string_eq(tmp5, tos3("int"))) {
      v_dot_table__Type tmp11 = v_dot_table__int_type;
      { v_dot_parser__Parser_next(p); }
      return tmp11;
      ;
    } else if (string_eq(tmp5, tos3("i64"))) {
      v_dot_table__Type tmp12 = v_dot_table__i64_type;
      { v_dot_parser__Parser_next(p); }
      return tmp12;
      ;
    } else if (string_eq(tmp5, tos3("byte"))) {
      v_dot_table__Type tmp13 = v_dot_table__byte_type;
      { v_dot_parser__Parser_next(p); }
      return tmp13;
      ;
    } else if (string_eq(tmp5, tos3("u16"))) {
      v_dot_table__Type tmp14 = v_dot_table__u16_type;
      { v_dot_parser__Parser_next(p); }
      return tmp14;
      ;
    } else if (string_eq(tmp5, tos3("u32"))) {
      v_dot_table__Type tmp15 = v_dot_table__u32_type;
      { v_dot_parser__Parser_next(p); }
      return tmp15;
      ;
    } else if (string_eq(tmp5, tos3("u64"))) {
      v_dot_table__Type tmp16 = v_dot_table__u64_type;
      { v_dot_parser__Parser_next(p); }
      return tmp16;
      ;
    } else if (string_eq(tmp5, tos3("f32"))) {
      v_dot_table__Type tmp17 = v_dot_table__f32_type;
      { v_dot_parser__Parser_next(p); }
      return tmp17;
      ;
    } else if (string_eq(tmp5, tos3("f64"))) {
      v_dot_table__Type tmp18 = v_dot_table__f64_type;
      { v_dot_parser__Parser_next(p); }
      return tmp18;
      ;
    } else if (string_eq(tmp5, tos3("string"))) {
      v_dot_table__Type tmp19 = v_dot_table__string_type;
      { v_dot_parser__Parser_next(p); }
      return tmp19;
      ;
    } else if (string_eq(tmp5, tos3("char"))) {
      v_dot_table__Type tmp20 = v_dot_table__char_type;
      { v_dot_parser__Parser_next(p); }
      return tmp20;
      ;
    } else if (string_eq(tmp5, tos3("bool"))) {
      v_dot_table__Type tmp21 = v_dot_table__bool_type;
      { v_dot_parser__Parser_next(p); }
      return tmp21;
      ;
    } else // default:
    {
      int idx = v_dot_table__Table_find_type_idx(&/* ? */ *p->table, name);
      if (idx > 0) {
        v_dot_table__Type tmp22 = v_dot_table__new_type(idx);
        { v_dot_parser__Parser_next(p); }
        return tmp22;
        ;
      };
      idx = v_dot_table__Table_add_placeholder_type(p->table, name);
      v_dot_table__Type tmp23 = v_dot_table__new_type(idx);
      { v_dot_parser__Parser_next(p); }
      return tmp23;
      ;
    };
    { v_dot_parser__Parser_next(p); }
  };
}
v_dot_ast__Stmt v_dot_parser__parse_stmt(string text, v_dot_table__Table *table,
                                         v_dot_ast__Scope *scope) {
  v_dot_scanner__Scanner *s = v_dot_scanner__new_scanner(
      text, v_dot_scanner__v_dot_scanner__CommentsMode_skip_comments);
  v_dot_parser__Parser p = (v_dot_parser__Parser){
      .scanner = s,
      .table = table,
      .pref = (v_dot_pref__Preferences *)memdup(
          &(v_dot_pref__Preferences){
              .is_test = 0,
              .is_script = 0,
              .is_live = 0,
              .is_solive = 0,
              .is_so = 0,
              .is_prof = 0,
              .translated = 0,
              .is_prod = 0,
              .obfuscate = 0,
              .is_repl = 0,
              .is_run = 0,
              .sanitize = 0,
              .is_debug = 0,
              .is_vlines = 0,
              .is_keep_c = 0,
              .is_pretty_c = 0,
              .is_cache = 0,
              .is_stats = 0,
              .no_auto_free = 0,
              .cflags = tos3(""),
              .ccompiler = tos3(""),
              .third_party_option = tos3(""),
              .building_v = 0,
              .autofree = 0,
              .compress = 0,
              .fast = 0,
              .enable_globals = 0,
              .is_bare = 0,
              .lookup_path = new_array(0, 1, sizeof(string)),
              .output_cross_c = 0,
              .prealloc = 0,
              .vroot = tos3(""),
              .out_name = tos3(""),
              .path = tos3(""),
              .compile_defines = new_array(0, 1, sizeof(string)),
              .compile_defines_all = new_array(0, 1, sizeof(string)),
              .mod = tos3("")},
          sizeof(v_dot_pref__Preferences)),
      .scope = scope,
      .file_name = tos3(""),
      .is_c = 0,
      .inside_if = 0,
      .builtin_mod = 0,
      .mod = tos3(""),
      .attr = tos3(""),
      .expr_mod = tos3(""),
      .imports = new_map(1, sizeof(string)),
      .ast_imports = new_array(0, 1, sizeof(v_dot_ast__Import)),
      .is_amp = 0};
  v_dot_parser__Parser_init_parse_fns(&/* ? */ p);
  v_dot_parser__Parser_read_first_token(&/* ? */ p);
  return v_dot_parser__Parser_stmt(&/* ? */ p);
}
v_dot_ast__File
v_dot_parser__parse_file(string path, v_dot_table__Table *table,
                         v_dot_scanner__CommentsMode comments_mode) {
  array_v_dot_ast__Stmt stmts = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Stmt),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Stmt, 0){TCCSKIP(0)});
  v_dot_parser__Parser p = (v_dot_parser__Parser){
      .scanner = v_dot_scanner__new_scanner_file(path, comments_mode),
      .table = table,
      .file_name = path,
      .pref = (v_dot_pref__Preferences *)memdup(
          &(v_dot_pref__Preferences){
              .is_test = 0,
              .is_script = 0,
              .is_live = 0,
              .is_solive = 0,
              .is_so = 0,
              .is_prof = 0,
              .translated = 0,
              .is_prod = 0,
              .obfuscate = 0,
              .is_repl = 0,
              .is_run = 0,
              .sanitize = 0,
              .is_debug = 0,
              .is_vlines = 0,
              .is_keep_c = 0,
              .is_pretty_c = 0,
              .is_cache = 0,
              .is_stats = 0,
              .no_auto_free = 0,
              .cflags = tos3(""),
              .ccompiler = tos3(""),
              .third_party_option = tos3(""),
              .building_v = 0,
              .autofree = 0,
              .compress = 0,
              .fast = 0,
              .enable_globals = 0,
              .is_bare = 0,
              .lookup_path = new_array(0, 1, sizeof(string)),
              .output_cross_c = 0,
              .prealloc = 0,
              .vroot = tos3(""),
              .out_name = tos3(""),
              .path = tos3(""),
              .compile_defines = new_array(0, 1, sizeof(string)),
              .compile_defines_all = new_array(0, 1, sizeof(string)),
              .mod = tos3("")},
          sizeof(v_dot_pref__Preferences)),
      .scope = (v_dot_ast__Scope *)memdup(
          &(v_dot_ast__Scope){.start_pos = 0,
                              .parent = 0,
                              .children =
                                  new_array(0, 1, sizeof(v_dot_ast__Scope *)),
                              .end_pos = 0,
                              .vars = new_map(1, sizeof(v_dot_ast__Var))},
          sizeof(v_dot_ast__Scope)),
      .is_c = 0,
      .inside_if = 0,
      .builtin_mod = 0,
      .mod = tos3(""),
      .attr = tos3(""),
      .expr_mod = tos3(""),
      .imports = new_map(1, sizeof(string)),
      .ast_imports = new_array(0, 1, sizeof(v_dot_ast__Import)),
      .is_amp = 0};
  v_dot_parser__Parser_read_first_token(&/* ? */ p);
  v_dot_ast__Module module_decl =
      ((p.tok.kind == v_dot_token__v_dot_token__Kind_key_module)
           ? (v_dot_parser__Parser_module_decl(&/* ? */ p))
           : ((v_dot_ast__Module){
                 .name = tos3("main"),
                 .path = tos3(""),
             }));
  p.mod = module_decl.name;
  p.builtin_mod = string_eq(p.mod, tos3("builtin"));
  while (1) {
    if (p.tok.kind == v_dot_token__v_dot_token__Kind_eof) {
      break;
    };
    _PUSH(&stmts,
          (/*typ = array_v_dot_ast__Stmt   tmp_typ=v_dot_ast__Stmt*/
           v_dot_parser__Parser_top_stmt(&/* ? */ p)),
          tmp1, v_dot_ast__Stmt);
  };
  p.scope->end_pos = p.tok.pos;
  return (v_dot_ast__File){.path = path,
                           .mod = module_decl,
                           .imports = p.ast_imports,
                           .stmts = stmts,
                           .scope = p.scope};
}
void v_dot_parser__Queue_run(v_dot_parser__Queue *q) {
  sync__Mutex_lock(&/* ? */ q->mu);
  int idx = q->idx;
  if (idx >= q->paths.len) {
    sync__Mutex_unlock(&/* ? */ q->mu);

    return;
  };
  q->idx++;
  sync__Mutex_unlock(&/* ? */ q->mu);
  string path = (*(string *)array_get(q->paths, idx));
  v_dot_ast__File file = v_dot_parser__parse_file(
      path, q->table, v_dot_scanner__v_dot_scanner__CommentsMode_skip_comments);
  sync__Mutex_lock(&/* ? */ q->mu);
  _PUSH(&q->parsed_ast_files,
        (/*typ = array_v_dot_ast__File   tmp_typ=v_dot_ast__File*/ file), tmp4,
        v_dot_ast__File);
  sync__Mutex_unlock(&/* ? */ q->mu);
}
array_v_dot_ast__File v_dot_parser__parse_files(array_string paths,
                                                v_dot_table__Table *table) {
  array_v_dot_ast__File files = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__File),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__File, 0){TCCSKIP(0)});
  array_string tmp5 = paths;
  for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
    string path = ((string *)tmp5.data)[tmp6];

    _PUSH(&files,
          (/*typ = array_v_dot_ast__File   tmp_typ=v_dot_ast__File*/
           v_dot_parser__parse_file(
               path, table,
               v_dot_scanner__v_dot_scanner__CommentsMode_skip_comments)),
          tmp7, v_dot_ast__File);
  };
  return files;
}
void v_dot_parser__Parser_init_parse_fns(v_dot_parser__Parser *p) {
  println(tos3(""));
}
void v_dot_parser__Parser_read_first_token(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_next(p);
  v_dot_parser__Parser_next(p);
}
void v_dot_parser__Parser_open_scope(v_dot_parser__Parser *p) {
  p->scope = (v_dot_ast__Scope *)memdup(
      &(v_dot_ast__Scope){.parent = p->scope,
                          .start_pos = p->tok.pos,
                          .children =
                              new_array(0, 1, sizeof(v_dot_ast__Scope *)),
                          .end_pos = 0,
                          .vars = new_map(1, sizeof(v_dot_ast__Var))},
      sizeof(v_dot_ast__Scope));
}
void v_dot_parser__Parser_close_scope(v_dot_parser__Parser *p) {
  p->scope->end_pos = p->tok.pos;
  _PUSH(&p->scope->parent->children,
        (/*typ = array_ptr_v_dot_ast__Scope   tmp_typ=v_dot_ast__Scope**/ p
             ->scope),
        tmp8, v_dot_ast__Scope *);
  p->scope = p->scope->parent;
}
array_v_dot_ast__Stmt
v_dot_parser__Parser_parse_block(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_open_scope(p);
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lcbr);
  array_v_dot_ast__Stmt stmts = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Stmt),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Stmt, 0){TCCSKIP(0)});
  if (p->tok.kind != v_dot_token__v_dot_token__Kind_rcbr) {
    while (1) {
      _PUSH(&stmts,
            (/*typ = array_v_dot_ast__Stmt   tmp_typ=v_dot_ast__Stmt*/
             v_dot_parser__Parser_stmt(p)),
            tmp9, v_dot_ast__Stmt);
      if ((p->tok.kind == v_dot_token__v_dot_token__Kind_eof ||
           p->tok.kind == v_dot_token__v_dot_token__Kind_rcbr)) {
        break;
      };
    };
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rcbr);
  v_dot_parser__Parser_close_scope(p);
  return stmts;
}
void v_dot_parser__Parser_next(v_dot_parser__Parser *p) {
  p->tok = p->peek_tok;
  p->peek_tok = v_dot_scanner__Scanner_scan(p->scanner);
}
void v_dot_parser__Parser_check(v_dot_parser__Parser *p,
                                v_dot_token__Kind expected) {
  if (p->tok.kind != expected) {
    string s = _STR("syntax error: unexpected `%.*s`, expecting `%.*s`",
                    v_dot_token__Kind_str(p->tok.kind).len,
                    v_dot_token__Kind_str(p->tok.kind).str,
                    v_dot_token__Kind_str(expected).len,
                    v_dot_token__Kind_str(expected).str);
    v_dot_parser__Parser_error(&/* ? */ *p, s);
  };
  v_dot_parser__Parser_next(p);
}
string v_dot_parser__Parser_check_name(v_dot_parser__Parser *p) {
  string name = p->tok.lit;
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_name);
  return name;
}
v_dot_ast__Stmt v_dot_parser__Parser_top_stmt(v_dot_parser__Parser *p) {
  v_dot_token__Kind tmp10 = p->tok.kind;

  if (tmp10 == v_dot_token__v_dot_token__Kind_key_pub) {
    v_dot_token__Kind tmp11 = p->peek_tok.kind;

    if (tmp11 == v_dot_token__v_dot_token__Kind_key_const) {
      return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
          .obj = memdup(
              &(v_dot_ast__ConstDecl[]){v_dot_parser__Parser_const_decl(p)},
              sizeof(v_dot_ast__ConstDecl)),
          .typ = SumType_v_dot_ast__Stmt_ConstDecl};
    } else if (tmp11 == v_dot_token__v_dot_token__Kind_key_fn) {
      return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
          .obj = memdup(&(v_dot_ast__FnDecl[]){v_dot_parser__Parser_fn_decl(p)},
                        sizeof(v_dot_ast__FnDecl)),
          .typ = SumType_v_dot_ast__Stmt_FnDecl};
    } else if ((tmp11 == v_dot_token__v_dot_token__Kind_key_struct) ||
               (tmp11 == v_dot_token__v_dot_token__Kind_key_union) ||
               (tmp11 == v_dot_token__v_dot_token__Kind_key_interface)) {
      return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
          .obj = memdup(
              &(v_dot_ast__StructDecl[]){v_dot_parser__Parser_struct_decl(p)},
              sizeof(v_dot_ast__StructDecl)),
          .typ = SumType_v_dot_ast__Stmt_StructDecl};
    } else if (tmp11 == v_dot_token__v_dot_token__Kind_key_enum) {
      return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
          .obj = memdup(
              &(v_dot_ast__EnumDecl[]){v_dot_parser__Parser_enum_decl(p)},
              sizeof(v_dot_ast__EnumDecl)),
          .typ = SumType_v_dot_ast__Stmt_EnumDecl};
    } else if (tmp11 == v_dot_token__v_dot_token__Kind_key_type) {
      return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
          .obj = memdup(
              &(v_dot_ast__TypeDecl[]){v_dot_parser__Parser_type_decl(p)},
              sizeof(v_dot_ast__TypeDecl)),
          .typ = SumType_v_dot_ast__Stmt_TypeDecl};
    } else // default:
    {
      v_dot_parser__Parser_error(&/* ? */ *p, tos3("wrong pub keyword usage"));
      return (v_dot_ast__Stmt){EMPTY_STRUCT_INITIALIZATION};
    };
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_lsbr) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(&(v_dot_ast__Attr[]){v_dot_parser__Parser_attribute(p)},
                      sizeof(v_dot_ast__Attr)),
        .typ = SumType_v_dot_ast__Stmt_Attr};
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_key_module) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj =
            memdup(&(v_dot_ast__Module[]){v_dot_parser__Parser_module_decl(p)},
                   sizeof(v_dot_ast__Module)),
        .typ = SumType_v_dot_ast__Stmt_Module};
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_key_import) {
    array_v_dot_ast__Import node = v_dot_parser__Parser_import_stmt(p);
    _PUSH_MANY(
        &p->ast_imports,
        (/*typ = array_v_dot_ast__Import   tmp_typ=v_dot_ast__Import*/ node),
        tmp12, array_v_dot_ast__Import);
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__Import[]){(*(v_dot_ast__Import *)array_get(node, 0))},
            sizeof(v_dot_ast__Import)),
        .typ = SumType_v_dot_ast__Stmt_Import};
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_key_global) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__GlobalDecl[]){v_dot_parser__Parser_global_decl(p)},
            sizeof(v_dot_ast__GlobalDecl)),
        .typ = SumType_v_dot_ast__Stmt_GlobalDecl};
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_key_const) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__ConstDecl[]){v_dot_parser__Parser_const_decl(p)},
            sizeof(v_dot_ast__ConstDecl)),
        .typ = SumType_v_dot_ast__Stmt_ConstDecl};
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_key_fn) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(&(v_dot_ast__FnDecl[]){v_dot_parser__Parser_fn_decl(p)},
                      sizeof(v_dot_ast__FnDecl)),
        .typ = SumType_v_dot_ast__Stmt_FnDecl};
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_key_struct) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__StructDecl[]){v_dot_parser__Parser_struct_decl(p)},
            sizeof(v_dot_ast__StructDecl)),
        .typ = SumType_v_dot_ast__Stmt_StructDecl};
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_dollar) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(&(v_dot_ast__CompIf[]){v_dot_parser__Parser_comp_if(p)},
                      sizeof(v_dot_ast__CompIf)),
        .typ = SumType_v_dot_ast__Stmt_CompIf};
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_hash) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(&(v_dot_ast__HashStmt[]){v_dot_parser__Parser_hash(p)},
                      sizeof(v_dot_ast__HashStmt)),
        .typ = SumType_v_dot_ast__Stmt_HashStmt};
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_key_type) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj =
            memdup(&(v_dot_ast__TypeDecl[]){v_dot_parser__Parser_type_decl(p)},
                   sizeof(v_dot_ast__TypeDecl)),
        .typ = SumType_v_dot_ast__Stmt_TypeDecl};
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_key_enum) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj =
            memdup(&(v_dot_ast__EnumDecl[]){v_dot_parser__Parser_enum_decl(p)},
                   sizeof(v_dot_ast__EnumDecl)),
        .typ = SumType_v_dot_ast__Stmt_EnumDecl};
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_key_union) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__StructDecl[]){v_dot_parser__Parser_struct_decl(p)},
            sizeof(v_dot_ast__StructDecl)),
        .typ = SumType_v_dot_ast__Stmt_StructDecl};
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_line_comment) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__LineComment[]){v_dot_parser__Parser_line_comment(p)},
            sizeof(v_dot_ast__LineComment)),
        .typ = SumType_v_dot_ast__Stmt_LineComment};
  } else if (tmp10 == v_dot_token__v_dot_token__Kind_mline_comment) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__MultiLineComment[]){(v_dot_ast__MultiLineComment){
                .text = p->scanner->line_comment}},
            sizeof(v_dot_ast__MultiLineComment)),
        .typ = SumType_v_dot_ast__Stmt_MultiLineComment};
  } else // default:
  {
    v_dot_parser__Parser_error(
        &/* ? */ *p, string_add(tos3("parser: bad top level statement "),
                                v_dot_token__Token_str(p->tok)));
    return (v_dot_ast__Stmt){EMPTY_STRUCT_INITIALIZATION};
  };
}
v_dot_ast__LineComment
v_dot_parser__Parser_line_comment(v_dot_parser__Parser *p) {
  string text = p->tok.lit;
  v_dot_parser__Parser_next(p);
  return (v_dot_ast__LineComment){.text = text};
}
v_dot_ast__Stmt v_dot_parser__Parser_stmt(v_dot_parser__Parser *p) {
  v_dot_token__Kind tmp15 = p->tok.kind;

  if (tmp15 == v_dot_token__v_dot_token__Kind_key_assert) {
    v_dot_parser__Parser_next(p);
    v_dot_ast__Expr expr = v_dot_parser__Parser_expr(p, 0);
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__AssertStmt[]){(v_dot_ast__AssertStmt){.expr = expr}},
            sizeof(v_dot_ast__AssertStmt)),
        .typ = SumType_v_dot_ast__Stmt_AssertStmt};
  } else if (tmp15 == v_dot_token__v_dot_token__Kind_key_mut) {
    return v_dot_parser__Parser_assign_stmt(p);
  } else if (tmp15 == v_dot_token__v_dot_token__Kind_key_for) {
    return v_dot_parser__Parser_for_statement(p);
  } else if (tmp15 == v_dot_token__v_dot_token__Kind_line_comment) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__LineComment[]){v_dot_parser__Parser_line_comment(p)},
            sizeof(v_dot_ast__LineComment)),
        .typ = SumType_v_dot_ast__Stmt_LineComment};
  } else if (tmp15 == v_dot_token__v_dot_token__Kind_key_return) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj =
            memdup(&(v_dot_ast__Return[]){v_dot_parser__Parser_return_stmt(p)},
                   sizeof(v_dot_ast__Return)),
        .typ = SumType_v_dot_ast__Stmt_Return};
  } else if (tmp15 == v_dot_token__v_dot_token__Kind_dollar) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(&(v_dot_ast__CompIf[]){v_dot_parser__Parser_comp_if(p)},
                      sizeof(v_dot_ast__CompIf)),
        .typ = SumType_v_dot_ast__Stmt_CompIf};
  } else if ((tmp15 == v_dot_token__v_dot_token__Kind_key_continue) ||
             (tmp15 == v_dot_token__v_dot_token__Kind_key_break)) {
    v_dot_token__Token tok = p->tok;
    v_dot_parser__Parser_next(p);
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__BranchStmt[]){(v_dot_ast__BranchStmt){.tok = tok}},
            sizeof(v_dot_ast__BranchStmt)),
        .typ = SumType_v_dot_ast__Stmt_BranchStmt};
  } else if (tmp15 == v_dot_token__v_dot_token__Kind_key_unsafe) {
    v_dot_parser__Parser_next(p);
    array_v_dot_ast__Stmt stmts = v_dot_parser__Parser_parse_block(p);
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__UnsafeStmt[]){(v_dot_ast__UnsafeStmt){.stmts = stmts}},
            sizeof(v_dot_ast__UnsafeStmt)),
        .typ = SumType_v_dot_ast__Stmt_UnsafeStmt};
  } else if (tmp15 == v_dot_token__v_dot_token__Kind_key_defer) {
    v_dot_parser__Parser_next(p);
    array_v_dot_ast__Stmt stmts = v_dot_parser__Parser_parse_block(p);
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__DeferStmt[]){(v_dot_ast__DeferStmt){.stmts = stmts}},
            sizeof(v_dot_ast__DeferStmt)),
        .typ = SumType_v_dot_ast__Stmt_DeferStmt};
  } else if (tmp15 == v_dot_token__v_dot_token__Kind_key_go) {
    v_dot_parser__Parser_next(p);
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(&(v_dot_ast__GoStmt[]){(v_dot_ast__GoStmt){
                          .expr = v_dot_parser__Parser_expr(p, 0)}},
                      sizeof(v_dot_ast__GoStmt)),
        .typ = SumType_v_dot_ast__Stmt_GoStmt};
  } else if (tmp15 == v_dot_token__v_dot_token__Kind_key_goto) {
    v_dot_parser__Parser_next(p);
    string name = v_dot_parser__Parser_check_name(p);
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__GotoStmt[]){(v_dot_ast__GotoStmt){.name = name}},
            sizeof(v_dot_ast__GotoStmt)),
        .typ = SumType_v_dot_ast__Stmt_GotoStmt};
  } else // default:
  {
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_name &&
        (p->peek_tok.kind == v_dot_token__v_dot_token__Kind_decl_assign ||
         p->peek_tok.kind == v_dot_token__v_dot_token__Kind_comma)) {
      return v_dot_parser__Parser_assign_stmt(p);
    } else if (p->tok.kind == v_dot_token__v_dot_token__Kind_name &&
               p->peek_tok.kind == v_dot_token__v_dot_token__Kind_colon) {
      string name = v_dot_parser__Parser_check_name(p);
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_colon);
      return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
          .obj = memdup(
              &(v_dot_ast__GotoLabel[]){(v_dot_ast__GotoLabel){.name = name}},
              sizeof(v_dot_ast__GotoLabel)),
          .typ = SumType_v_dot_ast__Stmt_GotoLabel};
    };
    v_dot_ast__Expr expr = v_dot_parser__Parser_expr(p, 0);
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(&(v_dot_ast__ExprStmt[]){(v_dot_ast__ExprStmt){
                          .expr = expr,
                      }},
                      sizeof(v_dot_ast__ExprStmt)),
        .typ = SumType_v_dot_ast__Stmt_ExprStmt};
  };
}
v_dot_ast__AssignExpr v_dot_parser__Parser_assign_expr(v_dot_parser__Parser *p,
                                                       v_dot_ast__Expr left) {
  v_dot_token__Kind op = p->tok.kind;
  v_dot_parser__Parser_next(p);
  v_dot_ast__Expr val = v_dot_parser__Parser_expr(p, 0);
  v_dot_ast__AssignExpr node = (v_dot_ast__AssignExpr){
      .left = left,
      .val = val,
      .op = op,
      .pos = v_dot_token__Token_position(&/* ? */ p->tok),
  };
  return node;
}
v_dot_ast__Attr v_dot_parser__Parser_attribute(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lsbr);
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_if) {
    v_dot_parser__Parser_next(p);
  };
  string name = v_dot_parser__Parser_check_name(p);
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rsbr);
  p->attr = name;
  return (v_dot_ast__Attr){.name = name};
}
void v_dot_parser__Parser_error(v_dot_parser__Parser *p, string s) {
  print_backtrace();
  string path = p->file_name;
  string workdir = string_add(os__getwd(), os__path_separator);
  if (string_starts_with(path, workdir)) {
    path = string_replace(path, workdir, tos3(""));
  };
  string final_msg_line = _STR("%.*s:%d: error: %.*s", path.len, path.str,
                               p->tok.line_nr, s.len, s.str);
  if (v_dot_parser__colored_output) {
    eprintln(term__bold(term__red(final_msg_line)));
  } else {
    eprintln(final_msg_line);
  };
  v_exit(1);
}
void v_dot_parser__Parser_error_at_line(v_dot_parser__Parser *p, string s,
                                        int line_nr) {
  string final_msg_line = _STR("%.*s:%d: error: %.*s", p->file_name.len,
                               p->file_name.str, line_nr, s.len, s.str);
  if (v_dot_parser__colored_output) {
    eprintln(term__bold(term__red(final_msg_line)));
  } else {
    eprintln(final_msg_line);
  };
  v_exit(1);
}
void v_dot_parser__Parser_warn(v_dot_parser__Parser *p, string s) {
  string final_msg_line = _STR("%.*s:%d: warning: %.*s", p->file_name.len,
                               p->file_name.str, p->tok.line_nr, s.len, s.str);
  if (v_dot_parser__colored_output) {
    eprintln(term__bold(term__blue(final_msg_line)));
  } else {
    eprintln(final_msg_line);
  };
}
v_dot_ast__Ident v_dot_parser__Parser_parse_ident(v_dot_parser__Parser *p,
                                                  bool is_c) {
  v_dot_token__Position pos = v_dot_token__Token_position(&/* ? */ p->tok);
  string name = v_dot_parser__Parser_check_name(p);
  if (string_eq(name, tos3("_"))) {
    return (v_dot_ast__Ident){
        .name = tos3("_"),
        .kind = v_dot_ast__v_dot_ast__IdentKind_blank_ident,
        .pos = pos,
        .value = tos3(""),
        .is_c = 0,
    };
  };
  if (p->expr_mod.len > 0) {
    name =
        _STR("%.*s.%.*s", p->expr_mod.len, p->expr_mod.str, name.len, name.str);
  };
  v_dot_ast__Ident ident = (v_dot_ast__Ident){
      .kind = v_dot_ast__v_dot_ast__IdentKind_unresolved,
      .name = name,
      .is_c = is_c,
      .pos = pos,
      .value = tos3(""),
  };
  if (p->expr_mod.len == 0) {
    Option_v_dot_ast__Var tmp16 =
        v_dot_ast__Scope_find_var(&/* ? */ *p->scope, name);

    if (tmp16.ok) {
      v_dot_ast__Var var = *(v_dot_ast__Var *)tmp16.data;
      ident.kind = v_dot_ast__v_dot_ast__IdentKind_variable;
      ident.info = /*SUM TYPE CAST2*/ (v_dot_ast__IdentInfo){
          .obj = memdup(&(v_dot_ast__IdentVar[]){(v_dot_ast__IdentVar){
                            .is_mut = 0, .is_static = 0, .is_optional = 0}},
                        sizeof(v_dot_ast__IdentVar)),
          .typ = SumType_v_dot_ast__IdentInfo_IdentVar};
    };
  };
  return ident;
}
v_dot_ast__StructInit
v_dot_parser__Parser_struct_init(v_dot_parser__Parser *p) {
  v_dot_table__Type typ = v_dot_parser__Parser_parse_type(p);
  p->expr_mod = tos3("");
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lcbr);
  array_string field_names = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_v_dot_ast__Expr exprs = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Expr),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Expr, 0){TCCSKIP(0)});
  int i = 0;
  bool is_short_syntax =
      !(p->peek_tok.kind == v_dot_token__v_dot_token__Kind_colon ||
        p->tok.kind == v_dot_token__v_dot_token__Kind_rcbr);
  while (p->tok.kind != v_dot_token__v_dot_token__Kind_rcbr) {

    string field_name = tos3("");
    if (is_short_syntax) {
      v_dot_ast__Expr expr = v_dot_parser__Parser_expr(p, 0);
      _PUSH(&exprs,
            (/*typ = array_v_dot_ast__Expr   tmp_typ=v_dot_ast__Expr*/ expr),
            tmp17, v_dot_ast__Expr);
    } else {
      field_name = v_dot_parser__Parser_check_name(p);
      _PUSH(&field_names, (/*typ = array_string   tmp_typ=string*/ field_name),
            tmp18, string);
    };
    if (!is_short_syntax) {
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_colon);
      v_dot_ast__Expr expr = v_dot_parser__Parser_expr(p, 0);
      _PUSH(&exprs,
            (/*typ = array_v_dot_ast__Expr   tmp_typ=v_dot_ast__Expr*/ expr),
            tmp19, v_dot_ast__Expr);
    };
    i++;
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_comma) {
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_comma);
    };
  };
  v_dot_ast__StructInit node = (v_dot_ast__StructInit){
      .typ = typ,
      .exprs = exprs,
      .fields = field_names,
      .pos = v_dot_token__Token_position(&/* ? */ p->tok)};
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rcbr);
  return node;
}
v_dot_ast__Expr v_dot_parser__Parser_name_expr(v_dot_parser__Parser *p) {
  v_dot_ast__Expr node = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
  bool is_c = string_eq(p->tok.lit, tos3("C"));
  string mod = tos3("");
  p->expr_mod = tos3("");
  if (string_eq(p->tok.lit, tos3("map")) &&
      p->peek_tok.kind == v_dot_token__v_dot_token__Kind_lsbr) {
    v_dot_table__Type map_type = v_dot_parser__Parser_parse_map_type(p);
    return /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(&(v_dot_ast__MapInit[]){(v_dot_ast__MapInit){
                          .typ = map_type,
                          .keys = new_array(0, 1, sizeof(v_dot_ast__Expr)),
                          .vals = new_array(0, 1, sizeof(v_dot_ast__Expr)),
                      }},
                      sizeof(v_dot_ast__MapInit)),
        .typ = SumType_v_dot_ast__Expr_MapInit};
  };
  bool known_var = v_dot_ast__Scope_known_var(&/* ? */ *p->scope, p->tok.lit);
  if (p->peek_tok.kind == v_dot_token__v_dot_token__Kind_dot && !known_var &&
      (is_c || v_dot_parser__Parser_known_import(&/* ? */ *p, p->tok.lit) ||
       string_eq(string_all_after(p->mod, tos3(".")), p->tok.lit))) {
    if (is_c) {
      mod = tos3("C");
    } else {
      string tmp20 = tos3("");
      bool tmp21 = map_get(/*parser.v : 587*/ p->imports, p->tok.lit, &tmp20);

      if (!tmp21)
        tmp20 = tos((byte *)"", 0);

      mod = tmp20;
    };
    v_dot_parser__Parser_next(p);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_dot);
    p->expr_mod = mod;
  };
  if (p->peek_tok.kind == v_dot_token__v_dot_token__Kind_lpar) {
    string name = p->tok.lit;
    if (mod.len > 0) {
      name = _STR("%.*s.%.*s", mod.len, mod.str, name.len, name.str);
    };
    string name_w_mod = v_dot_parser__Parser_prepend_mod(&/* ? */ *p, name);
    if (((_IN_MAP((name), p->table->type_idxs)) ||
         (_IN_MAP((name_w_mod), p->table->type_idxs))) &&
        !((string_eq(name, tos3("C.stat")) ||
           string_eq(name, tos3("C.sigaction"))))) {
      v_dot_table__Type to_typ = v_dot_parser__Parser_parse_type(p);
      if (p->is_amp) {
        to_typ = v_dot_table__type_to_ptr(to_typ);
      };
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lpar);
      v_dot_ast__Expr expr = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
      v_dot_ast__Expr arg = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
      bool has_arg = 0;
      expr = v_dot_parser__Parser_expr(p, 0);
      if (p->tok.kind == v_dot_token__v_dot_token__Kind_comma &&
          v_dot_table__type_idx(to_typ) == v_dot_table__string_type_idx) {
        v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_comma);
        arg = v_dot_parser__Parser_expr(p, 0);
        has_arg = 1;
      };
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rpar);
      node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
          .obj = memdup(&(v_dot_ast__CastExpr[]){(v_dot_ast__CastExpr){
                            .typ = to_typ,
                            .expr = expr,
                            .arg = arg,
                            .has_arg = has_arg,
                        }},
                        sizeof(v_dot_ast__CastExpr)),
          .typ = SumType_v_dot_ast__Expr_CastExpr};
      p->expr_mod = tos3("");
      return node;
    } else {
      v_dot_ast__CallExpr x = v_dot_parser__Parser_call_expr(p, is_c, mod);
      node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
          .obj =
              memdup(&(v_dot_ast__CallExpr[]){x}, sizeof(v_dot_ast__CallExpr)),
          .typ = SumType_v_dot_ast__Expr_CallExpr};
    };
  } else if (p->peek_tok.kind == v_dot_token__v_dot_token__Kind_lcbr &&
             (byte_is_capital(string_at(p->tok.lit, 0)) || is_c ||
              (_IN(string, (p->tok.lit), v_dot_table__builtin_type_names))) &&
             (p->tok.lit.len == 1 ||
              !byte_is_capital(string_at(p->tok.lit, p->tok.lit.len - 1)))) {
    return /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(
            &(v_dot_ast__StructInit[]){v_dot_parser__Parser_struct_init(p)},
            sizeof(v_dot_ast__StructInit)),
        .typ = SumType_v_dot_ast__Expr_StructInit};
  } else if (p->peek_tok.kind == v_dot_token__v_dot_token__Kind_dot &&
             (byte_is_capital(string_at(p->tok.lit, 0)) && !known_var)) {
    string enum_name = v_dot_parser__Parser_check_name(p);
    if (string_ne(mod, tos3(""))) {
      enum_name = string_add(string_add(mod, tos3(".")), enum_name);
    } else {
      enum_name = v_dot_parser__Parser_prepend_mod(&/* ? */ *p, enum_name);
    };
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_dot);
    string val = v_dot_parser__Parser_check_name(p);
    p->expr_mod = tos3("");
    return /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(&(v_dot_ast__EnumVal[]){(v_dot_ast__EnumVal){
                          .enum_name = enum_name,
                          .val = val,
                          .pos = v_dot_token__Token_position(&/* ? */ p->tok),
                          .mod = mod,
                      }},
                      sizeof(v_dot_ast__EnumVal)),
        .typ = SumType_v_dot_ast__Expr_EnumVal};
  } else {
    v_dot_ast__Ident ident = (v_dot_ast__Ident){
        .value = tos3(""),
        .is_c = 0,
        .name = tos3(""),
    };
    ident = v_dot_parser__Parser_parse_ident(p, is_c);
    node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(&(v_dot_ast__Ident[]){ident}, sizeof(v_dot_ast__Ident)),
        .typ = SumType_v_dot_ast__Expr_Ident};
  };
  p->expr_mod = tos3("");
  return node;
}
v_dot_ast__Expr v_dot_parser__Parser_expr(v_dot_parser__Parser *p,
                                          int precedence) {
  v_dot_table__Type typ = v_dot_table__void_type;
  v_dot_ast__Expr node = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
  v_dot_token__Kind tmp28 = p->tok.kind;

  if (tmp28 == v_dot_token__v_dot_token__Kind_name) {
    node = v_dot_parser__Parser_name_expr(p);
  } else if (tmp28 == v_dot_token__v_dot_token__Kind_string) {
    node = v_dot_parser__Parser_string_expr(p);
  } else if (tmp28 == v_dot_token__v_dot_token__Kind_dot) {
    node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(&(v_dot_ast__EnumVal[]){v_dot_parser__Parser_enum_val(p)},
                      sizeof(v_dot_ast__EnumVal)),
        .typ = SumType_v_dot_ast__Expr_EnumVal};
  } else if (tmp28 == v_dot_token__v_dot_token__Kind_chartoken) {
    node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(&(v_dot_ast__CharLiteral[]){(v_dot_ast__CharLiteral){
                          .val = p->tok.lit}},
                      sizeof(v_dot_ast__CharLiteral)),
        .typ = SumType_v_dot_ast__Expr_CharLiteral};
    v_dot_parser__Parser_next(p);
  } else if ((tmp28 == v_dot_token__v_dot_token__Kind_minus) ||
             (tmp28 == v_dot_token__v_dot_token__Kind_amp) ||
             (tmp28 == v_dot_token__v_dot_token__Kind_mul) ||
             (tmp28 == v_dot_token__v_dot_token__Kind_not) ||
             (tmp28 == v_dot_token__v_dot_token__Kind_bit_not)) {
    node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(
            &(v_dot_ast__PrefixExpr[]){v_dot_parser__Parser_prefix_expr(p)},
            sizeof(v_dot_ast__PrefixExpr)),
        .typ = SumType_v_dot_ast__Expr_PrefixExpr};
  } else if ((tmp28 == v_dot_token__v_dot_token__Kind_key_true) ||
             (tmp28 == v_dot_token__v_dot_token__Kind_key_false)) {
    node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(
            &(v_dot_ast__BoolLiteral[]){(v_dot_ast__BoolLiteral){
                .val = p->tok.kind == v_dot_token__v_dot_token__Kind_key_true}},
            sizeof(v_dot_ast__BoolLiteral)),
        .typ = SumType_v_dot_ast__Expr_BoolLiteral};
    v_dot_parser__Parser_next(p);
  } else if (tmp28 == v_dot_token__v_dot_token__Kind_key_match) {
    node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(
            &(v_dot_ast__MatchExpr[]){v_dot_parser__Parser_match_expr(p)},
            sizeof(v_dot_ast__MatchExpr)),
        .typ = SumType_v_dot_ast__Expr_MatchExpr};
  } else if (tmp28 == v_dot_token__v_dot_token__Kind_number) {
    node = v_dot_parser__Parser_parse_number_literal(p);
  } else if (tmp28 == v_dot_token__v_dot_token__Kind_lpar) {
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lpar);
    node = v_dot_parser__Parser_expr(p, 0);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rpar);
    node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj =
            memdup(&(v_dot_ast__ParExpr[]){(v_dot_ast__ParExpr){.expr = node}},
                   sizeof(v_dot_ast__ParExpr)),
        .typ = SumType_v_dot_ast__Expr_ParExpr};
  } else if (tmp28 == v_dot_token__v_dot_token__Kind_key_if) {
    node = v_dot_parser__Parser_if_expr(p);
  } else if (tmp28 == v_dot_token__v_dot_token__Kind_lsbr) {
    node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(
            &(v_dot_ast__ArrayInit[]){v_dot_parser__Parser_array_init(p)},
            sizeof(v_dot_ast__ArrayInit)),
        .typ = SumType_v_dot_ast__Expr_ArrayInit};
  } else if (tmp28 == v_dot_token__v_dot_token__Kind_key_none) {
    v_dot_parser__Parser_next(p);
    node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(&(v_dot_ast__None[]){(v_dot_ast__None){.foo = 0}},
                      sizeof(v_dot_ast__None)),
        .typ = SumType_v_dot_ast__Expr_None};
  } else if (tmp28 == v_dot_token__v_dot_token__Kind_key_sizeof) {
    v_dot_parser__Parser_next(p);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lpar);
    if (string_eq(p->tok.lit, tos3("C"))) {
      v_dot_parser__Parser_next(p);
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_dot);
    };
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_amp) {
      v_dot_parser__Parser_next(p);
    };
    string type_name = v_dot_parser__Parser_check_name(p);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rpar);
    node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(
            &(v_dot_ast__SizeOf[]){(v_dot_ast__SizeOf){.type_name = type_name}},
            sizeof(v_dot_ast__SizeOf)),
        .typ = SumType_v_dot_ast__Expr_SizeOf};
  } else if (tmp28 == v_dot_token__v_dot_token__Kind_lcbr) {
    v_dot_parser__Parser_next(p);
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_string) {
      array_v_dot_ast__Expr keys = new_array_from_c_array(
          0, 0, sizeof(v_dot_ast__Expr),
          EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Expr, 0){TCCSKIP(0)});
      array_v_dot_ast__Expr vals = new_array_from_c_array(
          0, 0, sizeof(v_dot_ast__Expr),
          EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Expr, 0){TCCSKIP(0)});
      while (p->tok.kind != v_dot_token__v_dot_token__Kind_rcbr &&
             p->tok.kind != v_dot_token__v_dot_token__Kind_eof) {

        v_dot_ast__Expr key = v_dot_parser__Parser_expr(p, 0);
        _PUSH(&keys,
              (/*typ = array_v_dot_ast__Expr   tmp_typ=v_dot_ast__Expr*/ key),
              tmp29, v_dot_ast__Expr);
        v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_colon);
        v_dot_ast__Expr val = v_dot_parser__Parser_expr(p, 0);
        _PUSH(&vals,
              (/*typ = array_v_dot_ast__Expr   tmp_typ=v_dot_ast__Expr*/ val),
              tmp30, v_dot_ast__Expr);
        if (p->tok.kind == v_dot_token__v_dot_token__Kind_comma) {
          v_dot_parser__Parser_next(p);
        };
      };
      node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
          .obj = memdup(&(v_dot_ast__MapInit[]){(v_dot_ast__MapInit){
                            .keys = keys,
                            .vals = vals,
                            .pos = v_dot_token__Token_position(&/* ? */ p->tok),
                        }},
                        sizeof(v_dot_ast__MapInit)),
          .typ = SumType_v_dot_ast__Expr_MapInit};
    } else {
      string name = v_dot_parser__Parser_check_name(p);
      array_string fields = new_array_from_c_array(
          0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
      array_v_dot_ast__Expr vals = new_array_from_c_array(
          0, 0, sizeof(v_dot_ast__Expr),
          EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Expr, 0){TCCSKIP(0)});
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_pipe);
      while (1) {
        _PUSH(&fields,
              (/*typ = array_string   tmp_typ=string*/
               v_dot_parser__Parser_check_name(p)),
              tmp31, string);
        v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_colon);
        v_dot_ast__Expr expr = v_dot_parser__Parser_expr(p, 0);
        _PUSH(&vals,
              (/*typ = array_v_dot_ast__Expr   tmp_typ=v_dot_ast__Expr*/ expr),
              tmp32, v_dot_ast__Expr);
        if (p->tok.kind == v_dot_token__v_dot_token__Kind_comma) {
          v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_comma);
        };
        if (p->tok.kind == v_dot_token__v_dot_token__Kind_rcbr) {
          break;
        };
      };
      node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
          .obj =
              memdup(&(v_dot_ast__Assoc[]){(v_dot_ast__Assoc){
                         .var_name = name,
                         .fields = fields,
                         .exprs = vals,
                         .pos = v_dot_token__Token_position(&/* ? */ p->tok)}},
                     sizeof(v_dot_ast__Assoc)),
          .typ = SumType_v_dot_ast__Expr_Assoc};
    };
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rcbr);
  } else // default:
  {
    v_dot_parser__Parser_error(&/* ? */ *p,
                               _STR("parser: expr(): bad token `%.*s`",
                                    v_dot_token__Token_str(p->tok).len,
                                    v_dot_token__Token_str(p->tok).str));
  };
  while (precedence < v_dot_token__Token_precedence(p->tok)) {

    if (v_dot_token__Kind_is_assign(p->tok.kind)) {
      node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
          .obj = memdup(
              &(v_dot_ast__AssignExpr[]){
                  v_dot_parser__Parser_assign_expr(p, node)},
              sizeof(v_dot_ast__AssignExpr)),
          .typ = SumType_v_dot_ast__Expr_AssignExpr};
    } else if (p->tok.kind == v_dot_token__v_dot_token__Kind_dot) {
      node = v_dot_parser__Parser_dot_expr(p, node);
    } else if (p->tok.kind == v_dot_token__v_dot_token__Kind_lsbr) {
      node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
          .obj =
              memdup(&(v_dot_ast__IndexExpr[]){v_dot_parser__Parser_index_expr(
                         p, node)},
                     sizeof(v_dot_ast__IndexExpr)),
          .typ = SumType_v_dot_ast__Expr_IndexExpr};
    } else if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_as) {
      v_dot_parser__Parser_next(p);
      typ = v_dot_parser__Parser_parse_type(p);
      node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
          .obj = memdup(&(v_dot_ast__AsCast[]){(v_dot_ast__AsCast){.expr = node,
                                                                   .typ = typ}},
                        sizeof(v_dot_ast__AsCast)),
          .typ = SumType_v_dot_ast__Expr_AsCast};
    } else if (p->tok.kind == v_dot_token__v_dot_token__Kind_left_shift) {
      v_dot_token__Token tok = p->tok;
      v_dot_parser__Parser_next(p);
      v_dot_ast__Expr right = v_dot_parser__Parser_expr(p, precedence - 1);
      node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
          .obj = memdup(&(v_dot_ast__InfixExpr[]){(v_dot_ast__InfixExpr){
                            .left = node,
                            .right = right,
                            .op = tok.kind,
                            .pos = v_dot_token__Token_position(&/* ? */ tok),
                        }},
                        sizeof(v_dot_ast__InfixExpr)),
          .typ = SumType_v_dot_ast__Expr_InfixExpr};
    } else if (v_dot_token__Kind_is_infix(p->tok.kind)) {
      node = v_dot_parser__Parser_infix_expr(p, node);
    } else if ((p->tok.kind == v_dot_token__v_dot_token__Kind_inc ||
                p->tok.kind == v_dot_token__v_dot_token__Kind_dec)) {
      node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
          .obj =
              memdup(&(v_dot_ast__PostfixExpr[]){(v_dot_ast__PostfixExpr){
                         .op = p->tok.kind,
                         .expr = node,
                         .pos = v_dot_token__Token_position(&/* ? */ p->tok)}},
                     sizeof(v_dot_ast__PostfixExpr)),
          .typ = SumType_v_dot_ast__Expr_PostfixExpr};
      v_dot_parser__Parser_next(p);
      return node;
    } else {
      return node;
    };
  };
  return node;
}
v_dot_ast__PrefixExpr
v_dot_parser__Parser_prefix_expr(v_dot_parser__Parser *p) {
  v_dot_token__Kind op = p->tok.kind;
  if (op == v_dot_token__v_dot_token__Kind_amp) {
    p->is_amp = 1;
  };
  v_dot_parser__Parser_next(p);
  v_dot_ast__Expr right = v_dot_parser__Parser_expr(p, 1);
  p->is_amp = 0;
  return (v_dot_ast__PrefixExpr){.op = op, .right = right};
}
v_dot_ast__IndexExpr v_dot_parser__Parser_index_expr(v_dot_parser__Parser *p,
                                                     v_dot_ast__Expr left) {
  v_dot_parser__Parser_next(p);
  bool has_low = 1;
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_dotdot) {
    has_low = 0;
    v_dot_parser__Parser_next(p);
    v_dot_ast__Expr high = v_dot_parser__Parser_expr(p, 0);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rsbr);
    return (v_dot_ast__IndexExpr){
        .left = left,
        .pos = v_dot_token__Token_position(&/* ? */ p->tok),
        .index = /*SUM TYPE CAST2*/ (
            v_dot_ast__Expr){.obj = memdup(
                                 &(v_dot_ast__RangeExpr[]){
                                     (v_dot_ast__RangeExpr){
                                         .low =
                                             (v_dot_ast__Expr){
                                                 EMPTY_STRUCT_INITIALIZATION},
                                         .high = high,
                                         .has_high = 1,
                                         .has_low = 0}},
                                 sizeof(v_dot_ast__RangeExpr)),
                             .typ = SumType_v_dot_ast__Expr_RangeExpr},
    };
  };
  v_dot_ast__Expr expr = v_dot_parser__Parser_expr(p, 0);
  bool has_high = 0;
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_dotdot) {
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_dotdot);
    v_dot_ast__Expr high = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
    if (p->tok.kind != v_dot_token__v_dot_token__Kind_rsbr) {
      has_high = 1;
      high = v_dot_parser__Parser_expr(p, 0);
    };
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rsbr);
    return (v_dot_ast__IndexExpr){
        .left = left,
        .pos = v_dot_token__Token_position(&/* ? */ p->tok),
        .index = /*SUM TYPE CAST2*/ (
            v_dot_ast__Expr){.obj = memdup(
                                 &(v_dot_ast__RangeExpr[]){(
                                     v_dot_ast__RangeExpr){.low = expr,
                                                           .high = high,
                                                           .has_high = has_high,
                                                           .has_low = has_low}},
                                 sizeof(v_dot_ast__RangeExpr)),
                             .typ = SumType_v_dot_ast__Expr_RangeExpr},
    };
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rsbr);
  return (v_dot_ast__IndexExpr){
      .left = left,
      .index = expr,
      .pos = v_dot_token__Token_position(&/* ? */ p->tok),
  };
}
void v_dot_parser__Parser_filter(v_dot_parser__Parser *p) {
  v_dot_ast__Scope_register_var(p->scope, (v_dot_ast__Var){
                                              .name = tos3("it"),
                                              .is_mut = 0,
                                          });
}
v_dot_ast__Expr v_dot_parser__Parser_dot_expr(v_dot_parser__Parser *p,
                                              v_dot_ast__Expr left) {
  v_dot_parser__Parser_next(p);
  string field_name = v_dot_parser__Parser_check_name(p);
  if (string_eq(field_name, tos3("filter"))) {
    v_dot_parser__Parser_open_scope(p);
    v_dot_parser__Parser_filter(p);
  };
  v_dot_token__Position pos = v_dot_token__Token_position(&/* ? */ p->tok);
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_lpar) {
    v_dot_parser__Parser_next(p);
    array_v_dot_ast__CallArg args = v_dot_parser__Parser_call_args(p);
    array_v_dot_ast__Stmt or_stmts = new_array_from_c_array(
        0, 0, sizeof(v_dot_ast__Stmt),
        EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Stmt, 0){TCCSKIP(0)});
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_orelse) {
      v_dot_parser__Parser_next(p);
      or_stmts = v_dot_parser__Parser_parse_block(p);
    };
    v_dot_ast__MethodCallExpr mcall_expr = (v_dot_ast__MethodCallExpr){
        .expr = left,
        .name = field_name,
        .args = args,
        .pos = pos,
        .or_block = (v_dot_ast__OrExpr){.stmts = or_stmts},
    };
    v_dot_ast__Expr node = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
    node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(&(v_dot_ast__MethodCallExpr[]){mcall_expr},
                      sizeof(v_dot_ast__MethodCallExpr)),
        .typ = SumType_v_dot_ast__Expr_MethodCallExpr};
    if (string_eq(field_name, tos3("filter"))) {
      v_dot_parser__Parser_close_scope(p);
    };
    return node;
  };
  v_dot_ast__SelectorExpr sel_expr = (v_dot_ast__SelectorExpr){
      .expr = left,
      .field = field_name,
      .pos = v_dot_token__Token_position(&/* ? */ p->tok),
  };
  v_dot_ast__Expr node = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
  node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
      .obj = memdup(&(v_dot_ast__SelectorExpr[]){sel_expr},
                    sizeof(v_dot_ast__SelectorExpr)),
      .typ = SumType_v_dot_ast__Expr_SelectorExpr};
  if (string_eq(field_name, tos3("filter"))) {
    v_dot_parser__Parser_close_scope(p);
  };
  return node;
}
v_dot_ast__Expr v_dot_parser__Parser_infix_expr(v_dot_parser__Parser *p,
                                                v_dot_ast__Expr left) {
  v_dot_token__Kind op = p->tok.kind;
  int precedence = v_dot_token__Token_precedence(p->tok);
  v_dot_token__Position pos = v_dot_token__Token_position(&/* ? */ p->tok);
  v_dot_parser__Parser_next(p);
  v_dot_ast__Expr right = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
  right = v_dot_parser__Parser_expr(p, precedence);
  v_dot_ast__Expr expr = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
  expr = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
      .obj = memdup(&(v_dot_ast__InfixExpr[]){(v_dot_ast__InfixExpr){
                        .left = left,
                        .right = right,
                        .op = op,
                        .pos = pos,
                    }},
                    sizeof(v_dot_ast__InfixExpr)),
      .typ = SumType_v_dot_ast__Expr_InfixExpr};
  return expr;
}
v_dot_ast__EnumVal v_dot_parser__Parser_enum_val(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_dot);
  string val = v_dot_parser__Parser_check_name(p);
  return (v_dot_ast__EnumVal){
      .val = val,
      .pos = v_dot_token__Token_position(&/* ? */ p->tok),
      .enum_name = tos3(""),
      .mod = tos3(""),
  };
}
v_dot_ast__Stmt v_dot_parser__Parser_for_statement(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_for);
  v_dot_parser__Parser_open_scope(p);
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_lcbr) {
    v_dot_token__Position pos = v_dot_token__Token_position(&/* ? */ p->tok);
    array_v_dot_ast__Stmt stmts = v_dot_parser__Parser_parse_block(p);
    v_dot_parser__Parser_close_scope(p);
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(&(v_dot_ast__ForStmt[]){(v_dot_ast__ForStmt){
                          .stmts = stmts,
                          .pos = pos,
                          .is_inf = 1,
                      }},
                      sizeof(v_dot_ast__ForStmt)),
        .typ = SumType_v_dot_ast__Stmt_ForStmt};
  } else if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_mut) {
    v_dot_parser__Parser_error(&/* ? */ *p,
                               tos3("`mut` is not required in for loops"));
  } else if ((p->peek_tok.kind == v_dot_token__v_dot_token__Kind_decl_assign ||
              p->peek_tok.kind == v_dot_token__v_dot_token__Kind_assign ||
              p->peek_tok.kind == v_dot_token__v_dot_token__Kind_semicolon) ||
             p->tok.kind == v_dot_token__v_dot_token__Kind_semicolon) {
    v_dot_ast__Stmt init = (v_dot_ast__Stmt){EMPTY_STRUCT_INITIALIZATION};
    v_dot_ast__Expr cond = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
    v_dot_ast__Expr inc = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
    bool has_init = 0;
    if ((p->peek_tok.kind == v_dot_token__v_dot_token__Kind_assign ||
         p->peek_tok.kind == v_dot_token__v_dot_token__Kind_decl_assign)) {
      init = v_dot_parser__Parser_assign_stmt(p);
      has_init = 1;
    } else if (p->tok.kind != v_dot_token__v_dot_token__Kind_semicolon) {
    };
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_semicolon);
    if (p->tok.kind != v_dot_token__v_dot_token__Kind_semicolon) {
      v_dot_table__Type typ = v_dot_table__void_type;
      cond = v_dot_parser__Parser_expr(p, 0);
    };
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_semicolon);
    if (p->tok.kind != v_dot_token__v_dot_token__Kind_lcbr) {
      inc = v_dot_parser__Parser_expr(p, 0);
    };
    array_v_dot_ast__Stmt stmts = v_dot_parser__Parser_parse_block(p);
    v_dot_parser__Parser_close_scope(p);
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(
            &(v_dot_ast__ForCStmt[]){(v_dot_ast__ForCStmt){.stmts = stmts,
                                                           .has_init = has_init,
                                                           .init = init,
                                                           .cond = cond,
                                                           .inc = inc}},
            sizeof(v_dot_ast__ForCStmt)),
        .typ = SumType_v_dot_ast__Stmt_ForCStmt};
  } else if ((p->peek_tok.kind == v_dot_token__v_dot_token__Kind_key_in ||
              p->peek_tok.kind == v_dot_token__v_dot_token__Kind_comma)) {
    string var_name = v_dot_parser__Parser_check_name(p);
    string val_name = tos3("");
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_comma) {
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_comma);
      val_name = v_dot_parser__Parser_check_name(p);
      v_dot_ast__Scope_register_var(p->scope, (v_dot_ast__Var){
                                                  .name = val_name,
                                                  .typ = v_dot_table__int_type,
                                                  .is_mut = 0,
                                              });
    };
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_in);
    v_dot_ast__Expr cond = v_dot_parser__Parser_expr(p, 0);
    v_dot_ast__Expr high_expr = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
    bool is_range = 0;
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_dotdot) {
      is_range = 1;
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_dotdot);
      high_expr = v_dot_parser__Parser_expr(p, 0);
    };
    v_dot_ast__Scope_register_var(p->scope, (v_dot_ast__Var){
                                                .name = var_name,
                                                .is_mut = 0,
                                            });
    array_v_dot_ast__Stmt stmts = v_dot_parser__Parser_parse_block(p);
    v_dot_parser__Parser_close_scope(p);
    return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
        .obj = memdup(&(v_dot_ast__ForInStmt[]){(v_dot_ast__ForInStmt){
                          .stmts = stmts,
                          .pos = v_dot_token__Token_position(&/* ? */ p->tok),
                          .cond = cond,
                          .key_var = var_name,
                          .val_var = val_name,
                          .high = high_expr,
                          .is_range = is_range}},
                      sizeof(v_dot_ast__ForInStmt)),
        .typ = SumType_v_dot_ast__Stmt_ForInStmt};
  };
  v_dot_ast__Expr cond = v_dot_parser__Parser_expr(p, 0);
  array_v_dot_ast__Stmt stmts = v_dot_parser__Parser_parse_block(p);
  v_dot_parser__Parser_close_scope(p);
  return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
      .obj = memdup(&(v_dot_ast__ForStmt[]){(v_dot_ast__ForStmt){
                        .cond = cond,
                        .stmts = stmts,
                        .pos = v_dot_token__Token_position(&/* ? */ p->tok),
                        .is_inf = 0}},
                    sizeof(v_dot_ast__ForStmt)),
      .typ = SumType_v_dot_ast__Stmt_ForStmt};
}
v_dot_ast__Expr v_dot_parser__Parser_if_expr(v_dot_parser__Parser *p) {
  p->inside_if = 1;
  v_dot_ast__Expr node = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_if);
  v_dot_token__Position pos = v_dot_token__Token_position(&/* ? */ p->tok);
  v_dot_ast__Expr cond = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
  bool is_or = 0;
  if (p->peek_tok.kind == v_dot_token__v_dot_token__Kind_decl_assign) {
    is_or = 1;
    v_dot_parser__Parser_open_scope(p);
    string var_name = v_dot_parser__Parser_check_name(p);
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_decl_assign);
    v_dot_ast__Expr expr = v_dot_parser__Parser_expr(p, 0);
    v_dot_ast__Scope_register_var(p->scope, (v_dot_ast__Var){
                                                .name = var_name,
                                                .expr = expr,
                                                .is_mut = 0,
                                            });
    cond = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(&(v_dot_ast__IfGuardExpr[]){(v_dot_ast__IfGuardExpr){
                          .var_name = var_name, .expr = expr}},
                      sizeof(v_dot_ast__IfGuardExpr)),
        .typ = SumType_v_dot_ast__Expr_IfGuardExpr};
  } else {
    cond = v_dot_parser__Parser_expr(p, 0);
  };
  p->inside_if = 0;
  bool has_else = 0;
  array_v_dot_ast__Stmt stmts = v_dot_parser__Parser_parse_block(p);
  array_v_dot_ast__Stmt else_stmts = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Stmt),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Stmt, 0){TCCSKIP(0)});
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_else) {
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_else);
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_if) {
      has_else = 1;
    } else {
      else_stmts = v_dot_parser__Parser_parse_block(p);
    };
  };
  if (is_or) {
    v_dot_parser__Parser_close_scope(p);
  };
  node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
      .obj = memdup(&(v_dot_ast__IfExpr[]){(v_dot_ast__IfExpr){
                        .cond = cond,
                        .stmts = stmts,
                        .else_stmts = else_stmts,
                        .pos = pos,
                        .has_else = has_else,
                    }},
                    sizeof(v_dot_ast__IfExpr)),
      .typ = SumType_v_dot_ast__Expr_IfExpr};
  return node;
}
v_dot_ast__Expr v_dot_parser__Parser_string_expr(v_dot_parser__Parser *p) {
  v_dot_ast__Expr node = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
  node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
      .obj = memdup(&(v_dot_ast__StringLiteral[]){(v_dot_ast__StringLiteral){
                        .val = p->tok.lit}},
                    sizeof(v_dot_ast__StringLiteral)),
      .typ = SumType_v_dot_ast__Expr_StringLiteral};
  if (p->peek_tok.kind != v_dot_token__v_dot_token__Kind_str_dollar) {
    v_dot_parser__Parser_next(p);
    return node;
  };
  while (p->tok.kind == v_dot_token__v_dot_token__Kind_string) {

    v_dot_parser__Parser_next(p);
    if (p->tok.kind != v_dot_token__v_dot_token__Kind_str_dollar) {
      continue;
    };
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_str_dollar);
    v_dot_parser__Parser_expr(p, 0);
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_colon) {
      v_dot_parser__Parser_next(p);
    };
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_minus) {
      v_dot_parser__Parser_next(p);
    };
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_number) {
      v_dot_parser__Parser_next(p);
      if (p->tok.lit.len == 1) {
        v_dot_parser__Parser_next(p);
      };
    };
  };
  return node;
}
v_dot_ast__ArrayInit v_dot_parser__Parser_array_init(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lsbr);
  v_dot_table__Type array_type = v_dot_table__void_type;
  v_dot_table__Type elem_type = v_dot_table__void_type;
  array_v_dot_ast__Expr exprs = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Expr),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Expr, 0){TCCSKIP(0)});
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_rsbr) {
    int line_nr = p->tok.line_nr;
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rsbr);
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_name &&
        p->tok.line_nr == line_nr) {
      elem_type = v_dot_parser__Parser_parse_type(p);
      int idx =
          v_dot_table__Table_find_or_register_array(p->table, elem_type, 1);
      array_type = v_dot_table__new_type(idx);
    };
  } else {
    for (int i = 0; p->tok.kind != v_dot_token__v_dot_token__Kind_rsbr; i++) {

      v_dot_ast__Expr expr = v_dot_parser__Parser_expr(p, 0);
      _PUSH(&exprs,
            (/*typ = array_v_dot_ast__Expr   tmp_typ=v_dot_ast__Expr*/ expr),
            tmp33, v_dot_ast__Expr);
      if (p->tok.kind == v_dot_token__v_dot_token__Kind_comma) {
        v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_comma);
      };
    };
    int line_nr = p->tok.line_nr;
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rsbr);
    if (exprs.len == 1 && p->tok.kind == v_dot_token__v_dot_token__Kind_name &&
        p->tok.line_nr == line_nr) {
      elem_type = v_dot_parser__Parser_parse_type(p);
    };
  };
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_not) {
    v_dot_parser__Parser_next(p);
  };
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_not) {
    v_dot_parser__Parser_next(p);
  };
  return (v_dot_ast__ArrayInit){
      .elem_type = elem_type,
      .typ = array_type,
      .exprs = exprs,
      .pos = v_dot_token__Token_position(&/* ? */ p->tok)};
}
v_dot_ast__Expr
v_dot_parser__Parser_parse_number_literal(v_dot_parser__Parser *p) {
  string lit = p->tok.lit;
  v_dot_ast__Expr node = (v_dot_ast__Expr){EMPTY_STRUCT_INITIALIZATION};
  if (string_contains(lit, tos3("."))) {
    node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(
            &(v_dot_ast__FloatLiteral[]){(v_dot_ast__FloatLiteral){.val = lit}},
            sizeof(v_dot_ast__FloatLiteral)),
        .typ = SumType_v_dot_ast__Expr_FloatLiteral};
  } else {
    node = /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
        .obj = memdup(&(v_dot_ast__IntegerLiteral[]){(
                          v_dot_ast__IntegerLiteral){.val = v_string_int(lit)}},
                      sizeof(v_dot_ast__IntegerLiteral)),
        .typ = SumType_v_dot_ast__Expr_IntegerLiteral};
  };
  v_dot_parser__Parser_next(p);
  return node;
}
v_dot_ast__Module v_dot_parser__Parser_module_decl(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_module);
  string mod = v_dot_parser__Parser_check_name(p);
  string full_mod =
      v_dot_table__Table_qualify_module(&/* ? */ *p->table, mod, p->file_name);
  p->mod = full_mod;
  return (v_dot_ast__Module){
      .name = full_mod,
      .path = tos3(""),
  };
}
v_dot_ast__Import v_dot_parser__Parser_parse_import(v_dot_parser__Parser *p) {
  v_dot_token__Position pos = v_dot_token__Token_position(&/* ? */ p->tok);
  string mod_name = v_dot_parser__Parser_check_name(p);
  string mod_alias = mod_name;
  while (p->tok.kind == v_dot_token__v_dot_token__Kind_dot) {

    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_dot);
    string submod_name = v_dot_parser__Parser_check_name(p);
    mod_name = string_add(mod_name, string_add(tos3("."), submod_name));
    mod_alias = submod_name;
  };
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_as) {
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_as);
    mod_alias = v_dot_parser__Parser_check_name(p);
  };
  map_set(&p->imports, mod_alias, &(string[]){mod_name});
  _PUSH(&p->table->imports, (/*typ = array_string   tmp_typ=string*/ mod_name),
        tmp34, string);
  return (v_dot_ast__Import){.mod = mod_name, .alias = mod_alias, .pos = pos};
}
array_v_dot_ast__Import
v_dot_parser__Parser_import_stmt(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_import);
  array_v_dot_ast__Import imports = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Import),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Import, 0){TCCSKIP(0)});
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_lpar) {
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lpar);
    while (p->tok.kind != v_dot_token__v_dot_token__Kind_rpar) {

      _PUSH(&imports,
            (/*typ = array_v_dot_ast__Import   tmp_typ=v_dot_ast__Import*/
             v_dot_parser__Parser_parse_import(p)),
            tmp35, v_dot_ast__Import);
    };
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rpar);
  } else {
    _PUSH(&imports,
          (/*typ = array_v_dot_ast__Import   tmp_typ=v_dot_ast__Import*/
           v_dot_parser__Parser_parse_import(p)),
          tmp36, v_dot_ast__Import);
  };
  return imports;
}
v_dot_ast__ConstDecl v_dot_parser__Parser_const_decl(v_dot_parser__Parser *p) {
  bool is_pub = p->tok.kind == v_dot_token__v_dot_token__Kind_key_pub;
  if (is_pub) {
    v_dot_parser__Parser_next(p);
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_const);
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lpar);
  array_v_dot_ast__Field fields = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Field),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Field, 0){TCCSKIP(0)});
  array_v_dot_ast__Expr exprs = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Expr),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Expr, 0){TCCSKIP(0)});
  while (p->tok.kind != v_dot_token__v_dot_token__Kind_rpar) {

    string name = v_dot_parser__Parser_prepend_mod(
        &/* ? */ *p, v_dot_parser__Parser_check_name(p));
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_assign);
    v_dot_ast__Expr expr = v_dot_parser__Parser_expr(p, 0);
    _PUSH(&fields,
          (/*typ = array_v_dot_ast__Field   tmp_typ=v_dot_ast__Field*/ (
              v_dot_ast__Field){
              .name = name,
          }),
          tmp37, v_dot_ast__Field);
    _PUSH(&exprs,
          (/*typ = array_v_dot_ast__Expr   tmp_typ=v_dot_ast__Expr*/ expr),
          tmp38, v_dot_ast__Expr);
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rpar);
  return (v_dot_ast__ConstDecl){
      .fields = fields, .exprs = exprs, .is_pub = is_pub};
}
v_dot_ast__StructDecl
v_dot_parser__Parser_struct_decl(v_dot_parser__Parser *p) {
  bool is_pub = p->tok.kind == v_dot_token__v_dot_token__Kind_key_pub;
  if (is_pub) {
    v_dot_parser__Parser_next(p);
  };
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_struct) {
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_struct);
  } else {
    v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_union);
  };
  bool is_c = string_eq(p->tok.lit, tos3("C")) &&
              p->peek_tok.kind == v_dot_token__v_dot_token__Kind_dot;
  if (is_c) {
    v_dot_parser__Parser_next(p);
    v_dot_parser__Parser_next(p);
  };
  string name = v_dot_parser__Parser_check_name(p);
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lcbr);
  array_v_dot_ast__Field ast_fields = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Field),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Field, 0){TCCSKIP(0)});
  array_v_dot_table__Field fields = new_array_from_c_array(
      0, 0, sizeof(v_dot_table__Field),
      EMPTY_ARRAY_OF_ELEMS(v_dot_table__Field, 0){TCCSKIP(0)});
  int mut_pos = -1;
  int pub_pos = -1;
  int pub_mut_pos = -1;
  while (p->tok.kind != v_dot_token__v_dot_token__Kind_rcbr) {

    if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_pub) {
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_pub);
      if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_mut) {
        v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_mut);
        pub_mut_pos = fields.len;
      } else {
        pub_pos = fields.len;
      };
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_colon);
    } else if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_mut) {
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_mut);
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_colon);
      mut_pos = fields.len;
    };
    string field_name = v_dot_parser__Parser_check_name(p);
    v_dot_table__Type typ = v_dot_parser__Parser_parse_type(p);
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_assign) {
      v_dot_parser__Parser_next(p);
      v_dot_parser__Parser_expr(p, 0);
    };
    _PUSH(&ast_fields,
          (/*typ = array_v_dot_ast__Field   tmp_typ=v_dot_ast__Field*/ (
              v_dot_ast__Field){.name = field_name, .typ = typ}),
          tmp39, v_dot_ast__Field);
    _PUSH(&fields,
          (/*typ = array_v_dot_table__Field   tmp_typ=v_dot_table__Field*/ (
              v_dot_table__Field){.name = field_name, .typ = typ}),
          tmp40, v_dot_table__Field);
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rcbr);
  if (is_c) {
    name = _STR("C.%.*s", name.len, name.str);
  } else {
    name = v_dot_parser__Parser_prepend_mod(&/* ? */ *p, name);
  };
  v_dot_table__TypeSymbol t = (v_dot_table__TypeSymbol){
      .kind = v_dot_table__v_dot_table__Kind_struct_,
      .name = name,
      .info = /*SUM TYPE CAST2*/ (
          v_dot_table__TypeInfo){.obj = memdup(&(v_dot_table__Struct[]){(
                                                   v_dot_table__Struct){
                                                   .fields = fields}},
                                               sizeof(v_dot_table__Struct)),
                                 .typ = SumType_v_dot_table__TypeInfo_Struct},
      .parent_idx = 0,
      .methods = new_array(0, 1, sizeof(v_dot_table__Fn))};
  int ret = 0;
  if (p->builtin_mod &&
      (_IN(string, (t.name), v_dot_table__builtin_type_names))) {
    ret = v_dot_table__Table_register_builtin_type_symbol(p->table, t);
  } else {
    ret = v_dot_table__Table_register_type_symbol(p->table, t);
  };
  if (ret == -1) {
    v_dot_parser__Parser_error(
        &/* ? */ *p,
        _STR("cannot register type `%.*s`, another type with this name exists",
             name.len, name.str));
  };
  p->expr_mod = tos3("");
  return (v_dot_ast__StructDecl){
      .name = name,
      .is_pub = is_pub,
      .fields = ast_fields,
      .pos = v_dot_token__Token_position(&/* ? */ p->tok),
      .mut_pos = mut_pos,
      .pub_pos = pub_pos,
      .pub_mut_pos = pub_mut_pos,
      .is_c = is_c};
}
v_dot_ast__Return v_dot_parser__Parser_return_stmt(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_next(p);
  array_v_dot_ast__Expr exprs = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Expr),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Expr, 0){TCCSKIP(0)});
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_rcbr) {
    return (v_dot_ast__Return){
        .pos = v_dot_token__Token_position(&/* ? */ p->tok),
        .exprs = new_array(0, 1, sizeof(v_dot_ast__Expr)),
        .types = new_array(0, 1, sizeof(v_dot_table__Type))};
  };
  while (1) {
    v_dot_ast__Expr expr = v_dot_parser__Parser_expr(p, 0);
    _PUSH(&exprs,
          (/*typ = array_v_dot_ast__Expr   tmp_typ=v_dot_ast__Expr*/ expr),
          tmp41, v_dot_ast__Expr);
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_comma) {
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_comma);
    } else {
      break;
    };
  };
  v_dot_ast__Return stmt =
      (v_dot_ast__Return){.exprs = exprs,
                          .pos = v_dot_token__Token_position(&/* ? */ p->tok),
                          .types = new_array(0, 1, sizeof(v_dot_table__Type))};
  return stmt;
}
array_v_dot_ast__Ident
v_dot_parser__Parser_parse_assign_lhs(v_dot_parser__Parser *p) {
  array_v_dot_ast__Ident idents = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Ident),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Ident, 0){TCCSKIP(0)});
  while (1) {
    bool is_mut = p->tok.kind == v_dot_token__v_dot_token__Kind_key_mut;
    if (is_mut) {
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_mut);
    };
    bool is_static = p->tok.kind == v_dot_token__v_dot_token__Kind_key_static;
    if (is_static) {
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_static);
    };
    v_dot_ast__Ident ident = v_dot_parser__Parser_parse_ident(p, 0);
    ident.info = /*SUM TYPE CAST2*/ (v_dot_ast__IdentInfo){
        .obj = memdup(
            &(v_dot_ast__IdentVar[]){(v_dot_ast__IdentVar){
                .is_mut = is_mut, .is_static = is_static, .is_optional = 0}},
            sizeof(v_dot_ast__IdentVar)),
        .typ = SumType_v_dot_ast__IdentInfo_IdentVar};
    _PUSH(&idents,
          (/*typ = array_v_dot_ast__Ident   tmp_typ=v_dot_ast__Ident*/ ident),
          tmp42, v_dot_ast__Ident);
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_comma) {
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_comma);
    } else {
      break;
    };
  };
  return idents;
}
array_v_dot_ast__Expr
v_dot_parser__Parser_parse_assign_rhs(v_dot_parser__Parser *p) {
  array_v_dot_ast__Expr exprs = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__Expr),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Expr, 0){TCCSKIP(0)});
  while (1) {
    v_dot_ast__Expr expr = v_dot_parser__Parser_expr(p, 0);
    _PUSH(&exprs,
          (/*typ = array_v_dot_ast__Expr   tmp_typ=v_dot_ast__Expr*/ expr),
          tmp43, v_dot_ast__Expr);
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_comma) {
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_comma);
    } else {
      break;
    };
  };
  return exprs;
}
v_dot_ast__Stmt v_dot_parser__Parser_assign_stmt(v_dot_parser__Parser *p) {
  array_v_dot_ast__Ident idents = v_dot_parser__Parser_parse_assign_lhs(p);
  v_dot_token__Kind op = p->tok.kind;
  v_dot_parser__Parser_next(p);
  array_v_dot_ast__Expr exprs = v_dot_parser__Parser_parse_assign_rhs(p);
  bool is_decl = op == v_dot_token__v_dot_token__Kind_decl_assign;
  array_v_dot_ast__Ident tmp44 = idents;
  for (int i = 0; i < tmp44.len; i++) {
    v_dot_ast__Ident ident = ((v_dot_ast__Ident *)tmp44.data)[i];

    bool known_var = v_dot_ast__Scope_known_var(&/* ? */ *p->scope, ident.name);
    if (!is_decl && !known_var) {
      v_dot_parser__Parser_error(
          &/* ? */ *p,
          _STR("unknown variable `%.*s`", ident.name.len, ident.name.str));
    };
    if (is_decl && ident.kind != v_dot_ast__v_dot_ast__IdentKind_blank_ident) {
      if (v_dot_ast__Scope_known_var(&/* ? */ *p->scope, ident.name)) {
        v_dot_parser__Parser_error(
            &/* ? */ *p,
            _STR("redefinition of `%.*s`", ident.name.len, ident.name.str));
      };
      if (idents.len == exprs.len) {
        v_dot_ast__Scope_register_var(
            p->scope, (v_dot_ast__Var){
                          .name = ident.name,
                          .expr = (*(v_dot_ast__Expr *)array_get(exprs, i)),
                          .is_mut = 0,
                      });
      } else {
        v_dot_ast__Scope_register_var(p->scope, (v_dot_ast__Var){
                                                    .name = ident.name,
                                                    .is_mut = 0,
                                                });
      };
    };
  };
  return /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
      .obj = memdup(
          &(v_dot_ast__AssignStmt[]){(v_dot_ast__AssignStmt){
              .left = idents,
              .right = exprs,
              .op = op,
              .pos = v_dot_token__Token_position(&/* ? */ p->tok),
              .left_types = new_array(0, 1, sizeof(v_dot_table__Type)),
              .right_types = new_array(0, 1, sizeof(v_dot_table__Type))}},
          sizeof(v_dot_ast__AssignStmt)),
      .typ = SumType_v_dot_ast__Stmt_AssignStmt};
}
v_dot_ast__HashStmt v_dot_parser__Parser_hash(v_dot_parser__Parser *p) {
  string val = p->tok.lit;
  v_dot_parser__Parser_next(p);
  return (v_dot_ast__HashStmt){.val = val};
}
v_dot_ast__GlobalDecl
v_dot_parser__Parser_global_decl(v_dot_parser__Parser *p) {
  if (!p->pref->translated && !p->pref->is_live && !p->builtin_mod &&
      !p->pref->building_v && string_ne(p->mod, tos3("ui")) &&
      string_ne(p->mod, tos3("gg2")) && string_ne(p->mod, tos3("uiold")) &&
      !string_contains(os__getwd(), tos3("/volt")) &&
      !p->pref->enable_globals) {
    v_dot_parser__Parser_error(
        &/* ? */ *p, tos3("use `v --enable-globals ...` to enable globals"));
  };
  v_dot_parser__Parser_next(p);
  string name = v_dot_parser__Parser_check_name(p);
  println(name);
  v_dot_table__Type typ = v_dot_parser__Parser_parse_type(p);
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_assign) {
    v_dot_parser__Parser_next(p);
    v_dot_parser__Parser_expr(p, 0);
  };
  v_dot_table__Table_register_global(p->table, name, typ);
  return (v_dot_ast__GlobalDecl){
      .name = name,
      .typ = typ,
  };
}
v_dot_ast__MatchExpr v_dot_parser__Parser_match_expr(v_dot_parser__Parser *p) {
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_match);
  bool is_mut = p->tok.kind == v_dot_token__v_dot_token__Kind_key_mut;
  bool is_sum_type = 0;
  if (is_mut) {
    v_dot_parser__Parser_next(p);
  };
  v_dot_ast__Expr cond = v_dot_parser__Parser_expr(p, 0);
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lcbr);
  array_v_dot_ast__MatchBranch branches = new_array_from_c_array(
      0, 0, sizeof(v_dot_ast__MatchBranch),
      EMPTY_ARRAY_OF_ELEMS(v_dot_ast__MatchBranch, 0){TCCSKIP(0)});
  while (1) {
    array_v_dot_ast__Expr exprs = new_array_from_c_array(
        0, 0, sizeof(v_dot_ast__Expr),
        EMPTY_ARRAY_OF_ELEMS(v_dot_ast__Expr, 0){TCCSKIP(0)});
    v_dot_parser__Parser_open_scope(p);
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_else) {
      v_dot_parser__Parser_next(p);
    } else if (p->tok.kind == v_dot_token__v_dot_token__Kind_name &&
               (byte_is_capital(string_at(p->tok.lit, 0)) ||
                p->peek_tok.kind == v_dot_token__v_dot_token__Kind_dot)) {
      v_dot_table__Type typ = v_dot_parser__Parser_parse_type(p);
      _PUSH(&exprs,
            (/*typ = array_v_dot_ast__Expr   tmp_typ=v_dot_ast__Expr*/
             /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
                 .obj =
                     memdup(&(v_dot_ast__Type[]){(v_dot_ast__Type){.typ = typ}},
                            sizeof(v_dot_ast__Type)),
                 .typ = SumType_v_dot_ast__Expr_Type}),
            tmp49, v_dot_ast__Expr);
      v_dot_ast__Scope_register_var(p->scope,
                                    (v_dot_ast__Var){
                                        .name = tos3("it"),
                                        .typ = v_dot_table__type_to_ptr(typ),
                                        .is_mut = 0,
                                    });
      if (p->tok.kind == v_dot_token__v_dot_token__Kind_comma) {
        v_dot_parser__Parser_next(p);
        v_dot_parser__Parser_parse_type(p);
      };
      is_sum_type = 1;
    } else {
      while (1) {
        v_dot_ast__Expr expr = v_dot_parser__Parser_expr(p, 0);
        _PUSH(&exprs,
              (/*typ = array_v_dot_ast__Expr   tmp_typ=v_dot_ast__Expr*/ expr),
              tmp50, v_dot_ast__Expr);
        if (p->tok.kind != v_dot_token__v_dot_token__Kind_comma) {
          break;
        };
        v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_comma);
      };
    };
    array_v_dot_ast__Stmt stmts = v_dot_parser__Parser_parse_block(p);
    _PUSH(
        &branches,
        (/*typ = array_v_dot_ast__MatchBranch   tmp_typ=v_dot_ast__MatchBranch*/
         (v_dot_ast__MatchBranch){
             .exprs = exprs,
             .stmts = stmts,
         }),
        tmp51, v_dot_ast__MatchBranch);
    v_dot_parser__Parser_close_scope(p);
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_rcbr) {
      break;
    };
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rcbr);
  return (v_dot_ast__MatchExpr){
      .branches = branches,
      .cond = cond,
      .is_sum_type = is_sum_type,
  };
}
v_dot_ast__EnumDecl v_dot_parser__Parser_enum_decl(v_dot_parser__Parser *p) {
  bool is_pub = p->tok.kind == v_dot_token__v_dot_token__Kind_key_pub;
  if (is_pub) {
    v_dot_parser__Parser_next(p);
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_enum);
  string name = v_dot_parser__Parser_prepend_mod(
      &/* ? */ *p, v_dot_parser__Parser_check_name(p));
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_lcbr);
  array_string vals = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  while (p->tok.kind != v_dot_token__v_dot_token__Kind_eof &&
         p->tok.kind != v_dot_token__v_dot_token__Kind_rcbr) {

    string val = v_dot_parser__Parser_check_name(p);
    _PUSH(&vals, (/*typ = array_string   tmp_typ=string*/ val), tmp52, string);
    if (p->tok.kind == v_dot_token__v_dot_token__Kind_assign) {
      v_dot_parser__Parser_next(p);
      v_dot_parser__Parser_expr(p, 0);
    };
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_rcbr);
  v_dot_table__Table_register_type_symbol(
      p->table,
      (v_dot_table__TypeSymbol){
          .kind = v_dot_table__v_dot_table__Kind_enum_,
          .name = name,
          .info = /*SUM TYPE CAST2*/ (
              v_dot_table__TypeInfo){.obj = memdup(
                                         &(v_dot_table__Enum[]){
                                             (v_dot_table__Enum){.vals = vals}},
                                         sizeof(v_dot_table__Enum)),
                                     .typ = SumType_v_dot_table__TypeInfo_Enum},
          .parent_idx = 0,
          .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  return (v_dot_ast__EnumDecl){.name = name, .is_pub = is_pub, .vals = vals};
}
v_dot_ast__TypeDecl v_dot_parser__Parser_type_decl(v_dot_parser__Parser *p) {
  bool is_pub = p->tok.kind == v_dot_token__v_dot_token__Kind_key_pub;
  if (is_pub) {
    v_dot_parser__Parser_next(p);
  };
  v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_key_type);
  string name = v_dot_parser__Parser_check_name(p);
  array_v_dot_table__Type sum_variants = new_array_from_c_array(
      0, 0, sizeof(v_dot_table__Type),
      EMPTY_ARRAY_OF_ELEMS(v_dot_table__Type, 0){TCCSKIP(0)});
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_assign) {
    v_dot_parser__Parser_next(p);
    while (1) {
      v_dot_table__Type variant_type = v_dot_parser__Parser_parse_type(p);
      _PUSH(&sum_variants,
            (/*typ = array_v_dot_table__Type   tmp_typ=v_dot_table__Type*/
             variant_type),
            tmp53, v_dot_table__Type);
      if (p->tok.kind != v_dot_token__v_dot_token__Kind_pipe) {
        break;
      };
      v_dot_parser__Parser_check(p, v_dot_token__v_dot_token__Kind_pipe);
    };
    v_dot_table__Table_register_type_symbol(
        p->table,
        (v_dot_table__TypeSymbol){
            .kind = v_dot_table__v_dot_table__Kind_sum_type,
            .name = v_dot_parser__Parser_prepend_mod(&/* ? */ *p, name),
            .info = /*SUM TYPE CAST2*/
            (v_dot_table__TypeInfo){
                .obj = memdup(&(v_dot_table__SumType[]){(v_dot_table__SumType){
                                  .variants = sum_variants}},
                              sizeof(v_dot_table__SumType)),
                .typ = SumType_v_dot_table__TypeInfo_SumType},
            .parent_idx = 0,
            .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
    return /*SUM TYPE CAST2*/ (v_dot_ast__TypeDecl){
        .obj = memdup(
            &(v_dot_ast__SumTypeDecl[]){(v_dot_ast__SumTypeDecl){
                .name = name, .is_pub = is_pub, .sub_types = sum_variants}},
            sizeof(v_dot_ast__SumTypeDecl)),
        .typ = SumType_v_dot_ast__TypeDecl_SumTypeDecl};
  };
  if (p->tok.kind == v_dot_token__v_dot_token__Kind_key_fn) {
    string fn_name = v_dot_parser__Parser_prepend_mod(&/* ? */ *p, name);
    v_dot_table__Type fn_type = v_dot_parser__Parser_parse_fn_type(p, fn_name);
    return /*SUM TYPE CAST2*/ (v_dot_ast__TypeDecl){
        .obj = memdup(&(v_dot_ast__FnTypeDecl[]){(v_dot_ast__FnTypeDecl){
                          .name = fn_name, .is_pub = is_pub, .typ = fn_type}},
                      sizeof(v_dot_ast__FnTypeDecl)),
        .typ = SumType_v_dot_ast__TypeDecl_FnTypeDecl};
  };
  v_dot_table__Type parent_type = v_dot_parser__Parser_parse_type(p);
  int pid = v_dot_table__type_idx(parent_type);
  v_dot_table__Table_register_type_symbol(
      p->table,
      (v_dot_table__TypeSymbol){
          .kind = v_dot_table__v_dot_table__Kind_alias,
          .name = v_dot_parser__Parser_prepend_mod(&/* ? */ *p, name),
          .parent_idx = pid,
          .info = /*SUM TYPE CAST2*/ (
              v_dot_table__TypeInfo){.obj = memdup(&(v_dot_table__Alias[]){(
                                                       v_dot_table__Alias){
                                                       .foo = tos3("")}},
                                                   sizeof(v_dot_table__Alias)),
                                     .typ =
                                         SumType_v_dot_table__TypeInfo_Alias},
          .methods = new_array(0, 1, sizeof(v_dot_table__Fn))});
  return /*SUM TYPE CAST2*/ (v_dot_ast__TypeDecl){
      .obj = memdup(
          &(v_dot_ast__AliasTypeDecl[]){(v_dot_ast__AliasTypeDecl){
              .name = name, .is_pub = is_pub, .parent_type = parent_type}},
          sizeof(v_dot_ast__AliasTypeDecl)),
      .typ = SumType_v_dot_ast__TypeDecl_AliasTypeDecl};
}
void v_dot_parser__verror(string s) {
  println(s);
  v_exit(1);
}
v_dot_checker__Checker v_dot_checker__new_checker(v_dot_table__Table *table) {
  return (v_dot_checker__Checker){.table = table,
                                  .nr_errors = 0,
                                  .errors = new_array(0, 1, sizeof(string)),
                                  .is_amp = 0};
}
void v_dot_checker__Checker_check(v_dot_checker__Checker *c,
                                  v_dot_ast__File ast_file) {
  c->file = ast_file;
  array_v_dot_ast__Stmt tmp1 = ast_file.stmts;
  for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
    v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp1.data)[tmp2];

    v_dot_checker__Checker_stmt(c, stmt);
  };
}
array_string v_dot_checker__Checker_check2(v_dot_checker__Checker *c,
                                           v_dot_ast__File ast_file) {
  c->file = ast_file;
  array_v_dot_ast__Stmt tmp3 = ast_file.stmts;
  for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
    v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp3.data)[tmp4];

    v_dot_checker__Checker_stmt(c, stmt);
  };
  return c->errors;
}
void v_dot_checker__Checker_check_files(v_dot_checker__Checker *c,
                                        array_v_dot_ast__File ast_files) {
  array_v_dot_ast__File tmp5 = ast_files;
  for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
    v_dot_ast__File file = ((v_dot_ast__File *)tmp5.data)[tmp6];

    c->file = file;
    array_v_dot_ast__Stmt tmp7 = file.stmts;
    for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
      v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp7.data)[tmp8];

      v_dot_ast__Stmt tmp9 = stmt;

      if (tmp9.typ == SumType_v_dot_ast__Stmt_ConstDecl) {
        v_dot_ast__ConstDecl *it = (v_dot_ast__ConstDecl *)tmp9.obj;
        v_dot_checker__Checker_stmt(
            c, /*SUM TYPE CAST2*/ (v_dot_ast__Stmt){
                .obj = memdup(&(v_dot_ast__ConstDecl[]){*it},
                              sizeof(v_dot_ast__ConstDecl)),
                .typ = SumType_v_dot_ast__Stmt_ConstDecl});
      } else // default:
      {
      };
    };
  };
  array_v_dot_ast__File tmp10 = ast_files;
  for (int tmp11 = 0; tmp11 < tmp10.len; tmp11++) {
    v_dot_ast__File file = ((v_dot_ast__File *)tmp10.data)[tmp11];

    v_dot_checker__Checker_check(c, file);
  };
}
v_dot_table__Type
v_dot_checker__Checker_check_struct_init(v_dot_checker__Checker *c,
                                         v_dot_ast__StructInit struct_init) {
  v_dot_table__TypeSymbol *typ_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, struct_init.typ);
  v_dot_table__Kind tmp12 = typ_sym->kind;

  if (tmp12 == v_dot_table__v_dot_table__Kind_placeholder) {
    v_dot_checker__Checker_error(
        c, _STR("unknown struct: %.*s", typ_sym->name.len, typ_sym->name.str),
        struct_init.pos);
  } else if (tmp12 == v_dot_table__v_dot_table__Kind_struct_) {
    v_dot_table__Struct info = *(v_dot_table__Struct *)typ_sym->info.obj;
    if (struct_init.fields.len == 0) {
      if (c->is_amp) {
        return v_dot_table__type_to_ptr(struct_init.typ);
      };
      return struct_init.typ;
    };
    if (struct_init.exprs.len > info.fields.len) {
      v_dot_checker__Checker_error(c, tos3("too many fields"), struct_init.pos);
    };
    array_v_dot_ast__Expr tmp13 = struct_init.exprs;
    for (int i = 0; i < tmp13.len; i++) {
      v_dot_ast__Expr expr = ((v_dot_ast__Expr *)tmp13.data)[i];

      string field_name = (*(string *)array_get(struct_init.fields, i));
      v_dot_table__Field field =
          (*(v_dot_table__Field *)array_get(info.fields, i));
      bool found_field = 0;
      array_v_dot_table__Field tmp18 = info.fields;
      for (int tmp19 = 0; tmp19 < tmp18.len; tmp19++) {
        v_dot_table__Field f = ((v_dot_table__Field *)tmp18.data)[tmp19];

        if (string_eq(f.name, field_name)) {
          field = f;
          found_field = 1;
          break;
        };
      };
      if (!found_field) {
        v_dot_checker__Checker_error(
            c,
            _STR("struct init: no such field `%.*s` for struct `%.*s`",
                 field_name.len, field_name.str, typ_sym->name.len,
                 typ_sym->name.str),
            struct_init.pos);
      };
      c->expected_type = field.typ;
      v_dot_table__Type expr_type = v_dot_checker__Checker_expr(c, expr);
      v_dot_table__TypeSymbol *expr_type_sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, expr_type);
      v_dot_table__TypeSymbol *field_type_sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, field.typ);
      if (!v_dot_table__Table_check(&/* ? */ *c->table, expr_type, field.typ)) {
        v_dot_checker__Checker_error(
            c,
            _STR("cannot assign `%.*s` as `%.*s` for field `%.*s`",
                 expr_type_sym->name.len, expr_type_sym->name.str,
                 field_type_sym->name.len, field_type_sym->name.str,
                 field.name.len, field.name.str),
            struct_init.pos);
      };
    };
  } else // default:
  {
  };
  if (c->is_amp) {
    return v_dot_table__type_to_ptr(struct_init.typ);
  };
  return struct_init.typ;
}
v_dot_table__Type
v_dot_checker__Checker_infix_expr(v_dot_checker__Checker *c,
                                  v_dot_ast__InfixExpr *infix_expr) {
  v_dot_table__Type left_type =
      v_dot_checker__Checker_expr(c, infix_expr->left);
  infix_expr->left_type = left_type;
  c->expected_type = left_type;
  v_dot_table__Type right_type =
      v_dot_checker__Checker_expr(c, infix_expr->right);
  infix_expr->right_type = right_type;
  if (!v_dot_table__Table_check(&/* ? */ *c->table, right_type, left_type)) {
    v_dot_table__TypeSymbol *left =
        v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, left_type);
    v_dot_table__TypeSymbol *right =
        v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, right_type);
    if (left->kind == v_dot_table__v_dot_table__Kind_array &&
        infix_expr->op == v_dot_token__v_dot_token__Kind_left_shift) {
      return v_dot_table__void_type;
    };
    if ((right->kind == v_dot_table__v_dot_table__Kind_array ||
         right->kind == v_dot_table__v_dot_table__Kind_map) &&
        infix_expr->op == v_dot_token__v_dot_token__Kind_key_in) {
      return v_dot_table__bool_type;
    };
    v_dot_checker__Checker_error(
        c,
        _STR("infix expr: cannot use `%.*s` (right) as `%.*s`", right->name.len,
             right->name.str, left->name.len, left->name.str),
        infix_expr->pos);
  };
  if (v_dot_token__Kind_is_relational(infix_expr->op)) {
    return v_dot_table__bool_type;
  };
  return left_type;
}
void v_dot_checker__Checker_assign_expr(v_dot_checker__Checker *c,
                                        v_dot_ast__AssignExpr *assign_expr) {
  v_dot_ast__Expr tmp20 = assign_expr->left;

  if (tmp20.typ == SumType_v_dot_ast__Expr_Ident) {
    v_dot_ast__Ident *it = (v_dot_ast__Ident *)tmp20.obj;
    if (it->kind == v_dot_ast__v_dot_ast__IdentKind_blank_ident) {

      return;
    };
  } else // default:
  {
  };
  v_dot_table__Type left_type =
      v_dot_checker__Checker_expr(c, assign_expr->left);
  c->expected_type = left_type;
  assign_expr->left_type = left_type;
  v_dot_table__Type right_type =
      v_dot_checker__Checker_expr(c, assign_expr->val);
  assign_expr->right_type = right_type;
  if (!v_dot_table__Table_check(&/* ? */ *c->table, right_type, left_type)) {
    v_dot_table__TypeSymbol *left_type_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, left_type);
    v_dot_table__TypeSymbol *right_type_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, right_type);
    v_dot_checker__Checker_error(
        c,
        _STR("cannot assign %.*s to %.*s", right_type_sym->name.len,
             right_type_sym->name.str, left_type_sym->name.len,
             left_type_sym->name.str),
        assign_expr->pos);
  };
}
v_dot_table__Type
v_dot_checker__Checker_call_expr(v_dot_checker__Checker *c,
                                 v_dot_ast__CallExpr *call_expr) {
  string fn_name = call_expr->name;
  if (string_eq(fn_name, tos3("typeof"))) {
    return v_dot_table__string_type;
  };
  if (string_eq(fn_name, tos3("C.calloc"))) {
    return v_dot_table__byteptr_type;
  } else if (string_eq(fn_name, tos3("C.exit"))) {
    return v_dot_table__void_type;
  } else if (string_eq(fn_name, tos3("C.free"))) {
    return v_dot_table__void_type;
  };
  v_dot_table__Fn f =
      (v_dot_table__Fn){.name = tos3(""),
                        .args = new_array(0, 1, sizeof(v_dot_table__Arg)),
                        .is_variadic = 0,
                        .is_c = 0};
  bool found = 0;
  if (!string_contains(fn_name, tos3(".")) &&
      !((string_eq(c->file.mod.name, tos3("builtin")) ||
         string_eq(c->file.mod.name, tos3("main"))))) {
    string name_prefixed = _STR("%.*s.%.*s", c->file.mod.name.len,
                                c->file.mod.name.str, fn_name.len, fn_name.str);
    Option_v_dot_table__Fn tmp21 =
        v_dot_table__Table_find_fn(&/* ? */ *c->table, name_prefixed);

    if (tmp21.ok) {
      v_dot_table__Fn f1 = *(v_dot_table__Fn *)tmp21.data;
      call_expr->name = name_prefixed;
      found = 1;
      f = f1;
    };
  };
  if (!found) {
    Option_v_dot_table__Fn tmp22 =
        v_dot_table__Table_find_fn(&/* ? */ *c->table, fn_name);

    if (tmp22.ok) {
      v_dot_table__Fn f1 = *(v_dot_table__Fn *)tmp22.data;
      found = 1;
      f = f1;
    };
  };
  if (!found) {
    v_dot_ast__Scope *scope =
        v_dot_ast__Scope_innermost(&/* ? */ *c->file.scope, call_expr->pos.pos);
    Option_v_dot_ast__Var tmp23 =
        v_dot_ast__Scope_find_var(&/* ? */ *scope, fn_name);

    if (tmp23.ok) {
      v_dot_ast__Var var = *(v_dot_ast__Var *)tmp23.data;
      if (var.typ != 0) {
        v_dot_table__TypeSymbol *vts =
            v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, var.typ);
        if (vts->kind == v_dot_table__v_dot_table__Kind_function) {
          f = *(v_dot_table__Fn *)vts->info.obj;
          found = 1;
        };
      };
    };
  };
  if (!found) {
    v_dot_checker__Checker_error(
        c, _STR("unknown fn: %.*s", fn_name.len, fn_name.str), call_expr->pos);
  };
  call_expr->return_type = f.return_type;
  if (f.is_c || call_expr->is_c) {
    array_v_dot_ast__CallArg tmp24 = call_expr->args;
    for (int tmp25 = 0; tmp25 < tmp24.len; tmp25++) {
      v_dot_ast__CallArg arg = ((v_dot_ast__CallArg *)tmp24.data)[tmp25];

      v_dot_checker__Checker_expr(c, arg.expr);
    };
    return f.return_type;
  };
  if (call_expr->args.len < f.args.len) {
    v_dot_checker__Checker_error(
        c,
        _STR("too few arguments in call to `%.*s`", fn_name.len, fn_name.str),
        call_expr->pos);
  } else if (!f.is_variadic && call_expr->args.len > f.args.len) {
    v_dot_checker__Checker_error(
        c,
        _STR("too many arguments in call to `%.*s` (%d instead of %d)",
             fn_name.len, fn_name.str, call_expr->args.len, f.args.len),
        call_expr->pos);
  };
  if (string_eq(fn_name, tos3("println"))) {
    (*(v_dot_ast__CallArg *)array_get(call_expr->args, 0)).typ =
        v_dot_checker__Checker_expr(
            c, (*(v_dot_ast__CallArg *)array_get(call_expr->args, 0)).expr);
    return f.return_type;
  };
  array_v_dot_ast__CallArg tmp30 = call_expr->args;
  for (int i = 0; i < tmp30.len; i++) {
    v_dot_ast__CallArg call_arg = ((v_dot_ast__CallArg *)tmp30.data)[i];

    v_dot_table__Arg arg =
        ((f.is_variadic && i >= f.args.len - 1)
             ? ((*(v_dot_table__Arg *)array_get(f.args, f.args.len - 1)))
             : ((*(v_dot_table__Arg *)array_get(f.args, i))));
    c->expected_type = arg.typ;
    v_dot_table__Type typ = v_dot_checker__Checker_expr(c, call_arg.expr);
    (*(v_dot_ast__CallArg *)array_get(call_expr->args, i)).typ = typ;
    (*(v_dot_ast__CallArg *)array_get(call_expr->args, i)).expected_type =
        arg.typ;
    v_dot_table__TypeSymbol *typ_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, typ);
    v_dot_table__TypeSymbol *arg_typ_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, arg.typ);
    if (!v_dot_table__Table_check(&/* ? */ *c->table, typ, arg.typ)) {
      if (arg_typ_sym->kind == v_dot_table__v_dot_table__Kind_string &&
          v_dot_table__TypeSymbol_has_method(&/* ? */ *typ_sym, tos3("str"))) {
        continue;
      };
      if (typ_sym->kind == v_dot_table__v_dot_table__Kind_void &&
          arg_typ_sym->kind == v_dot_table__v_dot_table__Kind_string) {
        continue;
      };
      if (typ_sym->kind == v_dot_table__v_dot_table__Kind_array_fixed) {
      };
      v_dot_checker__Checker_error(
          c,
          _STR(
              "!cannot use type `%.*s` as type `%.*s` in argument %d to `%.*s`",
              v_dot_table__TypeSymbol_str(&/* ? */ *typ_sym).len,
              v_dot_table__TypeSymbol_str(&/* ? */ *typ_sym).str,
              v_dot_table__TypeSymbol_str(&/* ? */ *arg_typ_sym).len,
              v_dot_table__TypeSymbol_str(&/* ? */ *arg_typ_sym).str, i + 1,
              fn_name.len, fn_name.str),
          call_expr->pos);
    };
  };
  return f.return_type;
}
v_dot_table__Type v_dot_checker__Checker_method_call_expr(
    v_dot_checker__Checker *c, v_dot_ast__MethodCallExpr *method_call_expr) {
  v_dot_table__Type typ =
      v_dot_checker__Checker_expr(c, method_call_expr->expr);
  method_call_expr->expr_type = typ;
  v_dot_table__TypeSymbol *typ_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, typ);
  string name = method_call_expr->name;
  if (typ_sym->kind == v_dot_table__v_dot_table__Kind_array &&
      (string_eq(name, tos3("filter")) || string_eq(name, tos3("clone")) ||
       string_eq(name, tos3("repeat")))) {
    if (string_eq(name, tos3("filter"))) {
      v_dot_table__Array array_info = *(v_dot_table__Array *)typ_sym->info.obj;
      v_dot_ast__Scope *scope = v_dot_ast__Scope_innermost(
          &/* ? */ *c->file.scope, method_call_expr->pos.pos);
      v_dot_ast__Scope_override_var(scope, (v_dot_ast__Var){
                                               .name = tos3("it"),
                                               .typ = array_info.elem_type,
                                               .is_mut = 0,
                                           });
    } else if (string_eq(name, tos3("repeat"))) {
      v_dot_checker__Checker_expr(
          c,
          (*(v_dot_ast__CallArg *)array_get(method_call_expr->args, 0)).expr);
    };
    method_call_expr->return_type = typ;
    return typ;
  } else if (typ_sym->kind == v_dot_table__v_dot_table__Kind_array &&
             (string_eq(name, tos3("first")) ||
              string_eq(name, tos3("last")))) {
    v_dot_table__Array info = *(v_dot_table__Array *)typ_sym->info.obj;
    method_call_expr->return_type = info.elem_type;
    return info.elem_type;
  };
  Option_v_dot_table__Fn tmp41 =
      v_dot_table__Table_type_find_method(&/* ? */ *c->table, typ_sym, name);

  if (tmp41.ok) {
    v_dot_table__Fn method = *(v_dot_table__Fn *)tmp41.data;
    if (method_call_expr->args.len < method.args.len - 1) {
      v_dot_checker__Checker_error(
          c,
          _STR("too few arguments in call to `%.*s.%.*s`", typ_sym->name.len,
               typ_sym->name.str, name.len, name.str),
          method_call_expr->pos);
    } else if (!method.is_variadic &&
               method_call_expr->args.len > method.args.len + 1) {
      v_dot_checker__Checker_error(
          c,
          _STR("too many arguments in call to `%.*s.%.*s` (%d instead of %d)",
               typ_sym->name.len, typ_sym->name.str, name.len, name.str,
               method_call_expr->args.len, method.args.len),
          method_call_expr->pos);
    };
    array_v_dot_ast__CallArg tmp42 = method_call_expr->args;
    for (int i = 0; i < tmp42.len; i++) {
      v_dot_ast__CallArg arg = ((v_dot_ast__CallArg *)tmp42.data)[i];

      c->expected_type =
          (*(v_dot_table__Arg *)array_get(method.args, i + 1)).typ;
      (*(v_dot_ast__CallArg *)array_get(method_call_expr->args, i))
          .expected_type = c->expected_type;
      (*(v_dot_ast__CallArg *)array_get(method_call_expr->args, i)).typ =
          v_dot_checker__Checker_expr(c, arg.expr);
    };
    method_call_expr->receiver_type =
        (*(v_dot_table__Arg *)array_get(method.args, 0)).typ;
    method_call_expr->return_type = method.return_type;
    return method.return_type;
  };
  v_dot_checker__Checker_error(c,
                               _STR("type `%.*s` has no method `%.*s`",
                                    typ_sym->name.len, typ_sym->name.str,
                                    name.len, name.str),
                               method_call_expr->pos);
  return v_dot_table__void_type;
}
v_dot_table__Type
v_dot_checker__Checker_selector_expr(v_dot_checker__Checker *c,
                                     v_dot_ast__SelectorExpr *selector_expr) {
  v_dot_table__Type typ = v_dot_checker__Checker_expr(c, selector_expr->expr);
  if (typ == v_dot_table__void_type_idx) {
    v_dot_checker__Checker_error(c, tos3("unknown selector expression"),
                                 selector_expr->pos);
    return v_dot_table__void_type;
  };
  selector_expr->expr_type = typ;
  v_dot_table__TypeSymbol *typ_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, typ);
  string field_name = selector_expr->field;
  if (v_dot_table__type_is_variadic(typ)) {
    if (string_eq(field_name, tos3("len"))) {
      return v_dot_table__int_type;
    };
  };
  Option_v_dot_table__Field tmp51 = v_dot_table__Table_struct_find_field(
      &/* ? */ *c->table, typ_sym, field_name);

  if (tmp51.ok) {
    v_dot_table__Field field = *(v_dot_table__Field *)tmp51.data;
    return field.typ;
  };
  if (typ_sym->kind != v_dot_table__v_dot_table__Kind_struct_) {
    v_dot_checker__Checker_error(
        c, _STR("`%.*s` is not a struct", typ_sym->name.len, typ_sym->name.str),
        selector_expr->pos);
  } else {
    v_dot_checker__Checker_error(c,
                                 _STR("unknown field `%.*s.%.*s`",
                                      typ_sym->name.len, typ_sym->name.str,
                                      field_name.len, field_name.str),
                                 selector_expr->pos);
  };
  return v_dot_table__void_type;
}
void v_dot_checker__Checker_return_stmt(v_dot_checker__Checker *c,
                                        v_dot_ast__Return *return_stmt) {
  c->expected_type = c->fn_return_type;
  if (return_stmt->exprs.len == 0) {

    return;
  };
  v_dot_table__Type expected_type = c->fn_return_type;
  v_dot_table__TypeSymbol *expected_type_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, expected_type);
  bool exp_is_optional = v_dot_table__type_is_optional(expected_type);
  array_v_dot_table__Type expected_types = new_array_from_c_array(
      1, 1, sizeof(v_dot_table__Type),
      EMPTY_ARRAY_OF_ELEMS(v_dot_table__Type, 1){expected_type});
  if (expected_type_sym->kind == v_dot_table__v_dot_table__Kind_multi_return) {
    v_dot_table__MultiReturn mr_info =
        *(v_dot_table__MultiReturn *)expected_type_sym->info.obj;
    expected_types = mr_info.types;
  };
  array_v_dot_table__Type got_types = new_array_from_c_array(
      0, 0, sizeof(v_dot_table__Type),
      EMPTY_ARRAY_OF_ELEMS(v_dot_table__Type, 0){TCCSKIP(0)});
  array_v_dot_ast__Expr tmp52 = return_stmt->exprs;
  for (int tmp53 = 0; tmp53 < tmp52.len; tmp53++) {
    v_dot_ast__Expr expr = ((v_dot_ast__Expr *)tmp52.data)[tmp53];

    v_dot_table__Type typ = v_dot_checker__Checker_expr(c, expr);
    _PUSH(&got_types,
          (/*typ = array_v_dot_table__Type   tmp_typ=v_dot_table__Type*/ typ),
          tmp54, v_dot_table__Type);
  };
  return_stmt->types = got_types;
  int tmp57 = 0;
  bool tmp58 =
      map_get(/*checker.v : 375*/ c->table->type_idxs, tos3("Option"), &tmp57);

  if (exp_is_optional &&
      (v_dot_table__type_idx((*(v_dot_table__Type *)array_get(got_types, 0))) ==
           v_dot_table__none_type_idx ||
       v_dot_table__type_idx((*(v_dot_table__Type *)array_get(got_types, 0))) ==
           tmp57)) {

    return;
  };
  if (expected_types.len > 0 && expected_types.len != got_types.len) {
    v_dot_checker__Checker_error(
        c,
        _STR("wrong number of return arguments:\n\texpected: %.*s\n\tgot: %.*s",
             array_v_dot_table__Type_str(expected_types).len,
             array_v_dot_table__Type_str(expected_types).str,
             array_v_dot_table__Type_str(got_types).len,
             array_v_dot_table__Type_str(got_types).str),
        return_stmt->pos);
  };
  array_v_dot_table__Type tmp59 = expected_types;
  for (int i = 0; i < tmp59.len; i++) {
    v_dot_table__Type exp_typ = ((v_dot_table__Type *)tmp59.data)[i];

    v_dot_table__Type got_typ = (*(v_dot_table__Type *)array_get(got_types, i));
    if (!v_dot_table__Table_check(&/* ? */ *c->table, got_typ, exp_typ)) {
      v_dot_table__TypeSymbol *got_typ_sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, got_typ);
      v_dot_table__TypeSymbol *exp_typ_sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, exp_typ);
      v_dot_checker__Checker_error(
          c,
          _STR("cannot use `%.*s` as type `%.*s` in return argument",
               got_typ_sym->name.len, got_typ_sym->name.str,
               exp_typ_sym->name.len, exp_typ_sym->name.str),
          return_stmt->pos);
    };
  };
}
void v_dot_checker__Checker_assign_stmt(v_dot_checker__Checker *c,
                                        v_dot_ast__AssignStmt *assign_stmt) {
  if (assign_stmt->left.len > assign_stmt->right.len) {
    v_dot_table__Type right = v_dot_checker__Checker_expr(
        c, (*(v_dot_ast__Expr *)array_get(assign_stmt->right, 0)));
    v_dot_table__TypeSymbol *right_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, right);
    v_dot_table__MultiReturn mr_info =
        v_dot_table__TypeSymbol_mr_info(&/* ? */ *right_sym);
    if (right_sym->kind != v_dot_table__v_dot_table__Kind_multi_return) {
      v_dot_checker__Checker_error(c, tos3("wrong number of vars"),
                                   assign_stmt->pos);
    };
    v_dot_ast__Scope *scope = v_dot_ast__Scope_innermost(
        &/* ? */ *c->file.scope, assign_stmt->pos.pos);
    array_v_dot_ast__Ident tmp64 = assign_stmt->left;
    for (int i = 0; i < tmp64.len; i++) {

      v_dot_ast__Ident ident =
          (*(v_dot_ast__Ident *)array_get(assign_stmt->left, i));
      v_dot_table__Type val_type =
          (*(v_dot_table__Type *)array_get(mr_info.types, i));
      v_dot_ast__IdentVar var_info = v_dot_ast__Ident_var_info(&/* ? */ ident);
      var_info.typ = val_type;
      ident.info = /*SUM TYPE CAST2*/ (v_dot_ast__IdentInfo){
          .obj = memdup(&(v_dot_ast__IdentVar[]){var_info},
                        sizeof(v_dot_ast__IdentVar)),
          .typ = SumType_v_dot_ast__IdentInfo_IdentVar};
      array_set(&/*q*/ assign_stmt->left, i, &(v_dot_ast__Ident[]){ident});
      if (assign_stmt->op == v_dot_token__v_dot_token__Kind_assign) {
        v_dot_table__Type var_type = v_dot_checker__Checker_expr(
            c, /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
                .obj = memdup(&(v_dot_ast__Ident[]){ident},
                              sizeof(v_dot_ast__Ident)),
                .typ = SumType_v_dot_ast__Expr_Ident});
        _PUSH(&assign_stmt->left_types,
              (/*typ = array_v_dot_table__Type   tmp_typ=v_dot_table__Type*/
               var_type),
              tmp69, v_dot_table__Type);
        if (!v_dot_table__Table_check(&/* ? */ *c->table, val_type, var_type)) {
          v_dot_table__TypeSymbol *val_type_sym =
              v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, val_type);
          v_dot_table__TypeSymbol *var_type_sym =
              v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, var_type);
          v_dot_checker__Checker_error(
              c,
              _STR("assign stmt: cannot use `%.*s` as `%.*s`",
                   val_type_sym->name.len, val_type_sym->name.str,
                   var_type_sym->name.len, var_type_sym->name.str),
              assign_stmt->pos);
        };
      };
      _PUSH(&assign_stmt->right_types,
            (/*typ = array_v_dot_table__Type   tmp_typ=v_dot_table__Type*/
             val_type),
            tmp70, v_dot_table__Type);
      v_dot_ast__Scope_override_var(
          scope, (v_dot_ast__Var){
                     .name = ident.name,
                     .typ = (*(v_dot_table__Type *)array_get(mr_info.types, i)),
                     .is_mut = 0,
                 });
    };
  } else {
    if (assign_stmt->left.len != assign_stmt->right.len) {
      v_dot_checker__Checker_error(c, tos3("wrong number of vars"),
                                   assign_stmt->pos);
    };
    v_dot_ast__Scope *scope = v_dot_ast__Scope_innermost(
        &/* ? */ *c->file.scope, assign_stmt->pos.pos);
    array_v_dot_ast__Ident tmp73 = assign_stmt->left;
    for (int i = 0; i < tmp73.len; i++) {

      v_dot_ast__Ident ident =
          (*(v_dot_ast__Ident *)array_get(assign_stmt->left, i));
      v_dot_ast__IdentVar ident_var_info =
          v_dot_ast__Ident_var_info(&/* ? */ ident);
      v_dot_table__Type val_type = v_dot_checker__Checker_expr(
          c, (*(v_dot_ast__Expr *)array_get(assign_stmt->right, i)));
      if (assign_stmt->op == v_dot_token__v_dot_token__Kind_assign) {
        v_dot_table__Type var_type = v_dot_checker__Checker_expr(
            c, /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
                .obj = memdup(&(v_dot_ast__Ident[]){ident},
                              sizeof(v_dot_ast__Ident)),
                .typ = SumType_v_dot_ast__Expr_Ident});
        _PUSH(&assign_stmt->left_types,
              (/*typ = array_v_dot_table__Type   tmp_typ=v_dot_table__Type*/
               var_type),
              tmp78, v_dot_table__Type);
        if (!v_dot_table__Table_check(&/* ? */ *c->table, val_type, var_type)) {
          v_dot_table__TypeSymbol *val_type_sym =
              v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, val_type);
          v_dot_table__TypeSymbol *var_type_sym =
              v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, var_type);
          v_dot_checker__Checker_error(
              c,
              _STR("assign stmt: cannot use `%.*s` as `%.*s`",
                   val_type_sym->name.len, val_type_sym->name.str,
                   var_type_sym->name.len, var_type_sym->name.str),
              assign_stmt->pos);
        };
      };
      _PUSH(&assign_stmt->right_types,
            (/*typ = array_v_dot_table__Type   tmp_typ=v_dot_table__Type*/
             val_type),
            tmp79, v_dot_table__Type);
      ident_var_info.typ = val_type;
      ident.info = /*SUM TYPE CAST2*/ (v_dot_ast__IdentInfo){
          .obj = memdup(&(v_dot_ast__IdentVar[]){ident_var_info},
                        sizeof(v_dot_ast__IdentVar)),
          .typ = SumType_v_dot_ast__IdentInfo_IdentVar};
      array_set(&/*q*/ assign_stmt->left, i, &(v_dot_ast__Ident[]){ident});
      v_dot_ast__Scope_override_var(scope, (v_dot_ast__Var){
                                               .name = ident.name,
                                               .typ = val_type,
                                               .is_mut = 0,
                                           });
    };
  };
}
v_dot_table__Type
v_dot_checker__Checker_array_init(v_dot_checker__Checker *c,
                                  v_dot_ast__ArrayInit *array_init) {
  v_dot_table__Type elem_type = v_dot_table__void_type;
  if (array_init->typ != v_dot_table__void_type) {
    return array_init->typ;
  };
  if (array_init->exprs.len == 0) {
    v_dot_table__TypeSymbol *type_sym = v_dot_table__Table_get_type_symbol(
        &/* ? */ *c->table, c->expected_type);
    v_dot_table__Array array_info =
        v_dot_table__TypeSymbol_array_info(&/* ? */ *type_sym);
    array_init->elem_type = array_info.elem_type;
    return c->expected_type;
  };
  if (array_init->exprs.len > 0 &&
      array_init->elem_type == v_dot_table__void_type) {
    array_v_dot_ast__Expr tmp80 = array_init->exprs;
    for (int i = 0; i < tmp80.len; i++) {
      v_dot_ast__Expr expr = ((v_dot_ast__Expr *)tmp80.data)[i];

      v_dot_checker__Checker_expr(c, expr);
      v_dot_table__Type typ = v_dot_checker__Checker_expr(c, expr);
      if (i == 0) {
        elem_type = typ;
        c->expected_type = typ;
        continue;
      };
      if (!v_dot_table__Table_check(&/* ? */ *c->table, elem_type, typ)) {
        v_dot_table__TypeSymbol *elem_type_sym =
            v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, elem_type);
        v_dot_checker__Checker_error(
            c,
            _STR("expected array element with type `%.*s`",
                 elem_type_sym->name.len, elem_type_sym->name.str),
            array_init->pos);
      };
    };
    int idx = v_dot_table__Table_find_or_register_array(c->table, elem_type, 1);
    array_init->typ = v_dot_table__new_type(idx);
    array_init->elem_type = elem_type;
  } else if (array_init->exprs.len == 1 &&
             array_init->elem_type != v_dot_table__void_type) {
    int fixed_size = 1;
    v_dot_ast__Expr tmp83 =
        (*(v_dot_ast__Expr *)array_get(array_init->exprs, 0));

    if (tmp83.typ == SumType_v_dot_ast__Expr_IntegerLiteral) {
      v_dot_ast__IntegerLiteral *it = (v_dot_ast__IntegerLiteral *)tmp83.obj;
      fixed_size = it->val;
    } else // default:
    {
      v_dot_checker__Checker_error(c, tos3("expecting `int` for fixed size"),
                                   array_init->pos);
    };
    int idx = v_dot_table__Table_find_or_register_array_fixed(
        c->table, array_init->elem_type, fixed_size, 1);
    v_dot_table__Type array_type = v_dot_table__new_type(idx);
    array_init->typ = array_type;
  };
  return array_init->typ;
}
void v_dot_checker__Checker_stmt(v_dot_checker__Checker *c,
                                 v_dot_ast__Stmt node) {
  v_dot_ast__Stmt tmp84 = node;

  if (tmp84.typ == SumType_v_dot_ast__Stmt_AssignStmt) {
    v_dot_ast__AssignStmt *it = (v_dot_ast__AssignStmt *)tmp84.obj;
    v_dot_checker__Checker_assign_stmt(c, it);
  } else if (tmp84.typ == SumType_v_dot_ast__Stmt_ConstDecl) {
    v_dot_ast__ConstDecl *it = (v_dot_ast__ConstDecl *)tmp84.obj;
    array_v_dot_ast__Expr tmp85 = it->exprs;
    for (int i = 0; i < tmp85.len; i++) {
      v_dot_ast__Expr expr = ((v_dot_ast__Expr *)tmp85.data)[i];

      v_dot_ast__Field field = (*(v_dot_ast__Field *)array_get(it->fields, i));
      v_dot_table__Type typ = v_dot_checker__Checker_expr(c, expr);
      v_dot_table__Table_register_const(c->table, (v_dot_table__Var){
                                                      .name = field.name,
                                                      .typ = typ,
                                                      .is_mut = 0,
                                                      .is_const = 0,
                                                      .is_global = 0,
                                                  });
      field.typ = typ;
      array_set(&/*q*/ it->fields, i, &(v_dot_ast__Field[]){field});
    };
  } else if (tmp84.typ == SumType_v_dot_ast__Stmt_ExprStmt) {
    v_dot_ast__ExprStmt *it = (v_dot_ast__ExprStmt *)tmp84.obj;
    v_dot_checker__Checker_expr(c, it->expr);
  } else if (tmp84.typ == SumType_v_dot_ast__Stmt_FnDecl) {
    v_dot_ast__FnDecl *it = (v_dot_ast__FnDecl *)tmp84.obj;
    c->fn_return_type = it->return_type;
    array_v_dot_ast__Stmt tmp88 = it->stmts;
    for (int tmp89 = 0; tmp89 < tmp88.len; tmp89++) {
      v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp88.data)[tmp89];

      v_dot_checker__Checker_stmt(c, stmt);
    };
  } else if (tmp84.typ == SumType_v_dot_ast__Stmt_ForStmt) {
    v_dot_ast__ForStmt *it = (v_dot_ast__ForStmt *)tmp84.obj;
    v_dot_table__Type typ = v_dot_checker__Checker_expr(c, it->cond);
    if (!it->is_inf &&
        v_dot_table__type_idx(typ) != v_dot_table__bool_type_idx) {
      v_dot_checker__Checker_error(c, tos3("non-bool used as for condition"),
                                   it->pos);
    };
    array_v_dot_ast__Stmt tmp90 = it->stmts;
    for (int tmp91 = 0; tmp91 < tmp90.len; tmp91++) {
      v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp90.data)[tmp91];

      v_dot_checker__Checker_stmt(c, stmt);
    };
  } else if (tmp84.typ == SumType_v_dot_ast__Stmt_ForCStmt) {
    v_dot_ast__ForCStmt *it = (v_dot_ast__ForCStmt *)tmp84.obj;
    v_dot_checker__Checker_stmt(c, it->init);
    v_dot_checker__Checker_expr(c, it->cond);
    v_dot_checker__Checker_expr(c, it->inc);
    array_v_dot_ast__Stmt tmp92 = it->stmts;
    for (int tmp93 = 0; tmp93 < tmp92.len; tmp93++) {
      v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp92.data)[tmp93];

      v_dot_checker__Checker_stmt(c, stmt);
    };
  } else if (tmp84.typ == SumType_v_dot_ast__Stmt_ForInStmt) {
    v_dot_ast__ForInStmt *it = (v_dot_ast__ForInStmt *)tmp84.obj;
    v_dot_checker__Checker_expr(c, it->cond);
    v_dot_checker__Checker_expr(c, it->high);
  } else if (tmp84.typ == SumType_v_dot_ast__Stmt_Import) {
    v_dot_ast__Import *it = (v_dot_ast__Import *)tmp84.obj;
  } else if (tmp84.typ == SumType_v_dot_ast__Stmt_Return) {
    v_dot_ast__Return *it = (v_dot_ast__Return *)tmp84.obj;
    v_dot_checker__Checker_return_stmt(c, it);
  } else if (tmp84.typ == SumType_v_dot_ast__Stmt_UnsafeStmt) {
    v_dot_ast__UnsafeStmt *it = (v_dot_ast__UnsafeStmt *)tmp84.obj;
    array_v_dot_ast__Stmt tmp94 = it->stmts;
    for (int tmp95 = 0; tmp95 < tmp94.len; tmp95++) {
      v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp94.data)[tmp95];

      v_dot_checker__Checker_stmt(c, stmt);
    };
  } else // default:
  {
  };
}
void v_dot_checker__Checker_stmts(v_dot_checker__Checker *c,
                                  array_v_dot_ast__Stmt stmts) {
  array_v_dot_ast__Stmt tmp96 = stmts;
  for (int tmp97 = 0; tmp97 < tmp96.len; tmp97++) {
    v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp96.data)[tmp97];

    v_dot_checker__Checker_stmt(c, stmt);
  };
}
v_dot_table__Type v_dot_checker__Checker_expr(v_dot_checker__Checker *c,
                                              v_dot_ast__Expr node) {
  v_dot_ast__Expr tmp98 = node;

  if (tmp98.typ == SumType_v_dot_ast__Expr_ArrayInit) {
    v_dot_ast__ArrayInit *it = (v_dot_ast__ArrayInit *)tmp98.obj;
    return v_dot_checker__Checker_array_init(c, it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_AsCast) {
    v_dot_ast__AsCast *it = (v_dot_ast__AsCast *)tmp98.obj;
    return it->typ;
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_AssignExpr) {
    v_dot_ast__AssignExpr *it = (v_dot_ast__AssignExpr *)tmp98.obj;
    v_dot_checker__Checker_assign_expr(c, it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_Assoc) {
    v_dot_ast__Assoc *it = (v_dot_ast__Assoc *)tmp98.obj;
    v_dot_ast__Scope *scope =
        v_dot_ast__Scope_innermost(&/* ? */ *c->file.scope, it->pos.pos);
    Option_v_dot_ast__Var tmp99 =
        v_dot_ast__Scope_find_var(&/* ? */ *scope, it->var_name);
    v_dot_ast__Var var;
    if (!tmp99.ok) {
      string err = tmp99.error;
      int errcode = tmp99.ecode;
      v_panic(err);
    }
    var = *(v_dot_ast__Var *)tmp99.data;
    ;
    return var.typ;
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_BoolLiteral) {
    v_dot_ast__BoolLiteral *it = (v_dot_ast__BoolLiteral *)tmp98.obj;
    return v_dot_table__bool_type;
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_CastExpr) {
    v_dot_ast__CastExpr *it = (v_dot_ast__CastExpr *)tmp98.obj;
    it->expr_type = v_dot_checker__Checker_expr(c, it->expr);
    if (it->has_arg) {
      v_dot_checker__Checker_expr(c, it->arg);
    };
    return it->typ;
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_CallExpr) {
    v_dot_ast__CallExpr *it = (v_dot_ast__CallExpr *)tmp98.obj;
    return v_dot_checker__Checker_call_expr(c, it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_CharLiteral) {
    v_dot_ast__CharLiteral *it = (v_dot_ast__CharLiteral *)tmp98.obj;
    return v_dot_table__byte_type;
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_EnumVal) {
    v_dot_ast__EnumVal *it = (v_dot_ast__EnumVal *)tmp98.obj;
    return v_dot_checker__Checker_enum_val(c, it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_FloatLiteral) {
    v_dot_ast__FloatLiteral *it = (v_dot_ast__FloatLiteral *)tmp98.obj;
    return v_dot_table__f64_type;
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_Ident) {
    v_dot_ast__Ident *it = (v_dot_ast__Ident *)tmp98.obj;
    return v_dot_checker__Checker_ident(c, it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_IfExpr) {
    v_dot_ast__IfExpr *it = (v_dot_ast__IfExpr *)tmp98.obj;
    return v_dot_checker__Checker_if_expr(c, it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_IfGuardExpr) {
    v_dot_ast__IfGuardExpr *it = (v_dot_ast__IfGuardExpr *)tmp98.obj;
    return v_dot_table__bool_type;
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_IndexExpr) {
    v_dot_ast__IndexExpr *it = (v_dot_ast__IndexExpr *)tmp98.obj;
    return v_dot_checker__Checker_index_expr(c, it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_InfixExpr) {
    v_dot_ast__InfixExpr *it = (v_dot_ast__InfixExpr *)tmp98.obj;
    return v_dot_checker__Checker_infix_expr(c, it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_IntegerLiteral) {
    v_dot_ast__IntegerLiteral *it = (v_dot_ast__IntegerLiteral *)tmp98.obj;
    return v_dot_table__int_type;
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_MapInit) {
    v_dot_ast__MapInit *it = (v_dot_ast__MapInit *)tmp98.obj;
    return v_dot_checker__Checker_map_init(c, it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_MatchExpr) {
    v_dot_ast__MatchExpr *it = (v_dot_ast__MatchExpr *)tmp98.obj;
    return v_dot_checker__Checker_match_expr(c, it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_MethodCallExpr) {
    v_dot_ast__MethodCallExpr *it = (v_dot_ast__MethodCallExpr *)tmp98.obj;
    return v_dot_checker__Checker_method_call_expr(c, it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_PostfixExpr) {
    v_dot_ast__PostfixExpr *it = (v_dot_ast__PostfixExpr *)tmp98.obj;
    return v_dot_checker__Checker_postfix_expr(c, *it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_PrefixExpr) {
    v_dot_ast__PrefixExpr *it = (v_dot_ast__PrefixExpr *)tmp98.obj;
    if (it->op == v_dot_token__v_dot_token__Kind_amp) {
      c->is_amp = 1;
    };
    v_dot_table__Type res = v_dot_checker__Checker_expr(c, it->right);
    c->is_amp = 0;
    return res;
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_None) {
    v_dot_ast__None *it = (v_dot_ast__None *)tmp98.obj;
    return v_dot_table__none_type;
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_ParExpr) {
    v_dot_ast__ParExpr *it = (v_dot_ast__ParExpr *)tmp98.obj;
    return v_dot_checker__Checker_expr(c, it->expr);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_SelectorExpr) {
    v_dot_ast__SelectorExpr *it = (v_dot_ast__SelectorExpr *)tmp98.obj;
    return v_dot_checker__Checker_selector_expr(c, it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_SizeOf) {
    v_dot_ast__SizeOf *it = (v_dot_ast__SizeOf *)tmp98.obj;
    return v_dot_table__int_type;
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_StringLiteral) {
    v_dot_ast__StringLiteral *it = (v_dot_ast__StringLiteral *)tmp98.obj;
    return v_dot_table__string_type;
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_StructInit) {
    v_dot_ast__StructInit *it = (v_dot_ast__StructInit *)tmp98.obj;
    return v_dot_checker__Checker_check_struct_init(c, *it);
  } else if (tmp98.typ == SumType_v_dot_ast__Expr_Type) {
    v_dot_ast__Type *it = (v_dot_ast__Type *)tmp98.obj;
    return it->typ;
  } else // default:
  {
  };
  return v_dot_table__void_type;
}
v_dot_table__Type v_dot_checker__Checker_ident(v_dot_checker__Checker *c,
                                               v_dot_ast__Ident *ident) {
  if (ident->kind == v_dot_ast__v_dot_ast__IdentKind_variable) {
    v_dot_ast__IdentVar info = *(v_dot_ast__IdentVar *)ident->info.obj;
    if (info.typ != 0) {
      return info.typ;
    };
    v_dot_ast__Scope *start_scope =
        v_dot_ast__Scope_innermost(&/* ? */ *c->file.scope, ident->pos.pos);
    bool found = 1;
    v_dot_ast__Scope *var_scope = ((v_dot_ast__Scope *)(0));
    v_dot_ast__Var var = (v_dot_ast__Var){
        .name = tos3(""),
        .is_mut = 0,
    };
    Option__V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var tmp100 =
        v_dot_ast__Scope_find_scope_and_var(&/* ? */ *start_scope, ident->name);
    _V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var _V_mret_3815_var_scope_var;
    if (!tmp100.ok) {
      string err = tmp100.error;
      int errcode = tmp100.ecode;
      found = 0;
      v_dot_checker__Checker_error(c,
                                   _STR("not found: %.*s - POS: %d",
                                        ident->name.len, ident->name.str,
                                        ident->pos.pos),
                                   ident->pos);
      v_panic(tos3(""));
    }
    _V_mret_3815_var_scope_var =
        *(_V_MulRet_v_dot_ast__Scope_PTR__V_v_dot_ast__Var *)tmp100.data;
    ;
    var_scope = _V_mret_3815_var_scope_var.var_0;
    var = _V_mret_3815_var_scope_var.var_1;
    if (found) {
      v_dot_table__Type typ = var.typ;
      if (typ == 0) {
        typ = v_dot_checker__Checker_expr(c, var.expr);
        var.typ = typ;
        v_dot_ast__Scope_override_var(var_scope, var);
      };
      ident->kind = v_dot_ast__v_dot_ast__IdentKind_variable;
      ident->info = /*SUM TYPE CAST2*/ (v_dot_ast__IdentInfo){
          .obj = memdup(&(v_dot_ast__IdentVar[]){(v_dot_ast__IdentVar){
                            .typ = typ,
                            .is_optional = v_dot_table__type_is_optional(typ),
                            .is_mut = 0,
                            .is_static = 0,
                        }},
                        sizeof(v_dot_ast__IdentVar)),
          .typ = SumType_v_dot_ast__IdentInfo_IdentVar};
      if (v_dot_table__type_is_optional(typ)) {
        return v_dot_table__type_clear_extra(typ);
      };
      return typ;
    };
  } else if (ident->kind == v_dot_ast__v_dot_ast__IdentKind_constant) {
    v_dot_ast__IdentVar info = *(v_dot_ast__IdentVar *)ident->info.obj;
    return info.typ;
  } else if (ident->kind == v_dot_ast__v_dot_ast__IdentKind_function) {
    v_dot_ast__IdentFn info = *(v_dot_ast__IdentFn *)ident->info.obj;
    return info.typ;
  } else if (ident->kind == v_dot_ast__v_dot_ast__IdentKind_unresolved) {
    string name = ident->name;
    if (!string_contains(name, tos3(".")) &&
        !((string_eq(c->file.mod.name, tos3("builtin")) ||
           string_eq(c->file.mod.name, tos3("main"))))) {
      name = _STR("%.*s.%.*s", c->file.mod.name.len, c->file.mod.name.str,
                  ident->name.len, ident->name.str);
    };
    Option_v_dot_table__Var tmp101 =
        v_dot_table__Table_find_const(&/* ? */ *c->table, name);

    if (tmp101.ok) {
      v_dot_table__Var constant = *(v_dot_table__Var *)tmp101.data;
      ident->name = name;
      ident->kind = v_dot_ast__v_dot_ast__IdentKind_constant;
      ident->info = /*SUM TYPE CAST2*/ (v_dot_ast__IdentInfo){
          .obj = memdup(&(v_dot_ast__IdentVar[]){(v_dot_ast__IdentVar){
                            .typ = constant.typ,
                            .is_mut = 0,
                            .is_static = 0,
                            .is_optional = 0}},
                        sizeof(v_dot_ast__IdentVar)),
          .typ = SumType_v_dot_ast__IdentInfo_IdentVar};
      return constant.typ;
    };
    Option_v_dot_table__Fn tmp102 =
        v_dot_table__Table_find_fn(&/* ? */ *c->table, name);

    if (tmp102.ok) {
      v_dot_table__Fn func = *(v_dot_table__Fn *)tmp102.data;
      int fn_type = v_dot_table__Table_find_or_register_fn_type(c->table, func);
      ident->name = name;
      ident->kind = v_dot_ast__v_dot_ast__IdentKind_function;
      ident->info = /*SUM TYPE CAST2*/ (v_dot_ast__IdentInfo){
          .obj = memdup(
              &(v_dot_ast__IdentFn[]){(v_dot_ast__IdentFn){.typ = fn_type}},
              sizeof(v_dot_ast__IdentFn)),
          .typ = SumType_v_dot_ast__IdentInfo_IdentFn};
      return fn_type;
    };
  };
  if (ident->is_c) {
    return v_dot_table__int_type;
  };
  return v_dot_table__void_type;
}
v_dot_table__Type
v_dot_checker__Checker_match_expr(v_dot_checker__Checker *c,
                                  v_dot_ast__MatchExpr *node) {
  v_dot_table__Type expr_type = v_dot_checker__Checker_expr(c, node->cond);
  if (expr_type == 0) {
    v_dot_checker__Checker_error(c, tos3("match 0 expr type"), node->pos);
  };
  c->expected_type = expr_type;
  v_dot_table__Type ret_type = v_dot_table__void_type;
  array_v_dot_ast__MatchBranch tmp103 = node->branches;
  for (int tmp104 = 0; tmp104 < tmp103.len; tmp104++) {
    v_dot_ast__MatchBranch branch =
        ((v_dot_ast__MatchBranch *)tmp103.data)[tmp104];

    array_v_dot_ast__Expr tmp105 = branch.exprs;
    for (int tmp106 = 0; tmp106 < tmp105.len; tmp106++) {
      v_dot_ast__Expr expr = ((v_dot_ast__Expr *)tmp105.data)[tmp106];

      c->expected_type = expr_type;
      v_dot_table__Type typ = v_dot_checker__Checker_expr(c, expr);
      v_dot_table__TypeSymbol *typ_sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, typ);
      if (typ_sym->kind == v_dot_table__v_dot_table__Kind_sum_type) {
      };
    };
    v_dot_checker__Checker_stmts(c, branch.stmts);
    if (branch.stmts.len > 0) {
      v_dot_ast__Stmt tmp109 =
          (*(v_dot_ast__Stmt *)array_get(branch.stmts, branch.stmts.len - 1));

      if (tmp109.typ == SumType_v_dot_ast__Stmt_ExprStmt) {
        v_dot_ast__ExprStmt *it = (v_dot_ast__ExprStmt *)tmp109.obj;
        ret_type = v_dot_checker__Checker_expr(c, it->expr);
      } else // default:
      {
      };
    };
  };
  node->expr_type = expr_type;
  return ret_type;
}
v_dot_table__Type v_dot_checker__Checker_if_expr(v_dot_checker__Checker *c,
                                                 v_dot_ast__IfExpr *node) {
  v_dot_table__Type typ = v_dot_checker__Checker_expr(c, node->cond);
  node->typ = typ;
  v_dot_table__TypeSymbol *typ_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, typ);
  if (v_dot_table__type_idx(typ) != v_dot_table__bool_type_idx) {
    v_dot_checker__Checker_error(c,
                                 _STR("non-bool (`%.*s`) used as if condition",
                                      typ_sym->name.len, typ_sym->name.str),
                                 node->pos);
  };
  array_v_dot_ast__Stmt tmp110 = node->stmts;
  for (int i = 0; i < tmp110.len; i++) {
    v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp110.data)[i];

    v_dot_checker__Checker_stmt(c, stmt);
  };
  if (node->else_stmts.len > 0) {
    array_v_dot_ast__Stmt tmp111 = node->else_stmts;
    for (int tmp112 = 0; tmp112 < tmp111.len; tmp112++) {
      v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp111.data)[tmp112];

      v_dot_checker__Checker_stmt(c, stmt);
    };
  };
  if (node->stmts.len > 0) {
    v_dot_ast__Stmt tmp115 =
        (*(v_dot_ast__Stmt *)array_get(node->stmts, node->stmts.len - 1));

    if (tmp115.typ == SumType_v_dot_ast__Stmt_ExprStmt) {
      v_dot_ast__ExprStmt *it = (v_dot_ast__ExprStmt *)tmp115.obj;
      v_dot_table__Type t = v_dot_checker__Checker_expr(c, it->expr);
      node->typ = t;
      return t;
    } else // default:
    {
    };
  };
  return typ;
}
v_dot_table__Type
v_dot_checker__Checker_postfix_expr(v_dot_checker__Checker *c,
                                    v_dot_ast__PostfixExpr node) {
  v_dot_table__Type typ = v_dot_checker__Checker_expr(c, node.expr);
  v_dot_table__TypeSymbol *typ_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, typ);
  if (!v_dot_table__TypeSymbol_is_number(&/* ? */ *typ_sym)) {
    println(v_dot_table__Kind_str(typ_sym->kind));
    v_dot_checker__Checker_error(
        c,
        _STR("invalid operation: %.*s (non-numeric type `%.*s`)",
             v_dot_token__Kind_str(node.op).len,
             v_dot_token__Kind_str(node.op).str, typ_sym->name.len,
             typ_sym->name.str),
        node.pos);
  };
  return typ;
}
v_dot_table__Type
v_dot_checker__Checker_index_expr(v_dot_checker__Checker *c,
                                  v_dot_ast__IndexExpr *node) {
  v_dot_table__Type typ = v_dot_checker__Checker_expr(c, node->left);
  bool is_range = 0;
  v_dot_ast__Expr tmp116 = node->index;

  if (tmp116.typ == SumType_v_dot_ast__Expr_RangeExpr) {
    v_dot_ast__RangeExpr *it = (v_dot_ast__RangeExpr *)tmp116.obj;
    is_range = 1;
    if (it->has_low) {
      v_dot_checker__Checker_expr(c, it->low);
    };
    if (it->has_high) {
      v_dot_checker__Checker_expr(c, it->high);
    };
  } else // default:
  {
  };
  node->container_type = typ;
  if (!is_range) {
    v_dot_table__TypeSymbol *typ_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, typ);
    v_dot_table__Type index_type = v_dot_checker__Checker_expr(c, node->index);
    v_dot_table__TypeSymbol *index_type_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, index_type);
    if (typ_sym->kind == v_dot_table__v_dot_table__Kind_array &&
        (!((_IN(int, (v_dot_table__type_idx(index_type)),
                v_dot_table__number_idxs))) &&
         index_type_sym->kind != v_dot_table__v_dot_table__Kind_enum_)) {
      v_dot_checker__Checker_error(
          c,
          _STR("non-integer index `%.*s` (array type `%.*s`)",
               index_type_sym->name.len, index_type_sym->name.str,
               typ_sym->name.len, typ_sym->name.str),
          node->pos);
    } else if (typ_sym->kind == v_dot_table__v_dot_table__Kind_map &&
               v_dot_table__type_idx(index_type) !=
                   v_dot_table__string_type_idx) {
      v_dot_checker__Checker_error(c,
                                   _STR("non-string map index (type `%.*s`)",
                                        typ_sym->name.len, typ_sym->name.str),
                                   node->pos);
    };
    if (typ_sym->kind == v_dot_table__v_dot_table__Kind_array) {
      v_dot_table__Array info = *(v_dot_table__Array *)typ_sym->info.obj;
      return info.elem_type;
    } else if (typ_sym->kind == v_dot_table__v_dot_table__Kind_array_fixed) {
      v_dot_table__ArrayFixed info =
          *(v_dot_table__ArrayFixed *)typ_sym->info.obj;
      return info.elem_type;
    } else if (typ_sym->kind == v_dot_table__v_dot_table__Kind_map) {
      v_dot_table__Map info = *(v_dot_table__Map *)typ_sym->info.obj;
      return info.value_type;
    } else if ((typ_sym->kind == v_dot_table__v_dot_table__Kind_byteptr ||
                typ_sym->kind == v_dot_table__v_dot_table__Kind_string)) {
      return v_dot_table__byte_type;
    } else if (v_dot_table__type_is_ptr(typ)) {
      return v_dot_table__type_deref(typ);
    };
  };
  return typ;
}
v_dot_table__Type v_dot_checker__Checker_enum_val(v_dot_checker__Checker *c,
                                                  v_dot_ast__EnumVal *node) {
  int typ_idx = ((string_eq(node->enum_name, tos3("")))
                     ? (c->expected_type)
                     : (v_dot_table__Table_find_type_idx(&/* ? */ *c->table,
                                                         node->enum_name)));
  if (typ_idx == 0) {
    v_dot_checker__Checker_error(c,
                                 _STR("not an enum (name=%.*s) (type_idx=0)",
                                      node->enum_name.len, node->enum_name.str),
                                 node->pos);
  };
  v_dot_table__Type typ = ((v_dot_table__Type)(typ_idx));
  v_dot_table__TypeSymbol *typ_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, typ);
  if (typ_sym->kind != v_dot_table__v_dot_table__Kind_enum_) {
    v_dot_checker__Checker_error(c, tos3("not an enum"), node->pos);
  };
  v_dot_table__Enum info = v_dot_table__TypeSymbol_enum_info(&/* ? */ *typ_sym);
  if (!((_IN(string, (node->val), info.vals)))) {
    v_dot_checker__Checker_error(
        c,
        _STR("enum `%.*s` does not have a value `%.*s`", typ_sym->name.len,
             typ_sym->name.str, node->val.len, node->val.str),
        node->pos);
  };
  node->typ = typ;
  return typ;
}
v_dot_table__Type v_dot_checker__Checker_map_init(v_dot_checker__Checker *c,
                                                  v_dot_ast__MapInit *node) {
  if (node->typ != 0) {
    v_dot_table__Map info = v_dot_table__TypeSymbol_map_info(
        &/* ? */ *v_dot_table__Table_get_type_symbol(&/* ? */ *c->table,
                                                     node->typ));
    node->key_type = info.key_type;
    node->value_type = info.value_type;
    return node->typ;
  };
  v_dot_table__Type key0_type = v_dot_checker__Checker_expr(
      c, (*(v_dot_ast__Expr *)array_get(node->keys, 0)));
  v_dot_table__Type val0_type = v_dot_checker__Checker_expr(
      c, (*(v_dot_ast__Expr *)array_get(node->vals, 0)));
  array_v_dot_ast__Expr tmp121 = node->keys;
  for (int i = 0; i < tmp121.len; i++) {
    v_dot_ast__Expr key = ((v_dot_ast__Expr *)tmp121.data)[i];

    if (i == 0) {
      continue;
    };
    v_dot_ast__Expr val = (*(v_dot_ast__Expr *)array_get(node->vals, i));
    v_dot_table__Type key_type = v_dot_checker__Checker_expr(c, key);
    v_dot_table__Type val_type = v_dot_checker__Checker_expr(c, val);
    if (!v_dot_table__Table_check(&/* ? */ *c->table, key_type, key0_type)) {
      v_dot_table__TypeSymbol *key0_type_sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, key0_type);
      v_dot_table__TypeSymbol *key_type_sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, key_type);
      v_dot_checker__Checker_error(
          c,
          _STR("map init: cannot use `%.*s` as `%p` for map key",
               key_type_sym->name.len, key_type_sym->name.str, key0_type_sym),
          node->pos);
    };
    if (!v_dot_table__Table_check(&/* ? */ *c->table, val_type, val0_type)) {
      v_dot_table__TypeSymbol *val0_type_sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, val0_type);
      v_dot_table__TypeSymbol *val_type_sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *c->table, val_type);
      v_dot_checker__Checker_error(
          c,
          _STR("map init: cannot use `%.*s` as `%p` for map value",
               val_type_sym->name.len, val_type_sym->name.str, val0_type_sym),
          node->pos);
    };
  };
  v_dot_table__Type map_type = v_dot_table__new_type(
      v_dot_table__Table_find_or_register_map(c->table, key0_type, val0_type));
  node->typ = map_type;
  node->key_type = key0_type;
  node->value_type = val0_type;
  return map_type;
}
void v_dot_checker__Checker_error(v_dot_checker__Checker *c, string s,
                                  v_dot_token__Position pos) {
  c->nr_errors++;
  print_backtrace();
  string path = c->file.path;
  string workdir = string_add(os__getwd(), os__path_separator);
  if (string_starts_with(path, workdir)) {
    path = string_replace(path, workdir, tos3(""));
  };
  string final_msg_line =
      _STR("%.*s:%d: checker error #%d: %.*s", path.len, path.str, pos.line_nr,
           c->nr_errors, s.len, s.str);
  _PUSH(&c->errors, (/*typ = array_string   tmp_typ=string*/ final_msg_line),
        tmp124, string);
  eprintln(final_msg_line);
  println(tos3("\n\n"));
  if (c->nr_errors >= v_dot_checker__max_nr_errors) {
    v_exit(1);
  };
}
string v_dot_gen__cgen(array_v_dot_ast__File files, v_dot_table__Table *table) {
  println(tos3("start cgen2"));
  v_dot_gen__Gen g =
      (v_dot_gen__Gen){.out = strings__new_builder(100),
                       .typedefs = strings__new_builder(100),
                       .definitions = strings__new_builder(100),
                       .table = table,
                       .fn_decl = 0,
                       .tmp_count = 0,
                       .varaidic_args = new_map(1, sizeof(int)),
                       .is_c_call = 0,
                       .is_assign_expr = 0,
                       .is_array_set = 0,
                       .is_amp = 0,
                       .optionals = new_array(0, 1, sizeof(string))};
  v_dot_gen__Gen_init(&/* ? */ g);
  array_v_dot_ast__File tmp1 = files;
  for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
    v_dot_ast__File file = ((v_dot_ast__File *)tmp1.data)[tmp2];

    v_dot_gen__Gen_stmts(&/* ? */ g, file.stmts);
  };
  v_dot_gen__Gen_write_variadic_types(&/* ? */ g);
  return string_add(string_add(strings__Builder_str(&/* ? */ g.typedefs),
                               strings__Builder_str(&/* ? */ g.definitions)),
                    strings__Builder_str(&/* ? */ g.out));
}
void v_dot_gen__Gen_init(v_dot_gen__Gen *g) {
  strings__Builder_writeln(&/* ? */ g->definitions,
                           tos3("// Generated by the V compiler"));
  strings__Builder_writeln(&/* ? */ g->definitions,
                           tos3("#include <inttypes.h>"));
  strings__Builder_writeln(&/* ? */ g->definitions, v_dot_gen__c_builtin_types);
  strings__Builder_writeln(&/* ? */ g->definitions, v_dot_gen__c_headers);
  v_dot_gen__Gen_write_builtin_types(g);
  v_dot_gen__Gen_write_typedef_types(g);
  v_dot_gen__Gen_write_sorted_types(g);
  v_dot_gen__Gen_write_multi_return_types(g);
  strings__Builder_writeln(&/* ? */ g->definitions,
                           tos3("// end of definitions #endif"));
}
string v_dot_gen__Gen_typ(v_dot_gen__Gen *g, v_dot_table__Type t) {
  int nr_muls = v_dot_table__type_nr_muls(t);
  v_dot_table__TypeSymbol *sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, t);
  string styp = string_replace_each(
      sym->name, new_array_from_c_array(
                     2, 2, sizeof(string),
                     EMPTY_ARRAY_OF_ELEMS(string, 2){tos3("."), tos3("__")}));
  if (nr_muls > 0) {
    styp = string_add(styp, strings__repeat('*', nr_muls));
  };
  if (string_starts_with(styp, tos3("C__"))) {
    styp = string_substr2(styp, 3, -1, true);
  };
  if ((string_eq(styp, tos3("stat")) || string_eq(styp, tos3("dirent*")) ||
       string_eq(styp, tos3("tm")))) {
    styp = _STR("struct %.*s", styp.len, styp.str);
  };
  if (v_dot_table__type_is_optional(t)) {
    styp = string_add(tos3("Option_"), styp);
    if (!((_IN(string, (styp), g->optionals)))) {
      strings__Builder_writeln(
          &/* ? */ g->definitions,
          _STR("typedef Option %.*s;", styp.len, styp.str));
      _PUSH(&g->optionals, (/*typ = array_string   tmp_typ=string*/ styp), tmp5,
            string);
    };
  };
  return styp;
}
void v_dot_gen__Gen_write_typedef_types(v_dot_gen__Gen *g) {
  array_v_dot_table__TypeSymbol tmp6 = g->table->types;
  for (int tmp7 = 0; tmp7 < tmp6.len; tmp7++) {
    v_dot_table__TypeSymbol typ = ((v_dot_table__TypeSymbol *)tmp6.data)[tmp7];

    v_dot_table__Kind tmp8 = typ.kind;

    if (tmp8 == v_dot_table__v_dot_table__Kind_alias) {
      v_dot_table__TypeSymbol *parent = &(*(v_dot_table__TypeSymbol *)array_get(
          g->table->types, typ.parent_idx));
      string styp = string_replace(typ.name, tos3("."), tos3("__"));
      string parent_styp = string_replace(parent->name, tos3("."), tos3("__"));
      strings__Builder_writeln(&/* ? */ g->definitions,
                               _STR("typedef %.*s %.*s;", parent_styp.len,
                                    parent_styp.str, styp.len, styp.str));
    } else if (tmp8 == v_dot_table__v_dot_table__Kind_array) {
      string styp = string_replace(typ.name, tos3("."), tos3("__"));
      strings__Builder_writeln(&/* ? */ g->definitions,
                               _STR("typedef array %.*s;", styp.len, styp.str));
    } else if (tmp8 == v_dot_table__v_dot_table__Kind_array_fixed) {
      string styp = string_replace(typ.name, tos3("."), tos3("__"));
      string fixed = string_substr2(styp, 12, -1, true);
      string len = string_after(styp, tos3("_"));
      fixed = string_substr2(fixed, 0, fixed.len - len.len - 1, false);
      strings__Builder_writeln(&/* ? */ g->definitions,
                               _STR("typedef %.*s %.*s [%.*s];", fixed.len,
                                    fixed.str, styp.len, styp.str, len.len,
                                    len.str));
    } else if (tmp8 == v_dot_table__v_dot_table__Kind_map) {
      string styp = string_replace(typ.name, tos3("."), tos3("__"));
      strings__Builder_writeln(&/* ? */ g->definitions,
                               _STR("typedef map %.*s;", styp.len, styp.str));
    } else if (tmp8 == v_dot_table__v_dot_table__Kind_function) {
    } else // default:
    {
      continue;
    };
  };
}
void v_dot_gen__Gen_write_multi_return_types(v_dot_gen__Gen *g) {
  strings__Builder_writeln(&/* ? */ g->definitions,
                           tos3("// multi return structs"));
  array_v_dot_table__TypeSymbol tmp15 = g->table->types;
  for (int tmp16 = 0; tmp16 < tmp15.len; tmp16++) {
    v_dot_table__TypeSymbol typ =
        ((v_dot_table__TypeSymbol *)tmp15.data)[tmp16];

    if (typ.kind != v_dot_table__v_dot_table__Kind_multi_return) {
      continue;
    };
    string name = string_replace(typ.name, tos3("."), tos3("__"));
    v_dot_table__MultiReturn info = *(v_dot_table__MultiReturn *)typ.info.obj;
    strings__Builder_writeln(&/* ? */ g->definitions, tos3("typedef struct {"));
    array_v_dot_table__Type tmp17 = info.types;
    for (int i = 0; i < tmp17.len; i++) {
      v_dot_table__Type mr_typ = ((v_dot_table__Type *)tmp17.data)[i];

      string type_name = v_dot_gen__Gen_typ(g, mr_typ);
      strings__Builder_writeln(
          &/* ? */ g->definitions,
          _STR("\t%.*s arg%d;", type_name.len, type_name.str, i));
    };
    strings__Builder_writeln(&/* ? */ g->definitions,
                             _STR("} %.*s;\n", name.len, name.str));
  };
}
void v_dot_gen__Gen_write_variadic_types(v_dot_gen__Gen *g) {
  if (g->varaidic_args.size > 0) {
    strings__Builder_writeln(&/* ? */ g->definitions,
                             tos3("// variadic structs"));
  };
  map_int tmp18 = g->varaidic_args;
  array_string keys_tmp18 = map_keys(&tmp18);
  for (int l = 0; l < keys_tmp18.len; l++) {
    string type_str = ((string *)keys_tmp18.data)[l];
    int arg_len = 0;
    map_get(tmp18, type_str, &arg_len);

    v_dot_table__Type typ = ((v_dot_table__Type)(v_string_int(type_str)));
    string type_name = v_dot_gen__Gen_typ(g, typ);
    string struct_name = string_add(
        tos3("varg_"), string_replace(type_name, tos3("*"), tos3("_ptr")));
    strings__Builder_writeln(
        &/* ? */ g->definitions,
        _STR("struct %.*s {", struct_name.len, struct_name.str));
    strings__Builder_writeln(&/* ? */ g->definitions, tos3("\tint len;"));
    strings__Builder_writeln(
        &/* ? */ g->definitions,
        _STR("\t%.*s args[%d];", type_name.len, type_name.str, arg_len));
    strings__Builder_writeln(&/* ? */ g->definitions, tos3("};\n"));
    strings__Builder_writeln(&/* ? */ g->typedefs,
                             _STR("typedef struct %.*s %.*s;", struct_name.len,
                                  struct_name.str, struct_name.len,
                                  struct_name.str));
  };
}
void v_dot_gen__Gen_save(v_dot_gen__Gen *g) {}
void v_dot_gen__Gen_write(v_dot_gen__Gen *g, string s) {
  strings__Builder_write(&/* ? */ g->out, s);
}
void v_dot_gen__Gen_writeln(v_dot_gen__Gen *g, string s) {
  strings__Builder_writeln(&/* ? */ g->out, s);
}
string v_dot_gen__Gen_new_tmp_var(v_dot_gen__Gen *g) {
  g->tmp_count++;
  return _STR("tmp%d", g->tmp_count);
}
void v_dot_gen__Gen_reset_tmp_count(v_dot_gen__Gen *g) { g->tmp_count = 0; }
void v_dot_gen__Gen_stmts(v_dot_gen__Gen *g, array_v_dot_ast__Stmt stmts) {
  array_v_dot_ast__Stmt tmp19 = stmts;
  for (int tmp20 = 0; tmp20 < tmp19.len; tmp20++) {
    v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp19.data)[tmp20];

    v_dot_gen__Gen_stmt(g, stmt);
    v_dot_gen__Gen_writeln(g, tos3(""));
  };
}
void v_dot_gen__Gen_stmt(v_dot_gen__Gen *g, v_dot_ast__Stmt node) {
  v_dot_ast__Stmt tmp21 = node;

  if (tmp21.typ == SumType_v_dot_ast__Stmt_AssignStmt) {
    v_dot_ast__AssignStmt *it = (v_dot_ast__AssignStmt *)tmp21.obj;
    v_dot_gen__Gen_gen_assign_stmt(g, *it);
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_AssertStmt) {
    v_dot_ast__AssertStmt *it = (v_dot_ast__AssertStmt *)tmp21.obj;
    v_dot_gen__Gen_writeln(g, tos3("// assert"));
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_Attr) {
    v_dot_ast__Attr *it = (v_dot_ast__Attr *)tmp21.obj;
    v_dot_gen__Gen_writeln(g, _STR("//[%.*s]", it->name.len, it->name.str));
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_BranchStmt) {
    v_dot_ast__BranchStmt *it = (v_dot_ast__BranchStmt *)tmp21.obj;
    v_dot_gen__Gen_write(g, v_dot_token__Kind_str(it->tok.kind));
    v_dot_gen__Gen_writeln(g, tos3(";"));
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_ConstDecl) {
    v_dot_ast__ConstDecl *it = (v_dot_ast__ConstDecl *)tmp21.obj;
    v_dot_gen__Gen_const_decl(g, *it);
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_CompIf) {
    v_dot_ast__CompIf *it = (v_dot_ast__CompIf *)tmp21.obj;
    v_dot_gen__Gen_writeln(g, tos3("//#ifdef "));
    v_dot_gen__Gen_expr(g, it->cond);
    v_dot_gen__Gen_stmts(g, it->stmts);
    v_dot_gen__Gen_writeln(g, tos3("//#endif"));
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_DeferStmt) {
    v_dot_ast__DeferStmt *it = (v_dot_ast__DeferStmt *)tmp21.obj;
    v_dot_gen__Gen_writeln(g, tos3("// defer"));
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_EnumDecl) {
    v_dot_ast__EnumDecl *it = (v_dot_ast__EnumDecl *)tmp21.obj;
    v_dot_gen__Gen_writeln(g, tos3("//"));
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_ExprStmt) {
    v_dot_ast__ExprStmt *it = (v_dot_ast__ExprStmt *)tmp21.obj;
    v_dot_gen__Gen_expr(g, it->expr);
    v_dot_ast__Expr tmp22 = it->expr;

    if (tmp22.typ == SumType_v_dot_ast__Expr_IfExpr) {
      v_dot_ast__IfExpr *it = (v_dot_ast__IfExpr *)tmp22.obj;
    } else // default:
    {
      v_dot_gen__Gen_writeln(g, tos3(";"));
    };
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_FnDecl) {
    v_dot_ast__FnDecl *it = (v_dot_ast__FnDecl *)tmp21.obj;
    g->fn_decl = it;
    v_dot_gen__Gen_gen_fn_decl(g, *it);
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_ForCStmt) {
    v_dot_ast__ForCStmt *it = (v_dot_ast__ForCStmt *)tmp21.obj;
    v_dot_gen__Gen_write(g, tos3("for ("));
    if (!it->has_init) {
      v_dot_gen__Gen_write(g, tos3("; "));
    } else {
      v_dot_gen__Gen_stmt(g, it->init);
    };
    v_dot_gen__Gen_expr(g, it->cond);
    v_dot_gen__Gen_write(g, tos3("; "));
    v_dot_gen__Gen_expr(g, it->inc);
    v_dot_gen__Gen_writeln(g, tos3(") {"));
    array_v_dot_ast__Stmt tmp23 = it->stmts;
    for (int tmp24 = 0; tmp24 < tmp23.len; tmp24++) {
      v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp23.data)[tmp24];

      v_dot_gen__Gen_stmt(g, stmt);
    };
    v_dot_gen__Gen_writeln(g, tos3("}"));
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_ForInStmt) {
    v_dot_ast__ForInStmt *it = (v_dot_ast__ForInStmt *)tmp21.obj;
    if (it->is_range) {
      string i = v_dot_gen__Gen_new_tmp_var(g);
      v_dot_gen__Gen_write(g, _STR("for (int %.*s = ", i.len, i.str));
      v_dot_gen__Gen_expr(g, it->cond);
      v_dot_gen__Gen_write(g, _STR("; %.*s < ", i.len, i.str));
      v_dot_gen__Gen_expr(g, it->high);
      v_dot_gen__Gen_writeln(g, _STR("; %.*s++) { ", i.len, i.str));
      v_dot_gen__Gen_writeln(g, tos3("}"));
    };
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_ForStmt) {
    v_dot_ast__ForStmt *it = (v_dot_ast__ForStmt *)tmp21.obj;
    v_dot_gen__Gen_write(g, tos3("while ("));
    if (it->is_inf) {
      v_dot_gen__Gen_write(g, tos3("1"));
    } else {
      v_dot_gen__Gen_expr(g, it->cond);
    };
    v_dot_gen__Gen_writeln(g, tos3(") {"));
    array_v_dot_ast__Stmt tmp25 = it->stmts;
    for (int tmp26 = 0; tmp26 < tmp25.len; tmp26++) {
      v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp25.data)[tmp26];

      v_dot_gen__Gen_stmt(g, stmt);
    };
    v_dot_gen__Gen_writeln(g, tos3("}"));
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_GlobalDecl) {
    v_dot_ast__GlobalDecl *it = (v_dot_ast__GlobalDecl *)tmp21.obj;
    string styp = v_dot_gen__Gen_typ(g, it->typ);
    strings__Builder_writeln(&/* ? */ g->definitions,
                             _STR("%.*s %.*s; // global", styp.len, styp.str,
                                  it->name.len, it->name.str));
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_GotoLabel) {
    v_dot_ast__GotoLabel *it = (v_dot_ast__GotoLabel *)tmp21.obj;
    v_dot_gen__Gen_writeln(g, _STR("%.*s:", it->name.len, it->name.str));
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_HashStmt) {
    v_dot_ast__HashStmt *it = (v_dot_ast__HashStmt *)tmp21.obj;
    string typ = string_all_before(it->val, tos3(" "));
    if ((string_eq(typ, tos3("include")) || string_eq(typ, tos3("define")))) {
      strings__Builder_writeln(&/* ? */ g->definitions,
                               _STR("#%.*s", it->val.len, it->val.str));
    };
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_Import) {
    v_dot_ast__Import *it = (v_dot_ast__Import *)tmp21.obj;
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_Return) {
    v_dot_ast__Return *it = (v_dot_ast__Return *)tmp21.obj;
    v_dot_gen__Gen_return_statement(g, *it);
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_StructDecl) {
    v_dot_ast__StructDecl *it = (v_dot_ast__StructDecl *)tmp21.obj;
    string name = string_replace(it->name, tos3("."), tos3("__"));
    if (!it->is_c) {
      strings__Builder_writeln(&/* ? */ g->typedefs,
                               _STR("typedef struct %.*s %.*s;", name.len,
                                    name.str, name.len, name.str));
    };
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_TypeDecl) {
    v_dot_ast__TypeDecl *it = (v_dot_ast__TypeDecl *)tmp21.obj;
    v_dot_gen__Gen_writeln(g, tos3("// TypeDecl"));
  } else if (tmp21.typ == SumType_v_dot_ast__Stmt_UnsafeStmt) {
    v_dot_ast__UnsafeStmt *it = (v_dot_ast__UnsafeStmt *)tmp21.obj;
    v_dot_gen__Gen_stmts(g, it->stmts);
  } else // default:
  {
    v_dot_gen__verror(
        string_add(tos3("cgen.stmt(): unhandled node "),
                   tos3(__SumTypeNames__v_dot_ast__Stmt[node.typ])));
  };
}
bool v_dot_gen__Gen_is_sum_cast(v_dot_gen__Gen *g, v_dot_table__Type got_type,
                                v_dot_table__Type exp_type) {
  if (exp_type != v_dot_table__void_type && exp_type != 0 && got_type != 0) {
    v_dot_table__TypeSymbol *exp_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, exp_type);
    if (exp_sym->kind == v_dot_table__v_dot_table__Kind_sum_type) {
      v_dot_table__SumType sum_info =
          *(v_dot_table__SumType *)exp_sym->info.obj;
      if ((_IN(v_dot_table__Type, (got_type), sum_info.variants))) {
        return 1;
      };
    };
  };
  return 0;
}
void v_dot_gen__Gen_sum_cast(v_dot_gen__Gen *g, v_dot_table__Type got_type,
                             v_dot_table__Type exp_type, v_dot_ast__Expr expr) {
  string got_styp = v_dot_gen__Gen_typ(g, got_type);
  string exp_styp = v_dot_gen__Gen_typ(g, exp_type);
  int got_idx = v_dot_table__type_idx(got_type);
  v_dot_gen__Gen_write(
      g, _STR("/* SUM TYPE CAST */ (%.*s) {.obj = memdup(&(%.*s[]) {",
              exp_styp.len, exp_styp.str, got_styp.len, got_styp.str));
  v_dot_gen__Gen_expr(g, expr);
  v_dot_gen__Gen_writeln(g, _STR("}, sizeof(%.*s)), .typ = %d};", got_styp.len,
                                 got_styp.str, got_idx));
}
void v_dot_gen__Gen_gen_assign_stmt(v_dot_gen__Gen *g,
                                    v_dot_ast__AssignStmt assign_stmt) {
  if (assign_stmt.left.len > assign_stmt.right.len) {
    v_dot_table__Type return_type = v_dot_table__void_type;
    v_dot_ast__Expr tmp29 =
        (*(v_dot_ast__Expr *)array_get(assign_stmt.right, 0));

    if (tmp29.typ == SumType_v_dot_ast__Expr_CallExpr) {
      v_dot_ast__CallExpr *it = (v_dot_ast__CallExpr *)tmp29.obj;
      return_type = it->return_type;
    } else if (tmp29.typ == SumType_v_dot_ast__Expr_MethodCallExpr) {
      v_dot_ast__MethodCallExpr *it = (v_dot_ast__MethodCallExpr *)tmp29.obj;
      return_type = it->return_type;
    } else // default:
    {
      v_panic(tos3("expected call"));
    };
    string mr_var_name = _STR("mr_%d", assign_stmt.pos.pos);
    string mr_typ_str = v_dot_gen__Gen_typ(g, return_type);
    v_dot_gen__Gen_write(g, _STR("%.*s %.*s = ", mr_typ_str.len, mr_typ_str.str,
                                 mr_var_name.len, mr_var_name.str));
    v_dot_gen__Gen_expr(g,
                        (*(v_dot_ast__Expr *)array_get(assign_stmt.right, 0)));
    v_dot_gen__Gen_writeln(g, tos3(";"));
    array_v_dot_ast__Ident tmp32 = assign_stmt.left;
    for (int i = 0; i < tmp32.len; i++) {
      v_dot_ast__Ident ident = ((v_dot_ast__Ident *)tmp32.data)[i];

      if (ident.kind == v_dot_ast__v_dot_ast__IdentKind_blank_ident) {
        continue;
      };
      v_dot_ast__IdentVar ident_var_info =
          v_dot_ast__Ident_var_info(&/* ? */ ident);
      string styp = v_dot_gen__Gen_typ(g, ident_var_info.typ);
      if (assign_stmt.op == v_dot_token__v_dot_token__Kind_decl_assign) {
        v_dot_gen__Gen_write(g, _STR("%.*s ", styp.len, styp.str));
      };
      v_dot_gen__Gen_expr(g, /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
                              .obj = memdup(&(v_dot_ast__Ident[]){ident},
                                            sizeof(v_dot_ast__Ident)),
                              .typ = SumType_v_dot_ast__Expr_Ident});
      v_dot_gen__Gen_writeln(
          g, _STR(" = %.*s.arg%d;", mr_var_name.len, mr_var_name.str, i));
    };
  } else {
    array_v_dot_ast__Ident tmp33 = assign_stmt.left;
    for (int i = 0; i < tmp33.len; i++) {
      v_dot_ast__Ident ident = ((v_dot_ast__Ident *)tmp33.data)[i];

      v_dot_ast__Expr val =
          (*(v_dot_ast__Expr *)array_get(assign_stmt.right, i));
      v_dot_ast__IdentVar ident_var_info =
          v_dot_ast__Ident_var_info(&/* ? */ ident);
      string styp = v_dot_gen__Gen_typ(g, ident_var_info.typ);
      if (ident.kind == v_dot_ast__v_dot_ast__IdentKind_blank_ident) {
        v_dot_ast__Expr tmp36 = val;

        bool is_call =
            ((tmp36.typ == SumType_v_dot_ast__Expr_CallExpr)
                 ? (1)
                 : ((tmp36.typ == SumType_v_dot_ast__Expr_MethodCallExpr)
                        ? (1)
                        : (0)));
        if (is_call) {
          v_dot_gen__Gen_expr(g, val);
        } else {
          v_dot_gen__Gen_write(g, _STR("{%.*s _ = ", styp.len, styp.str));
          v_dot_gen__Gen_expr(g, val);
          v_dot_gen__Gen_write(g, tos3("}"));
        };
      } else {
        bool is_fixed_array_init = 0;
        v_dot_ast__Expr tmp37 = val;

        if (tmp37.typ == SumType_v_dot_ast__Expr_ArrayInit) {
          v_dot_ast__ArrayInit *it = (v_dot_ast__ArrayInit *)tmp37.obj;
          is_fixed_array_init =
              v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, it->typ)
                  ->kind == v_dot_table__v_dot_table__Kind_array_fixed;
        } else // default:
        {
        };
        bool is_sum_cast = 0;
        if (assign_stmt.op == v_dot_token__v_dot_token__Kind_decl_assign) {
          v_dot_gen__Gen_write(g, _STR("%.*s ", styp.len, styp.str));
        } else {
          is_sum_cast = v_dot_gen__Gen_is_sum_cast(
              &/* ? */ *g,
              (*(v_dot_table__Type *)array_get(assign_stmt.right_types, i)),
              (*(v_dot_table__Type *)array_get(assign_stmt.left_types, i)));
        };
        v_dot_gen__Gen_expr(g, /*SUM TYPE CAST2*/ (v_dot_ast__Expr){
                                .obj = memdup(&(v_dot_ast__Ident[]){ident},
                                              sizeof(v_dot_ast__Ident)),
                                .typ = SumType_v_dot_ast__Expr_Ident});
        if (!is_fixed_array_init) {
          v_dot_gen__Gen_write(g, tos3(" = "));
          if (is_sum_cast) {
            v_dot_gen__Gen_sum_cast(
                g, ident_var_info.typ,
                (*(v_dot_table__Type *)array_get(assign_stmt.left_types, i)),
                val);
          } else {
            v_dot_gen__Gen_expr(g, val);
          };
        };
      };
      v_dot_gen__Gen_writeln(g, tos3(";"));
    };
  };
}
void v_dot_gen__Gen_gen_fn_decl(v_dot_gen__Gen *g, v_dot_ast__FnDecl it) {
  if (it.is_c || string_eq(it.name, tos3("malloc")) || it.no_body) {

    return;
  };
  v_dot_gen__Gen_reset_tmp_count(g);
  bool is_main = string_eq(it.name, tos3("main"));
  if (is_main) {
    v_dot_gen__Gen_write(g, _STR("int %.*s(", it.name.len, it.name.str));
  } else {
    string name = it.name;
    if (it.is_method) {
      name = string_add(string_add(v_dot_table__Table_get_type_symbol(
                                       &/* ? */ *g->table, it.receiver.typ)
                                       ->name,
                                   tos3("_")),
                        name);
    };
    name = string_replace(name, tos3("."), tos3("__"));
    if (string_starts_with(name, tos3("_op_"))) {
      name = v_dot_gen__op_to_fn_name(name);
    };
    if (string_eq(name, tos3("exit"))) {
      name = tos3("v_exit");
    };
    string type_name = v_dot_gen__Gen_typ(g, it.return_type);
    v_dot_gen__Gen_write(g, _STR("%.*s %.*s(", type_name.len, type_name.str,
                                 name.len, name.str));
    strings__Builder_write(
        &/* ? */ g->definitions,
        _STR("%.*s %.*s(", type_name.len, type_name.str, name.len, name.str));
  };
  v_dot_gen__Gen_fn_args(g, it.args, it.is_variadic);
  v_dot_gen__Gen_writeln(g, tos3(") { "));
  if (!is_main) {
    strings__Builder_writeln(&/* ? */ g->definitions, tos3(");"));
  };
  array_v_dot_ast__Stmt tmp44 = it.stmts;
  for (int tmp45 = 0; tmp45 < tmp44.len; tmp45++) {
    v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp44.data)[tmp45];

    v_dot_gen__Gen_stmt(g, stmt);
  };
  if (is_main) {
    v_dot_gen__Gen_writeln(g, tos3("return 0;"));
  };
  v_dot_gen__Gen_writeln(g, tos3("}"));
  g->fn_decl = 0;
}
void v_dot_gen__Gen_fn_args(v_dot_gen__Gen *g, array_v_dot_table__Arg args,
                            bool is_variadic) {
  bool no_names =
      args.len > 0 &&
      string_eq((*(v_dot_table__Arg *)array_get(args, 0)).name, tos3("arg_1"));
  array_v_dot_table__Arg tmp48 = args;
  for (int i = 0; i < tmp48.len; i++) {
    v_dot_table__Arg arg = ((v_dot_table__Arg *)tmp48.data)[i];

    v_dot_table__TypeSymbol *arg_type_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, arg.typ);
    string arg_type_name = v_dot_gen__Gen_typ(g, arg.typ);
    bool is_varg = i == args.len - 1 && is_variadic;
    if (is_varg) {
      map_set(&g->varaidic_args, int_str(((int)(arg.typ))), &(int[]){0});
      arg_type_name = string_add(tos3("varg_"),
                                 string_replace(v_dot_gen__Gen_typ(g, arg.typ),
                                                tos3("*"), tos3("_ptr")));
    };
    if (arg_type_sym->kind == v_dot_table__v_dot_table__Kind_function) {
      v_dot_table__Fn func = *(v_dot_table__Fn *)arg_type_sym->info.obj;
      v_dot_gen__Gen_write(g, _STR("%.*s (*%.*s)(",
                                   v_dot_gen__Gen_typ(g, func.return_type).len,
                                   v_dot_gen__Gen_typ(g, func.return_type).str,
                                   arg.name.len, arg.name.str));
      strings__Builder_write(&/* ? */ g->definitions,
                             _STR("%.*s (*%.*s)(",
                                  v_dot_gen__Gen_typ(g, func.return_type).len,
                                  v_dot_gen__Gen_typ(g, func.return_type).str,
                                  arg.name.len, arg.name.str));
      v_dot_gen__Gen_fn_args(g, func.args, func.is_variadic);
      v_dot_gen__Gen_write(g, tos3(")"));
      strings__Builder_write(&/* ? */ g->definitions, tos3(")"));
    } else if (no_names) {
      v_dot_gen__Gen_write(g, arg_type_name);
      strings__Builder_write(&/* ? */ g->definitions, arg_type_name);
    } else {
      int nr_muls = v_dot_table__type_nr_muls(arg.typ);
      string s = string_add(string_add(arg_type_name, tos3(" ")), arg.name);
      if (arg.is_mut) {
        nr_muls = 1;
      };
      v_dot_gen__Gen_write(g, s);
      strings__Builder_write(&/* ? */ g->definitions, s);
    };
    if (i < args.len - 1) {
      v_dot_gen__Gen_write(g, tos3(", "));
      strings__Builder_write(&/* ? */ g->definitions, tos3(", "));
    };
  };
}
void v_dot_gen__Gen_expr(v_dot_gen__Gen *g, v_dot_ast__Expr node) {
  v_dot_ast__Expr tmp49 = node;

  if (tmp49.typ == SumType_v_dot_ast__Expr_ArrayInit) {
    v_dot_ast__ArrayInit *it = (v_dot_ast__ArrayInit *)tmp49.obj;
    v_dot_table__TypeSymbol *type_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, it->typ);
    if (type_sym->kind != v_dot_table__v_dot_table__Kind_array_fixed) {
      v_dot_table__TypeSymbol *elem_sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, it->elem_type);
      string elem_type_str = v_dot_gen__Gen_typ(g, it->elem_type);
      v_dot_gen__Gen_write(g,
                           _STR("new_array_from_c_array(%d, %d, sizeof(%.*s), ",
                                it->exprs.len, it->exprs.len, elem_type_str.len,
                                elem_type_str.str));
      v_dot_gen__Gen_writeln(
          g, _STR("(%.*s[]){\t", elem_type_str.len, elem_type_str.str));
      array_v_dot_ast__Expr tmp50 = it->exprs;
      for (int tmp51 = 0; tmp51 < tmp50.len; tmp51++) {
        v_dot_ast__Expr expr = ((v_dot_ast__Expr *)tmp50.data)[tmp51];

        v_dot_gen__Gen_expr(g, expr);
        v_dot_gen__Gen_write(g, tos3(", "));
      };
      v_dot_gen__Gen_write(g, tos3("\n})"));
    } else {
    };
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_AsCast) {
    v_dot_ast__AsCast *it = (v_dot_ast__AsCast *)tmp49.obj;
    v_dot_gen__Gen_write(g, tos3("/* as */"));
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_AssignExpr) {
    v_dot_ast__AssignExpr *it = (v_dot_ast__AssignExpr *)tmp49.obj;
    g->is_assign_expr = 1;
    bool str_add = 0;
    if (it->left_type == v_dot_table__string_type_idx &&
        it->op == v_dot_token__v_dot_token__Kind_plus_assign) {
      v_dot_gen__Gen_expr(g, it->left);
      v_dot_gen__Gen_write(g, tos3(" = string_add("));
      str_add = 1;
    };
    v_dot_gen__Gen_expr(g, it->left);
    if (!g->is_array_set && !str_add) {
      v_dot_gen__Gen_write(g, _STR(" %.*s ", v_dot_token__Kind_str(it->op).len,
                                   v_dot_token__Kind_str(it->op).str));
    } else if (str_add) {
      v_dot_gen__Gen_write(g, tos3(", "));
    };
    g->is_assign_expr = 0;
    if (v_dot_gen__Gen_is_sum_cast(&/* ? */ *g, it->left_type,
                                   it->right_type)) {
      v_dot_gen__Gen_sum_cast(g, it->left_type, it->right_type, it->val);
    } else {
      v_dot_gen__Gen_expr(g, it->val);
    };
    if (g->is_array_set) {
      v_dot_gen__Gen_write(g, tos3(" })"));
      g->is_array_set = 0;
    } else if (str_add) {
      v_dot_gen__Gen_write(g, tos3(")"));
    };
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_Assoc) {
    v_dot_ast__Assoc *it = (v_dot_ast__Assoc *)tmp49.obj;
    v_dot_gen__Gen_write(g, tos3("/* assoc */"));
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_BoolLiteral) {
    v_dot_ast__BoolLiteral *it = (v_dot_ast__BoolLiteral *)tmp49.obj;
    v_dot_gen__Gen_write(g, bool_str(it->val));
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_CallExpr) {
    v_dot_ast__CallExpr *it = (v_dot_ast__CallExpr *)tmp49.obj;
    string name = string_replace(it->name, tos3("."), tos3("__"));
    if (string_eq(name, tos3("exit"))) {
      name = tos3("v_exit");
    };
    if (it->is_c) {
      g->is_c_call = 1;
      name = string_substr2(name, 3, -1, true);
    };
    v_dot_gen__Gen_write(g, _STR("%.*s(", name.len, name.str));
    if (string_eq(name, tos3("println")) &&
        (*(v_dot_ast__CallArg *)array_get(it->args, 0)).typ !=
            v_dot_table__string_type_idx) {
      v_dot_table__TypeSymbol *sym = v_dot_table__Table_get_type_symbol(
          &/* ? */ *g->table,
          (*(v_dot_ast__CallArg *)array_get(it->args, 0)).typ);
      v_dot_gen__Gen_write(g, _STR("%.*s_str(", sym->name.len, sym->name.str));
      v_dot_gen__Gen_expr(g,
                          (*(v_dot_ast__CallArg *)array_get(it->args, 0)).expr);
      v_dot_gen__Gen_write(g, tos3("))"));
    } else {
      v_dot_gen__Gen_call_args(g, it->args);
      v_dot_gen__Gen_write(g, tos3(")"));
    };
    g->is_c_call = 0;
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_CastExpr) {
    v_dot_ast__CastExpr *it = (v_dot_ast__CastExpr *)tmp49.obj;
    if (g->is_amp) {
      strings__Builder_go_back(&/* ? */ g->out, 1);
    };
    if (it->typ == v_dot_table__string_type_idx) {
      if (it->has_arg) {
        v_dot_gen__Gen_write(g, tos3("tos("));
      } else {
        v_dot_gen__Gen_write(g, tos3("tos2("));
      };
      v_dot_gen__Gen_expr(g, it->expr);
      v_dot_table__TypeSymbol *sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, it->expr_type);
      if (sym->kind == v_dot_table__v_dot_table__Kind_array) {
        v_dot_gen__Gen_write(g, tos3(".data"));
      };
      if (it->has_arg) {
        v_dot_gen__Gen_write(g, tos3(", "));
        v_dot_gen__Gen_expr(g, it->arg);
      };
      v_dot_gen__Gen_write(g, tos3(")"));
    } else {
      string styp = v_dot_gen__Gen_typ(g, it->typ);
      v_dot_gen__Gen_write(g, _STR("((%.*s)(", styp.len, styp.str));
      v_dot_gen__Gen_expr(g, it->expr);
      v_dot_gen__Gen_write(g, tos3("))"));
    };
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_CharLiteral) {
    v_dot_ast__CharLiteral *it = (v_dot_ast__CharLiteral *)tmp49.obj;
    v_dot_gen__Gen_write(g, _STR("'%.*s'", it->val.len, it->val.str));
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_EnumVal) {
    v_dot_ast__EnumVal *it = (v_dot_ast__EnumVal *)tmp49.obj;
    v_dot_gen__Gen_write(g, v_dot_gen__Gen_typ(g, it->typ));
    v_dot_gen__Gen_write(g, _STR("_%.*s", it->val.len, it->val.str));
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_FloatLiteral) {
    v_dot_ast__FloatLiteral *it = (v_dot_ast__FloatLiteral *)tmp49.obj;
    v_dot_gen__Gen_write(g, it->val);
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_Ident) {
    v_dot_ast__Ident *it = (v_dot_ast__Ident *)tmp49.obj;
    v_dot_gen__Gen_ident(g, *it);
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_IfExpr) {
    v_dot_ast__IfExpr *it = (v_dot_ast__IfExpr *)tmp49.obj;
    v_dot_table__TypeSymbol *type_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, it->typ);
    string tmp = tos3("");
    if (type_sym->kind != v_dot_table__v_dot_table__Kind_void) {
      tmp = v_dot_gen__Gen_new_tmp_var(g);
    };
    if (it->stmts.len == 1 && it->else_stmts.len == 1 &&
        type_sym->kind != v_dot_table__v_dot_table__Kind_void) {
      v_dot_ast__Expr cond = it->cond;
      v_dot_ast__Stmt stmt1 = (*(v_dot_ast__Stmt *)array_get(it->stmts, 0));
      v_dot_ast__Stmt else_stmt1 =
          (*(v_dot_ast__Stmt *)array_get(it->else_stmts, 0));
      v_dot_ast__Stmt tmp64 = stmt1;

      if (tmp64.typ == SumType_v_dot_ast__Stmt_ExprStmt) {
        v_dot_ast__ExprStmt *it = (v_dot_ast__ExprStmt *)tmp64.obj;
        v_dot_gen__Gen_expr(g, cond);
        v_dot_gen__Gen_write(g, tos3(" ? "));
        v_dot_ast__ExprStmt expr_stmt = *(v_dot_ast__ExprStmt *)stmt1.obj;
        v_dot_gen__Gen_expr(g, expr_stmt.expr);
        v_dot_gen__Gen_write(g, tos3(" : "));
        v_dot_gen__Gen_stmt(g, else_stmt1);
      } else // default:
      {
      };
    } else {
      v_dot_gen__Gen_write(g, tos3("if ("));
      v_dot_gen__Gen_expr(g, it->cond);
      v_dot_gen__Gen_writeln(g, tos3(") {"));
      array_v_dot_ast__Stmt tmp65 = it->stmts;
      for (int i = 0; i < tmp65.len; i++) {
        v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp65.data)[i];

        if (i == it->stmts.len - 1 &&
            type_sym->kind != v_dot_table__v_dot_table__Kind_void) {
        };
        v_dot_gen__Gen_stmt(g, stmt);
      };
      v_dot_gen__Gen_writeln(g, tos3("}"));
      if (it->else_stmts.len > 0) {
        v_dot_gen__Gen_writeln(g, tos3("else { "));
        array_v_dot_ast__Stmt tmp66 = it->else_stmts;
        for (int tmp67 = 0; tmp67 < tmp66.len; tmp67++) {
          v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp66.data)[tmp67];

          v_dot_gen__Gen_stmt(g, stmt);
        };
        v_dot_gen__Gen_writeln(g, tos3("}"));
      };
    };
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_IfGuardExpr) {
    v_dot_ast__IfGuardExpr *it = (v_dot_ast__IfGuardExpr *)tmp49.obj;
    v_dot_gen__Gen_write(g, tos3("/* guard */"));
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_IndexExpr) {
    v_dot_ast__IndexExpr *it = (v_dot_ast__IndexExpr *)tmp49.obj;
    v_dot_gen__Gen_index_expr(g, *it);
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_InfixExpr) {
    v_dot_ast__InfixExpr *it = (v_dot_ast__InfixExpr *)tmp49.obj;
    v_dot_gen__Gen_infix_expr(g, *it);
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_IntegerLiteral) {
    v_dot_ast__IntegerLiteral *it = (v_dot_ast__IntegerLiteral *)tmp49.obj;
    v_dot_gen__Gen_write(g, int_str(it->val));
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_MatchExpr) {
    v_dot_ast__MatchExpr *it = (v_dot_ast__MatchExpr *)tmp49.obj;
    v_dot_gen__Gen_match_expr(g, *it);
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_MapInit) {
    v_dot_ast__MapInit *it = (v_dot_ast__MapInit *)tmp49.obj;
    v_dot_table__TypeSymbol *key_typ_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, it->key_type);
    v_dot_table__TypeSymbol *value_typ_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, it->value_type);
    int size = it->vals.len;
    if (size > 0) {
      v_dot_gen__Gen_write(
          g, _STR("new_map_init(%d, sizeof(%.*s), (%.*s[%d]){", size,
                  value_typ_sym->name.len, value_typ_sym->name.str,
                  key_typ_sym->name.len, key_typ_sym->name.str, size));
      array_v_dot_ast__Expr tmp68 = it->keys;
      for (int tmp69 = 0; tmp69 < tmp68.len; tmp69++) {
        v_dot_ast__Expr expr = ((v_dot_ast__Expr *)tmp68.data)[tmp69];

        v_dot_gen__Gen_expr(g, expr);
        v_dot_gen__Gen_write(g, tos3(", "));
      };
      v_dot_gen__Gen_write(g, _STR("}, (%.*s[%d]){", value_typ_sym->name.len,
                                   value_typ_sym->name.str, size));
      array_v_dot_ast__Expr tmp70 = it->vals;
      for (int tmp71 = 0; tmp71 < tmp70.len; tmp71++) {
        v_dot_ast__Expr expr = ((v_dot_ast__Expr *)tmp70.data)[tmp71];

        v_dot_gen__Gen_expr(g, expr);
        v_dot_gen__Gen_write(g, tos3(", "));
      };
      v_dot_gen__Gen_write(g, tos3("})"));
    } else {
      v_dot_gen__Gen_write(g, _STR("new_map(1, sizeof(%.*s))",
                                   value_typ_sym->name.len,
                                   value_typ_sym->name.str));
    };
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_MethodCallExpr) {
    v_dot_ast__MethodCallExpr *it = (v_dot_ast__MethodCallExpr *)tmp49.obj;
    string receiver_name = tos3("TODO");
    if (it->expr_type != 0) {
      v_dot_table__TypeSymbol *typ_sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, it->expr_type);
      receiver_name = typ_sym->name;
      if (typ_sym->kind == v_dot_table__v_dot_table__Kind_array &&
          (string_eq(it->name, tos3("repeat")) ||
           string_eq(it->name, tos3("sort_with_compare")) ||
           string_eq(it->name, tos3("free")) ||
           string_eq(it->name, tos3("push_many")) ||
           string_eq(it->name, tos3("trim")) ||
           string_eq(it->name, tos3("first")) ||
           string_eq(it->name, tos3("clone")))) {
        receiver_name = tos3("array");
      };
    };
    string name =
        string_replace(_STR("%.*s_%.*s", receiver_name.len, receiver_name.str,
                            it->name.len, it->name.str),
                       tos3("."), tos3("__"));
    v_dot_gen__Gen_write(g, _STR("%.*s(", name.len, name.str));
    if (v_dot_table__type_is_ptr(it->receiver_type) &&
        !v_dot_table__type_is_ptr(it->expr_type)) {
      v_dot_gen__Gen_write(g, tos3("&"));
    } else if (!v_dot_table__type_is_ptr(it->receiver_type) &&
               v_dot_table__type_is_ptr(it->expr_type)) {
      v_dot_gen__Gen_write(g, tos3("/*rec*/*"));
    };
    v_dot_gen__Gen_expr(g, it->expr);
    if (it->args.len > 0) {
      v_dot_gen__Gen_write(g, tos3(", "));
    };
    v_dot_gen__Gen_call_args(g, it->args);
    v_dot_gen__Gen_write(g, tos3(")"));
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_None) {
    v_dot_ast__None *it = (v_dot_ast__None *)tmp49.obj;
    v_dot_gen__Gen_write(g, tos3("opt_none()"));
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_ParExpr) {
    v_dot_ast__ParExpr *it = (v_dot_ast__ParExpr *)tmp49.obj;
    v_dot_gen__Gen_write(g, tos3("("));
    v_dot_gen__Gen_expr(g, it->expr);
    v_dot_gen__Gen_write(g, tos3(")"));
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_PostfixExpr) {
    v_dot_ast__PostfixExpr *it = (v_dot_ast__PostfixExpr *)tmp49.obj;
    v_dot_gen__Gen_expr(g, it->expr);
    v_dot_gen__Gen_write(g, v_dot_token__Kind_str(it->op));
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_PrefixExpr) {
    v_dot_ast__PrefixExpr *it = (v_dot_ast__PrefixExpr *)tmp49.obj;
    if (it->op == v_dot_token__v_dot_token__Kind_amp) {
      g->is_amp = 1;
    };
    v_dot_gen__Gen_write(g, v_dot_token__Kind_str(it->op));
    v_dot_gen__Gen_expr(g, it->right);
    g->is_amp = 0;
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_SizeOf) {
    v_dot_ast__SizeOf *it = (v_dot_ast__SizeOf *)tmp49.obj;
    v_dot_gen__Gen_write(
        g, _STR("sizeof(%.*s)", it->type_name.len, it->type_name.str));
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_StringLiteral) {
    v_dot_ast__StringLiteral *it = (v_dot_ast__StringLiteral *)tmp49.obj;
    string escaped_val = string_replace_each(
        it->val,
        new_array_from_c_array(6, 6, sizeof(string),
                               EMPTY_ARRAY_OF_ELEMS(string, 6){
                                   tos3("\""), tos3("\\\""), tos3("\r\n"),
                                   tos3("\\n"), tos3("\n"), tos3("\\n")}));
    if (g->is_c_call) {
      v_dot_gen__Gen_write(g,
                           _STR("\"%.*s\"", escaped_val.len, escaped_val.str));
    } else {
      v_dot_gen__Gen_write(
          g, _STR("tos3(\"%.*s\")", escaped_val.len, escaped_val.str));
    };
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_StructInit) {
    v_dot_ast__StructInit *it = (v_dot_ast__StructInit *)tmp49.obj;
    string styp = v_dot_gen__Gen_typ(g, it->typ);
    if (g->is_amp) {
      strings__Builder_go_back(&/* ? */ g->out, 1);
      v_dot_gen__Gen_write(g, _STR("(%.*s*)memdup(&(%.*s){", styp.len, styp.str,
                                   styp.len, styp.str));
    } else {
      v_dot_gen__Gen_writeln(g, _STR("(%.*s){", styp.len, styp.str));
    };
    array_string tmp72 = it->fields;
    for (int i = 0; i < tmp72.len; i++) {
      string field = ((string *)tmp72.data)[i];

      v_dot_gen__Gen_write(g, _STR("\t.%.*s = ", field.len, field.str));
      v_dot_gen__Gen_expr(g, (*(v_dot_ast__Expr *)array_get(it->exprs, i)));
      v_dot_gen__Gen_writeln(g, tos3(", "));
    };
    if (it->fields.len == 0) {
      v_dot_gen__Gen_write(g, tos3("0"));
    };
    v_dot_gen__Gen_write(g, tos3("}"));
    if (g->is_amp) {
      v_dot_gen__Gen_write(g, _STR(", sizeof(%.*s))", styp.len, styp.str));
    };
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_SelectorExpr) {
    v_dot_ast__SelectorExpr *it = (v_dot_ast__SelectorExpr *)tmp49.obj;
    v_dot_gen__Gen_expr(g, it->expr);
    if (v_dot_table__type_is_ptr(it->expr_type)) {
      v_dot_gen__Gen_write(g, tos3("->"));
    } else {
      v_dot_gen__Gen_write(g, tos3("."));
    };
    if (it->expr_type == 0) {
      v_dot_gen__verror(_STR("cgen: SelectorExpr typ=0 field=%.*s",
                             it->field.len, it->field.str));
    };
    v_dot_gen__Gen_write(g, it->field);
  } else if (tmp49.typ == SumType_v_dot_ast__Expr_Type) {
    v_dot_ast__Type *it = (v_dot_ast__Type *)tmp49.obj;
    v_dot_gen__Gen_write(g, tos3("_type_idx_"));
    v_dot_gen__Gen_write(g, v_dot_gen__Gen_typ(g, it->typ));
  } else // default:
  {
    println(
        term__red(string_add(tos3("cgen.expr(): bad node "),
                             tos3(__SumTypeNames__v_dot_ast__Expr[node.typ]))));
  };
}
void v_dot_gen__Gen_infix_expr(v_dot_gen__Gen *g, v_dot_ast__InfixExpr node) {
  if (node.left_type == v_dot_table__string_type_idx &&
      node.op != v_dot_token__v_dot_token__Kind_key_in) {
    v_dot_token__Kind tmp75 = node.op;

    string fn_name =
        ((tmp75 == v_dot_token__v_dot_token__Kind_plus)
             ? (tos3("string_add("))
             : ((tmp75 == v_dot_token__v_dot_token__Kind_eq)
                    ? (tos3("string_eq("))
                    : ((tmp75 == v_dot_token__v_dot_token__Kind_ne)
                           ? (tos3("string_ne("))
                           : ((tmp75 == v_dot_token__v_dot_token__Kind_lt)
                                  ? (tos3("string_lt("))
                                  : ((tmp75 ==
                                      v_dot_token__v_dot_token__Kind_le)
                                         ? (tos3("string_le("))
                                         : ((tmp75 ==
                                             v_dot_token__v_dot_token__Kind_gt)
                                                ? (tos3("string_gt("))
                                                : ((tmp75 ==
                                                    v_dot_token__v_dot_token__Kind_ge)
                                                       ? (tos3("string_ge("))
                                                       : (tos3(
                                                             "/*node "
                                                             "error*/")))))))));
    v_dot_gen__Gen_write(g, fn_name);
    v_dot_gen__Gen_expr(g, node.left);
    v_dot_gen__Gen_write(g, tos3(", "));
    v_dot_gen__Gen_expr(g, node.right);
    v_dot_gen__Gen_write(g, tos3(")"));
  } else if (node.op == v_dot_token__v_dot_token__Kind_key_in) {
    string styp = v_dot_gen__Gen_typ(g, node.left_type);
    v_dot_gen__Gen_write(g, _STR("_IN(%.*s, ", styp.len, styp.str));
    v_dot_gen__Gen_expr(g, node.left);
    v_dot_gen__Gen_write(g, tos3(", "));
    v_dot_gen__Gen_expr(g, node.right);
    v_dot_gen__Gen_write(g, tos3(")"));
  } else if (node.op == v_dot_token__v_dot_token__Kind_left_shift &&
             v_dot_table__Table_get_type_symbol(&/* ? */ *g->table,
                                                node.left_type)
                     ->kind == v_dot_table__v_dot_table__Kind_array) {
    string tmp = v_dot_gen__Gen_new_tmp_var(g);
    v_dot_table__TypeSymbol *sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, node.left_type);
    v_dot_table__TypeSymbol *right_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, node.right_type);
    if (right_sym->kind == v_dot_table__v_dot_table__Kind_array) {
      v_dot_gen__Gen_write(g, tos3("_PUSH_MANY(&"));
      v_dot_gen__Gen_expr(g, node.left);
      v_dot_gen__Gen_write(g, tos3(", ("));
      v_dot_gen__Gen_expr(g, node.right);
      string styp = v_dot_gen__Gen_typ(g, node.left_type);
      v_dot_gen__Gen_write(
          g, _STR("), %.*s, %.*s)", tmp.len, tmp.str, styp.len, styp.str));
    } else {
      v_dot_table__Array info = *(v_dot_table__Array *)sym->info.obj;
      string elem_type_str = v_dot_gen__Gen_typ(g, info.elem_type);
      v_dot_gen__Gen_write(g, tos3("_PUSH(&"));
      v_dot_gen__Gen_expr(g, node.left);
      v_dot_gen__Gen_write(g, tos3(", ("));
      v_dot_gen__Gen_expr(g, node.right);
      v_dot_gen__Gen_write(g, _STR("), %.*s, %.*s)", tmp.len, tmp.str,
                                   elem_type_str.len, elem_type_str.str));
    };
  } else {
    v_dot_gen__Gen_expr(g, node.left);
    v_dot_gen__Gen_write(g, _STR(" %.*s ", v_dot_token__Kind_str(node.op).len,
                                 v_dot_token__Kind_str(node.op).str));
    v_dot_gen__Gen_expr(g, node.right);
  };
}
void v_dot_gen__Gen_match_expr(v_dot_gen__Gen *g, v_dot_ast__MatchExpr node) {
  if (node.expr_type == 0) {
    v_dot_gen__Gen_writeln(g, tos3("// match 0"));

    return;
  };
  v_dot_table__TypeSymbol *type_sym =
      v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, node.expr_type);
  string tmp = tos3("");
  if (type_sym->kind != v_dot_table__v_dot_table__Kind_void) {
    tmp = v_dot_gen__Gen_new_tmp_var(g);
  };
  string styp = v_dot_gen__Gen_typ(g, node.expr_type);
  v_dot_gen__Gen_write(
      g, _STR("%.*s %.*s = ", styp.len, styp.str, tmp.len, tmp.str));
  v_dot_gen__Gen_expr(g, node.cond);
  v_dot_gen__Gen_writeln(g, tos3(";"));
  array_v_dot_ast__MatchBranch tmp76 = node.branches;
  for (int j = 0; j < tmp76.len; j++) {
    v_dot_ast__MatchBranch branch = ((v_dot_ast__MatchBranch *)tmp76.data)[j];

    if (j == node.branches.len - 1) {
      v_dot_gen__Gen_writeln(g, tos3("else {"));
    } else {
      if (j > 0) {
        v_dot_gen__Gen_write(g, tos3("else "));
      };
      v_dot_gen__Gen_write(g, tos3("if ("));
      array_v_dot_ast__Expr tmp77 = branch.exprs;
      for (int i = 0; i < tmp77.len; i++) {
        v_dot_ast__Expr expr = ((v_dot_ast__Expr *)tmp77.data)[i];

        if (node.is_sum_type) {
          v_dot_gen__Gen_write(g, _STR("%.*s.typ == ", tmp.len, tmp.str));
        } else if (type_sym->kind == v_dot_table__v_dot_table__Kind_string) {
          v_dot_gen__Gen_write(g, _STR("string_eq(%.*s, ", tmp.len, tmp.str));
        } else {
          v_dot_gen__Gen_write(g, _STR("%.*s == ", tmp.len, tmp.str));
        };
        v_dot_gen__Gen_expr(g, expr);
        if (type_sym->kind == v_dot_table__v_dot_table__Kind_string) {
          v_dot_gen__Gen_write(g, tos3(")"));
        };
        if (i < branch.exprs.len - 1) {
          v_dot_gen__Gen_write(g, tos3(" || "));
        };
      };
      v_dot_gen__Gen_writeln(g, tos3(") {"));
    };
    if (node.is_sum_type && branch.exprs.len > 0) {
      v_dot_ast__Expr fe = (*(v_dot_ast__Expr *)array_get(branch.exprs, 0));
      v_dot_ast__Expr tmp80 = fe;

      if (tmp80.typ == SumType_v_dot_ast__Expr_Type) {
        v_dot_ast__Type *it = (v_dot_ast__Type *)tmp80.obj;
        string it_type = v_dot_gen__Gen_typ(g, it->typ);
        v_dot_gen__Gen_writeln(g, _STR("%.*s* it = (%.*s*)%.*s.obj; // ST it",
                                       it_type.len, it_type.str, it_type.len,
                                       it_type.str, tmp.len, tmp.str));
      } else // default:
      {
        v_dot_gen__verror(tos3("match sum type"));
      };
    };
    v_dot_gen__Gen_stmts(g, branch.stmts);
    v_dot_gen__Gen_writeln(g, tos3("}"));
  };
}
void v_dot_gen__Gen_ident(v_dot_gen__Gen *g, v_dot_ast__Ident node) {
  string name = string_replace(node.name, tos3("."), tos3("__"));
  if (string_starts_with(name, tos3("C__"))) {
    v_dot_gen__Gen_write(g, string_substr2(name, 3, -1, true));
  } else {
    v_dot_ast__IdentInfo tmp83 = node.info;

    if (tmp83.typ == SumType_v_dot_ast__IdentInfo_IdentVar) {
      v_dot_ast__IdentVar *it = (v_dot_ast__IdentVar *)tmp83.obj;
      if (it->is_optional) {
        v_dot_gen__Gen_write(g, tos3("/*opt*/"));
        string styp =
            string_substr2(v_dot_gen__Gen_typ(g, it->typ), 7, -1, true);
        v_dot_gen__Gen_write(g, _STR("(*(%.*s*)%.*s.data)", styp.len, styp.str,
                                     name.len, name.str));

        return;
      };
    } else // default:
    {
    };
    v_dot_gen__Gen_write(g, name);
  };
}
void v_dot_gen__Gen_index_expr(v_dot_gen__Gen *g, v_dot_ast__IndexExpr node) {
  bool is_range = 0;
  v_dot_ast__Expr tmp86 = node.index;

  if (tmp86.typ == SumType_v_dot_ast__Expr_RangeExpr) {
    v_dot_ast__RangeExpr *it = (v_dot_ast__RangeExpr *)tmp86.obj;
    if (node.container_type != 0) {
      v_dot_table__TypeSymbol *sym = v_dot_table__Table_get_type_symbol(
          &/* ? */ *g->table, node.container_type);
      is_range = 1;
      if (sym->kind == v_dot_table__v_dot_table__Kind_string) {
        v_dot_gen__Gen_write(g, tos3("string_substr("));
      } else if (sym->kind == v_dot_table__v_dot_table__Kind_array) {
        v_dot_gen__Gen_write(g, tos3("array_slice("));
      };
    };
    v_dot_gen__Gen_expr(g, node.left);
    v_dot_gen__Gen_write(g, tos3(", "));
    if (it->has_low) {
      v_dot_gen__Gen_expr(g, it->low);
    } else {
      v_dot_gen__Gen_write(g, tos3("0"));
    };
    v_dot_gen__Gen_write(g, tos3(", "));
    if (it->has_high) {
      v_dot_gen__Gen_expr(g, it->high);
    } else {
      v_dot_gen__Gen_expr(g, node.left);
      v_dot_gen__Gen_write(g, tos3(".len"));
    };
    v_dot_gen__Gen_write(g, tos3(")"));

    return;
  } else // default:
  {
  };
  if (!is_range && node.container_type != 0) {
    v_dot_table__TypeSymbol *sym = v_dot_table__Table_get_type_symbol(
        &/* ? */ *g->table, node.container_type);
    if (v_dot_table__type_is_variadic(node.container_type)) {
      v_dot_gen__Gen_expr(g, node.left);
      v_dot_gen__Gen_write(g, tos3(".args"));
      v_dot_gen__Gen_write(g, tos3("["));
      v_dot_gen__Gen_expr(g, node.index);
      v_dot_gen__Gen_write(g, tos3("]"));
    } else if (sym->kind == v_dot_table__v_dot_table__Kind_array) {
      v_dot_table__Array info = *(v_dot_table__Array *)sym->info.obj;
      string elem_type_str = v_dot_gen__Gen_typ(g, info.elem_type);
      if (g->is_assign_expr) {
        g->is_array_set = 1;
        v_dot_gen__Gen_write(g, tos3("array_set(&"));
        v_dot_gen__Gen_expr(g, node.left);
        v_dot_gen__Gen_write(g, tos3(", "));
        v_dot_gen__Gen_expr(g, node.index);
        v_dot_gen__Gen_write(
            g, _STR(", &(%.*s[]) { ", elem_type_str.len, elem_type_str.str));
      } else {
        v_dot_gen__Gen_write(g, _STR("(*(%.*s*)array_get(", elem_type_str.len,
                                     elem_type_str.str));
        v_dot_gen__Gen_expr(g, node.left);
        v_dot_gen__Gen_write(g, tos3(", "));
        v_dot_gen__Gen_expr(g, node.index);
        v_dot_gen__Gen_write(g, tos3("))"));
      };
    } else if (sym->kind == v_dot_table__v_dot_table__Kind_string) {
      v_dot_gen__Gen_write(g, tos3("string_at("));
      v_dot_gen__Gen_expr(g, node.left);
      v_dot_gen__Gen_write(g, tos3(", "));
      v_dot_gen__Gen_expr(g, node.index);
      v_dot_gen__Gen_write(g, tos3(")"));
    } else {
      v_dot_gen__Gen_expr(g, node.left);
      v_dot_gen__Gen_write(g, tos3("["));
      v_dot_gen__Gen_expr(g, node.index);
      v_dot_gen__Gen_write(g, tos3("]"));
    };
  };
}
void v_dot_gen__Gen_return_statement(v_dot_gen__Gen *g, v_dot_ast__Return it) {
  v_dot_gen__Gen_write(g, tos3("return"));
  if (it.exprs.len > 1) {
    v_dot_table__TypeSymbol *typ_sym = v_dot_table__Table_get_type_symbol(
        &/* ? */ *g->table, g->fn_decl->return_type);
    v_dot_table__MultiReturn mr_info =
        *(v_dot_table__MultiReturn *)typ_sym->info.obj;
    string styp = v_dot_gen__Gen_typ(g, g->fn_decl->return_type);
    v_dot_gen__Gen_write(g, _STR(" (%.*s){", styp.len, styp.str));
    array_v_dot_ast__Expr tmp87 = it.exprs;
    for (int i = 0; i < tmp87.len; i++) {
      v_dot_ast__Expr expr = ((v_dot_ast__Expr *)tmp87.data)[i];

      v_dot_gen__Gen_write(g, _STR(".arg%d=", i));
      v_dot_gen__Gen_expr(g, expr);
      if (i < it.exprs.len - 1) {
        v_dot_gen__Gen_write(g, tos3(","));
      };
    };
    v_dot_gen__Gen_write(g, tos3("}"));
  } else if (it.exprs.len == 1) {
    v_dot_gen__Gen_write(g, tos3(" "));
    if (v_dot_table__type_is_optional(g->fn_decl->return_type)) {
      bool is_none = 0;
      bool is_error = 0;
      v_dot_ast__Expr tmp90 = (*(v_dot_ast__Expr *)array_get(it.exprs, 0));

      if (tmp90.typ == SumType_v_dot_ast__Expr_None) {
        v_dot_ast__None *it = (v_dot_ast__None *)tmp90.obj;
        is_none = 1;
      } else if (tmp90.typ == SumType_v_dot_ast__Expr_CallExpr) {
        v_dot_ast__CallExpr *it = (v_dot_ast__CallExpr *)tmp90.obj;
        is_error = 1;
      } else // default:
      {
      };
      if (!is_none && !is_error) {
        string styp = string_substr2(
            v_dot_gen__Gen_typ(g, g->fn_decl->return_type), 7, -1, true);
        v_dot_gen__Gen_write(g,
                             _STR("opt_ok(& (%.*s []) { ", styp.len, styp.str));
        v_dot_gen__Gen_expr(g, (*(v_dot_ast__Expr *)array_get(it.exprs, 0)));
        v_dot_gen__Gen_writeln(g,
                               _STR(" }, sizeof(%.*s));", styp.len, styp.str));

        return;
      };
    };
    if (v_dot_gen__Gen_is_sum_cast(
            &/* ? */ *g, (*(v_dot_table__Type *)array_get(it.types, 0)),
            g->fn_decl->return_type)) {
      v_dot_gen__Gen_sum_cast(g, (*(v_dot_table__Type *)array_get(it.types, 0)),
                              g->fn_decl->return_type,
                              (*(v_dot_ast__Expr *)array_get(it.exprs, 0)));
    } else {
      v_dot_gen__Gen_expr(g, (*(v_dot_ast__Expr *)array_get(it.exprs, 0)));
    };
  };
  v_dot_gen__Gen_writeln(g, tos3(";"));
}
void v_dot_gen__Gen_const_decl(v_dot_gen__Gen *g, v_dot_ast__ConstDecl node) {
  array_v_dot_ast__Field tmp103 = node.fields;
  for (int i = 0; i < tmp103.len; i++) {
    v_dot_ast__Field field = ((v_dot_ast__Field *)tmp103.data)[i];

    string name = string_replace(field.name, tos3("."), tos3("__"));
    v_dot_ast__Expr expr = (*(v_dot_ast__Expr *)array_get(node.exprs, i));
    v_dot_ast__Expr tmp106 = expr;

    if ((tmp106.typ == SumType_v_dot_ast__Expr_CharLiteral) ||
        (tmp106.typ == SumType_v_dot_ast__Expr_IntegerLiteral)) {
      v_dot_ast__IntegerLiteral *it = (v_dot_ast__IntegerLiteral *)tmp106.obj;
      strings__Builder_write(&/* ? */ g->definitions,
                             _STR("#define %.*s ", name.len, name.str));
      v_dot_gen__Gen_write(g, tos3("//"));
      int pos = g->out.len;
      v_dot_gen__Gen_expr(g, expr);
      array_byte b = array_byte_clone(
          array_slice2(g->out.buf, pos, g->out.buf.len, false));
      _PUSH(&b, (/*typ = array_byte   tmp_typ=byte*/ '\0'), tmp109, byte);
      string val = (tos2((byte *)b.data));
      v_dot_gen__Gen_writeln(g, tos3(""));
      strings__Builder_writeln(&/* ? */ g->definitions, val);
    } else // default:
    {
      string styp = v_dot_gen__Gen_typ(g, field.typ);
      strings__Builder_writeln(&/* ? */ g->definitions,
                               _STR("%.*s %.*s; // inited later", styp.len,
                                    styp.str, name.len, name.str));
    };
  };
}
void v_dot_gen__Gen_call_args(v_dot_gen__Gen *g,
                              array_v_dot_ast__CallArg args) {
  array_v_dot_ast__CallArg tmp110 = args;
  for (int i = 0; i < tmp110.len; i++) {
    v_dot_ast__CallArg arg = ((v_dot_ast__CallArg *)tmp110.data)[i];

    if (v_dot_table__type_is_variadic(arg.expected_type)) {
      string struct_name =
          string_add(tos3("varg_"),
                     string_replace(v_dot_gen__Gen_typ(g, arg.expected_type),
                                    tos3("*"), tos3("_ptr")));
      int len = args.len - i;
      string type_str = int_str(((int)(arg.expected_type)));
      int tmp111 = 0;
      bool tmp112 =
          map_get(/*cgen.v : 1259*/ g->varaidic_args, type_str, &tmp111);

      if (len > tmp111) {
        map_set(&g->varaidic_args, type_str, &(int[]){len});
      };
      v_dot_gen__Gen_write(g, _STR("(%.*s){.len=%d,.args={", struct_name.len,
                                   struct_name.str, len));
      int tmp113 = i;
      ;
      for (int tmp114 = tmp113; tmp114 < args.len; tmp114++) {
        int j = tmp114;

        v_dot_gen__Gen_ref_or_deref_arg(
            g, (*(v_dot_ast__CallArg *)array_get(args, j)));
        v_dot_gen__Gen_expr(g,
                            (*(v_dot_ast__CallArg *)array_get(args, j)).expr);
        if (j < args.len - 1) {
          v_dot_gen__Gen_write(g, tos3(", "));
        };
      };
      v_dot_gen__Gen_write(g, tos3("}}"));
      break;
    };
    if (arg.expected_type != 0) {
      v_dot_gen__Gen_ref_or_deref_arg(g, arg);
    };
    v_dot_gen__Gen_expr(g, arg.expr);
    if (i != args.len - 1) {
      v_dot_gen__Gen_write(g, tos3(", "));
    };
  };
}
static inline void v_dot_gen__Gen_ref_or_deref_arg(v_dot_gen__Gen *g,
                                                   v_dot_ast__CallArg arg) {
  bool arg_is_ptr = v_dot_table__type_is_ptr(arg.expected_type) ||
                    arg.expected_type == v_dot_table__voidptr_type_idx;
  bool expr_is_ptr = v_dot_table__type_is_ptr(arg.typ);
  if (arg.is_mut && !arg_is_ptr) {
    v_dot_gen__Gen_write(g, tos3("&/*mut*/"));
  } else if (arg_is_ptr && !expr_is_ptr) {
    v_dot_gen__Gen_write(g, tos3("&/*q*/"));
  } else if (!arg_is_ptr && expr_is_ptr) {
    v_dot_gen__Gen_write(g, tos3("*/*d*/"));
  };
}
void v_dot_gen__verror(string s) { printf("cgen error: %.*s\n", s.len, s.str); }
void v_dot_gen__Gen_write_builtin_types(v_dot_gen__Gen *g) {
  array_v_dot_table__TypeSymbol builtin_types = new_array_from_c_array(
      0, 0, sizeof(v_dot_table__TypeSymbol),
      EMPTY_ARRAY_OF_ELEMS(v_dot_table__TypeSymbol, 0){TCCSKIP(0)});
  array_string tmp119 = v_dot_gen__builtins;
  for (int tmp120 = 0; tmp120 < tmp119.len; tmp120++) {
    string builtin_name = ((string *)tmp119.data)[tmp120];

    int tmp122 = 0;
    bool tmp123 =
        map_get(/*cgen.v : 1314*/ g->table->type_idxs, builtin_name, &tmp122);

    _PUSH(&builtin_types,
          (/*typ = array_v_dot_table__TypeSymbol
              tmp_typ=v_dot_table__TypeSymbol*/
           (*(v_dot_table__TypeSymbol *)array_get(g->table->types, tmp122))),
          tmp121, v_dot_table__TypeSymbol);
  };
  v_dot_gen__Gen_write_types(g, builtin_types);
}
void v_dot_gen__Gen_write_sorted_types(v_dot_gen__Gen *g) {
  array_v_dot_table__TypeSymbol types = new_array_from_c_array(
      0, 0, sizeof(v_dot_table__TypeSymbol),
      EMPTY_ARRAY_OF_ELEMS(v_dot_table__TypeSymbol, 0){TCCSKIP(0)});
  array_v_dot_table__TypeSymbol tmp126 = g->table->types;
  for (int tmp127 = 0; tmp127 < tmp126.len; tmp127++) {
    v_dot_table__TypeSymbol typ =
        ((v_dot_table__TypeSymbol *)tmp126.data)[tmp127];

    if (!((_IN(string, (typ.name), v_dot_gen__builtins)))) {
      _PUSH(&types,
            (/*typ = array_v_dot_table__TypeSymbol
                tmp_typ=v_dot_table__TypeSymbol*/
             typ),
            tmp128, v_dot_table__TypeSymbol);
    };
  };
  array_v_dot_table__TypeSymbol types_sorted =
      v_dot_gen__Gen_sort_structs(&/* ? */ *g, types);
  strings__Builder_writeln(&/* ? */ g->definitions, tos3("// builtin types:"));
  strings__Builder_writeln(&/* ? */ g->definitions,
                           tos3("//------------------ #endbuiltin"));
  v_dot_gen__Gen_write_types(g, types_sorted);
}
void v_dot_gen__Gen_write_types(v_dot_gen__Gen *g,
                                array_v_dot_table__TypeSymbol types) {
  array_v_dot_table__TypeSymbol tmp129 = types;
  for (int i = 0; i < tmp129.len; i++) {
    v_dot_table__TypeSymbol typ = ((v_dot_table__TypeSymbol *)tmp129.data)[i];

    if (string_starts_with(typ.name, tos3("C."))) {
      continue;
    };
    string name = string_replace(typ.name, tos3("."), tos3("__"));
    v_dot_table__TypeInfo tmp130 = typ.info;

    if (tmp130.typ == SumType_v_dot_table__TypeInfo_Struct) {
      v_dot_table__Struct *it = (v_dot_table__Struct *)tmp130.obj;
      v_dot_table__Struct info = *(v_dot_table__Struct *)typ.info.obj;
      strings__Builder_writeln(&/* ? */ g->definitions,
                               _STR("struct %.*s {", name.len, name.str));
      array_v_dot_table__Field tmp131 = info.fields;
      for (int tmp132 = 0; tmp132 < tmp131.len; tmp132++) {
        v_dot_table__Field field = ((v_dot_table__Field *)tmp131.data)[tmp132];

        string type_name = v_dot_gen__Gen_typ(g, field.typ);
        strings__Builder_writeln(&/* ? */ g->definitions,
                                 _STR("\t%.*s %.*s;", type_name.len,
                                      type_name.str, field.name.len,
                                      field.name.str));
      };
      strings__Builder_writeln(&/* ? */ g->definitions, tos3("};\n"));
      strings__Builder_writeln(
          &/* ? */ g->typedefs,
          _STR("#define _type_idx_%.*s %d", name.len, name.str, i));
    } else if (tmp130.typ == SumType_v_dot_table__TypeInfo_Enum) {
      v_dot_table__Enum *it = (v_dot_table__Enum *)tmp130.obj;
      strings__Builder_writeln(&/* ? */ g->definitions, tos3("typedef enum {"));
      array_string tmp133 = it->vals;
      for (int j = 0; j < tmp133.len; j++) {
        string val = ((string *)tmp133.data)[j];

        strings__Builder_writeln(&/* ? */ g->definitions,
                                 _STR("\t%.*s_%.*s, // %d", name.len, name.str,
                                      val.len, val.str, j));
      };
      strings__Builder_writeln(&/* ? */ g->definitions,
                               _STR("} %.*s;\n", name.len, name.str));
    } else if (tmp130.typ == SumType_v_dot_table__TypeInfo_SumType) {
      v_dot_table__SumType *it = (v_dot_table__SumType *)tmp130.obj;
      strings__Builder_writeln(&/* ? */ g->definitions, tos3("// Sum type"));
      strings__Builder_writeln(&/* ? */ g->definitions,
                               _STR("\n				typedef struct "
                                    "{\nvoid* obj;\nint typ;\n} %.*s;",
                                    name.len, name.str));
    } else // default:
    {
    };
  };
}
array_v_dot_table__TypeSymbol
v_dot_gen__Gen_sort_structs(v_dot_gen__Gen *g,
                            array_v_dot_table__TypeSymbol types) {
  v_dot_depgraph__DepGraph *dep_graph = v_dot_depgraph__new_dep_graph();
  array_string type_names = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_v_dot_table__TypeSymbol tmp134 = types;
  for (int tmp135 = 0; tmp135 < tmp134.len; tmp135++) {
    v_dot_table__TypeSymbol typ =
        ((v_dot_table__TypeSymbol *)tmp134.data)[tmp135];

    _PUSH(&type_names, (/*typ = array_string   tmp_typ=string*/ typ.name),
          tmp136, string);
  };
  array_v_dot_table__TypeSymbol tmp137 = types;
  for (int tmp138 = 0; tmp138 < tmp137.len; tmp138++) {
    v_dot_table__TypeSymbol t =
        ((v_dot_table__TypeSymbol *)tmp137.data)[tmp138];

    array_string field_deps = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    v_dot_table__TypeInfo tmp139 = t.info;

    if (tmp139.typ == SumType_v_dot_table__TypeInfo_Struct) {
      v_dot_table__Struct *it = (v_dot_table__Struct *)tmp139.obj;
      v_dot_table__Struct info = *(v_dot_table__Struct *)t.info.obj;
      array_v_dot_table__Field tmp140 = info.fields;
      for (int tmp141 = 0; tmp141 < tmp140.len; tmp141++) {
        v_dot_table__Field field = ((v_dot_table__Field *)tmp140.data)[tmp141];

        string dep =
            v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, field.typ)
                ->name;
        if (!((_IN(string, (dep), type_names))) ||
            (_IN(string, (dep), field_deps)) ||
            v_dot_table__type_is_ptr(field.typ)) {
          continue;
        };
        _PUSH(&field_deps, (/*typ = array_string   tmp_typ=string*/ dep),
              tmp142, string);
      };
    } else // default:
    {
    };
    v_dot_depgraph__DepGraph_add(dep_graph, t.name, field_deps);
  };
  v_dot_depgraph__DepGraph *dep_graph_sorted =
      v_dot_depgraph__DepGraph_resolve(&/* ? */ *dep_graph);
  if (!dep_graph_sorted->acyclic) {
    v_dot_gen__verror(string_add(
        string_add(
            string_add(tos3("cgen.sort_structs(): the following structs form a "
                            "dependency cycle:\n"),
                       v_dot_depgraph__DepGraph_display_cycles(
                           &/* ? */ *dep_graph_sorted)),
            tos3("\nyou can solve this by making one or both of the dependant "
                 "struct fields references, eg: field &MyStruct")),
        tos3("\nif you feel this is an error, please create a new issue here: "
             "https://github.com/vlang/v/issues and tag @joe-conigliaro")));
  };
  array_v_dot_table__TypeSymbol types_sorted = new_array_from_c_array(
      0, 0, sizeof(v_dot_table__TypeSymbol),
      EMPTY_ARRAY_OF_ELEMS(v_dot_table__TypeSymbol, 0){TCCSKIP(0)});
  array_v_dot_depgraph__DepGraphNode tmp143 = dep_graph_sorted->nodes;
  for (int tmp144 = 0; tmp144 < tmp143.len; tmp144++) {
    v_dot_depgraph__DepGraphNode node =
        ((v_dot_depgraph__DepGraphNode *)tmp143.data)[tmp144];

    int tmp146 = 0;
    bool tmp147 =
        map_get(/*cgen.v : 1418*/ g->table->type_idxs, node.name, &tmp146);

    _PUSH(&types_sorted,
          (/*typ = array_v_dot_table__TypeSymbol
              tmp_typ=v_dot_table__TypeSymbol*/
           (*(v_dot_table__TypeSymbol *)array_get(g->table->types, tmp146))),
          tmp145, v_dot_table__TypeSymbol);
  };
  return types_sorted;
}
string v_dot_gen__op_to_fn_name(string name) {
  string tmp150 = name;

  return ((string_eq(tmp150, tos3("+")))
              ? (tos3("_op_plus"))
              : ((string_eq(tmp150, tos3("-")))
                     ? (tos3("_op_minus"))
                     : ((string_eq(tmp150, tos3("*")))
                            ? (tos3("_op_mul"))
                            : ((string_eq(tmp150, tos3("/")))
                                   ? (tos3("_op_div"))
                                   : ((string_eq(tmp150, tos3("%")))
                                          ? (tos3("_op_mod"))
                                          : (_STR("bad op %.*s", name.len,
                                                  name.str)))))));
}
string v_dot_gen__jsgen(v_dot_ast__File program, v_dot_table__Table *table) {
  v_dot_gen__JsGen g =
      (v_dot_gen__JsGen){.out = strings__new_builder(100), .table = table};
  array_v_dot_ast__Stmt tmp1 = program.stmts;
  for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
    v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp1.data)[tmp2];

    v_dot_gen__JsGen_stmt(&/* ? */ g, stmt);
    v_dot_gen__JsGen_writeln(&/* ? */ g, tos3(""));
  };
  return (strings__Builder_str(&/* ? */ g.out));
}
void v_dot_gen__JsGen_save(v_dot_gen__JsGen *g) {}
void v_dot_gen__JsGen_write(v_dot_gen__JsGen *g, string s) {
  strings__Builder_write(&/* ? */ g->out, s);
}
void v_dot_gen__JsGen_writeln(v_dot_gen__JsGen *g, string s) {
  strings__Builder_writeln(&/* ? */ g->out, s);
}
void v_dot_gen__JsGen_stmt(v_dot_gen__JsGen *g, v_dot_ast__Stmt node) {
  v_dot_ast__Stmt tmp3 = node;

  if (tmp3.typ == SumType_v_dot_ast__Stmt_FnDecl) {
    v_dot_ast__FnDecl *it = (v_dot_ast__FnDecl *)tmp3.obj;
    v_dot_table__TypeSymbol *type_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, it->return_type);
    v_dot_gen__JsGen_write(g, _STR("/** @return { %.*s } **/\nfunction %.*s(",
                                   type_sym->name.len, type_sym->name.str,
                                   it->name.len, it->name.str));
    array_v_dot_table__Arg tmp4 = it->args;
    for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
      v_dot_table__Arg arg = ((v_dot_table__Arg *)tmp4.data)[tmp5];

      v_dot_table__TypeSymbol *arg_type_sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, arg.typ);
      v_dot_gen__JsGen_write(
          g, _STR(" /** @type { %.*s } **/ %.*s", arg_type_sym->name.len,
                  arg_type_sym->name.str, arg.name.len, arg.name.str));
    };
    v_dot_gen__JsGen_writeln(g, tos3(") { "));
    array_v_dot_ast__Stmt tmp6 = it->stmts;
    for (int tmp7 = 0; tmp7 < tmp6.len; tmp7++) {
      v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp6.data)[tmp7];

      v_dot_gen__JsGen_stmt(g, stmt);
    };
    v_dot_gen__JsGen_writeln(g, tos3("}"));
  } else if (tmp3.typ == SumType_v_dot_ast__Stmt_Return) {
    v_dot_ast__Return *it = (v_dot_ast__Return *)tmp3.obj;
    v_dot_gen__JsGen_write(g, tos3("return "));
    if (it->exprs.len > 0) {
    } else {
      v_dot_gen__JsGen_expr(g, (*(v_dot_ast__Expr *)array_get(it->exprs, 0)));
    };
    v_dot_gen__JsGen_writeln(g, tos3(";"));
  } else if (tmp3.typ == SumType_v_dot_ast__Stmt_AssignStmt) {
    v_dot_ast__AssignStmt *it = (v_dot_ast__AssignStmt *)tmp3.obj;
    if (it->left.len > it->right.len) {
    } else {
      array_v_dot_ast__Ident tmp10 = it->left;
      for (int i = 0; i < tmp10.len; i++) {
        v_dot_ast__Ident ident = ((v_dot_ast__Ident *)tmp10.data)[i];

        v_dot_ast__IdentVar var_info =
            v_dot_ast__Ident_var_info(&/* ? */ ident);
        v_dot_table__TypeSymbol *var_type_sym =
            v_dot_table__Table_get_type_symbol(&/* ? */ *g->table,
                                               var_info.typ);
        v_dot_ast__Expr val = (*(v_dot_ast__Expr *)array_get(it->right, i));
        v_dot_gen__JsGen_write(
            g, _STR("var /* %.*s */ %.*s = ", var_type_sym->name.len,
                    var_type_sym->name.str, ident.name.len, ident.name.str));
        v_dot_gen__JsGen_expr(g, val);
        v_dot_gen__JsGen_writeln(g, tos3(";"));
      };
    };
  } else if (tmp3.typ == SumType_v_dot_ast__Stmt_ForStmt) {
    v_dot_ast__ForStmt *it = (v_dot_ast__ForStmt *)tmp3.obj;
    v_dot_gen__JsGen_write(g, tos3("while ("));
    v_dot_gen__JsGen_expr(g, it->cond);
    v_dot_gen__JsGen_writeln(g, tos3(") {"));
    array_v_dot_ast__Stmt tmp13 = it->stmts;
    for (int tmp14 = 0; tmp14 < tmp13.len; tmp14++) {
      v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp13.data)[tmp14];

      v_dot_gen__JsGen_stmt(g, stmt);
    };
    v_dot_gen__JsGen_writeln(g, tos3("}"));
  } else if (tmp3.typ == SumType_v_dot_ast__Stmt_StructDecl) {
    v_dot_ast__StructDecl *it = (v_dot_ast__StructDecl *)tmp3.obj;
    v_dot_gen__JsGen_writeln(
        g, _STR("var %.*s = function() {};", it->name.len, it->name.str));
  } else if (tmp3.typ == SumType_v_dot_ast__Stmt_ExprStmt) {
    v_dot_ast__ExprStmt *it = (v_dot_ast__ExprStmt *)tmp3.obj;
    v_dot_gen__JsGen_expr(g, it->expr);
    v_dot_ast__Expr tmp15 = it->expr;

    if (tmp15.typ == SumType_v_dot_ast__Expr_IfExpr) {
      v_dot_ast__IfExpr *it = (v_dot_ast__IfExpr *)tmp15.obj;
    } else // default:
    {
      v_dot_gen__JsGen_writeln(g, tos3(";"));
    };
  } else // default:
  {
    v_dot_gen__verror(tos3("jsgen.stmt(): bad node"));
  };
}
void v_dot_gen__JsGen_expr(v_dot_gen__JsGen *g, v_dot_ast__Expr node) {
  v_dot_ast__Expr tmp16 = node;

  if (tmp16.typ == SumType_v_dot_ast__Expr_IntegerLiteral) {
    v_dot_ast__IntegerLiteral *it = (v_dot_ast__IntegerLiteral *)tmp16.obj;
    v_dot_gen__JsGen_write(g, int_str(it->val));
  } else if (tmp16.typ == SumType_v_dot_ast__Expr_FloatLiteral) {
    v_dot_ast__FloatLiteral *it = (v_dot_ast__FloatLiteral *)tmp16.obj;
    v_dot_gen__JsGen_write(g, it->val);
  } else if (tmp16.typ == SumType_v_dot_ast__Expr_StringLiteral) {
    v_dot_ast__StringLiteral *it = (v_dot_ast__StringLiteral *)tmp16.obj;
    v_dot_gen__JsGen_write(g, _STR("tos3(\"%.*s\")", it->val.len, it->val.str));
  } else if (tmp16.typ == SumType_v_dot_ast__Expr_InfixExpr) {
    v_dot_ast__InfixExpr *it = (v_dot_ast__InfixExpr *)tmp16.obj;
    v_dot_gen__JsGen_expr(g, it->left);
    v_dot_gen__JsGen_write(g, _STR(" %.*s ", v_dot_token__Kind_str(it->op).len,
                                   v_dot_token__Kind_str(it->op).str));
    v_dot_gen__JsGen_expr(g, it->right);
  } else if (tmp16.typ == SumType_v_dot_ast__Expr_StructInit) {
    v_dot_ast__StructInit *it = (v_dot_ast__StructInit *)tmp16.obj;
    v_dot_table__TypeSymbol *type_sym =
        v_dot_table__Table_get_type_symbol(&/* ? */ *g->table, it->typ);
    v_dot_gen__JsGen_writeln(
        g, _STR("/*%.*s*/{", type_sym->name.len, type_sym->name.str));
    array_string tmp17 = it->fields;
    for (int i = 0; i < tmp17.len; i++) {
      string field = ((string *)tmp17.data)[i];

      v_dot_gen__JsGen_write(g, _STR("\t%.*s : ", field.len, field.str));
      v_dot_gen__JsGen_expr(g, (*(v_dot_ast__Expr *)array_get(it->exprs, i)));
      v_dot_gen__JsGen_writeln(g, tos3(", "));
    };
    v_dot_gen__JsGen_write(g, tos3("}"));
  } else if (tmp16.typ == SumType_v_dot_ast__Expr_CallExpr) {
    v_dot_ast__CallExpr *it = (v_dot_ast__CallExpr *)tmp16.obj;
    v_dot_gen__JsGen_write(g, _STR("%.*s(", it->name.len, it->name.str));
    array_v_dot_ast__CallArg tmp20 = it->args;
    for (int i = 0; i < tmp20.len; i++) {
      v_dot_ast__CallArg arg = ((v_dot_ast__CallArg *)tmp20.data)[i];

      v_dot_gen__JsGen_expr(g, arg.expr);
      if (i != it->args.len - 1) {
        v_dot_gen__JsGen_write(g, tos3(", "));
      };
    };
    v_dot_gen__JsGen_write(g, tos3(")"));
  } else if (tmp16.typ == SumType_v_dot_ast__Expr_Ident) {
    v_dot_ast__Ident *it = (v_dot_ast__Ident *)tmp16.obj;
    v_dot_gen__JsGen_write(g, _STR("%.*s", it->name.len, it->name.str));
  } else if (tmp16.typ == SumType_v_dot_ast__Expr_BoolLiteral) {
    v_dot_ast__BoolLiteral *it = (v_dot_ast__BoolLiteral *)tmp16.obj;
    if (it->val == 1) {
      v_dot_gen__JsGen_write(g, tos3("true"));
    } else {
      v_dot_gen__JsGen_write(g, tos3("false"));
    };
  } else if (tmp16.typ == SumType_v_dot_ast__Expr_IfExpr) {
    v_dot_ast__IfExpr *it = (v_dot_ast__IfExpr *)tmp16.obj;
    v_dot_gen__JsGen_write(g, tos3("if ("));
    v_dot_gen__JsGen_expr(g, it->cond);
    v_dot_gen__JsGen_writeln(g, tos3(") {"));
    array_v_dot_ast__Stmt tmp21 = it->stmts;
    for (int tmp22 = 0; tmp22 < tmp21.len; tmp22++) {
      v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp21.data)[tmp22];

      v_dot_gen__JsGen_stmt(g, stmt);
    };
    v_dot_gen__JsGen_writeln(g, tos3("}"));
  } else // default:
  {
    println(term__red(tos3("jsgen.expr(): bad node")));
  };
}
void v_dot_gen_dot_x64__Gen_generate_elf_header(v_dot_gen_dot_x64__Gen *g) {
  _PUSH_MANY(&g->buf,
             (/*typ = array_byte   tmp_typ=byte*/ new_array_from_c_array(
                 4, 4, sizeof(byte),
                 EMPTY_ARRAY_OF_ELEMS(byte, 4){
                     ((byte)(v_dot_gen_dot_x64__mag0)), v_dot_gen_dot_x64__mag1,
                     v_dot_gen_dot_x64__mag2, v_dot_gen_dot_x64__mag3})),
             tmp1, array_byte);
  _PUSH(&g->buf,
        (/*typ = array_byte   tmp_typ=byte*/ v_dot_gen_dot_x64__elfclass64),
        tmp2, byte);
  _PUSH(&g->buf,
        (/*typ = array_byte   tmp_typ=byte*/ v_dot_gen_dot_x64__elfdata2lsb),
        tmp3, byte);
  _PUSH(&g->buf,
        (/*typ = array_byte   tmp_typ=byte*/ v_dot_gen_dot_x64__ev_current),
        tmp4, byte);
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ 1), tmp5, byte);
  v_dot_gen_dot_x64__Gen_write64(g, 0);
  v_dot_gen_dot_x64__Gen_write16(g, 2);
  v_dot_gen_dot_x64__Gen_write16(g, v_dot_gen_dot_x64__e_machine);
  v_dot_gen_dot_x64__Gen_write32(g, v_dot_gen_dot_x64__ev_current);
  int eh_size = 0x40;
  int phent_size = 0x38;
  v_dot_gen_dot_x64__Gen_write64(g, v_dot_gen_dot_x64__segment_start + eh_size +
                                        phent_size);
  v_dot_gen_dot_x64__Gen_write64(g, 0x40);
  v_dot_gen_dot_x64__Gen_write64(g, 0);
  v_dot_gen_dot_x64__Gen_write32(g, 0);
  v_dot_gen_dot_x64__Gen_write16(g, eh_size);
  v_dot_gen_dot_x64__Gen_write16(g, phent_size);
  v_dot_gen_dot_x64__Gen_write16(g, 1);
  v_dot_gen_dot_x64__Gen_write16(g, 0);
  v_dot_gen_dot_x64__Gen_write16(g, 0);
  v_dot_gen_dot_x64__Gen_write16(g, 0);
  v_dot_gen_dot_x64__Gen_write32(g, 1);
  v_dot_gen_dot_x64__Gen_write32(g, 5);
  v_dot_gen_dot_x64__Gen_write64(g, 0);
  v_dot_gen_dot_x64__Gen_write64(g, v_dot_gen_dot_x64__segment_start);
  v_dot_gen_dot_x64__Gen_write64(g, v_dot_gen_dot_x64__segment_start);
  g->file_size_pos = g->buf.len;
  v_dot_gen_dot_x64__Gen_write64(g, 0);
  v_dot_gen_dot_x64__Gen_write64(g, 0);
  v_dot_gen_dot_x64__Gen_write64(g, 0x1000);
  g->code_start_pos = g->buf.len;
  v_dot_gen_dot_x64__Gen_call(g, 0);
}
void v_dot_gen_dot_x64__Gen_generate_elf_footer(v_dot_gen_dot_x64__Gen *g) {
  v_dot_gen_dot_x64__Gen_mov(
      g, v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_edi, 0);
  v_dot_gen_dot_x64__Gen_mov(
      g, v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_eax, 60);
  v_dot_gen_dot_x64__Gen_syscall(g);
  array_string tmp6 = g->strings;
  for (int i = 0; i < tmp6.len; i++) {
    string s = ((string *)tmp6.data)[i];

    v_dot_gen_dot_x64__Gen_write64_at(
        g, v_dot_gen_dot_x64__segment_start + g->buf.len,
        ((int)((*(i64 *)array_get(g->str_pos, i)))));
    v_dot_gen_dot_x64__Gen_write_string(g, s);
    v_dot_gen_dot_x64__Gen_write8(g, 6);
  };
  int file_size = g->buf.len;
  v_dot_gen_dot_x64__Gen_write64_at(g, file_size, g->file_size_pos);
  v_dot_gen_dot_x64__Gen_write64_at(g, file_size, g->file_size_pos + 8);
  v_dot_gen_dot_x64__Gen_write64_at(
      g, ((int)(g->main_fn_addr - g->code_start_pos)) - 5,
      g->code_start_pos + 1);
  Option_os__File tmp9 = os__create(g->out_name);
  os__File f;
  if (!tmp9.ok) {
    string err = tmp9.error;
    int errcode = tmp9.ecode;
    v_panic(err);
  }
  f = *(os__File *)tmp9.data;
  ;
  os__chmod(g->out_name, 0775);
  os__File_write_bytes(&/* ? */ f, g->buf.data, g->buf.len);
  os__File_close(&/* ? */ f);
  println(tos3("x64 elf binary has been successfully generated"));
}
void v_dot_gen_dot_x64__Gen_section_header(v_dot_gen_dot_x64__Gen *g,
                                           v_dot_gen_dot_x64__SectionConfig c) {
  v_dot_gen_dot_x64__Gen_write32(g, g->sect_header_name_pos);
  g->sect_header_name_pos += c.name.len + 1;
  v_dot_gen_dot_x64__Gen_write32(g, ((int)(c.typ)));
  v_dot_gen_dot_x64__Gen_write64(g, c.flags);
  v_dot_gen_dot_x64__Gen_write64(g, 0);
  v_dot_gen_dot_x64__Gen_write64(g, g->offset);
  g->offset += c.datalen + 1;
  v_dot_gen_dot_x64__Gen_write64(g, c.datalen);
  v_dot_gen_dot_x64__Gen_write32(g, c.link);
  v_dot_gen_dot_x64__Gen_write32(g, c.info);
  v_dot_gen_dot_x64__Gen_write64(g, c.align);
  v_dot_gen_dot_x64__Gen_write64(g, c.entsize);
}
void v_dot_gen_dot_x64__genobj() {}
void v_dot_gen_dot_x64__gen(array_v_dot_ast__File files, string out_name) {
  v_dot_gen_dot_x64__Gen g =
      (v_dot_gen_dot_x64__Gen){.sect_header_name_pos = 0,
                               .out_name = out_name,
                               .buf = new_array(0, 1, sizeof(byte)),
                               .offset = 0,
                               .str_pos = new_array(0, 1, sizeof(i64)),
                               .strings = new_array(0, 1, sizeof(string)),
                               .file_size_pos = 0,
                               .main_fn_addr = 0,
                               .code_start_pos = 0,
                               .fn_addr = new_map(1, sizeof(i64))};
  v_dot_gen_dot_x64__Gen_generate_elf_header(&/* ? */ g);
  array_v_dot_ast__File tmp1 = files;
  for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
    v_dot_ast__File file = ((v_dot_ast__File *)tmp1.data)[tmp2];

    array_v_dot_ast__Stmt tmp3 = file.stmts;
    for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
      v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp3.data)[tmp4];

      v_dot_gen_dot_x64__Gen_stmt(&/* ? */ g, stmt);
      v_dot_gen_dot_x64__Gen_writeln(&/* ? */ g, tos3(""));
    };
  };
  v_dot_gen_dot_x64__Gen_generate_elf_footer(&/* ? */ g);
}
i64 v_dot_gen_dot_x64__Gen_pos(v_dot_gen_dot_x64__Gen *g) { return g->buf.len; }
void v_dot_gen_dot_x64__Gen_write8(v_dot_gen_dot_x64__Gen *g, int n) {
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n))), tmp5, byte);
}
void v_dot_gen_dot_x64__Gen_write16(v_dot_gen_dot_x64__Gen *g, int n) {
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n))), tmp6, byte);
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n >> 8))), tmp7,
        byte);
}
void v_dot_gen_dot_x64__Gen_write32(v_dot_gen_dot_x64__Gen *g, int n) {
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n))), tmp8, byte);
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n >> 8))), tmp9,
        byte);
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n >> 16))), tmp10,
        byte);
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n >> 24))), tmp11,
        byte);
}
void v_dot_gen_dot_x64__Gen_write64(v_dot_gen_dot_x64__Gen *g, i64 n) {
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n))), tmp12,
        byte);
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n >> 8))), tmp13,
        byte);
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n >> 16))), tmp14,
        byte);
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n >> 24))), tmp15,
        byte);
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n >> 32))), tmp16,
        byte);
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n >> 40))), tmp17,
        byte);
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n >> 48))), tmp18,
        byte);
  _PUSH(&g->buf, (/*typ = array_byte   tmp_typ=byte*/ ((byte)(n >> 56))), tmp19,
        byte);
}
void v_dot_gen_dot_x64__Gen_write64_at(v_dot_gen_dot_x64__Gen *g, i64 n,
                                       i64 at) {
  array_set(&/*q*/ g->buf, at, &(byte[]){((byte)(n))});
  array_set(&/*q*/ g->buf, at + 1, &(byte[]){((byte)(n >> 8))});
  array_set(&/*q*/ g->buf, at + 2, &(byte[]){((byte)(n >> 16))});
  array_set(&/*q*/ g->buf, at + 3, &(byte[]){((byte)(n >> 24))});
  array_set(&/*q*/ g->buf, at + 4, &(byte[]){((byte)(n >> 32))});
  array_set(&/*q*/ g->buf, at + 5, &(byte[]){((byte)(n >> 40))});
  array_set(&/*q*/ g->buf, at + 6, &(byte[]){((byte)(n >> 48))});
  array_set(&/*q*/ g->buf, at + 7, &(byte[]){((byte)(n >> 56))});
}
void v_dot_gen_dot_x64__Gen_write_string(v_dot_gen_dot_x64__Gen *g, string s) {
  string tmp20 = s;
  ;
  for (int tmp21 = 0; tmp21 < tmp20.len; tmp21++) {
    byte c = tmp20.str[tmp21];

    v_dot_gen_dot_x64__Gen_write8(g, ((int)(c)));
  };
}
void v_dot_gen_dot_x64__Gen_inc(v_dot_gen_dot_x64__Gen *g,
                                v_dot_gen_dot_x64__Register reg) {
  v_dot_gen_dot_x64__Gen_write16(g, 0xff49);
  v_dot_gen_dot_x64__Register tmp22 = reg;

  if (tmp22 == v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_r12) {
    v_dot_gen_dot_x64__Gen_write8(g, 0xc4);
  } else // default:
  {
    v_panic(_STR("unhandled inc %d", reg));
  };
}
void v_dot_gen_dot_x64__Gen_cmp(v_dot_gen_dot_x64__Gen *g,
                                v_dot_gen_dot_x64__Register reg,
                                v_dot_gen_dot_x64__Size size, i64 val) {
  v_dot_gen_dot_x64__Gen_write8(g, 0x49);
  v_dot_gen_dot_x64__Size tmp23 = size;

  if (tmp23 == v_dot_gen_dot_x64__v_dot_gen_dot_x64__Size__8) {
    v_dot_gen_dot_x64__Gen_write8(g, 0x83);
  } else if (tmp23 == v_dot_gen_dot_x64__v_dot_gen_dot_x64__Size__32) {
    v_dot_gen_dot_x64__Gen_write8(g, 0x81);
  } else // default:
  {
    v_panic(tos3("unhandled cmp"));
  };
  v_dot_gen_dot_x64__Register tmp24 = reg;

  if (tmp24 == v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_r12) {
    v_dot_gen_dot_x64__Gen_write8(g, 0xfc);
  } else // default:
  {
    v_panic(tos3("unhandled cmp"));
  };
  v_dot_gen_dot_x64__Gen_write8(g, ((int)(val)));
}
i64 v_dot_gen_dot_x64__abs(i64 a) { return ((a < 0) ? (-a) : (a)); }
void v_dot_gen_dot_x64__Gen_jle(v_dot_gen_dot_x64__Gen *g, i64 addr) {
  int offset = 0xff - ((int)(v_dot_gen_dot_x64__abs(addr - g->buf.len))) - 1;
  v_dot_gen_dot_x64__Gen_write8(g, 0x7e);
  v_dot_gen_dot_x64__Gen_write8(g, offset);
}
void v_dot_gen_dot_x64__Gen_jl(v_dot_gen_dot_x64__Gen *g, i64 addr) {
  int offset = 0xff - ((int)(v_dot_gen_dot_x64__abs(addr - g->buf.len))) - 1;
  v_dot_gen_dot_x64__Gen_write8(g, 0x7c);
  v_dot_gen_dot_x64__Gen_write8(g, offset);
}
int v_dot_gen_dot_x64__Gen_abs_to_rel_addr(v_dot_gen_dot_x64__Gen *g,
                                           i64 addr) {
  return ((int)(v_dot_gen_dot_x64__abs(addr - g->buf.len))) - 1;
}
void v_dot_gen_dot_x64__Gen_jmp(v_dot_gen_dot_x64__Gen *g, i64 addr) {
  int offset = 0xff - v_dot_gen_dot_x64__Gen_abs_to_rel_addr(&/* ? */ *g, addr);
  v_dot_gen_dot_x64__Gen_write8(g, 0xe9);
  v_dot_gen_dot_x64__Gen_write8(g, offset);
}
void v_dot_gen_dot_x64__Gen_mov64(v_dot_gen_dot_x64__Gen *g,
                                  v_dot_gen_dot_x64__Register reg, i64 val) {
  v_dot_gen_dot_x64__Register tmp25 = reg;

  if (tmp25 == v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_rsi) {
    v_dot_gen_dot_x64__Gen_write8(g, 0x48);
    v_dot_gen_dot_x64__Gen_write8(g, 0xbe);
  } else // default:
  {
    printf("unhandled mov %d\n", reg);
  };
  v_dot_gen_dot_x64__Gen_write64(g, val);
}
void v_dot_gen_dot_x64__Gen_call(v_dot_gen_dot_x64__Gen *g, int addr) {
  printf("call addr=%d rel_addr=%d pos=%d\n", addr, addr, g->buf.len);
  v_dot_gen_dot_x64__Gen_write8(g, 0xe8);
  v_dot_gen_dot_x64__Gen_write32(g, addr);
}
void v_dot_gen_dot_x64__Gen_syscall(v_dot_gen_dot_x64__Gen *g) {
  v_dot_gen_dot_x64__Gen_write8(g, 0x0f);
  v_dot_gen_dot_x64__Gen_write8(g, 0x05);
}
void v_dot_gen_dot_x64__Gen_ret(v_dot_gen_dot_x64__Gen *g) {
  v_dot_gen_dot_x64__Gen_write8(g, 0xc3);
}
int v_dot_gen_dot_x64__Gen_gen_loop_start(v_dot_gen_dot_x64__Gen *g, int from) {
  v_dot_gen_dot_x64__Gen_mov(
      g, v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_r12, from);
  int label = g->buf.len;
  v_dot_gen_dot_x64__Gen_inc(
      g, v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_r12);
  return label;
}
void v_dot_gen_dot_x64__Gen_gen_loop_end(v_dot_gen_dot_x64__Gen *g, int to,
                                         int label) {
  v_dot_gen_dot_x64__Gen_cmp(g,
                             v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_r12,
                             v_dot_gen_dot_x64__v_dot_gen_dot_x64__Size__8, to);
  v_dot_gen_dot_x64__Gen_jl(g, label);
}
void v_dot_gen_dot_x64__Gen_save_main_fn_addr(v_dot_gen_dot_x64__Gen *g) {
  g->main_fn_addr = g->buf.len;
}
void v_dot_gen_dot_x64__Gen_gen_print_from_expr(v_dot_gen_dot_x64__Gen *g,
                                                v_dot_ast__Expr expr) {
  v_dot_ast__Expr tmp26 = expr;

  if (tmp26.typ == SumType_v_dot_ast__Expr_StringLiteral) {
    v_dot_ast__StringLiteral *it = (v_dot_ast__StringLiteral *)tmp26.obj;
    v_dot_gen_dot_x64__Gen_gen_print(g, it->val);
  } else // default:
  {
  };
}
void v_dot_gen_dot_x64__Gen_gen_print(v_dot_gen_dot_x64__Gen *g, string s) {
  _PUSH(&g->strings,
        (/*typ = array_string   tmp_typ=string*/ string_add(s, tos3("\n"))),
        tmp27, string);
  v_dot_gen_dot_x64__Gen_mov(
      g, v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_eax, 1);
  v_dot_gen_dot_x64__Gen_mov(
      g, v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_edi, 1);
  int str_pos = g->buf.len + 2;
  _PUSH(&g->str_pos, (/*typ = array_i64   tmp_typ=i64*/ str_pos), tmp28, i64);
  v_dot_gen_dot_x64__Gen_mov64(
      g, v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_rsi, 0);
  v_dot_gen_dot_x64__Gen_mov(
      g, v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_edx, s.len + 1);
  v_dot_gen_dot_x64__Gen_syscall(g);
}
void v_dot_gen_dot_x64__Gen_gen_exit(v_dot_gen_dot_x64__Gen *g) {
  v_dot_gen_dot_x64__Gen_mov(
      g, v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_edi, 0);
  v_dot_gen_dot_x64__Gen_mov(
      g, v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_eax, 60);
  v_dot_gen_dot_x64__Gen_syscall(g);
}
void v_dot_gen_dot_x64__Gen_mov(v_dot_gen_dot_x64__Gen *g,
                                v_dot_gen_dot_x64__Register reg, int val) {
  v_dot_gen_dot_x64__Register tmp29 = reg;

  if (tmp29 == v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_eax) {
    v_dot_gen_dot_x64__Gen_write8(g, 0xb8);
  } else if (tmp29 == v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_edi) {
    v_dot_gen_dot_x64__Gen_write8(g, 0xbf);
  } else if (tmp29 == v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_edx) {
    v_dot_gen_dot_x64__Gen_write8(g, 0xba);
  } else if (tmp29 == v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_rsi) {
    v_dot_gen_dot_x64__Gen_write8(g, 0x48);
    v_dot_gen_dot_x64__Gen_write8(g, 0xbe);
  } else if (tmp29 == v_dot_gen_dot_x64__v_dot_gen_dot_x64__Register_r12) {
    v_dot_gen_dot_x64__Gen_write8(g, 0x41);
    v_dot_gen_dot_x64__Gen_write8(g, 0xbc);
  } else // default:
  {
    v_panic(_STR("unhandled mov %d", reg));
  };
  v_dot_gen_dot_x64__Gen_write32(g, val);
}
void v_dot_gen_dot_x64__Gen_register_function_address(v_dot_gen_dot_x64__Gen *g,
                                                      string name) {
  i64 addr = v_dot_gen_dot_x64__Gen_pos(&/* ? */ *g);
  map_set(&g->fn_addr, name, &(i64[]){addr});
}
void v_dot_gen_dot_x64__Gen_write(v_dot_gen_dot_x64__Gen *g, string s) {}
void v_dot_gen_dot_x64__Gen_writeln(v_dot_gen_dot_x64__Gen *g, string s) {}
void v_dot_gen_dot_x64__Gen_call_fn(v_dot_gen_dot_x64__Gen *g, string name) {
  if (!string_contains(name, tos3("__"))) {

    return;
  };
  i64 tmp30 = 0;
  bool tmp31 = map_get(/*gen.v : 310*/ g->fn_addr, name, &tmp30);

  i64 addr = tmp30;
  v_dot_gen_dot_x64__Gen_call(g, ((int)(addr)));
  printf("call %.*s %lld\n", name.len, name.str, addr);
}
void v_dot_gen_dot_x64__Gen_stmt(v_dot_gen_dot_x64__Gen *g,
                                 v_dot_ast__Stmt node) {
  v_dot_ast__Stmt tmp32 = node;

  if (tmp32.typ == SumType_v_dot_ast__Stmt_ConstDecl) {
    v_dot_ast__ConstDecl *it = (v_dot_ast__ConstDecl *)tmp32.obj;
  } else if (tmp32.typ == SumType_v_dot_ast__Stmt_FnDecl) {
    v_dot_ast__FnDecl *it = (v_dot_ast__FnDecl *)tmp32.obj;
    bool is_main = string_eq(it->name, tos3("main"));
    if (is_main) {
      v_dot_gen_dot_x64__Gen_save_main_fn_addr(g);
    };
    array_v_dot_table__Arg tmp33 = it->args;
    for (int tmp34 = 0; tmp34 < tmp33.len; tmp34++) {
      v_dot_table__Arg arg = ((v_dot_table__Arg *)tmp33.data)[tmp34];
    };
    array_v_dot_ast__Stmt tmp35 = it->stmts;
    for (int tmp36 = 0; tmp36 < tmp35.len; tmp36++) {
      v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp35.data)[tmp36];

      v_dot_gen_dot_x64__Gen_stmt(g, stmt);
    };
    if (is_main) {
      println(tos3("end of main: gen exit"));
      v_dot_gen_dot_x64__Gen_gen_exit(g);
    };
    v_dot_gen_dot_x64__Gen_ret(g);
  } else if (tmp32.typ == SumType_v_dot_ast__Stmt_Return) {
    v_dot_ast__Return *it = (v_dot_ast__Return *)tmp32.obj;
  } else if (tmp32.typ == SumType_v_dot_ast__Stmt_AssignStmt) {
    v_dot_ast__AssignStmt *it = (v_dot_ast__AssignStmt *)tmp32.obj;
  } else if (tmp32.typ == SumType_v_dot_ast__Stmt_ForStmt) {
    v_dot_ast__ForStmt *it = (v_dot_ast__ForStmt *)tmp32.obj;
  } else if (tmp32.typ == SumType_v_dot_ast__Stmt_StructDecl) {
    v_dot_ast__StructDecl *it = (v_dot_ast__StructDecl *)tmp32.obj;
  } else if (tmp32.typ == SumType_v_dot_ast__Stmt_ExprStmt) {
    v_dot_ast__ExprStmt *it = (v_dot_ast__ExprStmt *)tmp32.obj;
    v_dot_gen_dot_x64__Gen_expr(g, it->expr);
  } else // default:
  {
    v_dot_gen_dot_x64__verror(tos3("x64.stmt(): bad node"));
  };
}
void v_dot_gen_dot_x64__Gen_expr(v_dot_gen_dot_x64__Gen *g,
                                 v_dot_ast__Expr node) {
  v_dot_ast__Expr tmp37 = node;

  if (tmp37.typ == SumType_v_dot_ast__Expr_AssignExpr) {
    v_dot_ast__AssignExpr *it = (v_dot_ast__AssignExpr *)tmp37.obj;
  } else if (tmp37.typ == SumType_v_dot_ast__Expr_IntegerLiteral) {
    v_dot_ast__IntegerLiteral *it = (v_dot_ast__IntegerLiteral *)tmp37.obj;
  } else if (tmp37.typ == SumType_v_dot_ast__Expr_FloatLiteral) {
    v_dot_ast__FloatLiteral *it = (v_dot_ast__FloatLiteral *)tmp37.obj;
  } else if (tmp37.typ == SumType_v_dot_ast__Expr_StringLiteral) {
    v_dot_ast__StringLiteral *it = (v_dot_ast__StringLiteral *)tmp37.obj;
  } else if (tmp37.typ == SumType_v_dot_ast__Expr_InfixExpr) {
    v_dot_ast__InfixExpr *it = (v_dot_ast__InfixExpr *)tmp37.obj;
  } else if (tmp37.typ == SumType_v_dot_ast__Expr_StructInit) {
    v_dot_ast__StructInit *it = (v_dot_ast__StructInit *)tmp37.obj;
  } else if (tmp37.typ == SumType_v_dot_ast__Expr_CallExpr) {
    v_dot_ast__CallExpr *it = (v_dot_ast__CallExpr *)tmp37.obj;
    if (string_eq(it->name, tos3("println")) ||
        string_eq(it->name, tos3("print"))) {
      v_dot_ast__Expr expr =
          (*(v_dot_ast__CallArg *)array_get(it->args, 0)).expr;
      v_dot_gen_dot_x64__Gen_gen_print_from_expr(g, expr);
    };
  } else if (tmp37.typ == SumType_v_dot_ast__Expr_ArrayInit) {
    v_dot_ast__ArrayInit *it = (v_dot_ast__ArrayInit *)tmp37.obj;
  } else if (tmp37.typ == SumType_v_dot_ast__Expr_Ident) {
    v_dot_ast__Ident *it = (v_dot_ast__Ident *)tmp37.obj;
  } else if (tmp37.typ == SumType_v_dot_ast__Expr_BoolLiteral) {
    v_dot_ast__BoolLiteral *it = (v_dot_ast__BoolLiteral *)tmp37.obj;
  } else if (tmp37.typ == SumType_v_dot_ast__Expr_IfExpr) {
    v_dot_ast__IfExpr *it = (v_dot_ast__IfExpr *)tmp37.obj;
  } else // default:
  {
  };
}
void v_dot_gen_dot_x64__verror(string s) {
  println(s);
  v_exit(1);
}
string v_dot_doc__doc(string mod, v_dot_table__Table *table) {
  v_dot_doc__Doc d =
      (v_dot_doc__Doc){.out = strings__new_builder(1000),
                       .table = table,
                       .mod = mod,
                       .stmts = new_array(0, 1, sizeof(v_dot_ast__Stmt))};
  string vlib_path =
      string_add(os__dir(v_dot_pref__vexe_path()), tos3("/vlib"));
  string mod_path = string_replace(mod, tos3("."), os__path_separator);
  string path =
      os__join_path(vlib_path, &(varg_string){.len = 1, .args = {mod_path}});
  if (!os__exists(path)) {
    printf("module \"%.*s\" not found\n", mod.len, mod.str);
    println(path);
    return tos3("");
  };
  Option_array_string tmp1 = os__ls(path);
  array_string files;
  if (!tmp1.ok) {
    string err = tmp1.error;
    int errcode = tmp1.ecode;
    v_panic(err);
  }
  files = *(array_string *)tmp1.data;
  ;
  array_string tmp2 = files;
  for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
    string file = ((string *)tmp2.data)[tmp3];

    if (!string_ends_with(file, tos3(".v"))) {
      continue;
    };
    if (string_ends_with(file, tos3("_test.v")) ||
        string_ends_with(file, tos3("_windows.v")) ||
        string_ends_with(file, tos3("_macos.v"))) {
      continue;
    };
    v_dot_ast__File file_ast = v_dot_parser__parse_file(
        os__join_path(path, &(varg_string){.len = 1, .args = {file}}), table,
        v_dot_scanner__v_dot_scanner__CommentsMode_skip_comments);
    _PUSH_MANY(
        &d.stmts,
        (/*typ = array_v_dot_ast__Stmt   tmp_typ=v_dot_ast__Stmt*/ file_ast
             .stmts),
        tmp4, array_v_dot_ast__Stmt);
  };
  if (d.stmts.len == 0) {
    println(tos3("nothing here"));
    v_exit(1);
  };
  v_dot_doc__Doc_print_structs(&/* ? */ d);
  v_dot_doc__Doc_print_enums(&/* ? */ d);
  v_dot_doc__Doc_print_fns(&/* ? */ d);
  strings__Builder_writeln(&/* ? */ d.out, tos3(""));
  v_dot_doc__Doc_print_methods(&/* ? */ d);
  return string_trim_space(strings__Builder_str(&/* ? */ d.out));
}
string v_dot_doc__Doc_get_fn_node(v_dot_doc__Doc *d, v_dot_ast__FnDecl f) {
  return string_replace_each(
      v_dot_ast__FnDecl_str(&/* ? */ f, d->table),
      new_array_from_c_array(
          4, 4, sizeof(string),
          EMPTY_ARRAY_OF_ELEMS(string, 4){string_add(d->mod, tos3(".")),
                                          tos3(""), tos3("pub "), tos3("")}));
}
void v_dot_doc__Doc_print_fns(v_dot_doc__Doc *d) {
  array_string fn_signatures =
      v_dot_doc__Doc_get_fn_signatures(*d, v_dot_doc__is_pub_function);
  v_dot_doc__Doc_write_fn_signatures(d, fn_signatures);
}
void v_dot_doc__Doc_print_methods(v_dot_doc__Doc *d) {
  array_string fn_signatures =
      v_dot_doc__Doc_get_fn_signatures(*d, v_dot_doc__is_pub_method);
  v_dot_doc__Doc_write_fn_signatures(d, fn_signatures);
}
static inline void
v_dot_doc__Doc_write_fn_signatures(v_dot_doc__Doc *d,
                                   array_string fn_signatures) {
  array_string tmp5 = fn_signatures;
  for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
    string s = ((string *)tmp5.data)[tmp6];

    strings__Builder_writeln(&/* ? */ d->out, s);
  };
}
array_string v_dot_doc__Doc_get_fn_signatures(v_dot_doc__Doc d,
                                              v_dot_doc__FilterFn filter_fn) {
  array_string fn_signatures = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_v_dot_ast__Stmt tmp7 = d.stmts;
  for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
    v_dot_ast__Stmt stmt = ((v_dot_ast__Stmt *)tmp7.data)[tmp8];

    v_dot_ast__Stmt tmp9 = stmt;

    if (tmp9.typ == SumType_v_dot_ast__Stmt_FnDecl) {
      v_dot_ast__FnDecl *it = (v_dot_ast__FnDecl *)tmp9.obj;
      if (filter_fn(*it)) {
        _PUSH(
            &fn_signatures,
            (/*typ = array_string   tmp_typ=string*/ v_dot_doc__Doc_get_fn_node(
                &/* ? */ d, *it)),
            tmp10, string);
      };
    } else // default:
    {
    };
  };
  array_string_sort(&/* ? */ fn_signatures);
  return fn_signatures;
}
bool v_dot_doc__is_pub_method(v_dot_ast__FnDecl node) {
  return node.is_pub && node.is_method && !node.is_deprecated;
}
bool v_dot_doc__is_pub_function(v_dot_ast__FnDecl node) {
  return node.is_pub && !node.is_method && !node.is_deprecated;
}
void v_dot_doc__Doc_print_enums(v_dot_doc__Doc *d) {
  array_v_dot_table__TypeSymbol tmp11 = d->table->types;
  for (int tmp12 = 0; tmp12 < tmp11.len; tmp12++) {
    v_dot_table__TypeSymbol typ =
        ((v_dot_table__TypeSymbol *)tmp11.data)[tmp12];

    if (typ.kind != v_dot_table__v_dot_table__Kind_enum_) {
      continue;
    };
    strings__Builder_writeln(&/* ? */ d->out,
                             _STR("enum %.*s {", typ.name.len, typ.name.str));
    v_dot_table__Enum info = *(v_dot_table__Enum *)typ.info.obj;
    array_string tmp13 = info.vals;
    for (int tmp14 = 0; tmp14 < tmp13.len; tmp14++) {
      string val = ((string *)tmp13.data)[tmp14];

      strings__Builder_writeln(&/* ? */ d->out,
                               _STR("\t%.*s", val.len, val.str));
    };
    strings__Builder_writeln(&/* ? */ d->out, tos3("}"));
  };
}
void v_dot_doc__Doc_print_structs(v_dot_doc__Doc *d) {
  array_v_dot_table__TypeSymbol tmp15 = d->table->types;
  for (int tmp16 = 0; tmp16 < tmp15.len; tmp16++) {
    v_dot_table__TypeSymbol typ =
        ((v_dot_table__TypeSymbol *)tmp15.data)[tmp16];

    if (typ.kind != v_dot_table__v_dot_table__Kind_struct_ ||
        !string_starts_with(typ.name, string_add(d->mod, tos3(".")))) {
      continue;
    };
    string name = string_after(typ.name, tos3("."));
    strings__Builder_writeln(&/* ? */ d->out,
                             _STR("struct %.*s {", name.len, name.str));
    v_dot_table__Struct info = *(v_dot_table__Struct *)typ.info.obj;
    array_v_dot_table__Field tmp17 = info.fields;
    for (int tmp18 = 0; tmp18 < tmp17.len; tmp18++) {
      v_dot_table__Field field = ((v_dot_table__Field *)tmp17.data)[tmp18];

      v_dot_table__TypeSymbol *sym =
          v_dot_table__Table_get_type_symbol(&/* ? */ *d->table, field.typ);
      strings__Builder_writeln(
          &/* ? */ d->out, _STR("\t%.*s %.*s", field.name.len, field.name.str,
                                sym->name.len, sym->name.str));
    };
    strings__Builder_writeln(&/* ? */ d->out, tos3("}\n"));
  };
}
v_dot_builder__Builder
v_dot_builder__new_builder(v_dot_pref__Preferences *pref) {
  v_dot_table__Table *table = v_dot_table__new_table();
  return (v_dot_builder__Builder){
      .pref = pref,
      .table = table,
      .checker = v_dot_checker__new_checker(table),
      .compiled_dir = tos3(""),
      .module_path = tos3(""),
      .module_search_paths = new_array(0, 1, sizeof(string)),
      .parsed_files = new_array(0, 1, sizeof(v_dot_ast__File))};
}
string v_dot_builder__Builder_gen_c(v_dot_builder__Builder *b,
                                    array_string v_files) {
  i64 t0 = time__ticks();
  b->parsed_files = v_dot_parser__parse_files(v_files, b->table);
  v_dot_builder__Builder_parse_imports(b);
  i64 t1 = time__ticks();
  i64 parse_time = t1 - t0;
  printf("PARSE: %lldms\n", parse_time);
  v_dot_checker__Checker_check_files(&/* ? */ b->checker, b->parsed_files);
  i64 t2 = time__ticks();
  i64 check_time = t2 - t1;
  printf("CHECK: %lldms\n", check_time);
  if (b->checker.nr_errors > 0) {
    v_exit(1);
  };
  string res = v_dot_gen__cgen(b->parsed_files, b->table);
  i64 t3 = time__ticks();
  i64 gen_time = t3 - t2;
  printf("C GEN: %lldms\n", gen_time);
  println(tos3("cgen done"));
  return res;
}
void v_dot_builder__Builder_build_c(v_dot_builder__Builder *b,
                                    array_string v_files, string out_file) {
  printf("build_c(%.*s)\n", out_file.len, out_file.str);
  Option_os__File tmp1 = os__create(out_file);
  os__File f;
  if (!tmp1.ok) {
    string err = tmp1.error;
    int errcode = tmp1.ecode;
    v_panic(err);
  }
  f = *(os__File *)tmp1.data;
  ;
  os__File_writeln(&/* ? */ f, v_dot_builder__Builder_gen_c(b, v_files));
  os__File_close(&/* ? */ f);
}
void v_dot_builder__Builder_build_x64(v_dot_builder__Builder *b,
                                      array_string v_files, string out_file) {
  i64 t0 = time__ticks();
  b->parsed_files = v_dot_parser__parse_files(v_files, b->table);
  v_dot_builder__Builder_parse_imports(b);
  i64 t1 = time__ticks();
  i64 parse_time = t1 - t0;
  printf("PARSE: %lldms\n", parse_time);
  v_dot_checker__Checker_check_files(&/* ? */ b->checker, b->parsed_files);
  i64 t2 = time__ticks();
  i64 check_time = t2 - t1;
  printf("CHECK: %lldms\n", check_time);
  v_dot_gen_dot_x64__gen(b->parsed_files, out_file);
  i64 t3 = time__ticks();
  i64 gen_time = t3 - t2;
  printf("x64 GEN: %lldms\n", gen_time);
}
void v_dot_builder__Builder_parse_imports(v_dot_builder__Builder *b) {
  array_string done_imports = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  int tmp2 = 0;
  ;
  for (int tmp3 = tmp2; tmp3 < b->parsed_files.len; tmp3++) {
    int i = tmp3;

    v_dot_ast__File ast_file =
        (*(v_dot_ast__File *)array_get(b->parsed_files, i));
    array_v_dot_ast__Import tmp6 = ast_file.imports;
    for (int _ = 0; _ < tmp6.len; _++) {
      v_dot_ast__Import imp = ((v_dot_ast__Import *)tmp6.data)[_];

      string mod = imp.mod;
      if ((_IN(string, (mod), done_imports))) {
        continue;
      };
      Option_string tmp7 =
          v_dot_builder__Builder_find_module_path(&/* ? */ *b, mod);
      string import_path;
      if (!tmp7.ok) {
        string err = tmp7.error;
        int errcode = tmp7.ecode;
        v_panic(_STR("cannot import module \"%.*s\" (not found)", mod.len,
                     mod.str));
      }
      import_path = *(string *)tmp7.data;
      ;
      array_string v_files =
          v_dot_builder__Builder_v_files_from_dir(&/* ? */ *b, import_path);
      if (v_files.len == 0) {
        v_panic(_STR("cannot import module \"%.*s\" (no .v files in \"%.*s\")",
                     mod.len, mod.str, import_path.len, import_path.str));
      };
      array_v_dot_ast__File parsed_files =
          v_dot_parser__parse_files(v_files, b->table);
      array_v_dot_ast__File tmp8 = parsed_files;
      for (int tmp9 = 0; tmp9 < tmp8.len; tmp9++) {
        v_dot_ast__File file = ((v_dot_ast__File *)tmp8.data)[tmp9];

        if (string_ne(file.mod.name, mod)) {
          v_panic(_STR("bad module definition: %.*s imports module \"%.*s\" "
                       "but %.*s is defined as module `%.*s`",
                       ast_file.path.len, ast_file.path.str, mod.len, mod.str,
                       file.path.len, file.path.str, file.mod.name.len,
                       file.mod.name.str));
        };
      };
      _PUSH_MANY(&b->parsed_files,
                 (/*typ = array_v_dot_ast__File   tmp_typ=v_dot_ast__File*/
                  parsed_files),
                 tmp10, array_v_dot_ast__File);
      _PUSH(&done_imports, (/*typ = array_string   tmp_typ=string*/ mod), tmp11,
            string);
    };
  };
}
array_string v_dot_builder__Builder_v_files_from_dir(v_dot_builder__Builder *b,
                                                     string dir) {
  array_string res = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  if (!os__exists(dir)) {
    if (string_eq(dir, tos3("compiler")) && os__is_dir(tos3("vlib"))) {
      println(tos3("looks like you are trying to build V with an old command"));
      println(tos3("use `v -o v cmd/v` instead of `v -o v compiler`"));
    };
    v_dot_builder__verror(_STR("%.*s doesn't exist", dir.len, dir.str));
  } else if (!os__is_dir(dir)) {
    v_dot_builder__verror(_STR("%.*s isn't a directory", dir.len, dir.str));
  };
  Option_array_string tmp12 = os__ls(dir);
  array_string files;
  if (!tmp12.ok) {
    string err = tmp12.error;
    int errcode = tmp12.ecode;
    v_panic(err);
  }
  files = *(array_string *)tmp12.data;
  ;
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          b->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_one)) {
    printf("v_files_from_dir (\"%.*s\")\n", dir.len, dir.str);
  };
  array_string_sort(&/* ? */ files);
  array_string tmp13 = files;
  for (int tmp14 = 0; tmp14 < tmp13.len; tmp14++) {
    string file = ((string *)tmp13.data)[tmp14];

    if (!string_ends_with(file, tos3(".v")) &&
        !string_ends_with(file, tos3(".vh"))) {
      continue;
    };
    if (string_ends_with(file, tos3("_test.v"))) {
      continue;
    };
    if ((string_ends_with(file, tos3("_win.v")) ||
         string_ends_with(file, tos3("_windows.v"))) &&
        b->os != v_dot_pref__v_dot_pref__OS_windows) {
      continue;
    };
    if ((string_ends_with(file, tos3("_lin.v")) ||
         string_ends_with(file, tos3("_linux.v"))) &&
        b->os != v_dot_pref__v_dot_pref__OS_linux) {
      continue;
    };
    if ((string_ends_with(file, tos3("_mac.v")) ||
         string_ends_with(file, tos3("_darwin.v"))) &&
        b->os != v_dot_pref__v_dot_pref__OS_mac) {
      continue;
    };
    if (string_ends_with(file, tos3("_nix.v")) &&
        b->os == v_dot_pref__v_dot_pref__OS_windows) {
      continue;
    };
    if (string_ends_with(file, tos3("_js.v")) &&
        b->os != v_dot_pref__v_dot_pref__OS_js) {
      continue;
    };
    if (string_ends_with(file, tos3("_c.v")) &&
        b->os == v_dot_pref__v_dot_pref__OS_js) {
      continue;
    };
    _PUSH(&res,
          (/*typ = array_string   tmp_typ=string*/ os__join_path(
              dir, &(varg_string){.len = 1, .args = {file}})),
          tmp15, string);
  };
  return res;
}
void v_dot_builder__verror(string err) {
  v_panic(_STR("v error: %.*s", err.len, err.str));
}
void v_dot_builder__Builder_log(v_dot_builder__Builder *b, string s) {
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          b->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
    println(s);
  };
}
static inline string v_dot_builder__module_path(string mod) {
  return string_replace(mod, tos3("."), os__path_separator);
}
Option_string v_dot_builder__Builder_find_module_path(v_dot_builder__Builder *b,
                                                      string mod) {
  string mod_path = v_dot_builder__module_path(mod);
  array_string tmp16 = b->module_search_paths;
  for (int tmp17 = 0; tmp17 < tmp16.len; tmp17++) {
    string search_path = ((string *)tmp16.data)[tmp17];

    string try_path = os__join_path(
        search_path, &(varg_string){.len = 1, .args = {mod_path}});
    if (v_dot_pref__VerboseLevel_is_higher_or_equal(
            b->pref->verbosity,
            v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
      printf("  >> trying to find %.*s in %.*s ..\n", mod.len, mod.str,
             try_path.len, try_path.str);
    };
    if (os__is_dir(try_path)) {
      if (v_dot_pref__VerboseLevel_is_higher_or_equal(
              b->pref->verbosity,
              v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
        printf("  << found %.*s .\n", try_path.len, try_path.str);
      };
      string tmp18 = OPTION_CAST(string)(try_path);
      return opt_ok(&tmp18, sizeof(string));
    };
  };
  return v_error(_STR("module \"%.*s\" not found", mod.len, mod.str));
}
compiler__Parser compiler__V_new_parser_from_string(compiler__V *v,
                                                    string text) {
  compiler__Parser p = compiler__V_new_parser(v, compiler__new_scanner(text));
  compiler__Parser_scan_tokens(&/* ? */ p);
  return p;
}
void compiler__V_reset_cgen_file_line_parameters(compiler__V *v) {
  v->cgen->line = 0;
  v->cgen->file = tos3("");
  v->cgen->line_directives = v->pref->is_vlines;
}
compiler__Parser compiler__V_new_parser_from_file(compiler__V *v, string path) {
  compiler__V_reset_cgen_file_line_parameters(v);
  string path_pcguard = tos3("");
  string path_platform = tos3(".v");
  array_string tmp1 = new_array_from_c_array(
      7, 7, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 7){
          tos3("_lin.v"), tos3("_mac.v"), tos3("_win.v"), tos3("_nix.v"),
          tos3("_linux.v"), tos3("_darwin.v"), tos3("_windows.v")});
  for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
    string path_ending = ((string *)tmp1.data)[tmp2];

    if (string_ends_with(path, path_ending)) {
      if (string_eq(path_ending, tos3("_mac.v"))) {
        string p =
            string_replace(path_ending, tos3("_mac.v"), tos3("_darwin.v"));
        printf("warning: use \"%.*s\" file name instead of \"%.*s\"\n", p.len,
               p.str, path.len, path.str);
      };
      if (string_eq(path_ending, tos3("_lin.v"))) {
        string p =
            string_replace(path_ending, tos3("_lin.v"), tos3("_linux.v"));
        printf("warning: use \"%.*s\" file name instead of \"%.*s\"\n", p.len,
               p.str, path.len, path.str);
      };
      if (string_eq(path_ending, tos3("_win.v"))) {
        string p =
            string_replace(path_ending, tos3("_win.v"), tos3("_windows.v"));
        printf("warning: use \"%.*s\" file name instead of \"%.*s\"\n", p.len,
               p.str, path.len, path.str);
      };
      path_platform = path_ending;
      path_pcguard =
          compiler__V_platform_postfix_to_ifdefguard(&/* ? */ *v, path_ending);
      break;
    };
  };
  if (v->pref->compile_defines.len > 0) {
    array_string tmp3 = v->pref->compile_defines;
    for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
      string cdefine = ((string *)tmp3.data)[tmp4];

      string custom_path_ending = _STR("_d_%.*s.v", cdefine.len, cdefine.str);
      if (string_ends_with(path, custom_path_ending)) {
        path_platform = custom_path_ending;
        path_pcguard = compiler__V_platform_postfix_to_ifdefguard(
            &/* ? */ *v, _STR("custom %.*s", cdefine.len, cdefine.str));
        break;
      };
    };
  };
  compiler__Parser p =
      compiler__V_new_parser(v, compiler__new_scanner_file(path));
  string path_dir = os__realpath(os__dir(path));
  p = (compiler__Parser){
      .file_path = path,
      .file_path_dir = path_dir,
      .file_name = string_all_after(path, os__path_separator),
      .file_platform = path_platform,
      .file_pcguard = path_pcguard,
      .is_vh = string_ends_with(path, tos3(".vh")),
      .v_script = string_ends_with(path, tos3(".vsh")),
      .v = p.v,
      .pref = p.pref,
      .scanner = p.scanner,
      .tokens = p.tokens,
      .token_idx = p.token_idx,
      .prev_stuck_token_idx = p.prev_stuck_token_idx,
      .tok = p.tok,
      .prev_tok = p.prev_tok,
      .prev_tok2 = p.prev_tok2,
      .lit = p.lit,
      .cgen = p.cgen,
      .table = p.table,
      .import_table = p.import_table,
      .pass = p.pass,
      .os = p.os,
      .inside_const = p.inside_const,
      .expr_var = p.expr_var,
      .has_immutable_field = p.has_immutable_field,
      .first_immutable_field = p.first_immutable_field,
      .assigned_type = p.assigned_type,
      .expected_type = p.expected_type,
      .tmp_cnt = p.tmp_cnt,
      .builtin_mod = p.builtin_mod,
      .inside_if_expr = p.inside_if_expr,
      .inside_return_expr = p.inside_return_expr,
      .inside_unsafe = p.inside_unsafe,
      .is_struct_init = p.is_struct_init,
      .is_var_decl = p.is_var_decl,
      .if_expr_cnt = p.if_expr_cnt,
      .for_expr_cnt = p.for_expr_cnt,
      .ptr_cast = p.ptr_cast,
      .calling_c = p.calling_c,
      .cur_fn = p.cur_fn,
      .local_vars = p.local_vars,
      .global_vars = p.global_vars,
      .var_idx = p.var_idx,
      .returns = p.returns,
      .vroot = p.vroot,
      .is_c_struct_init = p.is_c_struct_init,
      .is_empty_c_struct_init = p.is_empty_c_struct_init,
      .is_c_fn_call = p.is_c_fn_call,
      .can_chash = p.can_chash,
      .attr = p.attr,
      .var_decl_name = p.var_decl_name,
      .is_alloc = p.is_alloc,
      .is_const_literal = p.is_const_literal,
      .in_dispatch = p.in_dispatch,
      .is_vgen = p.is_vgen,
      .is_sql = p.is_sql,
      .is_js = p.is_js,
      .sql_i = p.sql_i,
      .sql_params = p.sql_params,
      .sql_types = p.sql_types,
      .generic_dispatch = p.generic_dispatch,
      .mod = p.mod,
  };
  if (p.v_script) {
    println(tos3("new_parser: V script"));
  };
  if (p.pref->building_v) {
    p.scanner->print_rel_paths_on_error = 1;
  };
  compiler__Parser_scan_tokens(&/* ? */ p);
  return p;
}
compiler__Parser compiler__V_new_parser(compiler__V *v,
                                        compiler__Scanner *scanner) {
  compiler__V_reset_cgen_file_line_parameters(v);
  compiler__Parser p = (compiler__Parser){
      .scanner = scanner,
      .v = v,
      .table = v->table,
      .cur_fn = compiler__EmptyFn,
      .cgen = v->cgen,
      .pref = v->pref,
      .os = v->pref->os,
      .vroot = v->pref->vroot,
      .local_vars = array_repeat(
          new_array_from_c_array(
              1, 1, sizeof(compiler__Var),
              EMPTY_ARRAY_OF_ELEMS(compiler__Var, 1){(compiler__Var){
                  .typ = tos3(""),
                  .name = tos3(""),
                  .idx = 0,
                  .is_arg = 0,
                  .is_const = 0,
                  .args = new_array(0, 1, sizeof(compiler__Var)),
                  .attr = tos3(""),
                  .is_mut = 0,
                  .is_alloc = 0,
                  .is_returned = 0,
                  .ptr = 0,
                  .ref = 0,
                  .parent_fn = tos3(""),
                  .mod = tos3(""),
                  .is_global = 0,
                  .is_used = 0,
                  .is_changed = 0,
                  .scope_level = 0,
                  .is_c = 0,
                  .is_moved = 0,
                  .line_nr = 0,
                  .token_idx = 0,
                  .is_for_var = 0,
                  .is_public = 0}}),
          compiler__MaxLocalVars),
      .import_table = compiler__new_import_table(),
      .file_path = tos3(""),
      .file_path_dir = tos3(""),
      .file_name = tos3(""),
      .file_platform = tos3(""),
      .file_pcguard = tos3(""),
      .tokens = new_array(0, 1, sizeof(compiler__Token)),
      .token_idx = 0,
      .prev_stuck_token_idx = 0,
      .lit = tos3(""),
      .inside_const = 0,
      .has_immutable_field = 0,
      .assigned_type = tos3(""),
      .expected_type = tos3(""),
      .tmp_cnt = 0,
      .builtin_mod = 0,
      .inside_if_expr = 0,
      .inside_return_expr = 0,
      .inside_unsafe = 0,
      .is_struct_init = 0,
      .is_var_decl = 0,
      .if_expr_cnt = 0,
      .for_expr_cnt = 0,
      .ptr_cast = 0,
      .calling_c = 0,
      .global_vars = new_array(0, 1, sizeof(compiler__Var)),
      .var_idx = 0,
      .returns = 0,
      .is_c_struct_init = 0,
      .is_empty_c_struct_init = 0,
      .is_c_fn_call = 0,
      .can_chash = 0,
      .attr = tos3(""),
      .v_script = 0,
      .var_decl_name = tos3(""),
      .is_alloc = 0,
      .is_const_literal = 0,
      .in_dispatch = 0,
      .is_vgen = 0,
      .is_sql = 0,
      .is_js = 0,
      .sql_i = 0,
      .sql_params = new_array(0, 1, sizeof(string)),
      .sql_types = new_array(0, 1, sizeof(string)),
      .is_vh = 0,
      .mod = tos3("")};
#ifdef _VJS
#endif
  ;
  if (p.pref->is_repl) {
    p.scanner->print_line_on_error = 0;
    p.scanner->print_colored_error = 0;
    p.scanner->print_rel_paths_on_error = 1;
  };
  return p;
}
void compiler__Parser_scan_tokens(compiler__Parser *p) {
  while (1) {
    compiler__ScanRes res = compiler__Scanner_scan(p->scanner);
    _PUSH(&p->tokens,
          (/*typ = array_compiler__Token   tmp_typ=compiler__Token*/ (
              compiler__Token){
              .tok = res.tok,
              .lit = res.lit,
              .line_nr = p->scanner->line_nr,
              .pos = p->scanner->pos,
              .name_idx = 0,
          }),
          tmp5, compiler__Token);
    if (res.tok == compiler__compiler__TokenKind_eof) {
      break;
    };
  };
}
void compiler__Parser_set_current_fn(compiler__Parser *p, compiler__Fn f) {
  p->cur_fn = f;
  p->scanner->fn_name =
      _STR("%.*s.%.*s", f.mod.len, f.mod.str, f.name.len, f.name.str);
}
void compiler__Parser_next(compiler__Parser *p) {
  ;
  p->prev_tok2 = p->prev_tok;
  p->prev_tok = p->tok;
  p->scanner->prev_tok = p->tok;
  if (p->token_idx >= p->tokens.len) {
    p->tok = compiler__compiler__TokenKind_eof;
    p->lit = tos3("");

    return;
  };
  compiler__Token res =
      (*(compiler__Token *)array_get(p->tokens, p->token_idx));
  p->token_idx++;
  p->tok = res.tok;
  p->lit = res.lit;
  p->scanner->line_nr = res.line_nr;
  p->cgen->line = res.line_nr;
}
compiler__TokenKind compiler__Parser_peek(compiler__Parser *p) {
  if (p->token_idx >= p->tokens.len - 2) {
    return compiler__compiler__TokenKind_eof;
  };
  return (*(compiler__Token *)array_get(p->tokens, p->token_idx)).tok;
}
static inline compiler__Token compiler__Parser_prev_token(compiler__Parser *p) {
  return (*(compiler__Token *)array_get(p->tokens, p->token_idx - 2));
}
static inline compiler__Token compiler__Parser_cur_tok(compiler__Parser *p) {
  return (*(compiler__Token *)array_get(p->tokens, p->token_idx - 1));
}
static inline compiler__Token compiler__Parser_peek_token(compiler__Parser *p) {
  if (p->token_idx >= p->tokens.len - 2) {
    return (compiler__Token){.tok = compiler__compiler__TokenKind_eof,
                             .lit = tos3(""),
                             .line_nr = 0,
                             .name_idx = 0,
                             .pos = 0};
  };
  return (*(compiler__Token *)array_get(p->tokens, p->token_idx));
}
void compiler__Parser_log(compiler__Parser *p, string s) {}
compiler__ParserState compiler__Parser_save_state(compiler__Parser *p) {
  return (compiler__ParserState){.scanner_file_path = p->scanner->file_path,
                                 .scanner_line_nr = p->scanner->line_nr,
                                 .scanner_text = p->scanner->text,
                                 .scanner_pos = p->scanner->pos,
                                 .scanner_line_ends = p->scanner->line_ends,
                                 .scanner_nlines = p->scanner->nlines,
                                 .cgen_lines = p->cgen->lines,
                                 .cgen_cur_line = p->cgen->cur_line,
                                 .cgen_tmp_line = p->cgen->tmp_line,
                                 .cgen_is_tmp = p->cgen->is_tmp,
                                 .tokens = p->tokens,
                                 .token_idx = p->token_idx,
                                 .tok = p->tok,
                                 .prev_tok = p->prev_tok,
                                 .prev_tok2 = p->prev_tok2,
                                 .lit = p->lit};
}
void compiler__Parser_restore_state(compiler__Parser *p,
                                    compiler__ParserState state, bool scanner,
                                    bool cgen) {
  if (scanner) {
    p->scanner->file_path = state.scanner_file_path;
    p->scanner->line_nr = state.scanner_line_nr;
    p->scanner->text = state.scanner_text;
    p->scanner->pos = state.scanner_pos;
    p->scanner->line_ends = state.scanner_line_ends;
    p->scanner->nlines = state.scanner_nlines;
  };
  if (cgen) {
    p->cgen->lines = state.cgen_lines;
    p->cgen->cur_line = state.cgen_cur_line;
    p->cgen->tmp_line = state.cgen_tmp_line;
    p->cgen->is_tmp = state.cgen_is_tmp;
  };
  p->tokens = state.tokens;
  p->token_idx = state.token_idx;
  p->tok = state.tok;
  p->prev_tok = state.prev_tok;
  p->prev_tok2 = state.prev_tok2;
  p->lit = state.lit;
}
void compiler__Parser_clear_state(compiler__Parser *p, bool scanner,
                                  bool cgen) {
  if (scanner) {
    p->scanner->line_nr = 0;
    p->scanner->text = tos3("");
    p->scanner->pos = 0;
    p->scanner->line_ends = new_array_from_c_array(
        0, 0, sizeof(int), EMPTY_ARRAY_OF_ELEMS(int, 0){TCCSKIP(0)});
    p->scanner->nlines = 0;
  };
  if (cgen) {
    p->cgen->lines = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    p->cgen->cur_line = tos3("");
    p->cgen->tmp_line = tos3("");
    p->cgen->is_tmp = 0;
  };
  p->tokens = new_array_from_c_array(
      0, 0, sizeof(compiler__Token),
      EMPTY_ARRAY_OF_ELEMS(compiler__Token, 0){TCCSKIP(0)});
  p->token_idx = 0;
  p->lit = tos3("");
}
void compiler__Parser_add_text(compiler__Parser *p, string text) {
  if (p->tokens.len > 1 &&
      (*(compiler__Token *)array_get(p->tokens, p->tokens.len - 1)).tok ==
          compiler__compiler__TokenKind_eof) {
    v_array_delete(&/* ? */ p->tokens, p->tokens.len - 1);
  };
  p->scanner->text = string_add(string_add(p->scanner->text, tos3("\n")), text);
  compiler__Parser_scan_tokens(p);
}
void compiler__Parser_statements_from_text(compiler__Parser *p, string text,
                                           bool rcbr, string fpath) {
  compiler__ParserState saved_state = compiler__Parser_save_state(&/* ? */ *p);
  compiler__Parser_clear_state(p, 1, 0);
  if (string_ne(fpath, tos3(""))) {
    p->scanner->file_path = fpath;
  };
  compiler__Parser_add_text(p, text);
  compiler__Parser_next(p);
  if (rcbr) {
    compiler__Parser_statements(p);
  } else {
    compiler__Parser_statements_no_rcbr(p);
  };
  compiler__Parser_restore_state(p, saved_state, 1, 0);
}
void compiler__Parser_parse(compiler__Parser *p, compiler__Pass pass) {
  p->cgen->line = 0;
  p->cgen->file = compiler__cescaped_path(os__realpath(p->file_path));
  p->pass = pass;
  p->token_idx = 0;
  compiler__Parser_next(p);
  if (p->pref->is_script || p->pref->is_test) {
    if (p->tok == compiler__compiler__TokenKind_key_module) {
      compiler__Parser_next(p);
      ;
      p->mod = compiler__Parser_check_name(p);
    } else {
      p->mod = tos3("main");
    };
  } else {
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_module);
    ;
    p->mod = compiler__Parser_check_name(p);
  };
  ;
  p->cgen->nogen = 0;
  if (p->pref->build_mode == v_dot_pref__v_dot_pref__BuildMode_build_module &&
      string_ne(p->mod, p->v->pref->mod)) {
    p->cgen->nogen = 1;
  };
  ;
  p->builtin_mod = string_eq(p->mod, tos3("builtin"));
  p->can_chash =
      (string_eq(p->mod, tos3("parser")) || string_eq(p->mod, tos3("gg2")) ||
       string_eq(p->mod, tos3("ui")) || string_eq(p->mod, tos3("uiold")) ||
       string_eq(p->mod, tos3("darwin")) ||
       string_eq(p->mod, tos3("clipboard")) ||
       string_eq(p->mod, tos3("webview")));
  string fq_mod =
      ((p->pref->build_mode == v_dot_pref__v_dot_pref__BuildMode_build_module &&
        string_ends_with(p->v->pref->mod, p->mod))
           ? (p->v->pref->mod)
           : (compiler__Table_qualify_module(&/* ? */ *p->table, p->mod,
                                             p->file_path)));
  compiler__Table_register_module(p->table, fq_mod);
  p->mod = fq_mod;
  if (p->pass == compiler__compiler__Pass_imports) {
    while (p->tok == compiler__compiler__TokenKind_key_import &&
           compiler__Parser_peek(&/* ? */ *p) !=
               compiler__compiler__TokenKind_key_const) {

      compiler__Parser_imports(p);
    };
    if ((_IN(string, (tos3("builtin")), p->table->imports))) {
      compiler__Parser_error(p, tos3("module `builtin` cannot be imported"));
    };

    return;
  };
  i64 parsing_start_ticks = time__ticks();
  u64 compile_cycles_stuck_mask = ((u64)(0x1FFFFFFF));
  u64 parsing_cycle = ((u64)(1));
  p->prev_stuck_token_idx = p->token_idx;
  while (1) {
    parsing_cycle++;
    if (compile_cycles_stuck_mask ==
        (parsing_cycle & compile_cycles_stuck_mask)) {
      compiler__Parser_check_if_parser_is_stuck(p, parsing_cycle,
                                                parsing_start_ticks);
    };
    compiler__TokenKind tmp18 = p->tok;

    if (tmp18 == compiler__compiler__TokenKind_key_import) {
      compiler__Parser_imports(p);
    } else if (tmp18 == compiler__compiler__TokenKind_key_enum) {
      compiler__TokenKind next = compiler__Parser_peek(&/* ? */ *p);
      if (next == compiler__compiler__TokenKind_name) {
        compiler__Parser_enum_decl(p, 0);
      } else if (next == compiler__compiler__TokenKind_lcbr &&
                 p->pref->translated) {
        compiler__Parser_enum_decl(p, 1);
      } else {
        compiler__Parser_error(p, tos3("Nameless enums are not allowed."));
      };
    } else if (tmp18 == compiler__compiler__TokenKind_key_pub) {
      compiler__TokenKind next = compiler__Parser_peek(&/* ? */ *p);
      compiler__TokenKind tmp19 = next;

      if (tmp19 == compiler__compiler__TokenKind_key_fn) {
        compiler__Parser_fn_decl(p);
      } else if (tmp19 == compiler__compiler__TokenKind_key_const) {
        compiler__Parser_const_decl(p);
      } else if ((tmp19 == compiler__compiler__TokenKind_key_struct) ||
                 (tmp19 == compiler__compiler__TokenKind_key_union) ||
                 (tmp19 == compiler__compiler__TokenKind_key_interface)) {
        compiler__Parser_struct_decl(
            p, new_array_from_c_array(
                   0, 0, sizeof(string),
                   EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)}));
      } else if (tmp19 == compiler__compiler__TokenKind_key_enum) {
        compiler__Parser_enum_decl(p, 0);
      } else if (tmp19 == compiler__compiler__TokenKind_key_type) {
        compiler__Parser_type_decl(p);
      } else // default:
      {
        compiler__Parser_error(p, tos3("wrong pub keyword usage"));
      };
    } else if (tmp18 == compiler__compiler__TokenKind_key_fn) {
      compiler__Parser_fn_decl(p);
    } else if (tmp18 == compiler__compiler__TokenKind_key_type) {
      compiler__Parser_type_decl(p);
    } else if (tmp18 == compiler__compiler__TokenKind_lsbr) {
      compiler__Parser_attribute(p);
    } else if ((tmp18 == compiler__compiler__TokenKind_key_struct) ||
               (tmp18 == compiler__compiler__TokenKind_key_interface) ||
               (tmp18 == compiler__compiler__TokenKind_key_union) ||
               (tmp18 == compiler__compiler__TokenKind_lsbr)) {
      compiler__Parser_struct_decl(
          p,
          new_array_from_c_array(0, 0, sizeof(string),
                                 EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)}));
    } else if (tmp18 == compiler__compiler__TokenKind_key_const) {
      compiler__Parser_const_decl(p);
    } else if (tmp18 == compiler__compiler__TokenKind_hash) {
      compiler__Parser_chash(p);
    } else if (tmp18 == compiler__compiler__TokenKind_dollar) {
      compiler__Parser_comp_time(p);
    } else if (tmp18 == compiler__compiler__TokenKind_key_global) {
      if (!p->pref->translated && !p->pref->is_live && !p->builtin_mod &&
          !p->pref->building_v && string_ne(p->mod, tos3("ui")) &&
          string_ne(p->mod, tos3("gg2")) && string_ne(p->mod, tos3("uiold")) &&
          !string_contains(os__getwd(), tos3("/volt")) &&
          !p->pref->enable_globals) {
        compiler__Parser_error(
            p, tos3("use `v --enable-globals ...` to enable globals"));
      };
      compiler__Parser_next(p);
      ;
      string name = compiler__Parser_check_name(p);
      ;
      string typ = compiler__Parser_get_type(p);
      compiler__Parser_register_global(p, name, typ);
      string g =
          compiler__Table_cgen_name_type_pair(&/* ? */ *p->table, name, typ);
      if (p->tok == compiler__compiler__TokenKind_assign) {
        compiler__Parser_next(p);
        g = string_add(g, tos3(" = "));
        _V_MulRet_string_V_string _V_mret_2407___expr =
            compiler__Parser_tmp_expr(p);
        string expr = _V_mret_2407___expr.var_1;
        g = string_add(g, expr);
      };
      g = string_add(g, tos3("; // global"));
      if (!p->cgen->nogen) {
        _PUSH(&p->cgen->consts, (/*typ = array_string   tmp_typ=string*/ g),
              tmp20, string);
      };
      ;
      if (p->tok != compiler__compiler__TokenKind_key_global) {
        ;
      };
    } else if (tmp18 == compiler__compiler__TokenKind_eof) {
      if (!compiler__Parser_first_pass(&/* ? */ *p) && !p->pref->is_repl) {
        compiler__Parser_check_unused_imports(p);
      };
      ;

      return;
    } else // default:
    {
      if (p->pref->is_script && !p->pref->is_test) {
        if (string_eq(p->cur_fn.name, tos3(""))) {
          compiler__Parser_set_current_fn(p, compiler__MainFn);
          if (p->pref->is_repl) {
            if (compiler__Parser_first_pass(&/* ? */ *p)) {

              return;
            };
            compiler__Parser_clear_vars(p);
          };
        };
        int start = p->cgen->lines.len;
        compiler__Parser_statement(p, 1);
        compiler__Parser_genln(p, tos3(""));
        int end = p->cgen->lines.len;
        array_string lines = array_slice2(p->cgen->lines, start, end, false);
        p->cgen->fn_main =
            string_add(p->cgen->fn_main, array_string_join(lines, tos3("\n")));
        compiler__CGen_resetln(p->cgen, tos3(""));
        for (int i = start; i < end; i++) {

          array_set(&/*q*/ p->cgen->lines, i, &(string[]){tos3("")});
        };
        ;
      } else {
        compiler__Parser_error(p,
                               _STR("unexpected token `%.*s`",
                                    compiler__Parser_strtok(&/* ? */ *p).len,
                                    compiler__Parser_strtok(&/* ? */ *p).str));
      };
    };
  };
}
void compiler__Parser_imports(compiler__Parser *p) {
  compiler__Parser_check(p, compiler__compiler__TokenKind_key_import);
  if (p->tok == compiler__compiler__TokenKind_lpar) {
    ;
    compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
    ;
    ;
    while (p->tok != compiler__compiler__TokenKind_rpar &&
           p->tok != compiler__compiler__TokenKind_eof) {

      compiler__Parser_import_statement(p);
      ;
    };
    ;
    compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
    ;

    return;
  };
  compiler__Parser_import_statement(p);
  ;
  if (p->tok != compiler__compiler__TokenKind_key_import) {
    ;
  };
}
void compiler__Parser_import_statement(compiler__Parser *p) {
  ;
  if (p->tok != compiler__compiler__TokenKind_name) {
    compiler__Parser_error(p, tos3("bad import format"));
  };
  if (compiler__Parser_peek(&/* ? */ *p) ==
      compiler__compiler__TokenKind_number) {
    compiler__Parser_error(p, tos3("bad import format: module/submodule names "
                                   "cannot begin with a number"));
  };
  int import_tok_idx = p->token_idx - 1;
  string mod = string_trim_space(compiler__Parser_check_name(p));
  string mod_alias = mod;
  int depth = 1;
  while (p->tok == compiler__compiler__TokenKind_dot) {

    compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
    string submodule = compiler__Parser_check_name(p);
    mod_alias = submodule;
    mod = string_add(mod, string_add(tos3("."), submodule));
    depth++;
    if (depth > compiler__max_module_depth) {
      compiler__Parser_error(p, _STR("module depth of %d exceeded: %.*s",
                                     compiler__max_module_depth, mod.len,
                                     mod.str));
    };
  };
  if (p->tok == compiler__compiler__TokenKind_key_as &&
      compiler__Parser_peek(&/* ? */ *p) ==
          compiler__compiler__TokenKind_name) {
    ;
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_as);
    ;
    mod_alias = compiler__Parser_check_name(p);
  };
  compiler__Parser_register_import_alias(p, mod_alias, mod, import_tok_idx);
  if ((_IN(string, (mod), p->table->imports))) {

    return;
  };
  _PUSH(&p->table->imports, (/*typ = array_string   tmp_typ=string*/ mod),
        tmp23, string);
  compiler__Table_register_module(p->table, mod);
}
void compiler__Parser_const_decl(compiler__Parser *p) {
  bool is_pub = p->tok == compiler__compiler__TokenKind_key_pub;
  if (is_pub) {
    compiler__Parser_next(p);
    ;
  };
  p->inside_const = 1;
  compiler__Parser_check(p, compiler__compiler__TokenKind_key_const);
  ;
  compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
  ;
  ;
  while (p->tok == compiler__compiler__TokenKind_name) {

    if (string_eq(p->lit, tos3("_")) &&
        compiler__Parser_peek(&/* ? */ *p) ==
            compiler__compiler__TokenKind_assign &&
        !p->cgen->nogen) {
      compiler__Parser_gen_blank_identifier_assign(p);
      _PUSH(&p->cgen->consts_init,
            (/*typ = array_string   tmp_typ=string*/ string_trim_space(
                p->cgen->cur_line)),
            tmp24, string);
      compiler__CGen_resetln(p->cgen, tos3(""));
      continue;
    };
    int var_token_idx = compiler__Parser_cur_tok_index(&/* ? */ *p);
    string name = compiler__Parser_check_name(p);
    name = compiler__Parser_prepend_mod(&/* ? */ *p, name);
    string typ = tos3("");
    if (compiler__Parser_first_pass(&/* ? */ *p) &&
        compiler__Table_known_const(&/* ? */ *p->table, name)) {
      compiler__Parser_error_with_token_index(
          p, _STR("redefinition of `%.*s`", name.len, name.str), var_token_idx);
    };
    if (p->is_vh) {
      if (p->tok == compiler__compiler__TokenKind_assign) {
        compiler__Parser_next(p);
        p->cgen->nogen = 1;
        typ = compiler__Parser_expression(p);
        p->cgen->nogen = 0;
      } else {
        typ = compiler__Parser_get_type(p);
      };
      compiler__Table_register_const(p->table, name, typ, p->mod, is_pub);
      _PUSH(
          &p->cgen->consts,
          (/*typ = array_string   tmp_typ=string*/ string_add(
              (string_add(tos3("extern "), compiler__Table_cgen_name_type_pair(
                                               &/* ? */ *p->table, name, typ))),
              tos3(";"))),
          tmp25, string);
      continue;
    } else {
      compiler__Parser_check_space(p, compiler__compiler__TokenKind_assign);
      typ = compiler__Parser_expression(p);
    };
    if (compiler__Parser_first_pass(&/* ? */ *p)) {
      compiler__Table_register_const(p->table, name, typ, p->mod, is_pub);
    };
    Option_compiler__Var tmp26 =
        compiler__Table_find_const(&/* ? */ *p->v->table, name);

    if (tmp26.ok) {
      compiler__Var my_const = *(compiler__Var *)tmp26.data;
      if (string_eq(my_const.typ, tos3("void"))) {
        array_compiler__Var tmp27 = p->v->table->consts;
        for (int i = 0; i < tmp27.len; i++) {
          compiler__Var v = ((compiler__Var *)tmp27.data)[i];

          if (string_eq(v.name, name)) {
            (*(compiler__Var *)array_get(p->v->table->consts, i)).typ = typ;
            break;
          };
        };
      };
    };
    if (p->pass == compiler__compiler__Pass_main && p->cgen->nogen &&
        p->pref->build_mode == v_dot_pref__v_dot_pref__BuildMode_build_module) {
      _PUSH(
          &p->cgen->consts,
          (/*typ = array_string   tmp_typ=string*/ string_add(
              (string_add(tos3("extern "), compiler__Table_cgen_name_type_pair(
                                               &/* ? */ *p->table, name, typ))),
              tos3(";"))),
          tmp30, string);
    };
    if (p->pass == compiler__compiler__Pass_main && !p->cgen->nogen) {
      if (p->pref->build_mode !=
              v_dot_pref__v_dot_pref__BuildMode_build_module &&
          compiler__is_compile_time_const(p->cgen->cur_line)) {
        string const_val = p->cgen->cur_line;
        if (string_eq(typ, tos3("u64"))) {
          const_val = _STR("UINT64_C(%.*s)", const_val.len, const_val.str);
        };
        _PUSH(&p->cgen->const_defines,
              (/*typ = array_string   tmp_typ=string*/ _STR(
                  "#define %.*s %.*s", name.len, name.str, const_val.len,
                  const_val.str)),
              tmp31, string);
        compiler__CGen_resetln(p->cgen, tos3(""));
        ;
        continue;
      };
      if (string_starts_with(typ, tos3("["))) {
        _PUSH(&p->cgen->consts,
              (/*typ = array_string   tmp_typ=string*/ string_add(
                  compiler__Table_cgen_name_type_pair(&/* ? */ *p->table, name,
                                                      typ),
                  _STR(" = %.*s;", p->cgen->cur_line.len,
                       p->cgen->cur_line.str))),
              tmp32, string);
      } else {
        _PUSH(&p->cgen->consts,
              (/*typ = array_string   tmp_typ=string*/ string_add(
                  compiler__Table_cgen_name_type_pair(&/* ? */ *p->table, name,
                                                      typ),
                  tos3(";"))),
              tmp33, string);
        _PUSH(&p->cgen->consts_init,
              (/*typ = array_string   tmp_typ=string*/ _STR(
                  "%.*s = %.*s;", name.len, name.str, p->cgen->cur_line.len,
                  p->cgen->cur_line.str)),
              tmp34, string);
      };
      compiler__CGen_resetln(p->cgen, tos3(""));
    };
    ;
  };
  ;
  compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
  p->inside_const = 0;
  ;
  ;
}
void compiler__Parser_type_decl(compiler__Parser *p) {
  bool is_pub = p->tok == compiler__compiler__TokenKind_key_pub;
  if (is_pub) {
    compiler__Parser_next(p);
    ;
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_key_type);
  ;
  string name = compiler__Parser_check_name(p);
  ;
  if (p->tok == compiler__compiler__TokenKind_key_struct) {
    compiler__Parser_error(
        p, _STR("use `struct %.*s {` instead of `type %.*s struct {`", name.len,
                name.str, name.len, name.str));
  };
  bool is_sum = p->tok == compiler__compiler__TokenKind_assign;
  if (is_sum) {
    compiler__Parser_next(p);
    ;
  };
  compiler__Type parent =
      (compiler__Type){.mod = tos3(""),
                       .name = tos3(""),
                       .is_public = 0,
                       .fields = new_array(0, 1, sizeof(compiler__Var)),
                       .methods = new_array(0, 1, sizeof(compiler__Fn)),
                       .parent = tos3(""),
                       .is_c = 0,
                       .enum_vals = new_array(0, 1, sizeof(string)),
                       .gen_types = new_array(0, 1, sizeof(string)),
                       .default_vals = new_array(0, 1, sizeof(string)),
                       .parser_idx = 0,
                       .decl_tok_idx = 0,
                       .is_placeholder = 0,
                       .gen_str = 0,
                       .is_flag = 0,
                       .is_generic = 0,
                       .ctype_names = new_array(0, 1, sizeof(string))};
  if (!p->builtin_mod && string_ne(p->mod, tos3("main"))) {
    name = compiler__Parser_prepend_mod(&/* ? */ *p, name);
  };
  if (is_sum) {
    if (p->pass == compiler__compiler__Pass_main) {
      _PUSH(&p->cgen->consts,
            (/*typ = array_string   tmp_typ=string*/ _STR(
                "//// SUMTYPE:  %.*s | parent: %.*s | name: %.*s", p->mod.len,
                p->mod.str, name.len, name.str, parent.name.len,
                parent.name.str)),
            tmp35, string);
    };
    int idx = 0;
    bool done = 0;
    array_string ctype_names = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    array_string sum_variants = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    while (1) {
      idx++;
      string child_type_name = compiler__Parser_check_name(p);
      if (p->tok != compiler__compiler__TokenKind_pipe) {
        done = 1;
      };
      if (p->pass == compiler__compiler__Pass_main) {
        compiler__Type t =
            compiler__Parser_find_type(&/* ? */ *p, child_type_name);
        if (string_eq(t.name, tos3(""))) {
          compiler__Parser_error(p, _STR("unknown type `%.*s`",
                                         child_type_name.len,
                                         child_type_name.str));
        };
        _PUSH(&p->cgen->consts,
              (/*typ = array_string   tmp_typ=string*/ _STR(
                  "#define SumType_%.*s_%.*s %d // DEF2", name.len, name.str,
                  child_type_name.len, child_type_name.str, idx)),
              tmp36, string);
        _PUSH(&ctype_names,
              (/*typ = array_string   tmp_typ=string*/ child_type_name), tmp37,
              string);
        _PUSH(&sum_variants,
              (/*typ = array_string   tmp_typ=string*/ (
                  ((string_eq(p->mod, tos3("builtin")) ||
                    string_eq(p->mod, tos3("main"))) ||
                   (_IN(string, (child_type_name), compiler__builtin_types)))
                      ? (child_type_name)
                      : (compiler__Parser_prepend_mod(&/* ? */ *p,
                                                      child_type_name)))),
              tmp38, string);
      };
      if (done) {
        break;
      };
      ;
      compiler__Parser_check(p, compiler__compiler__TokenKind_pipe);
      ;
      if ((*(compiler__Token *)array_get(p->tokens, p->token_idx - 2)).line_nr <
          (*(compiler__Token *)array_get(p->tokens, p->token_idx - 1))
              .line_nr) {
        ;
      };
    };
    map_set(&p->table->sum_types, name, &(array_string[]){sum_variants});
    compiler__Table_register_type(
        p->table, (compiler__Type){
                      .name = name,
                      .mod = p->mod,
                      .cat = compiler__compiler__TypeCategory_alias,
                      .is_public = is_pub,
                      .ctype_names = ctype_names,
                      .fields = new_array(0, 1, sizeof(compiler__Var)),
                      .methods = new_array(0, 1, sizeof(compiler__Fn)),
                      .parent = tos3(""),
                      .is_c = 0,
                      .enum_vals = new_array(0, 1, sizeof(string)),
                      .gen_types = new_array(0, 1, sizeof(string)),
                      .default_vals = new_array(0, 1, sizeof(string)),
                      .parser_idx = 0,
                      .decl_tok_idx = 0,
                      .is_placeholder = 0,
                      .gen_str = 0,
                      .is_flag = 0,
                      .is_generic = 0,
                  });
    if (p->pass == compiler__compiler__Pass_main) {
      _PUSH(&p->cgen->consts,
            (/*typ = array_string   tmp_typ=string*/ _STR(
                "const char * __SumTypeNames__%.*s[] = {", name.len, name.str)),
            tmp43, string);
      _PUSH(&p->cgen->consts,
            (/*typ = array_string   tmp_typ=string*/ _STR("    \"%.*s\",",
                                                          name.len, name.str)),
            tmp44, string);
      array_string tmp45 = ctype_names;
      for (int tmp46 = 0; tmp46 < tmp45.len; tmp46++) {
        string ctype_name = ((string *)tmp45.data)[tmp46];

        _PUSH(&p->cgen->consts,
              (/*typ = array_string   tmp_typ=string*/ _STR(
                  "    \"%.*s\",", ctype_name.len, ctype_name.str)),
              tmp47, string);
      };
      _PUSH(&p->cgen->consts,
            (/*typ = array_string   tmp_typ=string*/ tos3("};")), tmp48,
            string);
    };
    compiler__Parser_gen_typedef(
        p, _STR("typedef struct {\nvoid* obj;\nint typ;\n} %.*s;\n", name.len,
                name.str));
  } else {
    parent = compiler__Parser_get_type2(p);
  };
  string nt_pair = compiler__Table_cgen_name_type_pair(&/* ? */ *p->table, name,
                                                       parent.name);
  string _struct =
      ((parent.cat != compiler__compiler__TypeCategory_array &&
        parent.cat != compiler__compiler__TypeCategory_func &&
        !compiler__Table_known_type(&/* ? */ *p->table, parent.name))
           ? (tos3("struct"))
           : (tos3("")));
  if (!is_sum) {
    compiler__Parser_gen_typedef(
        p, _STR("typedef %.*s %.*s; //type alias name=\"%.*s\" parent=`%.*s`",
                _struct.len, _struct.str, nt_pair.len, nt_pair.str, name.len,
                name.str, parent.name.len, parent.name.str));
    compiler__Table_register_type(
        p->table,
        (compiler__Type){.name = name,
                         .parent = parent.name,
                         .mod = p->mod,
                         .cat = compiler__compiler__TypeCategory_alias,
                         .is_public = is_pub,
                         .fields = new_array(0, 1, sizeof(compiler__Var)),
                         .methods = new_array(0, 1, sizeof(compiler__Fn)),
                         .is_c = 0,
                         .enum_vals = new_array(0, 1, sizeof(string)),
                         .gen_types = new_array(0, 1, sizeof(string)),
                         .default_vals = new_array(0, 1, sizeof(string)),
                         .parser_idx = 0,
                         .decl_tok_idx = 0,
                         .is_placeholder = 0,
                         .gen_str = 0,
                         .is_flag = 0,
                         .is_generic = 0,
                         .ctype_names = new_array(0, 1, sizeof(string))});
  };
  ;
  ;
}
compiler__Fn *compiler__Parser_interface_method(compiler__Parser *p,
                                                string field_name,
                                                string receiver) {
  compiler__Fn *method = (compiler__Fn *)memdup(
      &(compiler__Fn){.name = field_name,
                      .is_interface = 1,
                      .is_method = 1,
                      .receiver_typ = receiver,
                      .mod = tos3(""),
                      .args = new_array(0, 1, sizeof(compiler__Var)),
                      .scope_level = 0,
                      .typ = tos3(""),
                      .is_c = 0,
                      .is_public = 0,
                      .is_decl = 0,
                      .is_unsafe = 0,
                      .is_deprecated = 0,
                      .is_variadic = 0,
                      .is_generic = 0,
                      .returns_error = 0,
                      .defer_text = new_array(0, 1, sizeof(string)),
                      .type_pars = new_array(0, 1, sizeof(string)),
                      .type_inst = new_array(0, 1, sizeof(compiler__TypeInst)),
                      .generic_fn_idx = 0,
                      .parser_idx = 0,
                      .fn_name_token_idx = 0,
                      .comptime_define = tos3(""),
                      .is_used = 0},
      sizeof(compiler__Fn));
  compiler__Parser_fn_args(p, method);
  compiler__Token prev_tok = compiler__Parser_prev_token(&/* ? */ *p);
  compiler__Token cur_tok = compiler__Parser_cur_tok(&/* ? */ *p);
  if (prev_tok.line_nr != cur_tok.line_nr) {
    method->typ = tos3("void");
  } else {
    method->typ = compiler__Parser_get_type(p);
    ;
  };
  return method;
}
compiler__TypeCategory compiler__key_to_type_cat(compiler__TokenKind tok) {
  compiler__TokenKind tmp49 = tok;

  if (tmp49 == compiler__compiler__TokenKind_key_interface) {
    return compiler__compiler__TypeCategory_interface_;
  } else if (tmp49 == compiler__compiler__TokenKind_key_struct) {
    return compiler__compiler__TypeCategory_struct_;
  } else if (tmp49 == compiler__compiler__TokenKind_key_union) {
    return compiler__compiler__TypeCategory_union_;
  } else // default:
  {
  };
  compiler__verror(_STR("Unknown token: %d", tok));
  return compiler__compiler__TypeCategory_builtin;
}
string compiler__Parser_check_name(compiler__Parser *p) {
  string name = p->lit;
  compiler__Parser_check(p, compiler__compiler__TokenKind_name);
  return name;
}
string compiler__Parser_check_string(compiler__Parser *p) {
  string s = p->lit;
  compiler__Parser_check(p, compiler__compiler__TokenKind_string);
  return s;
}
void compiler__Parser_check_not_reserved(compiler__Parser *p) {
  bool tmp50 = 0;
  bool tmp51 =
      map_get(/*aparser.v : 989*/ compiler__reserved_types, p->lit, &tmp50);

  if (tmp50) {
    compiler__Parser_error(
        p, _STR("`%.*s` can\'t be used as name", p->lit.len, p->lit.str));
  };
}
string compiler__Parser_strtok(compiler__Parser *p) {
  if (p->tok == compiler__compiler__TokenKind_name) {
    return p->lit;
  };
  if (p->tok == compiler__compiler__TokenKind_number) {
    return p->lit;
  };
  if (p->tok == compiler__compiler__TokenKind_chartoken) {
    if (string_eq(p->lit, tos3("`"))) {
      return _STR("`\\%.*s`", p->lit.len, p->lit.str);
    };
    return _STR("`%.*s`", p->lit.len, p->lit.str);
  };
  if (p->tok == compiler__compiler__TokenKind_string) {
    if (string_contains(p->lit, tos3("'")) &&
        !string_contains(p->lit, tos3("\""))) {
      return _STR("\"%.*s\"", p->lit.len, p->lit.str);
    } else {
      return _STR("'%.*s'", p->lit.len, p->lit.str);
    };
  };
  if (p->tok == compiler__compiler__TokenKind_hash) {
    return string_add(tos3("#"), p->lit);
  };
  string res = compiler__TokenKind_str(p->tok);
  if (string_eq(res, tos3(""))) {
    int n = ((int)(p->tok));
    return int_str(n);
  };
  return res;
}
void compiler__Parser_check_space(compiler__Parser *p,
                                  compiler__TokenKind expected) {
  ;
  compiler__Parser_check(p, expected);
  ;
}
void compiler__Parser_check(compiler__Parser *p, compiler__TokenKind expected) {
  if (p->tok != expected) {
    string s = _STR("syntax error: unexpected `%.*s`, expecting `%.*s`",
                    compiler__Parser_strtok(&/* ? */ *p).len,
                    compiler__Parser_strtok(&/* ? */ *p).str,
                    compiler__TokenKind_str(expected).len,
                    compiler__TokenKind_str(expected).str);
    compiler__Parser_next(p);
    printf("next token = `%.*s`\n", compiler__Parser_strtok(&/* ? */ *p).len,
           compiler__Parser_strtok(&/* ? */ *p).str);
    if (p->pref->is_debug) {
      print_backtrace();
    };
    compiler__Parser_error(p, s);
  };
  compiler__Parser_next(p);
}
static inline bool compiler__Parser_first_pass(compiler__Parser *p) {
  return p->pass == compiler__compiler__Pass_decl;
}
string compiler__Parser_get_type(compiler__Parser *p) {
  bool mul = 0;
  int nr_muls = 0;
  string typ = tos3("");
  if (p->tok == compiler__compiler__TokenKind_key_fn) {
    compiler__Fn f =
        (compiler__Fn){.name = tos3("_"),
                       .mod = p->mod,
                       .args = new_array(0, 1, sizeof(compiler__Var)),
                       .is_interface = 0,
                       .scope_level = 0,
                       .typ = tos3(""),
                       .receiver_typ = tos3(""),
                       .is_c = 0,
                       .is_public = 0,
                       .is_method = 0,
                       .is_decl = 0,
                       .is_unsafe = 0,
                       .is_deprecated = 0,
                       .is_variadic = 0,
                       .is_generic = 0,
                       .returns_error = 0,
                       .defer_text = new_array(0, 1, sizeof(string)),
                       .type_pars = new_array(0, 1, sizeof(string)),
                       .type_inst = new_array(0, 1, sizeof(compiler__TypeInst)),
                       .generic_fn_idx = 0,
                       .parser_idx = 0,
                       .fn_name_token_idx = 0,
                       .comptime_define = tos3(""),
                       .is_used = 0};
    compiler__Parser_next(p);
    int line_nr = p->scanner->line_nr;
    compiler__Parser_fn_args(p, &/*114*/ f);
    if (p->scanner->line_nr == line_nr) {
      if ((p->tok == compiler__compiler__TokenKind_name ||
           p->tok == compiler__compiler__TokenKind_mul ||
           p->tok == compiler__compiler__TokenKind_amp ||
           p->tok == compiler__compiler__TokenKind_lsbr ||
           p->tok == compiler__compiler__TokenKind_question ||
           p->tok == compiler__compiler__TokenKind_lpar)) {
        f.typ = compiler__Parser_get_type(p);
      } else {
        f.typ = tos3("void");
      };
    } else {
      f.typ = tos3("void");
    };
    compiler__Type fn_typ =
        (compiler__Type){.name = compiler__Fn_typ_str(&/* ? */ f),
                         .mod = p->mod,
                         .func = f,
                         .is_public = 0,
                         .fields = new_array(0, 1, sizeof(compiler__Var)),
                         .methods = new_array(0, 1, sizeof(compiler__Fn)),
                         .parent = tos3(""),
                         .is_c = 0,
                         .enum_vals = new_array(0, 1, sizeof(string)),
                         .gen_types = new_array(0, 1, sizeof(string)),
                         .default_vals = new_array(0, 1, sizeof(string)),
                         .parser_idx = 0,
                         .decl_tok_idx = 0,
                         .is_placeholder = 0,
                         .gen_str = 0,
                         .is_flag = 0,
                         .is_generic = 0,
                         .ctype_names = new_array(0, 1, sizeof(string))};
    compiler__Table_register_type(p->table, fn_typ);
    return compiler__Fn_typ_str(&/* ? */ f);
  };
  bool is_question = p->tok == compiler__compiler__TokenKind_question;
  if (is_question) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_question);
  };
  if (p->tok == compiler__compiler__TokenKind_lpar) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
    array_string types = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    while (1) {
      _PUSH(&types,
            (/*typ = array_string   tmp_typ=string*/ compiler__Parser_get_type(
                p)),
            tmp52, string);
      if (p->tok != compiler__compiler__TokenKind_comma) {
        break;
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
    typ = compiler__Parser_register_multi_return_stuct(p, types);
    if (is_question) {
      typ = compiler__stringify_pointer(typ);
      typ = _STR("Option_%.*s", typ.len, typ.str);
      compiler__Table_register_type_with_parent(p->table, typ, tos3("Option"));
    };
    return typ;
  };
  int arr_level = 0;
  while (p->tok == compiler__compiler__TokenKind_lsbr) {

    compiler__Parser_check(p, compiler__compiler__TokenKind_lsbr);
    if (p->tok == compiler__compiler__TokenKind_number) {
      typ = string_add(typ, _STR("[%.*s]", p->lit.len, p->lit.str));
      compiler__Parser_next(p);
    } else {
      arr_level++;
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_rsbr);
  };
  if (!p->builtin_mod && p->tok == compiler__compiler__TokenKind_name &&
      string_eq(p->lit, tos3("map"))) {
    compiler__Parser_next(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_lsbr);
    string key_type = compiler__Parser_check_name(p);
    if (string_ne(key_type, tos3("string"))) {
      compiler__Parser_error(p, tos3("maps only support string keys for now"));
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_rsbr);
    string val_type = compiler__Parser_get_type(p);
    typ = _STR("map_%.*s", compiler__stringify_pointer(val_type).len,
               compiler__stringify_pointer(val_type).str);
    compiler__Parser_register_map(p, typ);
    return typ;
  };
  bool warn = 0;
  while (p->tok == compiler__compiler__TokenKind_mul) {

    if (compiler__Parser_first_pass(&/* ? */ *p)) {
      warn = 1;
    };
    mul = 1;
    nr_muls++;
    compiler__Parser_check(p, compiler__compiler__TokenKind_mul);
  };
  if (p->tok == compiler__compiler__TokenKind_amp) {
    mul = 1;
    nr_muls++;
    compiler__Parser_check(p, compiler__compiler__TokenKind_amp);
  };
  map_string ti = p->generic_dispatch.inst;
  if ((_IN(string, (p->lit), map_keys(&/* ? */ ti)))) {
    string tmp53 = tos3("");
    bool tmp54 = map_get(/*aparser.v : 1182*/ ti, p->lit, &tmp53);

    if (!tmp54)
      tmp53 = tos((byte *)"", 0);

    typ = string_add(typ, tmp53);
  } else {
    typ = string_add(typ, p->lit);
  };
  if (string_eq(p->lit, tos3("C")) &&
      compiler__Parser_peek(&/* ? */ *p) == compiler__compiler__TokenKind_dot) {
    compiler__Parser_next(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
    typ = p->lit;
  } else {
    if (warn && string_ne(p->mod, tos3("ui"))) {
      compiler__Parser_warn(p, tos3("use `&Foo` instead of `*Foo`"));
    };
    if (compiler__Parser_peek(&/* ? */ *p) ==
        compiler__compiler__TokenKind_dot) {
      if (!p->builtin_mod &&
          compiler__ImportTable_known_alias(&/* ? */ p->import_table, typ)) {
        string mod =
            compiler__ImportTable_resolve_alias(&/* ? */ p->import_table, typ);
        if (string_contains(mod, tos3("."))) {
          typ = compiler__mod_gen_name(mod);
        };
      };
      compiler__Parser_next(p);
      compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
      typ = string_add(typ, _STR("__%.*s", p->lit.len, p->lit.str));
    };
    compiler__Type t = compiler__Table_find_type(&/* ? */ *p->table, typ);
    if (string_eq(t.name, tos3("")) && !p->builtin_mod) {
      if (!string_contains(typ, tos3("array_")) &&
          string_ne(p->mod, tos3("main")) &&
          !string_contains(typ, tos3("__")) &&
          !string_starts_with(typ, tos3("["))) {
        typ = compiler__Parser_prepend_mod(&/* ? */ *p, typ);
      };
      t = compiler__Table_find_type(&/* ? */ *p->table, typ);
      if (string_eq(t.name, tos3("")) && !p->pref->translated &&
          !compiler__Parser_first_pass(&/* ? */ *p) &&
          !string_starts_with(typ, tos3("["))) {
        _V_MulRet_string_V_string _V_mret_5394_t_suggest_tc_suggest =
            compiler__Table_find_misspelled_type(&/* ? */ *p->table, typ, p,
                                                 0.50);
        string t_suggest = _V_mret_5394_t_suggest_tc_suggest.var_0;
        string tc_suggest = _V_mret_5394_t_suggest_tc_suggest.var_1;
        if (t_suggest.len > 0) {
          t_suggest = _STR(". did you mean: (%.*s) `%.*s`", tc_suggest.len,
                           tc_suggest.str, t_suggest.len, t_suggest.str);
        };
        string econtext =
            ((p->pref->is_debug)
                 ? (string_add(
                       string_add(
                           string_add(string_add(tos3("("),
                                                 tos3("/Users/alex/code/v/vlib/"
                                                      "compiler/aparser.v")),
                                      tos3(":")),
                           tos3("1236")),
                       tos3(")")))
                 : (tos3("")));
        compiler__Parser_error(p, _STR("unknown type `%.*s`%.*s %.*s", typ.len,
                                       typ.str, t_suggest.len, t_suggest.str,
                                       econtext.len, econtext.str));
      };
    } else if (!t.is_public && string_ne(t.mod, p->mod) && !p->is_vgen &&
               string_ne(t.name, tos3("")) &&
               !compiler__Parser_first_pass(&/* ? */ *p)) {
      compiler__Parser_error(
          p, _STR("type `%.*s` is private", t.name.len, t.name.str));
    };
  };
  if (compiler__Parser_peek(&/* ? */ *p) == compiler__compiler__TokenKind_lt) {
    compiler__Parser_next(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_lt);
    typ = _STR("%.*s_T", typ.len, typ.str);
    while (1) {
      string type_param = compiler__Parser_check_name(p);
      if ((_IN_MAP((type_param), p->generic_dispatch.inst))) {
        string tmp55 = tos3("");
        bool tmp56 = map_get(/*aparser.v : 1244*/ p->generic_dispatch.inst,
                             type_param, &tmp55);

        if (!tmp56)
          tmp55 = tos((byte *)"", 0);

        typ = string_add(_STR("%.*s_", typ.len, typ.str), tmp55);
      };
      if (p->tok != compiler__compiler__TokenKind_comma) {
        break;
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_gt);
    return typ;
  };
  if (string_eq(typ, tos3("void"))) {
    compiler__Parser_error(p, _STR("unknown type `%.*s`", typ.len, typ.str));
  };
  if (mul) {
    typ = string_add(typ, strings__repeat('*', nr_muls));
  };
  if (arr_level > 0) {
    for (int i = 0; i < arr_level; i++) {

      typ = _STR("array_%.*s", compiler__stringify_pointer(typ).len,
                 compiler__stringify_pointer(typ).str);
    };
    compiler__Parser_register_array(p, typ);
  };
  compiler__Parser_next(p);
  if (is_question) {
    typ = _STR("Option_%.*s", compiler__stringify_pointer(typ).len,
               compiler__stringify_pointer(typ).str);
    compiler__Table_register_type_with_parent(p->table, typ, tos3("Option"));
  };
  if (string_eq(typ, tos3("byteptr"))) {
    return tos3("byte*");
  };
  if (string_eq(typ, tos3("voidptr"))) {
    return tos3("void*");
  };
  return typ;
}
void compiler__Parser_print_tok(compiler__Parser *p) {
  if (p->tok == compiler__compiler__TokenKind_name) {
    println(p->lit);

    return;
  };
  if (p->tok == compiler__compiler__TokenKind_string) {
    printf("\"%.*s\"\n", p->lit.len, p->lit.str);

    return;
  };
  println(compiler__TokenKind_str(p->tok));
}
string compiler__Parser_statements(compiler__Parser *p) {
  string typ = compiler__Parser_statements_no_rcbr(p);
  if (!p->inside_if_expr) {
    compiler__Parser_genln(p, tos3("}"));
  };
  return typ;
}
string compiler__Parser_statements_no_rcbr(compiler__Parser *p) {
  compiler__Parser_open_scope(p);
  int i = 0;
  string last_st_typ = tos3("");
  while (p->tok != compiler__compiler__TokenKind_rcbr &&
         p->tok != compiler__compiler__TokenKind_eof) {

    last_st_typ = compiler__Parser_statement(p, 1);
    if (!p->inside_if_expr) {
      ;
    };
    i++;
    if (i > 50000) {
      compiler__CGen_save(p->cgen);
      compiler__Parser_error(
          p, _STR("more than 50 000 statements in function `%.*s`",
                  p->cur_fn.name.len, p->cur_fn.name.str));
    };
  };
  if (p->inside_if_expr) {
    ;
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
  compiler__Parser_close_scope(p);
  return last_st_typ;
}
void compiler__Parser_close_scope(compiler__Parser *p) {
  int i = p->var_idx - 1;
  for (; i >= 0; i--) {

    compiler__Var v = (*(compiler__Var *)array_get(p->local_vars, i));
    if (p->pref->autofree &&
        (v.is_alloc || (v.is_arg && string_eq(v.typ, tos3("string"))))) {
      compiler__Parser_free_var(p, v);
    };
    if (v.scope_level != p->cur_fn.scope_level) {
      break;
    };
  };
  if (string_ne(*(string *)array_last(p->cur_fn.defer_text), tos3(""))) {
    compiler__Parser_genln(p, *(string *)array_last(p->cur_fn.defer_text));
  };
  p->cur_fn.scope_level--;
  p->cur_fn.defer_text =
      array_slice2(p->cur_fn.defer_text, 0, p->cur_fn.scope_level + 1, false);
  p->var_idx = i + 1;
}
void compiler__Parser_free_var(compiler__Parser *p, compiler__Var v) {
  if ((string_eq(p->cur_fn.name, tos3("add")) ||
       string_eq(p->cur_fn.name, tos3("clone")) ||
       string_eq(p->cur_fn.name, tos3("free")))) {

    return;
  };
  string free_fn = tos3("free");
  if (string_starts_with(v.typ, tos3("array_"))) {
    free_fn = tos3("v_array_free");
  } else if (string_eq(v.typ, tos3("string"))) {
    free_fn = tos3("v_string_free");
  } else if (v.ptr || string_ends_with(v.typ, tos3("*"))) {
    free_fn = tos3("v_ptr_free");
  } else {

    return;
  };
  if (p->returns) {
    if (!v.is_returned && string_ne(v.typ, tos3("FILE*"))) {
      string prev_line =
          (*(string *)array_get(p->cgen->lines, p->cgen->lines.len - 1));
      string v_free =
          _STR("%.*s (%.*s); /* :) close_scope free %.*s */", free_fn.len,
               free_fn.str, v.name.len, v.name.str, v.typ.len, v.typ.str);
      array_set(
          &/*q*/ p->cgen->lines, p->cgen->lines.len - 1,
          &(string[]){string_add(string_add(v_free, tos3("\n")), prev_line)});
    };
  } else if (string_ne(p->mod, tos3("strings"))) {
    compiler__Parser_genln(p,
                           _STR("%.*s (%.*s); // close_scope free", free_fn.len,
                                free_fn.str, v.name.len, v.name.str));
  };
}
void compiler__Parser_genln(compiler__Parser *p, string s) {
  compiler__CGen_genln(p->cgen, s);
}
void compiler__Parser_gen(compiler__Parser *p, string s) {
  compiler__CGen_gen(p->cgen, s);
}
string compiler__Parser_statement(compiler__Parser *p, bool add_semi) {
  p->expected_type = tos3("");
  if (p->returns) {
    compiler__Parser_warn_or_error(p, tos3("unreachable code"));
  };
  p->cgen->is_tmp = 0;
  compiler__TokenKind tok = p->tok;
  string q = tos3("");
  compiler__TokenKind tmp63 = tok;

  if (tmp63 == compiler__compiler__TokenKind_name) {
    compiler__TokenKind next = compiler__Parser_peek(&/* ? */ *p);
    if (compiler__Parser_peek(&/* ? */ *p) ==
        compiler__compiler__TokenKind_colon) {
      ;
      string label = compiler__Parser_check_name(p);
      ;
      compiler__Parser_genln(p, string_add(label, tos3(": ;")));
      compiler__Parser_check(p, compiler__compiler__TokenKind_colon);
      return tos3("");
    } else if (compiler__Parser_peek(&/* ? */ *p) ==
                   compiler__compiler__TokenKind_decl_assign ||
               compiler__Parser_peek(&/* ? */ *p) ==
                   compiler__compiler__TokenKind_comma) {
      compiler__Parser_check_not_reserved(p);
      compiler__Parser_var_decl(p);
    } else if (string_eq(p->lit, tos3("_")) &&
               compiler__Parser_peek(&/* ? */ *p) ==
                   compiler__compiler__TokenKind_assign) {
      compiler__Parser_gen_blank_identifier_assign(p);
    } else {
      bool is_panic =
          string_eq(p->lit, tos3("panic")) || string_eq(p->lit, tos3("exit"));
      if (is_panic) {
        p->returns = 1;
      };
      q = compiler__Parser_bool_expression(p);
      if (is_panic && string_eq(p->cur_fn.typ, tos3("bool"))) {
        compiler__Parser_genln(p, tos3(";\nreturn false;"));
      };
    };
  } else if (tmp63 == compiler__compiler__TokenKind_key_goto) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_goto);
    ;
    string label = compiler__Parser_check_name(p);
    compiler__Parser_genln(p, _STR("goto %.*s;", label.len, label.str));
    return tos3("");
  } else if (tmp63 == compiler__compiler__TokenKind_key_defer) {
    compiler__Parser_defer_st(p);
    return tos3("");
  } else if (tmp63 == compiler__compiler__TokenKind_hash) {
    compiler__Parser_chash(p);
    return tos3("");
  } else if (tmp63 == compiler__compiler__TokenKind_key_unsafe) {
    compiler__Parser_next(p);
    p->inside_unsafe = 1;
    compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
    compiler__Parser_genln(p, tos3("{"));
    compiler__Parser_statements(p);
    p->inside_unsafe = 0;
  } else if (tmp63 == compiler__compiler__TokenKind_dollar) {
    compiler__Parser_comp_time(p);
  } else if (tmp63 == compiler__compiler__TokenKind_key_if) {
    compiler__Parser_if_statement(p, 0, 0);
  } else if (tmp63 == compiler__compiler__TokenKind_key_for) {
    compiler__Parser_for_st(p);
  } else if (tmp63 == compiler__compiler__TokenKind_key_switch) {
    compiler__Parser_switch_statement(p);
  } else if (tmp63 == compiler__compiler__TokenKind_key_match) {
    compiler__Parser_match_statement(p, 0);
  } else if ((tmp63 == compiler__compiler__TokenKind_key_mut) ||
             (tmp63 == compiler__compiler__TokenKind_key_static)) {
    compiler__Parser_var_decl(p);
  } else if (tmp63 == compiler__compiler__TokenKind_key_return) {
    compiler__Parser_return_st(p);
  } else if (tmp63 == compiler__compiler__TokenKind_lcbr) {
    if (compiler__Parser_prev_token(&/* ? */ *p).line_nr ==
        p->scanner->line_nr) {
      compiler__Parser_genln(p, tos3(""));
      compiler__Parser_error(p, tos3("{} block has to start on a new line"));
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
    if (p->tok == compiler__compiler__TokenKind_rcbr) {
      compiler__Parser_error(p, tos3("empty statements block"));
    };
    compiler__Parser_genln(p, tos3("{"));
    compiler__Parser_statements(p);
    return tos3("");
  } else if (tmp63 == compiler__compiler__TokenKind_key_continue) {
    if (p->for_expr_cnt == 0) {
      compiler__Parser_error(p, tos3("`continue` statement outside `for`"));
    };
    compiler__Parser_genln(p, tos3("continue"));
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_continue);
  } else if (tmp63 == compiler__compiler__TokenKind_key_break) {
    if (p->for_expr_cnt == 0) {
      compiler__Parser_error(p, tos3("`break` statement outside `for`"));
    };
    compiler__Parser_genln(p, tos3("break"));
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_break);
  } else if (tmp63 == compiler__compiler__TokenKind_key_go) {
    compiler__Parser_go_statement(p);
  } else if (tmp63 == compiler__compiler__TokenKind_key_assert) {
    compiler__Parser_assert_statement(p);
  } else if (tmp63 == compiler__compiler__TokenKind_key_asm) {
    compiler__Parser_inline_asm(p);
  } else // default:
  {
    string typ = compiler__Parser_expression(p);
    if (p->inside_if_expr) {
    } else {
      compiler__Parser_genln(p, tos3("; "));
    };
    return typ;
  };
  if (p->inside_if_expr && p->tok != compiler__compiler__TokenKind_rcbr) {
    compiler__Parser_gen(p, tos3(", "));
  };
  if (add_semi && !p->inside_if_expr) {
    compiler__Parser_genln(p, tos3(";"));
  };
  return q;
}
void compiler__Parser_assign_statement(compiler__Parser *p, compiler__Var v,
                                       int ph, bool is_map) {
  int errtok = compiler__Parser_cur_tok_index(&/* ? */ *p);
  bool is_vid = compiler__Parser_fileis(&/* ? */ *p, tos3("vid"));
  compiler__TokenKind tok = p->tok;
  if (!v.is_mut && !p->pref->translated && !v.is_global && !is_vid) {
    if (v.is_arg) {
      if (p->cur_fn.args.len > 0 &&
          string_eq((*(compiler__Var *)array_get(p->cur_fn.args, 0)).name,
                    v.name)) {
        printf("make the receiver `%.*s` mutable:\nfn (%.*s mut %.*s) "
               "%.*s(...) {\n\n",
               v.name.len, v.name.str, v.name.len, v.name.str, v.typ.len,
               v.typ.str, p->cur_fn.name.len, p->cur_fn.name.str);
      };
    };
    compiler__Parser_error(p,
                           _STR("`%.*s` is immutable", v.name.len, v.name.str));
  };
  if (!v.is_changed) {
    compiler__Parser_mark_var_changed(p, v);
  };
  bool is_str = string_eq(p->expected_type, tos3("string"));
  bool is_ustr = string_eq(p->expected_type, tos3("ustring"));
  compiler__TokenKind tmp66 = tok;

  if (tmp66 == compiler__compiler__TokenKind_assign) {
    if (!is_map && !p->is_empty_c_struct_init) {
      compiler__Parser_gen(p, tos3(" = "));
    };
  } else if (tmp66 == compiler__compiler__TokenKind_plus_assign) {
    if (is_str && !p->is_js) {
      string expr = p->cgen->cur_line;
      compiler__Parser_gen(p, _STR("= string_add(%.*s, ", expr.len, expr.str));
    } else if (is_ustr) {
      compiler__Parser_gen(
          p, _STR("= ustring_add(%.*s, ", v.name.len, v.name.str));
    } else {
      compiler__Token next = compiler__Parser_peek_token(&/* ? */ *p);
      if (next.tok == compiler__compiler__TokenKind_number &&
          string_eq(next.lit, tos3("1"))) {
        compiler__Parser_error(p, tos3("use `++` instead of `+= 1`"));
      };
      compiler__Parser_gen(p, tos3(" += "));
    };
  } else if (tmp66 == compiler__compiler__TokenKind_minus_assign) {
    compiler__Token next = compiler__Parser_peek_token(&/* ? */ *p);
    if (next.tok == compiler__compiler__TokenKind_number &&
        string_eq(next.lit, tos3("1"))) {
      compiler__Parser_error(p, tos3("use `--` instead of `-= 1`"));
    };
    compiler__Parser_gen(p, tos3(" -= "));
  } else // default:
  {
    compiler__Parser_gen(
        p, string_add(string_add(tos3(" "), compiler__TokenKind_str(p->tok)),
                      tos3(" ")));
  };
  ;
  compiler__Parser_next(p);
  ;
  int pos = p->cgen->cur_line.len;
  int expr_tok = compiler__Parser_cur_tok_index(&/* ? */ *p);
  p->is_var_decl = 1;
  string expr_type = compiler__Parser_bool_expression(p);
  p->is_var_decl = 0;
  if (string_eq(expr_type, tos3("void"))) {
    _V_MulRet_bool_V_string _V_mret_7250___fn_name =
        compiler__Parser_is_expr_fn_call(&/* ? */ *p, expr_tok + 1);
    string fn_name = _V_mret_7250___fn_name.var_1;
    compiler__Parser_error_with_token_index(
        p,
        _STR("%.*s() %.*s", fn_name.len, fn_name.str,
             compiler__err_used_as_value.len, compiler__err_used_as_value.str),
        expr_tok);
  };
  if (string_starts_with(p->assigned_type, tos3("Option_")) &&
      string_eq(expr_type,
                compiler__parse_pointer(string_substr2(
                    p->assigned_type, tos3("Option_").len, -1, true)))) {
    string expr = string_substr2(p->cgen->cur_line, pos, -1, true);
    string left = string_substr2(p->cgen->cur_line, 0, pos, false);
    string typ = compiler__parse_pointer(
        string_replace(expr_type, tos3("Option_"), tos3("")));
    compiler__CGen_resetln(
        p->cgen,
        string_add(left, _STR("opt_ok((%.*s[]){ %.*s }, sizeof(%.*s))", typ.len,
                              typ.str, expr.len, expr.str, typ.len, typ.str)));
  } else if (string_starts_with(expr_type, tos3("Option_")) &&
             string_eq(p->assigned_type,
                       compiler__parse_pointer(string_substr2(
                           expr_type, tos3("Option_").len, -1, true))) &&
             p->tok == compiler__compiler__TokenKind_key_orelse) {
    string line = p->cgen->cur_line;
    string vname = string_replace(string_substr2(line, 0, pos, false),
                                  tos3("="), tos3(""));
    Option_int tmp77 = string_index(line, tos3("="));

    if (tmp77.ok) {
      int idx = *(int *)tmp77.data;
      compiler__CGen_resetln(
          p->cgen, string_replace(line, string_substr2(line, 0, idx + 1, false),
                                  tos3("")));
      compiler__Parser_gen_handle_option_or_else(p, expr_type, vname, ph);
    };
  } else if (string_at(expr_type, 0) == '[') {
    string expr = string_all_before(
        string_all_after(string_substr2(p->cgen->cur_line, pos, -1, true),
                         tos3("{")),
        tos3("}"));
    string left = string_all_before(
        string_substr2(p->cgen->cur_line, 0, pos, false), tos3("="));
    string cline_pos = string_substr2(p->cgen->cur_line, pos, -1, true);
    string etype = string_all_before(cline_pos, tos3(" {"));
    if (string_ne(p->assigned_type, p->expected_type)) {
      compiler__Parser_error_with_token_index(
          p,
          _STR("incompatible types: %.*s != %.*s", p->assigned_type.len,
               p->assigned_type.str, p->expected_type.len,
               p->expected_type.str),
          errtok);
    };
    compiler__CGen_resetln(
        p->cgen, _STR("memcpy( (& %.*s), (%.*s{%.*s}), sizeof( %.*s ) );",
                      left.len, left.str, etype.len, etype.str, expr.len,
                      expr.str, left.len, left.str));
  } else if ((tok == compiler__compiler__TokenKind_plus_assign ||
              tok == compiler__compiler__TokenKind_minus_assign ||
              tok == compiler__compiler__TokenKind_mult_assign ||
              tok == compiler__compiler__TokenKind_div_assign)) {
    if (!((tok == compiler__compiler__TokenKind_plus_assign ||
           tok == compiler__compiler__TokenKind_minus_assign) &&
          (compiler__is_integer_type(p->assigned_type) ||
           compiler__is_pointer_type(p->assigned_type)) &&
          (compiler__is_integer_type(expr_type) ||
           compiler__is_pointer_type(expr_type)))) {
      if (!(tok == compiler__compiler__TokenKind_plus_assign &&
            string_eq(p->assigned_type, expr_type) &&
            string_eq(expr_type, tos3("string")))) {
        if (!compiler__is_number_type(p->assigned_type)) {
          compiler__Parser_error_with_token_index(
              p,
              _STR("cannot use assignment operator %.*s on non-numeric type "
                   "`%.*s`",
                   compiler__TokenKind_str(tok).len,
                   compiler__TokenKind_str(tok).str, p->assigned_type.len,
                   p->assigned_type.str),
              errtok);
        };
        if (!compiler__is_number_type(expr_type)) {
          compiler__Parser_error_with_token_index(
              p,
              _STR("cannot use non-numeric type `%.*s` as assignment operator "
                   "%.*s argument",
                   expr_type.len, expr_type.str,
                   compiler__TokenKind_str(tok).len,
                   compiler__TokenKind_str(tok).str),
              errtok);
        };
      };
    };
  } else if ((tok == compiler__compiler__TokenKind_left_shift_assign ||
              tok == compiler__compiler__TokenKind_righ_shift_assign ||
              tok == compiler__compiler__TokenKind_mod_assign ||
              tok == compiler__compiler__TokenKind_xor_assign ||
              tok == compiler__compiler__TokenKind_and_assign ||
              tok == compiler__compiler__TokenKind_or_assign)) {
    if (!compiler__is_integer_type(p->assigned_type)) {
      compiler__Parser_error_with_token_index(
          p,
          _STR("cannot use %.*s assignment operator on non-integer type `%.*s`",
               compiler__TokenKind_str(tok).len,
               compiler__TokenKind_str(tok).str, p->assigned_type.len,
               p->assigned_type.str),
          errtok);
    };
    if (!compiler__is_integer_type(expr_type)) {
      compiler__Parser_error_with_token_index(
          p,
          _STR("cannot use non-integer type `%.*s` as %.*s argument",
               expr_type.len, expr_type.str, compiler__TokenKind_str(tok).len,
               compiler__TokenKind_str(tok).str),
          errtok);
    };
  } else if (!p->builtin_mod && !compiler__Parser_check_types_no_throw(
                                    p, expr_type, p->assigned_type)) {
    compiler__Type t =
        compiler__Table_find_type(&/* ? */ *p->table, p->assigned_type);
    if (t.cat == compiler__compiler__TypeCategory_enum_ && t.is_flag) {
      compiler__Parser_error_with_token_index(p, compiler__err_modify_bitfield,
                                              errtok);
    };
    compiler__Parser_error_with_token_index(
        p,
        _STR("cannot use type `%.*s` as type `%.*s` in assignment",
             expr_type.len, expr_type.str, p->assigned_type.len,
             p->assigned_type.str),
        errtok);
  };
  if ((is_str || is_ustr) && tok == compiler__compiler__TokenKind_plus_assign &&
      !p->is_js) {
    compiler__Parser_gen(p, tos3(")"));
  };
  p->assigned_type = tos3("");
  if (!v.is_used) {
    compiler__Parser_mark_var_used(p, v);
  };
}
void compiler__Parser_var_decl(compiler__Parser *p) {
  p->is_alloc = 0;
  bool is_mut = p->tok == compiler__compiler__TokenKind_key_mut ||
                p->prev_tok == compiler__compiler__TokenKind_key_for;
  bool is_static = p->tok == compiler__compiler__TokenKind_key_static;
  if (p->tok == compiler__compiler__TokenKind_key_mut) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_mut);
    ;
  };
  if (p->tok == compiler__compiler__TokenKind_key_static) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_static);
    ;
  };
  array_int var_token_idxs =
      new_array_from_c_array(1, 1, sizeof(int),
                             EMPTY_ARRAY_OF_ELEMS(int, 1){
                                 compiler__Parser_cur_tok_index(&/* ? */ *p)});
  array_bool var_mut = new_array_from_c_array(
      1, 1, sizeof(bool), EMPTY_ARRAY_OF_ELEMS(bool, 1){is_mut});
  array_string var_names = new_array_from_c_array(
      1, 1, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 1){compiler__Parser_check_name(p)});
  int new_vars = 0;
  if (string_ne((*(string *)array_get(var_names, 0)), tos3("_")) &&
      !compiler__Parser_known_var(&/* ? */ *p,
                                  (*(string *)array_get(var_names, 0)))) {
    new_vars++;
  };
  while (p->tok == compiler__compiler__TokenKind_comma) {

    compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
    if (p->tok == compiler__compiler__TokenKind_key_mut) {
      compiler__Parser_check(p, compiler__compiler__TokenKind_key_mut);
      ;
      _PUSH(&var_mut, (/*typ = array_bool   tmp_typ=bool*/ 1), tmp92, bool);
    } else {
      _PUSH(&var_mut, (/*typ = array_bool   tmp_typ=bool*/ 0), tmp93, bool);
    };
    _PUSH(&var_token_idxs,
          (/*typ = array_int   tmp_typ=int*/ compiler__Parser_cur_tok_index(
              &/* ? */ *p)),
          tmp94, int);
    string var_name = compiler__Parser_check_name(p);
    if (string_ne(var_name, tos3("_")) &&
        !compiler__Parser_known_var(&/* ? */ *p, var_name)) {
      new_vars++;
    };
    _PUSH(&var_names, (/*typ = array_string   tmp_typ=string*/ var_name), tmp95,
          string);
  };
  bool is_assign = p->tok == compiler__compiler__TokenKind_assign;
  bool is_decl_assign = p->tok == compiler__compiler__TokenKind_decl_assign;
  if (is_assign) {
    compiler__Parser_check_space(p, compiler__compiler__TokenKind_assign);
  } else if (is_decl_assign) {
    compiler__Parser_check_space(p, compiler__compiler__TokenKind_decl_assign);
  } else {
    compiler__Parser_error(p, tos3("expected `=` or `:=`"));
  };
  int expr_tok = compiler__Parser_cur_tok_index(&/* ? */ *p);
  if (is_decl_assign && var_names.len == 1 &&
      string_eq((*(string *)array_get(var_names, 0)), tos3("_"))) {
    compiler__Parser_error_with_token_index(p, tos3("use `=` instead of `:=`"),
                                            *(int *)array_last(var_token_idxs));
  };
  p->var_decl_name =
      ((var_names.len > 1)
           ? (string_add(_STR("_V_mret_%d_", p->token_idx),
                         array_string_join(var_names, tos3("_"))))
           : ((*(string *)array_get(var_names, 0))));
  string t = compiler__Parser_gen_var_decl(p, p->var_decl_name, is_static);
  if (string_eq(t, tos3("void"))) {
    _V_MulRet_bool_V_string _V_mret_8241___fn_name =
        compiler__Parser_is_expr_fn_call(&/* ? */ *p, expr_tok + 1);
    string fn_name = _V_mret_8241___fn_name.var_1;
    compiler__Parser_error_with_token_index(
        p,
        _STR("%.*s() %.*s", fn_name.len, fn_name.str,
             compiler__err_used_as_value.len, compiler__err_used_as_value.str),
        expr_tok);
  };
  array_string var_types = new_array_from_c_array(
      1, 1, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 1){t});
  if (var_names.len > 1) {
    var_types = string_split(
        string_replace(string_replace(t, tos3("_V_MulRet_"), tos3("")),
                       tos3("_PTR_"), tos3("*")),
        tos3("_V_"));
  };
  if (var_names.len != var_types.len) {
    string mr_fn = string_trim_space(
        string_find_between(p->cgen->cur_line, tos3("="), tos3("(")));
    compiler__Parser_error_with_token_index(
        p,
        _STR("assignment mismatch: %d variables but `%.*s` returns %d values",
             var_names.len, mr_fn.len, mr_fn.str, var_types.len),
        *(int *)array_last(var_token_idxs));
  };
  array_string tmp100 = var_names;
  for (int i = 0; i < tmp100.len; i++) {
    string var_name = ((string *)tmp100.data)[i];

    int var_token_idx = (*(int *)array_get(var_token_idxs, i));
    bool var_is_mut = (*(bool *)array_get(var_mut, i));
    string var_type = (*(string *)array_get(var_types, i));
    bool known_var = compiler__Parser_known_var(&/* ? */ *p, var_name);
    if (string_eq(var_name, tos3("_"))) {
      if (var_is_mut) {
        compiler__Parser_error_with_token_index(
            p, tos3("`mut` has no effect here"), var_token_idx - 1);
      };
      continue;
    };
    if (is_decl_assign && known_var) {
      compiler__Parser_error_with_token_index(
          p, _STR("redefinition of `%.*s`", var_name.len, var_name.str),
          var_token_idx);
    };
    if (known_var && var_is_mut) {
      compiler__Parser_error_with_token_index(
          p,
          _STR("cannot specify mutability for existing var `%.*s`, only for "
               "new vars",
               var_name.len, var_name.str),
          var_token_idx);
    };
    if (is_assign && !known_var) {
      string suggested =
          compiler__Parser_find_misspelled_local_var(&/* ? */ *p, var_name, 50);
      if (string_ne(suggested, tos3(""))) {
        compiler__Parser_error_with_token_index(
            p,
            _STR("undefined: `%.*s`. did you mean:%.*s", var_name.len,
                 var_name.str, suggested.len, suggested.str),
            var_token_idx);
      };
      compiler__Parser_error_with_token_index(
          p, _STR("undefined: `%.*s`.", var_name.len, var_name.str),
          var_token_idx);
    };
    if (var_name.len > 1 && compiler__contains_capital(var_name)) {
      compiler__Parser_error_with_token_index(
          p,
          tos3("variable names cannot contain uppercase letters, use "
               "snake_case instead"),
          var_token_idx);
    };
    if (var_names.len > 1) {
      compiler__Parser_gen(p, tos3(";\n"));
      if (known_var) {
        Option_compiler__Var tmp107 =
            compiler__Parser_find_var(&/* ? */ *p, var_name);
        compiler__Var v;
        if (!tmp107.ok) {
          string err = tmp107.error;
          int errcode = tmp107.ecode;
          compiler__Parser_error_with_token_index(
              p, _STR("cannot find `%.*s`", var_name.len, var_name.str),
              var_token_idx);
          break;
        }
        v = *(compiler__Var *)tmp107.data;
        ;
        compiler__Parser_check_types_with_token_index(p, var_type, v.typ,
                                                      var_token_idx);
        if (!v.is_mut) {
          compiler__Parser_error_with_token_index(
              p, _STR("`%.*s` is immutable", v.name.len, v.name.str),
              var_token_idx);
        };
        compiler__Parser_mark_var_used(p, v);
        compiler__Parser_mark_var_changed(p, v);
        compiler__Parser_gen(p, _STR("%.*s = %.*s.var_%d", var_name.len,
                                     var_name.str, p->var_decl_name.len,
                                     p->var_decl_name.str, i));
        continue;
      };
      compiler__Parser_gen(p,
                           _STR("%.*s %.*s = %.*s.var_%d", var_type.len,
                                var_type.str, var_name.len, var_name.str,
                                p->var_decl_name.len, p->var_decl_name.str, i));
    };
    if (p->pass == compiler__compiler__Pass_main) {
      compiler__Parser_register_var(
          p, (compiler__Var){
                 .name = var_name,
                 .typ = var_type,
                 .is_mut = var_is_mut,
                 .is_alloc = p->is_alloc ||
                             string_starts_with(var_type, tos3("array_")),
                 .line_nr =
                     (*(compiler__Token *)array_get(p->tokens, var_token_idx))
                         .line_nr,
                 .token_idx = var_token_idx,
                 .idx = 0,
                 .is_arg = 0,
                 .is_const = 0,
                 .args = new_array(0, 1, sizeof(compiler__Var)),
                 .attr = tos3(""),
                 .is_returned = 0,
                 .ptr = 0,
                 .ref = 0,
                 .parent_fn = tos3(""),
                 .mod = tos3(""),
                 .is_global = 0,
                 .is_used = 0,
                 .is_changed = 0,
                 .scope_level = 0,
                 .is_c = 0,
                 .is_moved = 0,
                 .is_for_var = 0,
                 .is_public = 0});
    };
  };
  p->var_decl_name = tos3("");
  p->is_empty_c_struct_init = 0;
}
string compiler__Parser_get_struct_type(compiler__Parser *p, string name_,
                                        bool is_c, bool is_ptr) {
  string name = name_;
  if (is_ptr) {
    name = string_add(name, tos3("*"));
  };
  if ((_IN(string, (name), compiler__reserved_type_param_names))) {
    compiler__Parser_warn(p, _STR("name `%.*s` is reserved for type parameters",
                                  name.len, name.str));
  };
  p->is_c_struct_init = is_c;
  return compiler__Parser_struct_init(p, name);
}
string compiler__Parser_get_var_type(compiler__Parser *p, string name,
                                     bool is_ptr, int deref_nr) {
  Option_compiler__Var tmp110 =
      compiler__Parser_find_var_check_new_var(&/* ? */ *p, name);
  compiler__Var v;
  if (!tmp110.ok) {
    string err = tmp110.error;
    int errcode = tmp110.ecode;
    return tos3("");
  }
  v = *(compiler__Var *)tmp110.data;
  ;
  if (is_ptr) {
    compiler__Parser_gen(p, tos3("&"));
  } else if (deref_nr > 0) {
    int tmp111 = 0;
    ;
    for (int tmp112 = tmp111; tmp112 < deref_nr; tmp112++) {

      compiler__Parser_gen(p, tos3("*"));
    };
  };
  string typ = compiler__Parser_var_expr(p, v);
  if (deref_nr > 0) {
    if (!string_contains(typ, tos3("*")) &&
        !string_ends_with(typ, tos3("ptr"))) {
      printf("name=\"%.*s\", t=%.*s\n", name.len, name.str, v.typ.len,
             v.typ.str);
      compiler__Parser_error(
          p, _STR("dereferencing requires a pointer, but got `%.*s`", typ.len,
                  typ.str));
    };
    int tmp113 = 0;
    ;
    for (int tmp114 = tmp113; tmp114 < deref_nr; tmp114++) {

      typ = string_replace_once(typ, tos3("ptr"), tos3(""));
      typ = string_replace_once(typ, tos3("*"), tos3(""));
    };
  } else if (is_ptr) {
    typ = string_add(typ, tos3("*"));
  };
  if (p->inside_return_expr) {
    compiler__Parser_mark_var_returned(p, v);
  };
  return typ;
}
string compiler__Parser_get_const_type(compiler__Parser *p, string name,
                                       bool is_ptr) {
  Option_compiler__Var tmp115 =
      compiler__Table_find_const(&/* ? */ *p->table, name);
  compiler__Var c;
  if (!tmp115.ok) {
    string err = tmp115.error;
    int errcode = tmp115.ecode;
    return tos3("");
  }
  c = *(compiler__Var *)tmp115.data;
  ;
  if (is_ptr && !c.is_global) {
    compiler__Parser_error(p, _STR("cannot take the address of constant `%.*s`",
                                   c.name.len, c.name.str));
  } else if (is_ptr && c.is_global) {
    compiler__Parser_gen(p, tos3("& /*const*/ "));
  };
  if (!c.is_public && string_ne(c.mod, p->mod)) {
    compiler__Parser_warn(
        p, _STR("constant `%.*s` is private", c.name.len, c.name.str));
  };
  string typ = compiler__Parser_var_expr(p, c);
  if (is_ptr) {
    typ = string_add(typ, tos3("*"));
  };
  return typ;
}
string compiler__Parser_get_c_func_type(compiler__Parser *p, string name) {
  compiler__Fn f =
      (compiler__Fn){.name = name,
                     .is_c = 1,
                     .mod = tos3(""),
                     .args = new_array(0, 1, sizeof(compiler__Var)),
                     .is_interface = 0,
                     .scope_level = 0,
                     .typ = tos3(""),
                     .receiver_typ = tos3(""),
                     .is_public = 0,
                     .is_method = 0,
                     .is_decl = 0,
                     .is_unsafe = 0,
                     .is_deprecated = 0,
                     .is_variadic = 0,
                     .is_generic = 0,
                     .returns_error = 0,
                     .defer_text = new_array(0, 1, sizeof(string)),
                     .type_pars = new_array(0, 1, sizeof(string)),
                     .type_inst = new_array(0, 1, sizeof(compiler__TypeInst)),
                     .generic_fn_idx = 0,
                     .parser_idx = 0,
                     .fn_name_token_idx = 0,
                     .comptime_define = tos3(""),
                     .is_used = 0};
  p->is_c_fn_call = 1;
  compiler__Parser_fn_call(p, &/*114*/ f, 0, tos3(""), tos3(""));
  p->is_c_fn_call = 0;
  Option_compiler__Fn tmp116 =
      compiler__Table_find_fn(&/* ? */ *p->table, name);
  compiler__Fn cfn;
  if (!tmp116.ok) {
    string err = tmp116.error;
    int errcode = tmp116.ecode;
    if (!string_starts_with(name, tos3("gl")) &&
        !string_starts_with(name, tos3("glad"))) {
      compiler__Parser_error(
          p, string_add(
                 _STR("undefined C function `%.*s`\n", f.name.len, f.name.str),
                 _STR("define it with `fn C.%.*s([args]) [return_type]`",
                      name.len, name.str)));
    };
    return tos3("void*");
  }
  cfn = *(compiler__Fn *)tmp116.data;
  ;
  return cfn.typ;
}
void compiler__Parser_undefined_error(compiler__Parser *p, string name,
                                      string orig_name) {
  string name_dotted =
      compiler__mod_gen_name_rev(string_replace(name, tos3("__"), tos3(".")));
  string suggested = compiler__Parser_identify_typo(&/* ? */ *p, name);
  if (suggested.len != 0) {
    compiler__Parser_error(p, _STR("undefined: `%.*s`. did you mean:\n%.*s\n",
                                   name_dotted.len, name_dotted.str,
                                   suggested.len, suggested.str));
  };
  if (compiler__Table_known_mod(&/* ? */ *p->table, orig_name) ||
      compiler__ImportTable_known_alias(&/* ? */ p->import_table, orig_name)) {
    compiler__Parser_error(p, _STR("undefined: `%.*s` (in module `%.*s`)",
                                   name_dotted.len, name_dotted.str,
                                   orig_name.len, orig_name.str));
  } else if ((_IN(string, (orig_name), compiler__reserved_type_param_names))) {
    compiler__Parser_error(
        p, _STR("the letter `%.*s` is reserved for type parameters",
                orig_name.len, orig_name.str));
  };
  compiler__Parser_error(
      p, _STR("undefined: `%.*s`", orig_name.len, orig_name.str));
}
string compiler__Parser_var_expr(compiler__Parser *p, compiler__Var v) {
  if (!v.is_const) {
    compiler__Parser_mark_var_used(p, v);
    if (p->calling_c && !v.is_changed) {
      compiler__Parser_mark_var_changed(p, v);
    };
  };
  int fn_ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
  p->expr_var = v;
  compiler__Parser_gen(
      p, compiler__Table_var_cgen_name(&/* ? */ *p->table, v.name));
  compiler__Parser_next(p);
  string typ = v.typ;
  if (string_starts_with(compiler__Parser_base_type(p, typ), tos3("fn ")) &&
      p->tok == compiler__compiler__TokenKind_lpar) {
    compiler__Type tt = compiler__Table_find_type(
        &/* ? */ *p->table, compiler__Parser_base_type(p, typ));
    compiler__Parser_gen(p, tos3("("));
    compiler__Parser_fn_call_args(
        p, &/*114*/ tt.func,
        new_array_from_c_array(0, 0, sizeof(string),
                               EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)}));
    compiler__Parser_gen(p, tos3(")"));
    typ = tt.func.typ;
  };
  if (p->tok == compiler__compiler__TokenKind_lsbr) {
    typ = compiler__Parser_index_expr(p, typ, fn_ph);
    if (string_starts_with(compiler__Parser_base_type(p, typ), tos3("fn ")) &&
        p->tok == compiler__compiler__TokenKind_lpar) {
      compiler__Type tt = compiler__Table_find_type(
          &/* ? */ *p->table, compiler__Parser_base_type(p, typ));
      compiler__Parser_gen(p, tos3("("));
      compiler__Parser_fn_call_args(
          p, &/*114*/ tt.func,
          new_array_from_c_array(0, 0, sizeof(string),
                                 EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)}));
      compiler__Parser_gen(p, tos3(")"));
      typ = tt.func.typ;
    };
  };
  while (p->tok == compiler__compiler__TokenKind_dot) {

    if (compiler__Parser_peek(&/* ? */ *p) ==
        compiler__compiler__TokenKind_key_select) {
      compiler__Parser_next(p);
      return compiler__Parser_select_query(p, fn_ph);
    };
    if (string_eq(typ, tos3("pg__DB")) &&
        !compiler__Parser_fileis(&/* ? */ *p, tos3("pg.v")) &&
        compiler__Parser_peek(&/* ? */ *p) ==
            compiler__compiler__TokenKind_name) {
      string name =
          (*(compiler__Token *)array_get(p->tokens, p->token_idx)).lit;
      if (!string_contains(name, tos3("exec")) &&
          !string_starts_with(name, tos3("q_"))) {
        compiler__Parser_next(p);
        if (string_eq(name, tos3("insert"))) {
          compiler__Parser_insert_query(p, fn_ph);
        } else if (string_eq(name, tos3("update"))) {
          compiler__Parser_update_query(p, fn_ph);
        };
        return tos3("void");
      };
    };
    typ = compiler__Parser_dot(p, typ, fn_ph);
    if (p->tok == compiler__compiler__TokenKind_lsbr) {
      typ = compiler__Parser_index_expr(p, typ, fn_ph);
    };
  };
  if (p->tok == compiler__compiler__TokenKind_inc ||
      p->tok == compiler__compiler__TokenKind_dec) {
    if (!v.is_mut && !p->pref->translated) {
      compiler__Parser_error(
          p, _STR("`%.*s` is immutable", v.name.len, v.name.str));
    };
    if (!v.is_changed) {
      compiler__Parser_mark_var_changed(p, v);
    };
    if (string_ne(typ, tos3("int")) && !string_contains(typ, tos3("*"))) {
      if (!p->pref->translated && !compiler__is_number_type(typ)) {
        compiler__Parser_error(
            p, _STR("cannot ++/-- value of type `%.*s`", typ.len, typ.str));
      };
    };
    compiler__Parser_gen(p, compiler__TokenKind_str(p->tok));
    compiler__Parser_next(p);
    if (p->pref->translated) {
    } else {
      return typ;
    };
  };
  typ = compiler__Parser_index_expr(p, typ, fn_ph);
  if (p->tok == compiler__compiler__TokenKind_dot) {
    while (p->tok == compiler__compiler__TokenKind_dot) {

      typ = compiler__Parser_dot(p, typ, fn_ph);
    };
    typ = compiler__Parser_index_expr(p, typ, fn_ph);
  };
  return typ;
}
string compiler__Parser_dot(compiler__Parser *p, string str_typ_,
                            int method_ph) {
  string str_typ = str_typ_;
  compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
  bool is_variadic_arg = string_starts_with(str_typ, tos3("varg_"));
  compiler__Type typ = compiler__Parser_find_type(&/* ? */ *p, str_typ);
  if (typ.name.len == 0) {
    compiler__Parser_error(
        p, _STR("dot(): cannot find type `%.*s`", str_typ.len, str_typ.str));
  };
  if (p->tok == compiler__compiler__TokenKind_dollar) {
    compiler__Parser_comptime_method_call(p, typ);
    return tos3("void");
  };
  string field_name = p->lit;
  if (string_eq(field_name, tos3("filter")) &&
      string_starts_with(str_typ, tos3("array_"))) {
    compiler__Parser_gen_array_filter(p, str_typ, method_ph);
    return str_typ;
  } else if (string_eq(field_name, tos3("map")) &&
             string_starts_with(str_typ, tos3("array_"))) {
    return compiler__Parser_gen_array_map(p, str_typ, method_ph);
  };
  int fname_tidx = compiler__Parser_cur_tok_index(&/* ? */ *p);
  bool has_field = compiler__Table_type_has_field(
      &/* ? */ *p->table, &/*114*/ typ,
      compiler__Table_var_cgen_name(&/* ? */ *p->table, field_name));
  bool has_method = compiler__Table_type_has_method(&/* ? */ *p->table,
                                                    &/*114*/ typ, field_name);
  if (is_variadic_arg && string_eq(field_name, tos3("len"))) {
    compiler__Parser_gen(p, _STR("->%.*s", field_name.len, field_name.str));
    compiler__Parser_next(p);
    return tos3("int");
  };
  if (!has_method && string_eq(field_name, tos3("str")) &&
      string_starts_with(typ.name, tos3("array_"))) {
    compiler__Parser_gen_array_str(p, typ);
    has_method = 1;
  };
  if (!typ.is_c && !p->is_c_fn_call && !has_field && !has_method &&
      !compiler__Parser_first_pass(&/* ? */ *p)) {
    if (string_starts_with(typ.name, tos3("Option_"))) {
      string opt_type = string_replace(string_substr2(typ.name, 7, -1, true),
                                       tos3("ptr_"), tos3("&"));
      compiler__Parser_error(p, _STR("unhandled option type: `?%.*s`",
                                     opt_type.len, opt_type.str));
    };
    compiler__Parser_error_with_token_index(
        p,
        _STR("type `%.*s` has no field or method `%.*s`", typ.name.len,
             typ.name.str, field_name.len, field_name.str),
        fname_tidx);
  };
  string dot = tos3(".");
  if (string_ends_with(str_typ, tos3("*")) ||
      string_eq(str_typ, tos3("FT_Face"))) {
    dot = compiler__dot_ptr;
  };
  if (has_field) {
    string struct_field =
        ((string_ne(typ.name, tos3("Option")))
             ? (compiler__Table_var_cgen_name(&/* ? */ *p->table, field_name))
             : (field_name));
    Option_compiler__Var tmp121 = compiler__Table_find_field(
        &/* ? */ *p->table, &/*114*/ typ, struct_field);
    compiler__Var field;
    if (!tmp121.ok) {
      string err = tmp121.error;
      int errcode = tmp121.ecode;
      compiler__Parser_error_with_token_index(
          p,
          _STR("missing field: %.*s in type %.*s", struct_field.len,
               struct_field.str, typ.name.len, typ.name.str),
          fname_tidx);
      v_exit(1);
    }
    field = *(compiler__Var *)tmp121.data;
    ;
    if (!field.is_mut && !p->has_immutable_field) {
      p->has_immutable_field = 1;
      p->first_immutable_field = field;
    };
    compiler__TokenKind next = compiler__Parser_peek(&/* ? */ *p);
    bool modifying = compiler__TokenKind_is_assign(next) ||
                     next == compiler__compiler__TokenKind_inc ||
                     next == compiler__compiler__TokenKind_dec ||
                     (string_starts_with(field.typ, tos3("array_")) &&
                      next == compiler__compiler__TokenKind_left_shift);
    if (modifying) {
      p->expected_type = field.typ;
    };
    if (!p->builtin_mod && !p->pref->translated && modifying &&
        p->has_immutable_field) {
      compiler__Var f = p->first_immutable_field;
      compiler__Parser_error_with_token_index(
          p,
          string_add(
              _STR("cannot modify immutable field `%.*s` (type `%.*s`)\n",
                   f.name.len, f.name.str, f.parent_fn.len, f.parent_fn.str),
              _STR("declare the field with `mut:`\nstruct %.*s "
                   "{\nmut:\n	%.*s %.*s\n}\n",
                   f.parent_fn.len, f.parent_fn.str, f.name.len, f.name.str,
                   f.typ.len, f.typ.str)),
          fname_tidx);
    };
    if (field.access_mod == compiler__compiler__AccessMod_private &&
        !p->builtin_mod && !p->pref->translated && string_ne(p->mod, typ.mod) &&
        !p->is_vgen) {
      compiler__Parser_error_with_token_index(
          p,
          string_add(
              _STR("cannot refer to unexported field `%.*s` (type `%.*s`)\n",
                   struct_field.len, struct_field.str, typ.name.len,
                   typ.name.str),
              _STR("declare the field with `pub:`\nstruct %.*s "
                   "{\npub:\n	%.*s %.*s\n}\n",
                   typ.name.len, typ.name.str, struct_field.len,
                   struct_field.str, field.typ.len, field.typ.str)),
          fname_tidx);
    };
    string base = compiler__Parser_base_type(p, field.typ);
    if (string_starts_with(base, tos3("fn ")) &&
        compiler__Parser_peek(&/* ? */ *p) ==
            compiler__compiler__TokenKind_lpar) {
      compiler__Type tmp_typ =
          compiler__Table_find_type(&/* ? */ *p->table, base);
      compiler__Fn f = tmp_typ.func;
      compiler__Parser_gen(p, _STR("%.*s%.*s", dot.len, dot.str, field.name.len,
                                   field.name.str));
      compiler__Parser_gen(p, tos3("("));
      compiler__Parser_check(p, compiler__compiler__TokenKind_name);
      compiler__Parser_fn_call_args(
          p, &/*114*/ f,
          new_array_from_c_array(0, 0, sizeof(string),
                                 EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)}));
      compiler__Parser_gen(p, tos3(")"));
      return f.typ;
    };
    compiler__Parser_gen(p, string_add(dot, struct_field));
    compiler__Parser_next(p);
    return field.typ;
  };
  Option_compiler__Fn tmp122 =
      compiler__Table_find_method(&/* ? */ *p->table, &/*114*/ typ, field_name);
  compiler__Fn method;
  if (!tmp122.ok) {
    string err = tmp122.error;
    int errcode = tmp122.ecode;
    compiler__Parser_error_with_token_index(
        p, _STR("could not find method `%.*s`", field_name.len, field_name.str),
        fname_tidx);
    v_exit(1);
  }
  method = *(compiler__Fn *)tmp122.data;
  ;
  compiler__Parser_fn_call(p, &/*114*/ method, method_ph, tos3(""), str_typ);
  bool is_or_else = p->tok == compiler__compiler__TokenKind_key_orelse;
  if (is_or_else) {
    ;
  };
  if (p->tok == compiler__compiler__TokenKind_question) {
    return compiler__Parser_gen_handle_question_suffix(p, method, method_ph);
  } else if (!p->is_var_decl && is_or_else) {
    method.typ = compiler__Parser_gen_handle_option_or_else(
        p, method.typ, tos3(""), method_ph);
  } else if (!p->is_var_decl && !is_or_else && !p->inside_return_expr &&
             string_starts_with(method.typ, tos3("Option_"))) {
    string opt_type = string_replace(string_substr2(method.typ, 7, -1, true),
                                     tos3("ptr_"), tos3("&"));
    compiler__Parser_error(
        p, _STR("unhandled option type: `?%.*s`", opt_type.len, opt_type.str));
  };
  if (string_eq(method.typ, tos3("array")) &&
      string_starts_with(typ.name, tos3("array_"))) {
    return typ.name;
  };
  if (string_eq(method.typ, tos3("void*")) &&
      string_starts_with(typ.name, tos3("array_"))) {
    return compiler__parse_pointer(string_substr2(typ.name, 6, -1, true));
  };
  if (string_ends_with(method.typ, tos3("*"))) {
    p->is_alloc = 1;
  };
  return method.typ;
}
compiler__IndexType compiler__get_index_type(string typ) {
  if (string_starts_with(typ, tos3("map_"))) {
    return compiler__compiler__IndexType_map;
  };
  if (string_eq(typ, tos3("string"))) {
    return compiler__compiler__IndexType_str;
  };
  if (string_starts_with(typ, tos3("array_")) ||
      string_eq(typ, tos3("array"))) {
    return compiler__compiler__IndexType_array;
  };
  if (string_eq(typ, tos3("byte*")) || string_eq(typ, tos3("byteptr")) ||
      string_contains(typ, tos3("*"))) {
    return compiler__compiler__IndexType_ptr;
  };
  if (string_at(typ, 0) == '[') {
    return compiler__compiler__IndexType_fixed_array;
  };
  return compiler__compiler__IndexType_noindex;
}
string compiler__Parser_index_expr(compiler__Parser *p, string typ_,
                                   int fn_ph) {
  string typ = typ_;
  compiler__Var v = p->expr_var;
  bool is_variadic_arg = string_starts_with(typ, tos3("varg_"));
  bool is_map = string_starts_with(typ, tos3("map_"));
  bool is_str = string_eq(typ, tos3("string"));
  bool is_arr0 = string_starts_with(typ, tos3("array_"));
  bool is_arr = is_arr0 || string_eq(typ, tos3("array"));
  bool is_ptr = string_eq(typ, tos3("byte*")) ||
                string_eq(typ, tos3("byteptr")) ||
                string_contains(typ, tos3("*"));
  bool is_slice = 0;
  bool is_indexer = p->tok == compiler__compiler__TokenKind_lsbr;
  bool close_bracket = 0;
  int index_error_tok_pos = p->token_idx;
  if (is_indexer) {
    bool is_fixed_arr = string_at(typ, 0) == '[';
    if (!is_str && !is_arr && !is_map && !is_ptr && !is_fixed_arr &&
        !is_variadic_arg) {
      compiler__Parser_error(
          p, _STR("invalid operation: type `%.*s` does not support indexing",
                  typ.len, typ.str));
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_lsbr);
    if (is_str) {
      typ = tos3("byte");
      if (p->builtin_mod || p->pref->is_bare) {
        compiler__Parser_gen(p, tos3(".str["));
        close_bracket = 1;
      } else {
        compiler__Parser_gen(p, tos3(", "));
      };
    };
    if (is_variadic_arg) {
      typ = string_substr2(typ, 5, -1, true);
    };
    if (is_fixed_arr) {
      if (string_contains(typ, tos3("]["))) {
        int pos = string_index_after(typ, tos3("["), 1);
        typ = string_substr2(typ, pos, -1, true);
      } else {
        typ = string_all_after(typ, tos3("]"));
      };
      compiler__Parser_gen(p, tos3("["));
      close_bracket = 1;
    } else if (is_ptr && !is_variadic_arg) {
      typ = string_replace(typ, tos3("*"), tos3(""));
      if (!is_arr && !is_map) {
        compiler__Parser_gen(p, tos3("[/*ptr!*/"));
        close_bracket = 1;
      };
    };
    if (is_arr) {
      if (is_arr0) {
        typ = compiler__parse_pointer(string_substr2(typ, 6, -1, true));
      };
      compiler__Parser_gen_array_at(p, typ, is_arr0, fn_ph);
    };
    if (is_map) {
      typ = string_replace(typ, tos3("map_"), tos3(""));
      typ = compiler__parse_pointer(typ);
      if (string_eq(typ, tos3("map"))) {
        typ = tos3("void*");
      };
      compiler__Parser_gen(p, tos3(","));
    };
    if (is_arr || is_str) {
      if (p->tok != compiler__compiler__TokenKind_dotdot) {
        int index_pos = p->cgen->cur_line.len;
        compiler__Type tt = compiler__Table_find_type(
            &/* ? */ *p->table, compiler__Parser_expression(p));
        if (string_ne(tt.parent, tos3("int")) &&
            string_ne(tt.parent, tos3("u32"))) {
          compiler__Parser_check_types(p, tt.name, tos3("int"));
        };
        if (v_string_int(string_replace(
                string_substr2(p->cgen->cur_line, index_pos, -1, true),
                tos3(" "), tos3(""))) < 0) {
          compiler__Parser_error(p, tos3("cannot access negative array index"));
        };
      } else {
        compiler__Parser_gen(p, tos3("0"));
      };
      if (p->tok == compiler__compiler__TokenKind_dotdot) {
        if (is_arr) {
          typ = string_add(tos3("array_"), compiler__stringify_pointer(typ));
        } else if (is_str) {
          typ = tos3("string");
        } else {
          compiler__Parser_error(
              p, tos3("slicing is supported by arrays and strings only"));
        };
        is_slice = 1;
        compiler__Parser_next(p);
        compiler__Parser_gen(p, tos3(","));
        if (p->tok != compiler__compiler__TokenKind_rsbr) {
          compiler__Parser_check_types(p, compiler__Parser_expression(p),
                                       tos3("int"));
          compiler__Parser_gen(p, tos3(", false"));
        } else {
          compiler__Parser_gen(p, tos3("-1, true"));
        };
      };
    } else {
      compiler__Type tt = compiler__Table_find_type(
          &/* ? */ *p->table, compiler__Parser_expression(p));
      if (is_map && string_ne(tt.parent, tos3("string"))) {
        compiler__Parser_check_types(p, tt.name, tos3("string"));
      };
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_rsbr);
    if (close_bracket) {
      compiler__Parser_gen(p,
                           _STR("]/*r%.*s %d*/", typ.len, typ.str, v.is_mut));
    };
    p->expr_var = v;
  };
  if (is_variadic_arg) {
    if (is_indexer) {
      string l = string_trim_space(p->cgen->cur_line);
      Option_int tmp139 = string_last_index(l, tos3(" "));
      int idx;
      if (!tmp139.ok) {
        string err = tmp139.error;
        int errcode = tmp139.ecode;
        v_panic(tos3("idx"));
      }
      idx = *(int *)tmp139.data;
      ;
      string index_val = string_trim_space(string_substr2(l, idx, -1, true));
      compiler__CGen_resetln(p->cgen, string_substr2(l, 0, fn_ph, false));
      _PUSH(
          &p->table->varg_access,
          (/*typ = array_compiler__VargAccess   tmp_typ=compiler__VargAccess*/ (
              compiler__VargAccess){.fn_name = p->cur_fn.name,
                                    .tok_idx = index_error_tok_pos,
                                    .index = v_string_int(index_val)}),
          tmp144, compiler__VargAccess);
      compiler__CGen_set_placeholder(p->cgen, fn_ph,
                                     _STR("%.*s->args[%.*s]", v.name.len,
                                          v.name.str, index_val.len,
                                          index_val.str));
      return typ;
    };
  };
  if ((p->tok == compiler__compiler__TokenKind_assign && !p->is_sql) ||
      compiler__TokenKind_is_assign(p->tok)) {
    if (is_indexer && is_str && !p->builtin_mod) {
      compiler__Parser_error(p, tos3("strings are immutable"));
    };
    p->assigned_type = typ;
    p->expected_type = typ;
    int assign_pos = p->cgen->cur_line.len;
    bool is_cao = p->tok != compiler__compiler__TokenKind_assign;
    compiler__Parser_assign_statement(p, v, fn_ph,
                                      is_indexer && (is_map || is_arr));
    if (is_indexer && (is_map || is_arr)) {
      compiler__Parser_gen_array_set(p, typ, is_ptr, is_map, fn_ph, assign_pos,
                                     is_cao);
    };
    return typ;
  } else if ((is_map || is_arr || (is_str && !p->builtin_mod)) && is_indexer) {
    typ = compiler__parse_pointer(typ);
    compiler__Parser_index_get(p, typ, fn_ph,
                               (compiler__IndexConfig){
                                   .is_arr = is_arr,
                                   .is_map = is_map,
                                   .is_ptr = is_ptr,
                                   .is_str = is_str,
                                   .is_slice = is_slice,
                                   .is_arr0 = 0,
                               });
  };
  return typ;
}
bool compiler__Parser_fileis(compiler__Parser *p, string s) {
  return string_contains(os__filename(p->scanner->file_path), s);
}
string compiler__Parser_indot_expr(compiler__Parser *p) {
  int ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
  string typ = compiler__Parser_term(p);
  if (p->tok == compiler__compiler__TokenKind_dot) {
    while (p->tok == compiler__compiler__TokenKind_dot) {

      typ = compiler__Parser_dot(p, typ, ph);
    };
  };
  if (p->tok == compiler__compiler__TokenKind_key_in) {
    ;
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_in);
    p->expected_type = typ;
    if (p->tok == compiler__compiler__TokenKind_lsbr) {
      ;
      compiler__Parser_in_optimization(p, typ, ph);
      return tos3("bool");
    };
    ;
    compiler__Parser_gen(p, tos3("), "));
    string arr_typ = compiler__Parser_expression(p);
    bool is_map = string_starts_with(arr_typ, tos3("map_"));
    bool is_arr = string_starts_with(arr_typ, tos3("array_"));
    if (!is_arr && !is_map) {
      compiler__Parser_error(p, tos3("`in` requires an array/map"));
    };
    if (is_arr &&
        string_ne(compiler__parse_pointer(string_substr2(arr_typ, 6, -1, true)),
                  typ)) {
      compiler__Parser_error(p,
                             _STR("bad element type: `%.*s` in `%.*s`", typ.len,
                                  typ.str, arr_typ.len, arr_typ.str));
    };
    if (is_map && string_ne(typ, tos3("string"))) {
      compiler__Parser_error(p, tos3("bad element type: expecting `string`"));
    };
    compiler__Type arr_typ2 =
        compiler__Table_find_type(&/* ? */ *p->table, arr_typ);
    if (!is_map &&
        !compiler__Type_has_method(&/* ? */ arr_typ2, tos3("contains"))) {
      compiler__Parser_error(
          p, _STR("%.*s has no method `contains`", arr_typ.len, arr_typ.str));
    };
    if (is_map) {
      compiler__CGen_set_placeholder(p->cgen, ph, tos3("(_IN_MAP( ("));
    } else {
      compiler__CGen_set_placeholder(p->cgen, ph,
                                     _STR("(_IN(%.*s, (", typ.len, typ.str));
    };
    compiler__Parser_gen(p, tos3("))"));
    return tos3("bool");
  };
  return typ;
}
string compiler__Parser_assoc(compiler__Parser *p) {
  compiler__Parser_next(p);
  string name = compiler__Parser_check_name(p);
  ;
  Option_compiler__Var tmp147 =
      compiler__Parser_find_var_or_const(&/* ? */ *p, name);
  compiler__Var var;
  if (!tmp147.ok) {
    string err = tmp147.error;
    int errcode = tmp147.ecode;
    compiler__Parser_error(p,
                           _STR("unknown variable `%.*s`", name.len, name.str));
    v_exit(1);
  }
  var = *(compiler__Var *)tmp147.data;
  ;
  if (!var.is_const) {
    compiler__Parser_mark_var_used(p, var);
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_pipe);
  ;
  compiler__Parser_gen(p, _STR("(%.*s){", var.typ.len, var.typ.str));
  compiler__Type typ = compiler__Table_find_type(&/* ? */ *p->table, var.typ);
  array_string fields = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  while (p->tok != compiler__compiler__TokenKind_rcbr) {

    string field = compiler__Parser_check_name(p);
    Option_compiler__Var tmp148 =
        compiler__Type_find_field(&/* ? */ typ, field);
    compiler__Var f;
    if (!tmp148.ok) {
      string err = tmp148.error;
      int errcode = tmp148.ecode;
      compiler__Parser_error(p, _STR("`%.*s` has no field `%.*s`", typ.name.len,
                                     typ.name.str, field.len, field.str));
      v_exit(1);
    }
    f = *(compiler__Var *)tmp148.data;
    ;
    _PUSH(&fields, (/*typ = array_string   tmp_typ=string*/ field), tmp149,
          string);
    compiler__Parser_gen(p, _STR(".%.*s = ", field.len, field.str));
    compiler__Parser_check(p, compiler__compiler__TokenKind_colon);
    compiler__Parser_check_types(p, compiler__Parser_bool_expression(p), f.typ);
    compiler__Parser_gen(p, tos3(","));
    if (p->tok != compiler__compiler__TokenKind_rcbr) {
      if (p->tok == compiler__compiler__TokenKind_comma) {
        compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
      };
    };
    ;
  };
  array_compiler__Var tmp150 = typ.fields;
  for (int tmp151 = 0; tmp151 < tmp150.len; tmp151++) {
    compiler__Var ffield = ((compiler__Var *)tmp150.data)[tmp151];

    string f = ffield.name;
    if ((_IN(string, (f), fields))) {
      continue;
    };
    compiler__Parser_gen(p, _STR(".%.*s = %.*s.%.*s,", f.len, f.str,
                                 var.name.len, var.name.str, f.len, f.str));
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
  compiler__Parser_gen(p, tos3("}"));
  return var.typ;
}
void compiler__Parser_char_expr(compiler__Parser *p) {
  compiler__Parser_gen(p, _STR("\'%.*s\'", p->lit.len, p->lit.str));
  compiler__Parser_next(p);
}
string compiler__format_str(string _str) {
  string str = string_replace(_str, tos3("\""), tos3("\\\""));
  str = string_replace(str, tos3("\r\n"), tos3("\\n"));
  str = string_replace(str, tos3("\n"), tos3("\\n"));
  return str;
}
string compiler__Parser_map_init(compiler__Parser *p) {
  string keys_gen = tos3("");
  string vals_gen = tos3("");
  string val_type = tos3("");
  if (p->tok == compiler__compiler__TokenKind_lcbr) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
    int i = 0;
    while (1) {
      string key = p->lit;
      keys_gen =
          string_add(keys_gen, _STR("tos3(\"%.*s\"), ", key.len, key.str));
      compiler__Parser_check(p, compiler__compiler__TokenKind_string);
      compiler__Parser_check(p, compiler__compiler__TokenKind_colon);
      ;
      _V_MulRet_string_V_string _V_mret_12409_t_val_expr =
          compiler__Parser_tmp_expr(p);
      string t = _V_mret_12409_t_val_expr.var_0;
      string val_expr = _V_mret_12409_t_val_expr.var_1;
      if (i == 0) {
        val_type = t;
      };
      i++;
      if (string_ne(val_type, t)) {
        if (!compiler__Parser_check_types_no_throw(p, val_type, t)) {
          compiler__Parser_error(
              p, _STR("bad map element type `%.*s` instead of `%.*s`",
                      val_type.len, val_type.str, t.len, t.str));
        };
      };
      vals_gen =
          string_add(vals_gen, _STR("%.*s, ", val_expr.len, val_expr.str));
      if (p->tok == compiler__compiler__TokenKind_rcbr) {
        ;
        compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
        break;
      };
      if (p->tok == compiler__compiler__TokenKind_comma) {
        compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
      };
      ;
    };
    compiler__Parser_gen(
        p, string_add(_STR("new_map_init(%d, sizeof(%.*s), ", i, val_type.len,
                           val_type.str),
                      _STR("(string[%d]){ %.*s }, (%.*s [%d]){ %.*s } )", i,
                           keys_gen.len, keys_gen.str, val_type.len,
                           val_type.str, i, vals_gen.len, vals_gen.str)));
    string typ = _STR("map_%.*s", compiler__stringify_pointer(val_type).len,
                      compiler__stringify_pointer(val_type).str);
    compiler__Parser_register_map(p, typ);
    return typ;
  };
  compiler__Parser_next(p);
  compiler__Parser_check(p, compiler__compiler__TokenKind_lsbr);
  string key_type = compiler__Parser_check_name(p);
  if (string_ne(key_type, tos3("string"))) {
    compiler__Parser_error(p, tos3("only string key maps allowed for now"));
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_rsbr);
  val_type = compiler__Parser_get_type(p);
  string typ = _STR("map_%.*s", compiler__stringify_pointer(val_type).len,
                    compiler__stringify_pointer(val_type).str);
  compiler__Parser_register_map(p, typ);
  compiler__Parser_gen(
      p, _STR("new_map(1, sizeof(%.*s))", val_type.len, val_type.str));
  if (p->tok == compiler__compiler__TokenKind_lcbr) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
    compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
    println(string_add(_STR("warning: %.*s:%d ", p->file_name.len,
                            p->file_name.str, p->scanner->line_nr),
                       tos3("initializaing maps no longer requires `{}`")));
  };
  return typ;
}
string compiler__Parser_array_init(compiler__Parser *p) {
  string expected_array_type = p->expected_type;
  p->is_alloc = 1;
  compiler__Parser_check(p, compiler__compiler__TokenKind_lsbr);
  bool is_integer = p->tok == compiler__compiler__TokenKind_number;
  bool is_const_len = 0;
  if (p->tok == compiler__compiler__TokenKind_name && !p->inside_const) {
    string const_name = compiler__Parser_prepend_mod(&/* ? */ *p, p->lit);
    if (compiler__Table_known_const(&/* ? */ *p->table, const_name)) {
      Option_compiler__Var tmp152 =
          compiler__Table_find_const(&/* ? */ *p->table, const_name);
      compiler__Var c;
      if (!tmp152.ok) {
        string err = tmp152.error;
        int errcode = tmp152.ecode;
        compiler__Parser_error(
            p, _STR("unknown const `%.*s`", const_name.len, const_name.str));
        v_exit(1);
      }
      c = *(compiler__Var *)tmp152.data;
      ;
      if (string_eq(c.typ, tos3("int")) &&
          compiler__Parser_peek(&/* ? */ *p) ==
              compiler__compiler__TokenKind_rsbr) {
        is_integer = 1;
        is_const_len = 1;
      } else {
        compiler__Parser_error(p, _STR("bad fixed size array const `%.*s`",
                                       p->lit.len, p->lit.str));
      };
    };
  };
  string lit = p->lit;
  string typ = tos3("");
  int new_arr_ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
  int i = 0;
  while (p->tok != compiler__compiler__TokenKind_rsbr) {

    if (string_starts_with(expected_array_type, tos3("array_"))) {
      p->expected_type = string_substr2(expected_array_type, 6, -1, true);
    };
    string val_typ = compiler__Parser_bool_expression(p);
    if (i == 0) {
      typ = val_typ;
      if (is_integer && p->tok == compiler__compiler__TokenKind_rsbr &&
          compiler__Parser_peek(&/* ? */ *p) ==
              compiler__compiler__TokenKind_name &&
          compiler__Parser_cur_tok(&/* ? */ *p).line_nr ==
              compiler__Parser_peek_token(&/* ? */ *p).line_nr) {
        if (compiler__Parser_cur_tok(&/* ? */ *p).pos +
                compiler__Parser_peek_token(&/* ? */ *p).lit.len ==
            compiler__Parser_peek_token(&/* ? */ *p).pos) {
          compiler__Parser_check(p, compiler__compiler__TokenKind_rsbr);
          bool is_c = p->tok == compiler__compiler__TokenKind_name &&
                      string_eq(p->lit, tos3("C"));
          if (is_c) {
            compiler__CGen_insert_before(p->cgen, tos3("struct "));
          };
          string array_elem_typ = compiler__Parser_get_type(p);
          if (!compiler__Table_known_type(&/* ? */ *p->table, array_elem_typ)) {
            compiler__Parser_error(p,
                                   _STR("bad type `%.*s`", array_elem_typ.len,
                                        array_elem_typ.str));
          };
          compiler__CGen_resetln(p->cgen, tos3(""));
          p->is_alloc = 0;
          if (is_const_len) {
            return _STR("[%.*s__%.*s]%.*s", compiler__mod_gen_name(p->mod).len,
                        compiler__mod_gen_name(p->mod).str, lit.len, lit.str,
                        array_elem_typ.len, array_elem_typ.str);
          };
          return _STR("[%.*s]%.*s", lit.len, lit.str, array_elem_typ.len,
                      array_elem_typ.str);
        } else {
          compiler__Parser_check(p, compiler__compiler__TokenKind_rsbr);
          typ = compiler__Parser_get_type(p);
          compiler__Parser_error(
              p, _STR("no space allowed between [%.*s] and %.*s", lit.len,
                      lit.str, typ.len, typ.str));
        };
      };
    };
    if (string_ne(val_typ, typ)) {
      if (!compiler__Parser_check_types_no_throw(p, val_typ, typ)) {
        bool ok = 0;
        if (string_ends_with(expected_array_type, tos3("er"))) {
          if (compiler__Parser_satisfies_interface(p, expected_array_type, typ,
                                                   0)) {
            ok = 1;
          };
        };
        if (!ok) {
          compiler__Parser_error(
              p, _STR("bad array element type `%.*s` instead of `%.*s`",
                      val_typ.len, val_typ.str, typ.len, typ.str));
        };
      };
    };
    if (p->tok != compiler__compiler__TokenKind_rsbr &&
        p->tok != compiler__compiler__TokenKind_semicolon) {
      compiler__Parser_gen(p, tos3(", "));
      compiler__TokenKind line_nr = p->tok;
      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
      ;
    };
    i++;
    if (i == 1 && p->tok == compiler__compiler__TokenKind_semicolon) {
      compiler__Parser_error(
          p,
          tos3(
              "`[0 ; len]` syntax was removed. Use `[0].repeat(len)` instead"));
    };
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_rsbr);
  bool exp_array = string_starts_with(p->expected_type, tos3("array_"));
  if (p->tok != compiler__compiler__TokenKind_name &&
      p->tok != compiler__compiler__TokenKind_mul &&
      p->tok != compiler__compiler__TokenKind_lsbr &&
      p->tok != compiler__compiler__TokenKind_amp && i == 0 && !exp_array) {
    compiler__Parser_error(p,
                           tos3("specify array type: `[]typ` instead of `[]`"));
  };
  if (i == 0 &&
      (p->tok == compiler__compiler__TokenKind_name ||
       p->tok == compiler__compiler__TokenKind_mul ||
       p->tok == compiler__compiler__TokenKind_amp) &&
      (*(compiler__Token *)array_get(p->tokens, p->token_idx - 2)).line_nr ==
          (*(compiler__Token *)array_get(p->tokens, p->token_idx - 1))
              .line_nr) {
    if (exp_array) {
      string type_expected =
          string_replace(string_substr2(p->expected_type, 6, -1, true),
                         tos3("ptr_"), tos3("&"));
      compiler__Parser_warn(p, _STR("no need to specify the full array type "
                                    "here, use `[]` instead of `[]%.*s`",
                                    type_expected.len, type_expected.str));
    };
    typ = compiler__Parser_get_type(p);
  } else if (exp_array && i == 0) {
    typ = string_substr2(p->expected_type, 6, -1, true);
  };
  bool no_alloc = p->tok == compiler__compiler__TokenKind_not;
  if (no_alloc) {
    compiler__Parser_next(p);
  };
  bool is_fixed_size = p->tok == compiler__compiler__TokenKind_not;
  if (is_fixed_size) {
    compiler__Parser_next(p);
    compiler__Parser_gen(p, tos3(" }"));
    if (!compiler__Parser_first_pass(&/* ? */ *p)) {
      if (p->inside_const) {
        compiler__CGen_set_placeholder(p->cgen, new_arr_ph, tos3("{"));
      } else {
        compiler__CGen_set_placeholder(p->cgen, new_arr_ph,
                                       _STR("(%.*s[]) {", typ.len, typ.str));
      };
    };
    return _STR("[%d]%.*s", i, typ.len, typ.str);
  };
  string real = compiler__parse_pointer(typ);
  compiler__Parser_gen_array_init(p, real, no_alloc, new_arr_ph, i);
  typ = _STR("array_%.*s", compiler__stringify_pointer(typ).len,
             compiler__stringify_pointer(typ).str);
  compiler__Parser_register_array(p, typ);
  return typ;
}
string compiler__Parser_get_tmp(compiler__Parser *p) {
  p->tmp_cnt++;
  return _STR("tmp%d", p->tmp_cnt);
}
int compiler__Parser_get_tmp_counter(compiler__Parser *p) {
  p->tmp_cnt++;
  return p->tmp_cnt;
}
void compiler__Parser_assert_statement(compiler__Parser *p) {
  if (compiler__Parser_first_pass(&/* ? */ *p)) {

    return;
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_key_assert);
  ;
  string tmp = compiler__Parser_get_tmp(p);
  compiler__Parser_gen(p, _STR("bool %.*s = ", tmp.len, tmp.str));
  compiler__Parser_check_types(p, compiler__Parser_bool_expression(p),
                               tos3("bool"));
  int nline = p->scanner->line_nr;
  string filename = compiler__cescaped_path(p->file_path);
  string cfname = string_replace(p->cur_fn.name, tos3("main__"), tos3(""));
  string sourceline = string_replace(
      compiler__Scanner_line(*p->scanner, nline - 1), tos3("\""), tos3("\'"));
  if (!p->pref->is_test) {
    compiler__Parser_genln(
        p, _STR(";\n\n/// sline: \"%.*s\"\nif (!%.*s) {\n	"
                "g_test_fails++;\n	eprintln(tos3(\"%.*s:%d: FAILED: "
                "%.*s()\"));\n	eprintln(tos3(\"Source: %.*s\"));\n   "
                "v_panic(tos3(\"An assertion failed.\"));\n   exit(1);\n} else "
                "{\n	g_test_oks++;\n}\n",
                sourceline.len, sourceline.str, tmp.len, tmp.str, filename.len,
                filename.str, p->scanner->line_nr, cfname.len, cfname.str,
                sourceline.len, sourceline.str));

    return;
  };
  compiler__Parser_genln(
      p,
      _STR(";\n\nif (!%.*s) {\n g_test_fails++;\n main__cb_assertion_failed(\n "
           "   tos3(\"%.*s\"),\n    %d,\n    tos3(\"%.*s\"),\n    "
           "tos3(\"%.*s()\")\n );\n exit(1);\n // TODO\n // Maybe print all "
           "vars in a test function if it fails?\n} else {\n g_test_oks++;\n "
           "main__cb_assertion_ok(\n    tos3(\"%.*s\"),\n    %d,\n    "
           "tos3(\"%.*s\"),\n    tos3(\"%.*s()\")\n );\n}\n\n",
           tmp.len, tmp.str, filename.len, filename.str, p->scanner->line_nr,
           sourceline.len, sourceline.str, p->cur_fn.name.len,
           p->cur_fn.name.str, filename.len, filename.str, p->scanner->line_nr,
           sourceline.len, sourceline.str, p->cur_fn.name.len,
           p->cur_fn.name.str));
}
void compiler__Parser_return_st(compiler__Parser *p) {
  compiler__Parser_check(p, compiler__compiler__TokenKind_key_return);
  ;
  string deferred_text = compiler__Parser_get_deferred_text(&/* ? */ *p);
  bool fn_returns = string_ne(p->cur_fn.typ, tos3("void"));
  if (fn_returns) {
    if (p->tok == compiler__compiler__TokenKind_rcbr) {
      compiler__Parser_error(p, _STR("`%.*s` needs to return `%.*s`",
                                     p->cur_fn.name.len, p->cur_fn.name.str,
                                     p->cur_fn.typ.len, p->cur_fn.typ.str));
    };
    int ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
    p->inside_return_expr = 1;
    bool is_none = p->tok == compiler__compiler__TokenKind_key_none;
    p->expected_type = p->cur_fn.typ;
    string expr_type = compiler__Parser_bool_expression(p);
    string expr_type_chk = expr_type;
    array_string types = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    array_string mr_values = new_array_from_c_array(
        1, 1, sizeof(string),
        EMPTY_ARRAY_OF_ELEMS(string, 1){string_trim_space(
            string_substr2(p->cgen->cur_line, ph, -1, true))});
    _PUSH(&types, (/*typ = array_string   tmp_typ=string*/ expr_type), tmp165,
          string);
    while (p->tok == compiler__compiler__TokenKind_comma) {

      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
      _V_MulRet_string_V_string _V_mret_13879_typ_expr =
          compiler__Parser_tmp_expr(p);
      string typ = _V_mret_13879_typ_expr.var_0;
      string expr = _V_mret_13879_typ_expr.var_1;
      _PUSH(&types, (/*typ = array_string   tmp_typ=string*/ typ), tmp166,
            string);
      _PUSH(&mr_values,
            (/*typ = array_string   tmp_typ=string*/ string_trim_space(expr)),
            tmp167, string);
    };
    string cur_fn_typ_chk = p->cur_fn.typ;
    if (types.len > 1) {
      string mr_type = ((string_starts_with(p->cur_fn.typ, tos3("Option_")))
                            ? (string_substr2(p->cur_fn.typ, 7, -1, true))
                            : (p->cur_fn.typ));
      expr_type = mr_type;
      expr_type_chk = array_string_join(types, tos3(","));
      cur_fn_typ_chk = string_replace(
          string_replace(
              string_replace(cur_fn_typ_chk, tos3("_V_MulRet_"), tos3("")),
              tos3("_PTR_"), tos3("*")),
          tos3("_V_"), tos3(","));
      string ret_fields = tos3("");
      array_string tmp170 = mr_values;
      for (int ret_val_idx = 0; ret_val_idx < tmp170.len; ret_val_idx++) {
        string ret_val = ((string *)tmp170.data)[ret_val_idx];

        if (ret_val_idx > 0) {
          ret_fields = string_add(ret_fields, tos3(","));
        };
        ret_fields = string_add(ret_fields, _STR(".var_%d=%.*s", ret_val_idx,
                                                 ret_val.len, ret_val.str));
      };
      compiler__CGen_resetln(p->cgen,
                             _STR("(%.*s){%.*s}", mr_type.len, mr_type.str,
                                  ret_fields.len, ret_fields.str));
    };
    p->inside_return_expr = 0;
    if (string_ends_with(p->cur_fn.typ,
                         compiler__stringify_pointer(expr_type)) &&
        !is_none && string_starts_with(p->cur_fn.typ, tos3("Option_"))) {
      string tmp = compiler__Parser_get_tmp(p);
      string ret = string_substr2(p->cgen->cur_line, ph, -1, true);
      string typ = compiler__parse_pointer(
          string_replace(expr_type, tos3("Option_"), tos3("")));
      compiler__CGen_resetln(
          p->cgen, _STR("%.*s %.*s = OPTION_CAST(%.*s)(%.*s);", expr_type.len,
                        expr_type.str, tmp.len, tmp.str, expr_type.len,
                        expr_type.str, ret.len, ret.str));
      compiler__Parser_genln(p, deferred_text);
      compiler__Parser_gen(p, _STR("return opt_ok(&%.*s, sizeof(%.*s))",
                                   tmp.len, tmp.str, typ.len, typ.str));
    } else {
      string ret = string_substr2(p->cgen->cur_line, ph, -1, true);
      if (string_eq(deferred_text, tos3("")) ||
          string_eq(expr_type, tos3("void*"))) {
        if (string_eq(expr_type,
                      _STR("%.*s*", p->cur_fn.typ.len, p->cur_fn.typ.str))) {
          compiler__CGen_resetln(p->cgen,
                                 _STR("return *%.*s", ret.len, ret.str));
        } else {
          compiler__CGen_resetln(p->cgen,
                                 _STR("return %.*s", ret.len, ret.str));
        };
      } else {
        string tmp = compiler__Parser_get_tmp(p);
        compiler__CGen_resetln(
            p->cgen, _STR("%.*s %.*s = %.*s;\n", expr_type.len, expr_type.str,
                          tmp.len, tmp.str, ret.len, ret.str));
        compiler__Parser_genln(p, deferred_text);
        compiler__Parser_genln(p, _STR("return %.*s;", tmp.len, tmp.str));
      };
    };
    compiler__Parser_check_types(p, expr_type_chk, cur_fn_typ_chk);
  } else {
    if (p->tok == compiler__compiler__TokenKind_name ||
        p->tok == compiler__compiler__TokenKind_number ||
        p->tok == compiler__compiler__TokenKind_string) {
      compiler__Parser_error_with_token_index(
          p,
          _STR("function `%.*s` should not return a value", p->cur_fn.name.len,
               p->cur_fn.name.str),
          p->cur_fn.fn_name_token_idx);
    };
    compiler__Parser_genln(p, deferred_text);
    if (string_eq(p->cur_fn.name, tos3("main"))) {
      compiler__Parser_gen(p, tos3("return 0"));
    } else {
      compiler__Parser_gen(p, tos3("return"));
    };
  };
  p->returns = 1;
}
string compiler__Parser_get_deferred_text(compiler__Parser *p) {
  string deferred_text = tos3("");
  array_string tmp175 = p->cur_fn.defer_text;
  for (int tmp176 = 0; tmp176 < tmp175.len; tmp176++) {
    string text = ((string *)tmp175.data)[tmp176];

    if (string_ne(text, tos3(""))) {
      deferred_text = string_add(text, deferred_text);
    };
  };
  return deferred_text;
}
string compiler__prepend_mod(string mod, string name) {
  return _STR("%.*s__%.*s", mod.len, mod.str, name.len, name.str);
}
string compiler__Parser_prepend_mod(compiler__Parser *p, string name) {
  return compiler__prepend_mod(compiler__mod_gen_name(p->mod), name);
}
void compiler__Parser_go_statement(compiler__Parser *p) {
  compiler__Parser_check(p, compiler__compiler__TokenKind_key_go);
  ;
  int gotoken_idx = compiler__Parser_cur_tok_index(&/* ? */ *p);
  if (compiler__Parser_peek(&/* ? */ *p) == compiler__compiler__TokenKind_dot) {
    string var_name = p->lit;
    Option_compiler__Var tmp177 =
        compiler__Parser_find_var(&/* ? */ *p, var_name);
    compiler__Var v;
    if (!tmp177.ok) {
      string err = tmp177.error;
      int errcode = tmp177.ecode;

      return;
    }
    v = *(compiler__Var *)tmp177.data;
    ;
    compiler__Parser_mark_var_used(p, v);
    gotoken_idx = compiler__Parser_cur_tok_index(&/* ? */ *p);
    compiler__Parser_next(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
    compiler__Type typ = compiler__Table_find_type(&/* ? */ *p->table, v.typ);
    Option_compiler__Fn tmp178 =
        compiler__Table_find_method(&/* ? */ *p->table, &/*114*/ typ, p->lit);
    compiler__Fn method;
    if (!tmp178.ok) {
      string err = tmp178.error;
      int errcode = tmp178.ecode;
      compiler__Parser_error_with_token_index(
          p, _STR("go method missing %.*s", var_name.len, var_name.str),
          gotoken_idx);

      return;
    }
    method = *(compiler__Fn *)tmp178.data;
    ;
    compiler__Parser_async_fn_call(p, method, 0, var_name, v.typ);
  } else {
    string f_name = p->lit;
    Option_compiler__Fn tmp179 = compiler__Table_find_fn(
        &/* ? */ *p->table, compiler__Parser_prepend_mod(&/* ? */ *p, f_name));
    compiler__Fn f;
    if (!tmp179.ok) {
      string err = tmp179.error;
      int errcode = tmp179.ecode;
      println(compiler__Table_debug_fns(&/* ? */ *p->table));
      compiler__Parser_error_with_token_index(
          p, _STR("can not find function %.*s", f_name.len, f_name.str),
          gotoken_idx);

      return;
    }
    f = *(compiler__Fn *)tmp179.data;
    ;
    if (string_eq(f.name, tos3("println")) ||
        string_eq(f.name, tos3("print"))) {
      compiler__Parser_error_with_token_index(
          p, tos3("`go` cannot be used with `println`"), gotoken_idx);
    };
    compiler__Parser_async_fn_call(p, f, 0, tos3(""), tos3(""));
  };
}
string compiler__Parser_js_decode(compiler__Parser *p) {
  compiler__Parser_check(p, compiler__compiler__TokenKind_name);
  compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
  string op = compiler__Parser_check_name(p);
  int op_token_idx = compiler__Parser_cur_tok_index(&/* ? */ *p);
  if (string_eq(op, tos3("decode"))) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
    string typ = compiler__Parser_get_type(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
    _V_MulRet_string_V_string _V_mret_14695_styp_expr =
        compiler__Parser_tmp_expr(p);
    string styp = _V_mret_14695_styp_expr.var_0;
    string expr = _V_mret_14695_styp_expr.var_1;
    compiler__Parser_check_types(p, styp, tos3("string"));
    compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
    string tmp = compiler__Parser_get_tmp(p);
    string cjson_tmp = compiler__Parser_get_tmp(p);
    string decl = _STR("%.*s %.*s; ", typ.len, typ.str, tmp.len, tmp.str);
    compiler__Type tt = compiler__Table_find_type(&/* ? */ *p->table, typ);
    array_compiler__Var tmp180 = tt.fields;
    for (int tmp181 = 0; tmp181 < tmp180.len; tmp181++) {
      compiler__Var field = ((compiler__Var *)tmp180.data)[tmp181];

      string def_val = compiler__type_default(field.typ);
      if (string_ne(def_val, tos3(""))) {
        decl = string_add(decl, _STR("%.*s.%.*s = OPTION_CAST(%.*s) %.*s;\n",
                                     tmp.len, tmp.str, field.name.len,
                                     field.name.str, field.typ.len,
                                     field.typ.str, def_val.len, def_val.str));
      };
    };
    compiler__Parser_gen_json_for_type(p, tt);
    decl = string_add(decl,
                      _STR("cJSON* %.*s = json__json_parse(%.*s);",
                           cjson_tmp.len, cjson_tmp.str, expr.len, expr.str));
    compiler__CGen_insert_before(p->cgen, decl);
    compiler__Parser_gen(
        p, _STR("json__jsdecode_%.*s(%.*s, &%.*s); cJSON_Delete(%.*s);",
                typ.len, typ.str, cjson_tmp.len, cjson_tmp.str, tmp.len,
                tmp.str, cjson_tmp.len, cjson_tmp.str));
    string opt_type = _STR("Option_%.*s", typ.len, typ.str);
    _PUSH(&p->cgen->typedefs,
          (/*typ = array_string   tmp_typ=string*/ _STR(
              "typedef Option %.*s;", opt_type.len, opt_type.str)),
          tmp182, string);
    compiler__Table_register_builtin(p->table, opt_type);
    return opt_type;
  } else if (string_eq(op, tos3("encode"))) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
    _V_MulRet_string_V_string _V_mret_14875_typ_expr =
        compiler__Parser_tmp_expr(p);
    string typ = _V_mret_14875_typ_expr.var_0;
    string expr = _V_mret_14875_typ_expr.var_1;
    compiler__Type tt = compiler__Table_find_type(&/* ? */ *p->table, typ);
    compiler__Parser_gen_json_for_type(p, tt);
    compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
    compiler__Parser_gen(p, _STR("json__json_print(json__jsencode_%.*s(%.*s))",
                                 typ.len, typ.str, expr.len, expr.str));
    return tos3("string");
  } else {
    compiler__Parser_error_with_token_index(
        p, _STR("bad json op \"%.*s\"", op.len, op.str), op_token_idx);
  };
  return tos3("");
}
void compiler__Parser_attribute(compiler__Parser *p) {
  compiler__Parser_check(p, compiler__compiler__TokenKind_lsbr);
  if (p->tok == compiler__compiler__TokenKind_key_if) {
    compiler__Parser_next(p);
    ;
    p->attr = string_add(tos3("if "), compiler__Parser_check_name(p));
  } else {
    p->attr = compiler__Parser_check_name(p);
  };
  int attr_token_idx = compiler__Parser_cur_tok_index(&/* ? */ *p);
  if (p->tok == compiler__compiler__TokenKind_colon) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_colon);
    p->attr = string_add(string_add(p->attr, tos3(":")),
                         compiler__Parser_check_name(p));
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_rsbr);
  ;
  bool is_pub = p->tok == compiler__compiler__TokenKind_key_pub;
  compiler__TokenKind peek = compiler__Parser_peek(&/* ? */ *p);
  if (p->tok == compiler__compiler__TokenKind_key_fn ||
      (is_pub && peek == compiler__compiler__TokenKind_key_fn)) {
    compiler__Parser_fn_decl(p);
    p->attr = tos3("");

    return;
  } else if (p->tok == compiler__compiler__TokenKind_key_struct ||
             (is_pub && peek == compiler__compiler__TokenKind_key_struct)) {
    compiler__Parser_struct_decl(
        p, new_array_from_c_array(0, 0, sizeof(string),
                                  EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)}));
    p->attr = tos3("");

    return;
  } else if (p->tok == compiler__compiler__TokenKind_key_enum ||
             (is_pub && peek == compiler__compiler__TokenKind_key_enum)) {
    compiler__Parser_enum_decl(p, 0);
    p->attr = tos3("");

    return;
  };
  compiler__Parser_error_with_token_index(p, tos3("bad attribute usage"),
                                          attr_token_idx);
}
void compiler__Parser_defer_st(compiler__Parser *p) {
  compiler__Parser_check(p, compiler__compiler__TokenKind_key_defer);
  ;
  compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
  int pos = p->cgen->lines.len;
  compiler__Parser_genln(p, tos3("{"));
  compiler__Parser_statements(p);
  *(string *)array_last(p->cur_fn.defer_text) =
      string_add(array_string_join(array_slice2(p->cgen->lines, pos, -1, true),
                                   tos3("\n")),
                 *(string *)array_last(p->cur_fn.defer_text));
  p->cgen->lines = array_slice2(p->cgen->lines, 0, pos, false);
  compiler__CGen_resetln(p->cgen, tos3(""));
}
void compiler__Parser_check_and_register_used_imported_type(compiler__Parser *p,
                                                            string typ_name) {
  Option_int tmp187 = string_index(typ_name, tos3("__"));
  int us_idx;
  if (!tmp187.ok) {
    string err = tmp187.error;
    int errcode = tmp187.ecode;

    return;
  }
  us_idx = *(int *)tmp187.data;
  ;
  string arg_mod = string_substr2(typ_name, 0, us_idx, false);
  if (string_contains(arg_mod, tos3("_dot_"))) {
    arg_mod = string_all_after(arg_mod, tos3("_dot_"));
  };
  if (compiler__ImportTable_known_alias(&/* ? */ p->import_table, arg_mod)) {
    compiler__ImportTable_register_used_import(&/* ? */ p->import_table,
                                               arg_mod);
  };
}
void compiler__Parser_check_unused_imports(compiler__Parser *p) {
  if (p->is_vgen) {

    return;
  };
  string output = tos3("");
  map_string tmp190 = p->import_table.imports;
  array_string keys_tmp190 = map_keys(&tmp190);
  for (int l = 0; l < keys_tmp190.len; l++) {
    string alias = ((string *)keys_tmp190.data)[l];
    string mod = tos3("");
    map_get(tmp190, alias, &mod);

    if (!compiler__ImportTable_is_used_import(&/* ? */ p->import_table,
                                              alias)) {
      string mod_alias =
          ((string_eq(alias, mod))
               ? (alias)
               : (_STR("%.*s (%.*s)", alias.len, alias.str, mod.len, mod.str)));
      output =
          string_add(output, _STR("\n * %.*s", mod_alias.len, mod_alias.str));
    };
  };
  if (string_eq(output, tos3(""))) {

    return;
  };
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          p->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
    eprintln(_STR("Used imports table: %.*s",
                  array_string_str(p->import_table.used_imports).len,
                  array_string_str(p->import_table.used_imports).str));
  };
  compiler__Parser_warn(p, _STR("the following imports were never used: %.*s",
                                output.len, output.str));
}
_V_MulRet_bool_V_string compiler__Parser_is_expr_fn_call(compiler__Parser *p,
                                                         int start_tok_idx) {
  string expr = compiler__Token_str(
      (*(compiler__Token *)array_get(p->tokens, start_tok_idx - 1)));
  bool is_fn_call =
      (*(compiler__Token *)array_get(p->tokens, start_tok_idx)).tok ==
      compiler__compiler__TokenKind_lpar;
  if (!is_fn_call) {
    int i = start_tok_idx;
    while (((*(compiler__Token *)array_get(p->tokens, i)).tok ==
                compiler__compiler__TokenKind_dot ||
            (*(compiler__Token *)array_get(p->tokens, i)).tok ==
                compiler__compiler__TokenKind_name) &&
           string_ne((*(compiler__Token *)array_get(p->tokens, i)).lit,
                     tos3("_")) &&
           i < p->tokens.len) {

      expr = string_add(
          expr,
          compiler__Token_str((*(compiler__Token *)array_get(p->tokens, i))));
      i++;
    };
    is_fn_call = (*(compiler__Token *)array_get(p->tokens, i)).tok ==
                 compiler__compiler__TokenKind_lpar;
  };
  return (_V_MulRet_bool_V_string){.var_0 = is_fn_call, .var_1 = expr};
}
static inline void compiler__Parser_skip_block(compiler__Parser *p,
                                               bool inside_first_lcbr) {
  int cbr_depth = ((inside_first_lcbr) ? (1) : (0));
  while (1) {
    if (p->tok == compiler__compiler__TokenKind_lcbr) {
      cbr_depth++;
    };
    if (p->tok == compiler__compiler__TokenKind_rcbr) {
      cbr_depth--;
      if (cbr_depth == 0) {
        break;
      };
    };
    compiler__Parser_next(p);
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
}
void compiler__todo_remove() {}
void compiler__Parser_check_if_parser_is_stuck(compiler__Parser *p,
                                               u64 parsing_cycle,
                                               i64 parsing_start_ticks) {
  compiler__Parser_warn(p, tos3("todo..."));
}
void compiler__Parser_inline_asm(compiler__Parser *p) {
  if (!p->inside_unsafe) {
    compiler__Parser_error(p, tos3("asm() needs to be run inside `unsafe {}`"));
  };
  compiler__Parser_next(p);
  compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
  string s = compiler__Parser_check_string(p);
  compiler__Parser_genln(p, _STR("asm(\"%.*s\"", s.len, s.str));
  while (p->tok == compiler__compiler__TokenKind_string) {

    compiler__Parser_genln(p, _STR("\"%.*s\"", p->lit.len, p->lit.str));
    compiler__Parser_next(p);
  };
  while (p->tok == compiler__compiler__TokenKind_colon) {

    compiler__Parser_next(p);
    string arg = compiler__Parser_check_string(p);
    compiler__Parser_gen(p, _STR(": \"%.*s\"", arg.len, arg.str));
    if (p->tok == compiler__compiler__TokenKind_lpar) {
      compiler__Parser_next(p);
      string var_name = compiler__Parser_check_name(p);
      if (!compiler__Parser_known_var(&/* ? */ *p, var_name)) {
        compiler__Parser_error(
            p, _STR("unknown variable `%.*s`", var_name.len, var_name.str));
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
      compiler__Parser_genln(p, _STR("(%.*s)", var_name.len, var_name.str));
    };
  };
  compiler__Parser_genln(p, tos3(");"));
  compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
}
void compiler__todo() {}
bool compiler__V_no_cc_installed(compiler__V *v) {
#ifdef _WIN32
  Option_os__Result tmp1 =
      os__exec(_STR("%.*s -v", v->pref->ccompiler.len, v->pref->ccompiler.str));
  if (!tmp1.ok) {
    string err = tmp1.error;
    int errcode = tmp1.ecode;
    if (v_dot_pref__VerboseLevel_is_higher_or_equal(
            v->pref->verbosity,
            v_dot_pref__v_dot_pref__VerboseLevel_level_one)) {
      println(tos3("C compiler not found, trying to build with msvc..."));
    };
    return 1;
  };
#endif
  ;
  return 0;
}
void compiler__V_cc(compiler__V *v) {
  if (string_contains(os__executable(), tos3("vfmt"))) {

    return;
  };
  compiler__V_build_thirdparty_obj_files(&/* ? */ *v);
  string vexe = v_dot_pref__vexe_path();
  string vdir = os__dir(vexe);
  bool ends_with_c = string_ends_with(v->pref->out_name, tos3(".c"));
  bool ends_with_js = string_ends_with(v->pref->out_name, tos3(".js"));
  if (v->pref->is_pretty_c && !ends_with_js) {
    Option_os__Result tmp2 =
        os__exec(_STR("clang-format -i -style=file \"%.*s\"", v->out_name_c.len,
                      v->out_name_c.str));
    os__Result format_result;
    if (!tmp2.ok) {
      string err = tmp2.error;
      int errcode = tmp2.ecode;
      eprintln(tos3("clang-format not found"));
    }
    if (tmp2.ok) {
      format_result = *(os__Result *)tmp2.data;
    } else {
      format_result = (os__Result){.exit_code = -1, .output = tos3("")};
    };
    if (format_result.exit_code > 0) {
      eprintln(_STR("clang-format failed to format %.*s", v->out_name_c.len,
                    v->out_name_c.str));
      eprintln(format_result.output);
    };
  };
  if (ends_with_c || ends_with_js) {
#ifndef _VJS
    if (ends_with_js) {
      string vjs_path = string_add(vexe, tos3("js"));
      if (!os__exists(vjs_path)) {
        println(tos3("V.js compiler not found, building..."));
        int ret = os__system(_STR("%.*s -o %.*s -os js %.*s/cmd/v", vexe.len,
                                  vexe.str, vjs_path.len, vjs_path.str,
                                  vdir.len, vdir.str));
        if (ret == 0) {
          println(tos3("Done."));
        } else {
          println(tos3("Failed."));
          v_exit(1);
        };
      };
      int ret = os__system(_STR("%.*s -o %.*s %.*s", vjs_path.len, vjs_path.str,
                                v->pref->out_name.len, v->pref->out_name.str,
                                v->pref->path.len, v->pref->path.str));
      if (ret == 0) {
        printf("Done. Run it with `node %.*s`\n", v->pref->out_name.len,
               v->pref->out_name.str);
        println(tos3("JS backend is at a very early stage."));
      };
    };
#endif
    ;
    Option_bool tmp3 = os__mv_by_cp(v->out_name_c, v->pref->out_name);
    if (!tmp3.ok) {
      string err = tmp3.error;
      int errcode = tmp3.ecode;
      v_panic(err);
    };
    v_exit(0);
  };
  if (v->pref->os == v_dot_pref__v_dot_pref__OS_windows) {
#ifndef _WIN32
#endif
    ;
  };
#ifdef _WIN32
  if (string_eq(v->pref->ccompiler, tos3("msvc")) ||
      compiler__V_no_cc_installed(&/* ? */ *v)) {
    compiler__V_cc_msvc(v);

    return;
  };
#endif
  ;
  array_string a = new_array_from_c_array(
      10, 10, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 10){
          v->pref->cflags, tos3("-std=gnu11"), tos3("-Wall"), tos3("-Wextra"),
          tos3("-Wno-unused-variable"), tos3("-Wno-unused-parameter"),
          tos3("-Wno-unused-result"), tos3("-Wno-unused-function"),
          tos3("-Wno-missing-braces"), tos3("-Wno-unused-label")});
  if (v->pref->fast) {
#ifdef __linux__
#else
    compiler__verror(tos3("-fast is only supported on Linux right now"));
#endif
    ;
  };
  if (!v->pref->is_so &&
      v->pref->build_mode != v_dot_pref__v_dot_pref__BuildMode_build_module &&
      string_eq(os__user_os(), tos3("windows")) &&
      !string_ends_with(v->pref->out_name, tos3(".exe"))) {
    v->pref->out_name = string_add(v->pref->out_name, tos3(".exe"));
  };
  compiler__V_log(&/* ? */ *v,
                  _STR("cc() isprod=%d outname=%.*s", v->pref->is_prod,
                       v->pref->out_name.len, v->pref->out_name.str));
  if (v->pref->is_so) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("-shared -fPIC ")),
          tmp4, string);
    v->pref->out_name = string_add(v->pref->out_name, tos3(".so"));
  };
  if (v->pref->is_bare) {
    _PUSH(&a,
          (/*typ = array_string   tmp_typ=string*/ tos3(
              "-fno-stack-protector -static -ffreestanding -nostdlib")),
          tmp5, string);
  };
  if (v->pref->build_mode == v_dot_pref__v_dot_pref__BuildMode_build_module) {
    string out_dir =
        ((string_starts_with(v->pref->path, tos3("vlib")))
             ? (_STR("%.*s%.*scache%.*s%.*s", compiler__v_modules_path.len,
                     compiler__v_modules_path.str, os__path_separator.len,
                     os__path_separator.str, os__path_separator.len,
                     os__path_separator.str, v->pref->path.len,
                     v->pref->path.str))
             : (_STR("%.*s%.*s%.*s", compiler__v_modules_path.len,
                     compiler__v_modules_path.str, os__path_separator.len,
                     os__path_separator.str, v->pref->path.len,
                     v->pref->path.str)));
    string pdir = string_all_before_last(out_dir, os__path_separator);
    if (!os__is_dir(pdir)) {
      os__mkdir_all(pdir);
    };
    v->pref->out_name = _STR("%.*s.o", out_dir.len, out_dir.str);
    printf("Building %.*s...\n", v->pref->out_name.len, v->pref->out_name.str);
  };
  bool debug_mode = v->pref->is_debug;
  string debug_options = tos3("-g");
  string optimization_options = tos3("-O2");
  string guessed_compiler = v->pref->ccompiler;
  if (string_eq(guessed_compiler, tos3("cc")) && v->pref->is_prod) {
    Option_os__Result tmp6 = os__exec(tos3("cc --version"));

    if (tmp6.ok) {
      os__Result ccversion = *(os__Result *)tmp6.data;
      if (ccversion.exit_code == 0) {
        if (string_contains(ccversion.output, tos3("This is free software;")) &&
            string_contains(ccversion.output,
                            tos3("Free Software Foundation, Inc."))) {
          guessed_compiler = tos3("gcc");
        };
        if (string_contains(ccversion.output, tos3("clang version "))) {
          guessed_compiler = tos3("clang");
        };
      };
    };
  };
  if (string_contains(v->pref->ccompiler, tos3("clang")) ||
      string_eq(guessed_compiler, tos3("clang"))) {
    if (debug_mode) {
      debug_options = tos3("-g -O0 -no-pie");
    };
    optimization_options = tos3("-O3");
    bool have_flto = 1;
#ifdef __OpenBSD__
#endif
    ;
    if (have_flto) {
      optimization_options = string_add(optimization_options, tos3(" -flto"));
    };
  };
  if (string_contains(v->pref->ccompiler, tos3("gcc")) ||
      string_eq(guessed_compiler, tos3("gcc"))) {
    if (debug_mode) {
      debug_options = tos3("-g3 -no-pie");
    };
    optimization_options = tos3("-O3 -fno-strict-aliasing -flto");
  };
  if (debug_mode) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ debug_options), tmp7,
          string);
#ifdef __APPLE__
#endif
    ;
  };
  if (v->pref->is_prod) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ optimization_options),
          tmp8, string);
  };
  if (debug_mode && string_ne(os__user_os(), tos3("windows"))) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3(" -rdynamic ")),
          tmp9, string);
  };
  if (string_ne(v->pref->ccompiler, tos3("msvc")) &&
      v->pref->os != v_dot_pref__v_dot_pref__OS_freebsd) {
    _PUSH(&a,
          (/*typ = array_string   tmp_typ=string*/ tos3(
              "-Werror=implicit-function-declaration")),
          tmp10, string);
  };
  array_string tmp11 =
      compiler__V_generate_hotcode_reloading_compiler_flags(&/* ? */ *v);
  for (int tmp12 = 0; tmp12 < tmp11.len; tmp12++) {
    string f = ((string *)tmp11.data)[tmp12];

    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ f), tmp13, string);
  };
  string libs = tos3("");
  if (v->pref->build_mode == v_dot_pref__v_dot_pref__BuildMode_build_module) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("-c")), tmp14,
          string);
  } else if (v->pref->is_cache) {
    string builtin_o_path =
        os__join_path(compiler__v_modules_path,
                      &(varg_string){.len = 3,
                                     .args = {tos3("cache"), tos3("vlib"),
                                              tos3("builtin.o")}});
    _PUSH(&a,
          (/*typ = array_string   tmp_typ=string*/ string_replace(
              builtin_o_path, tos3("builtin.o"), tos3("strconv.o"))),
          tmp15, string);
    if (os__exists(builtin_o_path)) {
      libs = builtin_o_path;
    } else {
      printf("%.*s not found... building module builtin\n", builtin_o_path.len,
             builtin_o_path.str);
      os__system(_STR("%.*s build module vlib%.*sbuiltin", vexe.len, vexe.str,
                      os__path_separator.len, os__path_separator.str));
    };
    array_string tmp16 = v->table->imports;
    for (int tmp17 = 0; tmp17 < tmp16.len; tmp17++) {
      string imp = ((string *)tmp16.data)[tmp17];

      if (string_contains(imp, tos3("vweb"))) {
        continue;
      };
      if (string_eq(imp, tos3("webview"))) {
        continue;
      };
      string imp_path = string_replace(imp, tos3("."), os__path_separator);
      string path =
          _STR("%.*s%.*scache%.*svlib%.*s%.*s.o", compiler__v_modules_path.len,
               compiler__v_modules_path.str, os__path_separator.len,
               os__path_separator.str, os__path_separator.len,
               os__path_separator.str, os__path_separator.len,
               os__path_separator.str, imp_path.len, imp_path.str);
      if (os__exists(path)) {
        libs = string_add(libs, string_add(tos3(" "), path));
      } else {
        printf("%.*s not found... building module %.*s\n", path.len, path.str,
               imp.len, imp.str);
        if (string_ends_with(path, tos3("vlib/ui.o"))) {
          println(tos3("copying ui..."));
          Option_bool tmp18 =
              os__cp(_STR("%.*s/thirdparty/ui/ui.o", vdir.len, vdir.str), path);
          if (!tmp18.ok) {
            string err = tmp18.error;
            int errcode = tmp18.ecode;
            v_panic(tos3("error copying ui files"));
          };
          Option_bool tmp19 =
              os__cp(_STR("%.*s/thirdparty/ui/ui.vh", vdir.len, vdir.str),
                     string_add(compiler__v_modules_path, tos3("/vlib/ui.vh")));
          if (!tmp19.ok) {
            string err = tmp19.error;
            int errcode = tmp19.ecode;
            v_panic(tos3("error copying ui files"));
          };
        } else {
          os__system(_STR("%.*s build module vlib%.*s%.*s", vexe.len, vexe.str,
                          os__path_separator.len, os__path_separator.str,
                          imp_path.len, imp_path.str));
        };
      };
      if (string_ends_with(path, tos3("vlib/ui.o"))) {
        _PUSH(&a,
              (/*typ = array_string   tmp_typ=string*/ tos3(
                  "-framework Cocoa -framework Carbon")),
              tmp20, string);
      };
    };
  };
  if (v->pref->sanitize) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("-fsanitize=leak")),
          tmp21, string);
  };
  _PUSH(&a,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "-o \"%.*s\"", v->pref->out_name.len, v->pref->out_name.str)),
        tmp22, string);
  if (os__is_dir(v->pref->out_name)) {
    compiler__verror(_STR("\'%.*s\' is a directory", v->pref->out_name.len,
                          v->pref->out_name.str));
  };
  if (v->pref->os == v_dot_pref__v_dot_pref__OS_mac) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("-x objective-c")),
          tmp23, string);
  };
  _PUSH(&a,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "\"%.*s\"", v->out_name_c.len, v->out_name_c.str)),
        tmp24, string);
  if (v->pref->os == v_dot_pref__v_dot_pref__OS_mac) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("-x none")), tmp25,
          string);
  };
  if (v->pref->os == v_dot_pref__v_dot_pref__OS_mac) {
    _PUSH(&a,
          (/*typ = array_string   tmp_typ=string*/ tos3(
              "-mmacosx-version-min=10.7")),
          tmp26, string);
  };
  if (v->pref->os == v_dot_pref__v_dot_pref__OS_windows) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("-municode")),
          tmp27, string);
  };
  array_compiler__CFlag cflags = compiler__V_get_os_cflags(&/* ? */ *v);
  _PUSH(&a,
        (/*typ = array_string   tmp_typ=string*/
         array_compiler__CFlag_c_options_only_object_files(cflags)),
        tmp28, string);
  _PUSH(&a,
        (/*typ = array_string   tmp_typ=string*/
         array_compiler__CFlag_c_options_without_object_files(cflags)),
        tmp29, string);
  _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ libs), tmp30, string);
  if (!v->pref->is_bare &&
      v->pref->build_mode != v_dot_pref__v_dot_pref__BuildMode_build_module &&
      (v->pref->os == v_dot_pref__v_dot_pref__OS_linux ||
       v->pref->os == v_dot_pref__v_dot_pref__OS_freebsd ||
       v->pref->os == v_dot_pref__v_dot_pref__OS_openbsd ||
       v->pref->os == v_dot_pref__v_dot_pref__OS_netbsd ||
       v->pref->os == v_dot_pref__v_dot_pref__OS_dragonfly ||
       v->pref->os == v_dot_pref__v_dot_pref__OS_solaris ||
       v->pref->os == v_dot_pref__v_dot_pref__OS_haiku)) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("-lm -lpthread ")),
          tmp31, string);
    if (v->pref->os == v_dot_pref__v_dot_pref__OS_linux) {
      _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3(" -ldl ")), tmp32,
            string);
    };
    if (v->pref->os == v_dot_pref__v_dot_pref__OS_freebsd) {
      _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3(" -lexecinfo ")),
            tmp33, string);
    };
  };
  if (!v->pref->is_bare && v->pref->os == v_dot_pref__v_dot_pref__OS_js &&
      string_eq(os__user_os(), tos3("linux"))) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("-lm")), tmp34,
          string);
  };
  string args = array_string_join(a, tos3(" "));
start:;
  compiler__todo();
  string cmd = _STR("%.*s %.*s", v->pref->ccompiler.len, v->pref->ccompiler.str,
                    args.len, args.str);
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_one)) {
    println(tos3("\n=========="));
    println(cmd);
  };
  i64 ticks = time__ticks();
  Option_os__Result tmp35 = os__exec(cmd);
  os__Result res;
  if (!tmp35.ok) {
    string err = tmp35.error;
    int errcode = tmp35.ecode;
    println(tos3("C compilation failed."));
    compiler__verror(err);

    return;
  }
  res = *(os__Result *)tmp35.data;
  ;
  if (res.exit_code != 0) {
    if (res.exit_code == 127) {
#ifdef __linux__
#endif
      ;
      compiler__verror(string_add(
          string_add(
              string_add(
                  string_add(
                      string_add(
                          string_add(tos3("C compiler error, while attempting "
                                          "to run: \n"),
                                     tos3("------------------------------------"
                                          "-----------------------\n")),
                          _STR("%.*s\n", cmd.len, cmd.str)),
                      tos3("---------------------------------------------------"
                           "--------\n")),
                  tos3("Probably your C compiler is missing. \n")),
              tos3("Please reinstall it, or make it available in your "
                   "PATH.\n\n")),
          compiler__missing_compiler_info()));
    };
    if (v->pref->is_debug) {
      string eword = tos3("error:");
      string khighlight =
          ((term__can_show_color_on_stdout()) ? (term__red(eword)) : (eword));
      println(string_replace(res.output, eword, khighlight));
      compiler__verror(_STR(
          "\n==================\nC error. This should never happen.\n\nV "
          "compiler version: V %.*s %.*s\nHost OS: %.*s\nTarget OS: %.*s\n\nIf "
          "you were not working with C interop and are not sure about what's "
          "happening,\nplease put the whole output in a pastebin and contact "
          "us through the following ways with a link to the pastebin:\n- Raise "
          "an issue on GitHub: https://github.com/vlang/v/issues/new/choose\n- "
          "Ask a question in #help on Discord: https://discord.gg/vlang",
          compiler__Version.len, compiler__Version.str, compiler__vhash().len,
          compiler__vhash().str,
          v_dot_pref__OS_str(v_dot_pref__get_host_os()).len,
          v_dot_pref__OS_str(v_dot_pref__get_host_os()).str,
          v_dot_pref__OS_str(v->pref->os).len,
          v_dot_pref__OS_str(v->pref->os).str));
    } else {
      if (res.output.len < 30) {
        println(res.output);
      } else {
        array_string elines =
            compiler__error_context_lines(res.output, tos3("error:"), 1, 12);
        println(tos3("=================="));
        array_string tmp36 = elines;
        for (int tmp37 = 0; tmp37 < tmp36.len; tmp37++) {
          string eline = ((string *)tmp36.data)[tmp37];

          println(eline);
        };
        println(tos3("..."));
        println(tos3("=================="));
        println(tos3("(Use `v -cg` to print the entire error message)\n"));
      };
      compiler__verror(tos3(
          "C error.\n\nPlease make sure that:\n- You have all V dependencies "
          "installed.\n- You did not declare a C function that was not "
          "included. (Try commenting your code that involves C interop)\n- You "
          "are running the latest version of V. (Try running `v up` and "
          "rerunning your command)\n\nIf you're confident that all of the "
          "above is true, please try running V with the `-cg` option which "
          "enables more debugging capabilities.\n"));
    };
  };
  i64 diff = time__ticks() - ticks;
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_one)) {
    printf("%.*s took %lld ms\n", v->pref->ccompiler.len,
           v->pref->ccompiler.str, diff);
    println(tos3("=========\n"));
  };
  if (!v->pref->is_keep_c && string_ne(v->out_name_c, tos3("v.c"))) {
    os__rm(v->out_name_c);
  };
  if (v->pref->compress) {
#ifdef _WIN32
    println(tos3("-compress does not work on Windows for now"));

    return;
#endif
    ;
    int ret = os__system(
        _STR("strip %.*s", v->pref->out_name.len, v->pref->out_name.str));
    if (ret != 0) {
      println(tos3("strip failed"));

      return;
    };
    int ret2 = os__system(_STR("upx --lzma -qqq %.*s", v->pref->out_name.len,
                               v->pref->out_name.str));
    if (ret2 != 0) {
      ret2 = os__system(
          _STR("upx -qqq %.*s", v->pref->out_name.len, v->pref->out_name.str));
    };
    if (ret2 != 0) {
      println(tos3("upx failed"));
#ifdef __APPLE__
#endif
      ;
#ifdef __linux__
#endif
      ;
#ifdef _WIN32
#endif
      ;
    };
  };
}
void compiler__V_cc_windows_cross(compiler__V *c) {
  println(tos3("Cross compiling for Windows..."));
  if (!string_ends_with(c->pref->out_name, tos3(".exe"))) {
    c->pref->out_name = string_add(c->pref->out_name, tos3(".exe"));
  };
  string args =
      _STR("-o %.*s -w -L. ", c->pref->out_name.len, c->pref->out_name.str);
  array_compiler__CFlag cflags = compiler__V_get_os_cflags(&/* ? */ *c);
  args = string_add(
      args, ((string_eq(c->pref->ccompiler, tos3("msvc")))
                 ? (array_compiler__CFlag_c_options_before_target_msvc(cflags))
                 : (array_compiler__CFlag_c_options_before_target(cflags))));
  string libs = tos3("");
  if (0 &&
      c->pref->build_mode == v_dot_pref__v_dot_pref__BuildMode_default_mode) {
    libs = _STR("\"%.*s/vlib/builtin.o\"", compiler__v_modules_path.len,
                compiler__v_modules_path.str);
    if (!os__exists(libs)) {
      printf("`%.*s` not found\n", libs.len, libs.str);
      v_exit(1);
    };
    array_string tmp38 = c->table->imports;
    for (int tmp39 = 0; tmp39 < tmp38.len; tmp39++) {
      string imp = ((string *)tmp38.data)[tmp39];

      libs = string_add(
          libs, _STR(" \"%.*s/vlib/%.*s.o\"", compiler__v_modules_path.len,
                     compiler__v_modules_path.str, imp.len, imp.str));
    };
  };
  args = string_add(args, _STR(" %.*s ", c->out_name_c.len, c->out_name_c.str));
  args = string_add(
      args, ((string_eq(c->pref->ccompiler, tos3("msvc")))
                 ? (array_compiler__CFlag_c_options_after_target_msvc(cflags))
                 : (array_compiler__CFlag_c_options_after_target(cflags))));
  string cmd = tos3("");
  cmd = tos3("");
#ifdef __APPLE__
#else
  v_panic(tos3("your platform is not supported yet"));
#endif
  ;
  println(cmd);
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          c->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_one)) {
    println(cmd);
  };
  if (os__system(cmd) != 0) {
    println(tos3("Cross compilation for Windows failed. Make sure you have "
                 "clang installed."));
    v_exit(1);
  };
  println(tos3("Done!"));
}
void compiler__V_build_thirdparty_obj_files(compiler__V *c) {
  array_compiler__CFlag tmp40 = compiler__V_get_os_cflags(&/* ? */ *c);
  for (int tmp41 = 0; tmp41 < tmp40.len; tmp41++) {
    compiler__CFlag flag = ((compiler__CFlag *)tmp40.data)[tmp41];

    if (string_ends_with(flag.value, tos3(".o"))) {
      array_compiler__CFlag rest_of_module_flags =
          compiler__V_get_rest_of_module_cflags(&/* ? */ *c, &/*114*/ flag);
      if (string_eq(c->pref->ccompiler, tos3("msvc")) ||
          compiler__V_no_cc_installed(&/* ? */ *c)) {
        compiler__build_thirdparty_obj_file_with_msvc(flag.value,
                                                      rest_of_module_flags);
      } else {
        compiler__V_build_thirdparty_obj_file(&/* ? */ *c, flag.value,
                                              rest_of_module_flags);
      };
    };
  };
}
string compiler__missing_compiler_info() {
#ifdef _WIN32
  return tos3(
      "https://github.com/vlang/v/wiki/Installing-a-C-compiler-on-Windows");
#endif
  ;
#ifdef __linux__
#endif
  ;
#ifdef __APPLE__
#endif
  ;
  return tos3("");
}
array_string compiler__error_context_lines(string text, string keyword,
                                           int before, int after) {
  string khighlight =
      ((term__can_show_color_on_stdout()) ? (term__red(keyword)) : (keyword));
  int eline_idx = 0;
  array_string lines = string_split_into_lines(text);
  array_string tmp42 = lines;
  for (int idx = 0; idx < tmp42.len; idx++) {
    string eline = ((string *)tmp42.data)[idx];

    if (string_contains(eline, keyword)) {
      array_set(&/*q*/ lines, idx,
                &(string[]){string_replace((*(string *)array_get(lines, idx)),
                                           keyword, khighlight)});
      if (eline_idx == 0) {
        eline_idx = idx;
      };
    };
  };
  int idx_s = ((eline_idx - before >= 0) ? (eline_idx - before) : (0));
  int idx_e = ((idx_s + after < lines.len) ? (idx_s + after) : (lines.len));
  return array_slice2(lines, idx_s, idx_e, false);
}
string compiler__CFlag_str(compiler__CFlag *c) {
  return _STR(
      "CFlag{ name: \"%.*s\" value: \"%.*s\" mod: \"%.*s\" os: \"%.*s\" }",
      c->name.len, c->name.str, c->value.len, c->value.str, c->mod.len,
      c->mod.str, c->os.len, c->os.str);
}
array_compiler__CFlag compiler__V_get_os_cflags(compiler__V *v) {
  array_compiler__CFlag flags = new_array_from_c_array(
      0, 0, sizeof(compiler__CFlag),
      EMPTY_ARRAY_OF_ELEMS(compiler__CFlag, 0){TCCSKIP(0)});
  array_string ctimedefines = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  if (v->pref->compile_defines.len > 0) {
    _PUSH_MANY(
        &ctimedefines,
        (/*typ = array_string   tmp_typ=string*/ v->pref->compile_defines),
        tmp1, array_string);
  };
  array_compiler__CFlag tmp2 = v->table->cflags;
  for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
    compiler__CFlag flag = ((compiler__CFlag *)tmp2.data)[tmp3];

    if (string_eq(flag.os, tos3("")) ||
        (string_eq(flag.os, tos3("linux")) &&
         v->pref->os == v_dot_pref__v_dot_pref__OS_linux) ||
        (string_eq(flag.os, tos3("darwin")) &&
         v->pref->os == v_dot_pref__v_dot_pref__OS_mac) ||
        (string_eq(flag.os, tos3("freebsd")) &&
         v->pref->os == v_dot_pref__v_dot_pref__OS_freebsd) ||
        (string_eq(flag.os, tos3("windows")) &&
         v->pref->os == v_dot_pref__v_dot_pref__OS_windows) ||
        (string_eq(flag.os, tos3("mingw")) &&
         v->pref->os == v_dot_pref__v_dot_pref__OS_windows &&
         string_ne(v->pref->ccompiler, tos3("msvc")))) {
      _PUSH(&flags,
            (/*typ = array_compiler__CFlag   tmp_typ=compiler__CFlag*/ flag),
            tmp4, compiler__CFlag);
    };
    if ((_IN(string, (flag.os), ctimedefines))) {
      _PUSH(&flags,
            (/*typ = array_compiler__CFlag   tmp_typ=compiler__CFlag*/ flag),
            tmp5, compiler__CFlag);
    };
  };
  return flags;
}
array_compiler__CFlag
compiler__V_get_rest_of_module_cflags(compiler__V *v, compiler__CFlag *c) {
  array_compiler__CFlag flags = new_array_from_c_array(
      0, 0, sizeof(compiler__CFlag),
      EMPTY_ARRAY_OF_ELEMS(compiler__CFlag, 0){TCCSKIP(0)});
  array_compiler__CFlag cflags = compiler__V_get_os_cflags(&/* ? */ *v);
  array_compiler__CFlag tmp6 = cflags;
  for (int tmp7 = 0; tmp7 < tmp6.len; tmp7++) {
    compiler__CFlag flag = ((compiler__CFlag *)tmp6.data)[tmp7];

    if (string_eq(c->mod, flag.mod)) {
      if (string_eq(c->name, flag.name) && string_eq(c->value, flag.value) &&
          string_eq(c->os, flag.os)) {
        continue;
      };
      _PUSH(&flags,
            (/*typ = array_compiler__CFlag   tmp_typ=compiler__CFlag*/ flag),
            tmp8, compiler__CFlag);
    };
  };
  return flags;
}
string compiler__CFlag_format(compiler__CFlag *cf) {
  string value = cf->value;
  if ((string_eq(cf->name, tos3("-l")) || string_eq(cf->name, tos3("-Wa")) ||
       string_eq(cf->name, tos3("-Wl")) || string_eq(cf->name, tos3("-Wp"))) &&
      value.len > 0) {
    return string_trim_space(
        _STR("%.*s%.*s", cf->name.len, cf->name.str, value.len, value.str));
  };
  if (string_eq(cf->name, tos3("-I")) || string_eq(cf->name, tos3("-L")) ||
      string_ends_with(value, tos3(".o"))) {
    value = string_add(string_add(tos3("\""), os__realpath(value)), tos3("\""));
  };
  return string_trim_space(
      _STR("%.*s %.*s", cf->name.len, cf->name.str, value.len, value.str));
}
bool compiler__Table_has_cflag(compiler__Table *table, compiler__CFlag cflag) {
  array_compiler__CFlag tmp9 = table->cflags;
  for (int tmp10 = 0; tmp10 < tmp9.len; tmp10++) {
    compiler__CFlag cf = ((compiler__CFlag *)tmp9.data)[tmp10];

    if (string_eq(cf.os, cflag.os) && string_eq(cf.name, cflag.name) &&
        string_eq(cf.value, cflag.value)) {
      return 1;
    };
  };
  return 0;
}
Option_bool compiler__Table_parse_cflag(compiler__Table *table, string cflag,
                                        string mod, array_string ctimedefines) {
  array_string allowed_flags =
      new_array_from_c_array(8, 8, sizeof(string),
                             EMPTY_ARRAY_OF_ELEMS(string, 8){
                                 tos3("framework"),
                                 tos3("library"),
                                 tos3("Wa"),
                                 tos3("Wl"),
                                 tos3("Wp"),
                                 tos3("I"),
                                 tos3("l"),
                                 tos3("L"),
                             });
  string flag_orig = string_trim_space(cflag);
  string flag = flag_orig;
  if (string_eq(flag, tos3(""))) {
    bool tmp11 = OPTION_CAST(bool)(1);
    return opt_ok(&tmp11, sizeof(bool));
  };
  string fos = tos3("");
  array_string allowed_os_overrides =
      new_array_from_c_array(5, 5, sizeof(string),
                             EMPTY_ARRAY_OF_ELEMS(string, 5){
                                 tos3("linux"), tos3("darwin"), tos3("freebsd"),
                                 tos3("windows"), tos3("mingw")});
  _PUSH_MANY(&allowed_os_overrides,
             (/*typ = array_string   tmp_typ=string*/ ctimedefines), tmp12,
             array_string);
  array_string tmp13 = allowed_os_overrides;
  for (int tmp14 = 0; tmp14 < tmp13.len; tmp14++) {
    string os_override = ((string *)tmp13.data)[tmp14];

    if (!string_starts_with(flag, os_override)) {
      continue;
    };
    Option_int tmp15 = string_index(flag, tos3(" "));
    int pos;
    if (!tmp15.ok) {
      string err = tmp15.error;
      int errcode = tmp15.ecode;
      return opt_none();
    }
    pos = *(int *)tmp15.data;
    ;
    fos = string_trim_space(string_substr2(flag, 0, pos, false));
    flag = string_trim_space(string_substr2(flag, pos, -1, true));
  };
  while (1) {
    string name = tos3("");
    string value = tos3("");
    if (string_at(flag, 0) == '-') {
      array_string tmp22 = allowed_flags;
      for (int tmp23 = 0; tmp23 < tmp22.len; tmp23++) {
        string f = ((string *)tmp22.data)[tmp23];

        int i = 1 + f.len;
        if (i <= flag.len && string_eq(f, string_substr2(flag, 1, i, false))) {
          name = string_trim_space(string_substr2(flag, 0, i, false));
          flag = string_trim_space(string_substr2(flag, i, -1, true));
          break;
        };
      };
    };
    Option_int tmp30 = string_index(flag, tos3(" -"));
    int index;
    if (!tmp30.ok) {
      string err = tmp30.error;
      int errcode = tmp30.ecode;
    }
    if (tmp30.ok) {
      index = *(int *)tmp30.data;
    } else {
      index = -1;
    };
    while (index > -1) {

      bool has_next = 0;
      array_string tmp31 = allowed_flags;
      for (int tmp32 = 0; tmp32 < tmp31.len; tmp32++) {
        string f = ((string *)tmp31.data)[tmp32];

        int i = index + 2 + f.len;
        if (i <= flag.len &&
            string_eq(f, string_substr2(flag, index + 2, i, false))) {
          value = string_trim_space(string_substr2(flag, 0, index + 1, false));
          flag = string_trim_space(string_substr2(flag, index + 1, -1, true));
          has_next = 1;
          break;
        };
      };
      if (has_next) {
        break;
      };
      index = string_index_after(flag, tos3(" -"), index + 1);
    };
    if (index == -1) {
      value = string_trim_space(flag);
    };
    if (((string_eq(name, tos3("-I")) || string_eq(name, tos3("-l")) ||
          string_eq(name, tos3("-L")))) &&
        string_eq(value, tos3(""))) {
      string hint = ((string_eq(name, tos3("-l"))) ? (tos3("library name"))
                                                   : (tos3("path")));
      return v_error(_STR("bad #flag `%.*s`: missing %.*s after `%.*s`",
                          flag_orig.len, flag_orig.str, hint.len, hint.str,
                          name.len, name.str));
    };
    compiler__CFlag cf =
        (compiler__CFlag){.mod = mod, .os = fos, .name = name, .value = value};
    if (!compiler__Table_has_cflag(&/* ? */ *table, cf)) {
      _PUSH(&table->cflags,
            (/*typ = array_compiler__CFlag   tmp_typ=compiler__CFlag*/ cf),
            tmp39, compiler__CFlag);
    };
    if (index == -1) {
      break;
    };
  };
  bool tmp40 = OPTION_CAST(bool)(1);
  return opt_ok(&tmp40, sizeof(bool));
}
string array_compiler__CFlag_c_options_before_target_msvc(
    array_compiler__CFlag cflags) {
  return tos3("");
}
string array_compiler__CFlag_c_options_after_target_msvc(
    array_compiler__CFlag cflags) {
  return tos3("");
}
string
array_compiler__CFlag_c_options_before_target(array_compiler__CFlag cflags) {
  array_string args = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_compiler__CFlag tmp41 = cflags;
  for (int tmp42 = 0; tmp42 < tmp41.len; tmp42++) {
    compiler__CFlag flag = ((compiler__CFlag *)tmp41.data)[tmp42];

    if (string_ne(flag.name, tos3("-l"))) {
      _PUSH(&args,
            (/*typ = array_string   tmp_typ=string*/ compiler__CFlag_format(
                &/* ? */ flag)),
            tmp43, string);
    };
  };
  return array_string_join(args, tos3(" "));
}
string
array_compiler__CFlag_c_options_after_target(array_compiler__CFlag cflags) {
  array_string args = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_compiler__CFlag tmp44 = cflags;
  for (int tmp45 = 0; tmp45 < tmp44.len; tmp45++) {
    compiler__CFlag flag = ((compiler__CFlag *)tmp44.data)[tmp45];

    if (string_eq(flag.name, tos3("-l"))) {
      _PUSH(&args,
            (/*typ = array_string   tmp_typ=string*/ compiler__CFlag_format(
                &/* ? */ flag)),
            tmp46, string);
    };
  };
  return array_string_join(args, tos3(" "));
}
string array_compiler__CFlag_c_options_without_object_files(
    array_compiler__CFlag cflags) {
  array_string args = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_compiler__CFlag tmp47 = cflags;
  for (int tmp48 = 0; tmp48 < tmp47.len; tmp48++) {
    compiler__CFlag flag = ((compiler__CFlag *)tmp47.data)[tmp48];

    if (string_ends_with(flag.value, tos3(".o")) ||
        string_ends_with(flag.value, tos3(".obj"))) {
      continue;
    };
    _PUSH(&args,
          (/*typ = array_string   tmp_typ=string*/ compiler__CFlag_format(
              &/* ? */ flag)),
          tmp49, string);
  };
  return array_string_join(args, tos3(" "));
}
string array_compiler__CFlag_c_options_only_object_files(
    array_compiler__CFlag cflags) {
  array_string args = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_compiler__CFlag tmp50 = cflags;
  for (int tmp51 = 0; tmp51 < tmp50.len; tmp51++) {
    compiler__CFlag flag = ((compiler__CFlag *)tmp50.data)[tmp51];

    if (string_ends_with(flag.value, tos3(".o")) ||
        string_ends_with(flag.value, tos3(".obj"))) {
      _PUSH(&args,
            (/*typ = array_string   tmp_typ=string*/ compiler__CFlag_format(
                &/* ? */ flag)),
            tmp52, string);
    };
  };
  return array_string_join(args, tos3(" "));
}
compiler__CGen *compiler__new_cgen(string out_name_c) {
  string path = out_name_c;
  Option_os__File tmp1 = os__create(path);
  os__File out;
  if (!tmp1.ok) {
    string err = tmp1.error;
    int errcode = tmp1.ecode;
    printf("failed to create %.*s\n", path.len, path.str);
    return (compiler__CGen *)memdup(
        &(compiler__CGen){.out_path = tos3(""),
                          .thread_fns = new_array(0, 1, sizeof(string)),
                          .is_user = 0,
                          .lines = new_array(0, 1, sizeof(string)),
                          .lines_extra = new_array(0, 1, sizeof(string)),
                          .typedefs = new_array(0, 1, sizeof(string)),
                          .type_aliases = new_array(0, 1, sizeof(string)),
                          .includes = new_array(0, 1, sizeof(string)),
                          .thread_args = new_array(0, 1, sizeof(string)),
                          .consts = new_array(0, 1, sizeof(string)),
                          .const_defines = new_array(0, 1, sizeof(string)),
                          .fns = new_array(0, 1, sizeof(string)),
                          .so_fns = new_array(0, 1, sizeof(string)),
                          .consts_init = new_array(0, 1, sizeof(string)),
                          .nogen = 0,
                          .prev_tmps = new_array(0, 1, sizeof(string)),
                          .tmp_line = tos3(""),
                          .cur_line = tos3(""),
                          .prev_line = tos3(""),
                          .is_tmp = 0,
                          .fn_main = tos3(""),
                          .stash = tos3(""),
                          .file = tos3(""),
                          .line = 0,
                          .line_directives = 0,
                          .cut_pos = 0},
        sizeof(compiler__CGen));
  }
  out = *(os__File *)tmp1.data;
  ;
  compiler__CGen *gen = (compiler__CGen *)memdup(
      &(compiler__CGen){.out_path = path,
                        .out = out,
                        .lines = make(0, 1000, sizeof(string)),
                        .thread_fns = new_array(0, 1, sizeof(string)),
                        .is_user = 0,
                        .lines_extra = new_array(0, 1, sizeof(string)),
                        .typedefs = new_array(0, 1, sizeof(string)),
                        .type_aliases = new_array(0, 1, sizeof(string)),
                        .includes = new_array(0, 1, sizeof(string)),
                        .thread_args = new_array(0, 1, sizeof(string)),
                        .consts = new_array(0, 1, sizeof(string)),
                        .const_defines = new_array(0, 1, sizeof(string)),
                        .fns = new_array(0, 1, sizeof(string)),
                        .so_fns = new_array(0, 1, sizeof(string)),
                        .consts_init = new_array(0, 1, sizeof(string)),
                        .nogen = 0,
                        .prev_tmps = new_array(0, 1, sizeof(string)),
                        .tmp_line = tos3(""),
                        .cur_line = tos3(""),
                        .prev_line = tos3(""),
                        .is_tmp = 0,
                        .fn_main = tos3(""),
                        .stash = tos3(""),
                        .file = tos3(""),
                        .line = 0,
                        .line_directives = 0,
                        .cut_pos = 0},
      sizeof(compiler__CGen));
  return gen;
}
void compiler__CGen_genln(compiler__CGen *g, string s) {
  if (g->nogen || g->pass != compiler__compiler__Pass_main) {

    return;
  };
  if (g->is_tmp) {
    g->tmp_line =
        _STR("%.*s %.*s\n", g->tmp_line.len, g->tmp_line.str, s.len, s.str);

    return;
  };
  g->cur_line =
      _STR("%.*s %.*s", g->cur_line.len, g->cur_line.str, s.len, s.str);
  if (string_ne(g->cur_line, tos3(""))) {
    if (g->line_directives &&
        string_ne(string_trim_space(g->cur_line), tos3(""))) {
      if (g->file.len > 0 && g->line > 0) {
        _PUSH(&g->lines,
              (/*typ = array_string   tmp_typ=string*/ _STR(
                  "\n#line %d \"%.*s\"", g->line, g->file.len, g->file.str)),
              tmp2, string);
      };
    };
    _PUSH(&g->lines, (/*typ = array_string   tmp_typ=string*/ g->cur_line),
          tmp3, string);
    g->prev_line = g->cur_line;
    g->cur_line = tos3("");
  };
}
void compiler__CGen_prepend_to_statement(compiler__CGen *g, string s) {
  if (g->is_tmp) {
    g->tmp_line = string_add(s, g->tmp_line);

    return;
  };
  _PUSH(&g->lines, (/*typ = array_string   tmp_typ=string*/ s), tmp4, string);
  g->prev_line = g->cur_line;
}
void compiler__CGen_gen(compiler__CGen *g, string s) {
  if (g->nogen || g->pass != compiler__compiler__Pass_main) {

    return;
  };
  if (g->is_tmp) {
    g->tmp_line =
        _STR("%.*s %.*s", g->tmp_line.len, g->tmp_line.str, s.len, s.str);
  } else {
    g->cur_line =
        _STR("%.*s %.*s", g->cur_line.len, g->cur_line.str, s.len, s.str);
  };
}
void compiler__CGen_resetln(compiler__CGen *g, string s) {
  if (g->nogen || g->pass != compiler__compiler__Pass_main) {

    return;
  };
  if (g->is_tmp) {
    g->tmp_line = s;
  } else {
    g->cur_line = s;
  };
}
void compiler__CGen_save(compiler__CGen *g) {
  string s = array_string_join(g->lines, tos3("\n"));
  os__File_writeln(&/* ? */ g->out, s);
  os__File_writeln(&/* ? */ g->out,
                   array_string_join(g->lines_extra, tos3("\n")));
  os__File_close(&/* ? */ g->out);
}
_V_MulRet_string_V_string compiler__Parser_tmp_expr(compiler__Parser *p) {
  if (p->cgen->is_tmp) {
    _PUSH(&p->cgen->prev_tmps,
          (/*typ = array_string   tmp_typ=string*/ p->cgen->tmp_line), tmp5,
          string);
  };
  p->cgen->tmp_line = tos3("");
  p->cgen->is_tmp = 1;
  string typ = compiler__Parser_bool_expression(p);
  string res = p->cgen->tmp_line;
  if (p->cgen->prev_tmps.len > 0) {
    p->cgen->tmp_line = *(string *)array_last(p->cgen->prev_tmps);
    p->cgen->prev_tmps =
        array_slice2(p->cgen->prev_tmps, 0, p->cgen->prev_tmps.len - 1, false);
  } else {
    p->cgen->tmp_line = tos3("");
    p->cgen->is_tmp = 0;
  };
  return (_V_MulRet_string_V_string){.var_0 = typ, .var_1 = res};
}
int compiler__CGen_add_placeholder(compiler__CGen *g) {
  if (g->is_tmp) {
    return g->tmp_line.len;
  };
  return g->cur_line.len;
}
void compiler__CGen_start_cut(compiler__CGen *g) {
  g->cut_pos = compiler__CGen_add_placeholder(&/* ? */ *g);
}
string compiler__CGen_cut(compiler__CGen *g) {
  int pos = g->cut_pos;
  g->cut_pos = 0;
  if (g->is_tmp) {
    string res = string_substr2(g->tmp_line, pos, -1, true);
    g->tmp_line = string_substr2(g->tmp_line, 0, pos, false);
    return res;
  };
  string res = string_substr2(g->cur_line, pos, -1, true);
  g->cur_line = string_substr2(g->cur_line, 0, pos, false);
  return res;
}
void compiler__CGen_set_placeholder(compiler__CGen *g, int pos, string val) {
  if (g->nogen || g->pass != compiler__compiler__Pass_main) {

    return;
  };
  if (g->is_tmp) {
    string left = string_substr2(g->tmp_line, 0, pos, false);
    string right = string_substr2(g->tmp_line, pos, -1, true);
    g->tmp_line = _STR("%.*s%.*s%.*s", left.len, left.str, val.len, val.str,
                       right.len, right.str);

    return;
  };
  string left = string_substr2(g->cur_line, 0, pos, false);
  string right = string_substr2(g->cur_line, pos, -1, true);
  g->cur_line = _STR("%.*s%.*s%.*s", left.len, left.str, val.len, val.str,
                     right.len, right.str);
}
void compiler__CGen_insert_before(compiler__CGen *g, string val) {
  if (g->nogen) {

    return;
  };
  string prev = (*(string *)array_get(g->lines, g->lines.len - 1));
  array_set(&/*q*/ g->lines, g->lines.len - 1,
            &(string[]){
                _STR("%.*s \n %.*s \n", prev.len, prev.str, val.len, val.str)});
}
void compiler__CGen_register_thread_fn(compiler__CGen *g, string wrapper_name,
                                       string wrapper_text,
                                       string struct_text) {
  array_string tmp26 = g->thread_args;
  for (int tmp27 = 0; tmp27 < tmp26.len; tmp27++) {
    string arg = ((string *)tmp26.data)[tmp27];

    if (string_contains(arg, wrapper_name)) {

      return;
    };
  };
  _PUSH(&g->thread_args, (/*typ = array_string   tmp_typ=string*/ struct_text),
        tmp28, string);
  _PUSH(&g->thread_args, (/*typ = array_string   tmp_typ=string*/ wrapper_text),
        tmp29, string);
}
string compiler__V_prof_counters(compiler__V *v) {
  array_string res = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  return array_string_join(res, tos3(";\n"));
}
string compiler__Parser_print_prof_counters(compiler__Parser *p) {
  array_string res = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  return array_string_join(res, tos3(";\n"));
}
void compiler__Parser_gen_typedef(compiler__Parser *p, string s) {
  if (!compiler__Parser_first_pass(&/* ? */ *p)) {

    return;
  };
  _PUSH(&p->cgen->typedefs, (/*typ = array_string   tmp_typ=string*/ s), tmp30,
        string);
}
void compiler__Parser_gen_type_alias(compiler__Parser *p, string s) {
  if (!compiler__Parser_first_pass(&/* ? */ *p)) {

    return;
  };
  _PUSH(&p->cgen->type_aliases, (/*typ = array_string   tmp_typ=string*/ s),
        tmp31, string);
}
void compiler__CGen_add_to_main(compiler__CGen *g, string s) {
  g->fn_main = string_add(g->fn_main, s);
}
void compiler__V_build_thirdparty_obj_file(compiler__V *v, string path,
                                           array_compiler__CFlag moduleflags) {
  string obj_path = os__realpath(path);
  if (os__exists(obj_path)) {

    return;
  };
  printf("%.*s not found, building it...\n", obj_path.len, obj_path.str);
  string parent = os__dir(obj_path);
  Option_array_string tmp32 = os__ls(parent);
  array_string files;
  if (!tmp32.ok) {
    string err = tmp32.error;
    int errcode = tmp32.ecode;
    v_panic(err);
  }
  files = *(array_string *)tmp32.data;
  ;
  string cfiles = tos3("");
  array_string tmp33 = files;
  for (int tmp34 = 0; tmp34 < tmp33.len; tmp34++) {
    string file = ((string *)tmp33.data)[tmp34];

    if (string_ends_with(file, tos3(".c"))) {
      cfiles = string_add(
          cfiles,
          string_add(
              string_add(tos3("\""),
                         os__realpath(string_add(
                             string_add(parent, os__path_separator), file))),
              tos3("\" ")));
    };
  };
  string btarget = array_compiler__CFlag_c_options_before_target(moduleflags);
  string atarget = array_compiler__CFlag_c_options_after_target(moduleflags);
  string cmd = _STR(
      "%.*s %.*s %.*s -c -o \"%.*s\" %.*s %.*s ", v->pref->ccompiler.len,
      v->pref->ccompiler.str, v->pref->third_party_option.len,
      v->pref->third_party_option.str, btarget.len, btarget.str, obj_path.len,
      obj_path.str, cfiles.len, cfiles.str, atarget.len, atarget.str);
  Option_os__Result tmp35 = os__exec(cmd);
  os__Result res;
  if (!tmp35.ok) {
    string err = tmp35.error;
    int errcode = tmp35.ecode;
    printf("failed thirdparty object build cmd: %.*s\n", cmd.len, cmd.str);
    compiler__verror(err);

    return;
  }
  res = *(os__Result *)tmp35.data;
  ;
  if (res.exit_code != 0) {
    printf("failed thirdparty object build cmd: %.*s\n", cmd.len, cmd.str);
    compiler__verror(res.output);

    return;
  };
  println(res.output);
}
string compiler__os_name_to_ifdef(string name) {
  string tmp36 = name;

  if (string_eq(tmp36, tos3("windows"))) {
    return tos3("_WIN32");
  } else if (string_eq(tmp36, tos3("mac"))) {
    return tos3("__APPLE__");
  } else if (string_eq(tmp36, tos3("macos"))) {
    return tos3("__APPLE__");
  } else if (string_eq(tmp36, tos3("linux"))) {
    return tos3("__linux__");
  } else if (string_eq(tmp36, tos3("freebsd"))) {
    return tos3("__FreeBSD__");
  } else if (string_eq(tmp36, tos3("openbsd"))) {
    return tos3("__OpenBSD__");
  } else if (string_eq(tmp36, tos3("netbsd"))) {
    return tos3("__NetBSD__");
  } else if (string_eq(tmp36, tos3("dragonfly"))) {
    return tos3("__DragonFly__");
  } else if (string_eq(tmp36, tos3("msvc"))) {
    return tos3("_MSC_VER");
  } else if (string_eq(tmp36, tos3("android"))) {
    return tos3("__ANDROID__");
  } else if (string_eq(tmp36, tos3("js"))) {
    return tos3("_VJS");
  } else if (string_eq(tmp36, tos3("solaris"))) {
    return tos3("__sun");
  } else if (string_eq(tmp36, tos3("haiku"))) {
    return tos3("__haiku__");
  } else if (string_eq(tmp36, tos3("linux_or_macos"))) {
    return tos3("");
  } else // default:
  {
    compiler__verror(_STR("bad os ifdef name \"%.*s\"", name.len, name.str));
  };
  return tos3("");
}
string compiler__V_platform_postfix_to_ifdefguard(compiler__V *v, string name) {
  if (string_starts_with(name, tos3("custom "))) {
    string cdefine = string_replace(name, tos3("custom "), tos3(""));
    return _STR("#ifdef CUSTOM_DEFINE_%.*s", cdefine.len, cdefine.str);
  };
  string tmp37 = name;

  string s =
      ((string_eq(tmp37, tos3(".v")))
           ? (tos3(""))
           : (((string_eq(tmp37, tos3("_win.v"))) ||
               (string_eq(tmp37, tos3("_windows.v"))))
                  ? (tos3("#ifdef _WIN32"))
                  : ((string_eq(tmp37, tos3("_nix.v")))
                         ? (tos3("#ifndef _WIN32"))
                         : (((string_eq(tmp37, tos3("_lin.v"))) ||
                             (string_eq(tmp37, tos3("_linux.v"))))
                                ? (tos3("#ifdef __linux__"))
                                : (((string_eq(tmp37, tos3("_mac.v"))) ||
                                    (string_eq(tmp37, tos3("_darwin.v"))))
                                       ? (tos3("#ifdef __APPLE__"))
                                       : (((string_eq(tmp37, tos3("_bsd.v"))) ||
                                           (string_eq(tmp37,
                                                      tos3("_freebsd.v "))))
                                              ? (tos3("#ifdef __FreeBSD__"))
                                              : ((string_eq(tmp37,
                                                            tos3("_solaris.v")))
                                                     ? (tos3("#ifdef __sun"))
                                                     : ((string_eq(
                                                            tmp37,
                                                            tos3("_haiku.v")))
                                                            ? (tos3(
                                                                  "#ifdef "
                                                                  "__haiku__"))
                                                            : (tos3(
                                                                  ""))))))))));
  if (string_eq(s, tos3(""))) {
    compiler__verror(_STR("bad platform_postfix \"%.*s\"", name.len, name.str));
  };
  return s;
}
string compiler__V_type_definitions(compiler__V *v) {
  array_compiler__Type types = new_array_from_c_array(
      0, 0, sizeof(compiler__Type),
      EMPTY_ARRAY_OF_ELEMS(compiler__Type, 0){TCCSKIP(0)});
  array_compiler__Type builtin_types = new_array_from_c_array(
      0, 0, sizeof(compiler__Type),
      EMPTY_ARRAY_OF_ELEMS(compiler__Type, 0){TCCSKIP(0)});
  array_string builtins = new_array_from_c_array(
      6, 6, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 6){tos3("string"), tos3("array"),
                                      tos3("KeyValue"), tos3("DenseArray"),
                                      tos3("map"), tos3("Option")});
  array_string tmp38 = builtins;
  for (int tmp39 = 0; tmp39 < tmp38.len; tmp39++) {
    string builtin = ((string *)tmp38.data)[tmp39];

    compiler__Type tmp40 = {0};
    bool tmp41 = map_get(/*cgen.v : 406*/ v->table->typesmap, builtin, &tmp40);

    compiler__Type typ = tmp40;
    _PUSH(&builtin_types,
          (/*typ = array_compiler__Type   tmp_typ=compiler__Type*/ typ), tmp42,
          compiler__Type);
  };
  map_compiler__Type tmp43 = v->table->typesmap;
  array_string keys_tmp43 = map_keys(&tmp43);
  for (int l = 0; l < keys_tmp43.len; l++) {
    string t_name = ((string *)keys_tmp43.data)[l];
    compiler__Type t = {0};
    map_get(tmp43, t_name, &t);

    if ((_IN(string, (t_name), builtins)) || t.is_generic) {
      continue;
    };
    _PUSH(&types, (/*typ = array_compiler__Type   tmp_typ=compiler__Type*/ t),
          tmp44, compiler__Type);
  };
  array_compiler__Type types_sorted = compiler__sort_structs(types);
  string res =
      string_add(string_add(compiler__types_to_c(builtin_types, v->table),
                            tos3("\n//----\n")),
                 compiler__types_to_c(types_sorted, v->table));
  return res;
}
array_compiler__Type compiler__sort_structs(array_compiler__Type types) {
  compiler__DepGraph *dep_graph = compiler__new_dep_graph();
  array_string type_names = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_compiler__Type tmp45 = types;
  for (int tmp46 = 0; tmp46 < tmp45.len; tmp46++) {
    compiler__Type typ = ((compiler__Type *)tmp45.data)[tmp46];

    _PUSH(&type_names, (/*typ = array_string   tmp_typ=string*/ typ.name),
          tmp47, string);
  };
  array_compiler__Type tmp48 = types;
  for (int tmp49 = 0; tmp49 < tmp48.len; tmp49++) {
    compiler__Type t = ((compiler__Type *)tmp48.data)[tmp49];

    array_string field_deps = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    array_compiler__Var tmp50 = t.fields;
    for (int tmp51 = 0; tmp51 < tmp50.len; tmp51++) {
      compiler__Var field = ((compiler__Var *)tmp50.data)[tmp51];

      string ft = ((string_starts_with(field.typ, tos3("[")))
                       ? (string_all_after(field.typ, tos3("]")))
                       : (field.typ));
      if (!((_IN(string, (ft), type_names))) ||
          (_IN(string, (ft), field_deps))) {
        continue;
      };
      _PUSH(&field_deps, (/*typ = array_string   tmp_typ=string*/ ft), tmp52,
            string);
    };
    compiler__DepGraph_add(dep_graph, t.name, field_deps);
  };
  compiler__DepGraph *dep_graph_sorted =
      compiler__DepGraph_resolve(&/* ? */ *dep_graph);
  if (!dep_graph_sorted->acyclic) {
    compiler__verror(string_add(
        string_add(
            string_add(
                tos3("cgen.sort_structs(): the following structs form a "
                     "dependency cycle:\n"),
                compiler__DepGraph_display_cycles(&/* ? */ *dep_graph_sorted)),
            tos3("\nyou can solve this by making one or both of the dependant "
                 "struct fields references, eg: field &MyStruct")),
        tos3("\nif you feel this is an error, please create a new issue here: "
             "https://github.com/vlang/v/issues and tag @joe-conigliaro")));
  };
  array_compiler__Type types_sorted = new_array_from_c_array(
      0, 0, sizeof(compiler__Type),
      EMPTY_ARRAY_OF_ELEMS(compiler__Type, 0){TCCSKIP(0)});
  array_compiler__DepGraphNode tmp53 = dep_graph_sorted->nodes;
  for (int tmp54 = 0; tmp54 < tmp53.len; tmp54++) {
    compiler__DepGraphNode node = ((compiler__DepGraphNode *)tmp53.data)[tmp54];

    array_compiler__Type tmp55 = types;
    for (int tmp56 = 0; tmp56 < tmp55.len; tmp56++) {
      compiler__Type t = ((compiler__Type *)tmp55.data)[tmp56];

      if (string_eq(t.name, node.name)) {
        _PUSH(&types_sorted,
              (/*typ = array_compiler__Type   tmp_typ=compiler__Type*/ t),
              tmp57, compiler__Type);
        continue;
      };
    };
  };
  return types_sorted;
}
string compiler__V_interface_table(compiler__V *v) {
  strings__Builder sb = strings__new_builder(100);
  map_compiler__Type tmp58 = v->table->typesmap;
  array_string keys_tmp58 = map_keys(&tmp58);
  for (int l = 0; l < keys_tmp58.len; l++) {
    string _ = ((string *)keys_tmp58.data)[l];
    compiler__Type t = {0};
    map_get(tmp58, _, &t);

    if (t.cat != compiler__compiler__TypeCategory_interface_) {
      continue;
    };
    string interface_name = t.name;
    string methods = tos3("");
    string generated_casting_functions = tos3("");
    strings__Builder_writeln(&/* ? */ sb,
                             _STR("// NR methods = %d", t.gen_types.len));
    array_string tmp59 = t.gen_types;
    for (int i = 0; i < tmp59.len; i++) {
      string gen_type = ((string *)tmp59.data)[i];

      string ptr_ctype = string_replace(gen_type, tos3("*"), tos3("_ptr"));
      string cctype = string_replace(gen_type, tos3("*"), tos3(""));
      string interface_index_name =
          _STR("_%.*s_%.*s_index", interface_name.len, interface_name.str,
               ptr_ctype.len, ptr_ctype.str);
      generated_casting_functions = string_add(
          generated_casting_functions,
          _STR("\n%.*s I_%.*s_to_%.*s(%.*s x) {\n  return (%.*s){\n           "
               "._object = (void*) memdup(&x, sizeof(%.*s)),\n           "
               "._interface_idx = %.*s };\n}\n",
               interface_name.len, interface_name.str, cctype.len, cctype.str,
               interface_name.len, interface_name.str, cctype.len, cctype.str,
               interface_name.len, interface_name.str, cctype.len, cctype.str,
               interface_index_name.len, interface_index_name.str));
      methods = string_add(methods, tos3("{\n"));
      array_compiler__Fn tmp60 = t.methods;
      for (int j = 0; j < tmp60.len; j++) {
        compiler__Fn method = ((compiler__Fn *)tmp60.data)[j];

        methods = string_add(methods, _STR(" (void*)    %.*s_%.*s", cctype.len,
                                           cctype.str, method.name.len,
                                           method.name.str));
        if (j < t.methods.len - 1) {
          methods = string_add(methods, tos3(", \n"));
        };
      };
      methods = string_add(methods, tos3("\n},\n\n"));
      strings__Builder_writeln(&/* ? */ sb,
                               _STR("int %.*s = %d;", interface_index_name.len,
                                    interface_index_name.str, i));
    };
    if (t.gen_types.len > 0) {
      strings__Builder_writeln(
          &/* ? */ sb,
          string_add(
              _STR("void* (* %.*s_name_table[][%d]) = ", interface_name.len,
                   interface_name.str, t.methods.len),
              _STR("{ \n %.*s \n }; ", methods.len, methods.str)));
    } else {
      strings__Builder_writeln(
          &/* ? */ sb, string_add(_STR("void* (* %.*s_name_table[][1]) = ",
                                       interface_name.len, interface_name.str),
                                  tos3("{ {NULL} }; ")));
    };
    if (generated_casting_functions.len > 0) {
      strings__Builder_writeln(
          &/* ? */ sb, _STR("// Casting functions for interface \"%.*s\" :",
                            interface_name.len, interface_name.str));
      strings__Builder_writeln(&/* ? */ sb, generated_casting_functions);
    };
  };
  return strings__Builder_str(&/* ? */ sb);
}
void compiler__Parser_error(compiler__Parser *p, string s) {
  compiler__Parser_error_with_token_index(p, s, p->token_idx - 1);
}
void compiler__Parser_warn_or_error(compiler__Parser *p, string s) {
  if (p->pref->is_prod) {
    compiler__Parser_error(p, s);
  } else {
    compiler__Parser_warn(p, s);
  };
}
void compiler__Parser_warn(compiler__Parser *p, string s) {
  compiler__Parser_warn_with_token_index(p, s, p->token_idx - 1);
}
void compiler__Parser_production_error_with_token_index(compiler__Parser *p,
                                                        string e,
                                                        int tokenindex) {
  if (p->pref->is_prod) {
    compiler__Parser_error_with_token_index(p, e, tokenindex);
  } else {
    compiler__Parser_warn_with_token_index(p, e, tokenindex);
  };
}
void compiler__Parser_error_with_token_index(compiler__Parser *p, string s,
                                             int tokenindex) {
  compiler__Parser_error_with_position(
      p, s,
      compiler__Scanner_get_scanner_pos_of_token(
          &/* ? */ *p->scanner,
          &/*113 e="compiler__Token*" g="compiler__Token"*/ (compiler__Token[]){
              (*(compiler__Token *)array_get(p->tokens, tokenindex))}[0]));
}
void compiler__Parser_warn_with_token_index(compiler__Parser *p, string s,
                                            int tokenindex) {
  compiler__Parser_warn_with_position(
      p, s,
      compiler__Scanner_get_scanner_pos_of_token(
          &/* ? */ *p->scanner,
          &/*113 e="compiler__Token*" g="compiler__Token"*/ (compiler__Token[]){
              (*(compiler__Token *)array_get(p->tokens, tokenindex))}[0]));
}
void compiler__Parser_error_with_position(compiler__Parser *p, string s,
                                          compiler__ScannerPos sp) {
  compiler__Parser_print_error_context(p);
  string e = compiler__normalized_error(s);
  compiler__Scanner_goto_scanner_position(p->scanner, sp);
  compiler__Scanner_error_with_col(&/* ? */ *p->scanner, e,
                                   sp.pos - sp.last_nl_pos);
}
void compiler__Parser_warn_with_position(compiler__Parser *p, string s,
                                         compiler__ScannerPos sp) {
  if (p->scanner->is_fmt) {

    return;
  };
  compiler__ScannerPos cpos =
      compiler__Scanner_get_scanner_pos(&/* ? */ *p->scanner);
  string e = compiler__normalized_error(s);
  compiler__Scanner_goto_scanner_position(p->scanner, sp);
  compiler__Scanner_warn_with_col(&/* ? */ *p->scanner, e,
                                  sp.pos - sp.last_nl_pos);
  compiler__Scanner_goto_scanner_position(p->scanner, cpos);
}
void compiler__Scanner_error(compiler__Scanner *s, string msg) {
  compiler__Scanner_error_with_col(&/* ? */ *s, msg, 0);
}
void compiler__Scanner_warn(compiler__Scanner *s, string msg) {
  compiler__Scanner_warn_with_col(&/* ? */ *s, msg, 0);
}
void compiler__Scanner_warn_with_col(compiler__Scanner *s, string msg,
                                     int col) {
  string fullpath = compiler__Scanner_get_error_filepath(&/* ? */ *s);
  bool color_on = compiler__Scanner_is_color_output_on(&/* ? */ *s);
  string final_message =
      ((color_on) ? (term__bold(term__bright_blue(msg))) : (msg));
  eprintln(_STR("warning: %.*s:%d:%d: %.*s", fullpath.len, fullpath.str,
                s->line_nr + 1, col, final_message.len, final_message.str));
}
void compiler__Scanner_error_with_col(compiler__Scanner *s, string msg,
                                      int col) {
  string fullpath = compiler__Scanner_get_error_filepath(&/* ? */ *s);
  bool color_on = compiler__Scanner_is_color_output_on(&/* ? */ *s);
  string final_message = ((color_on) ? (term__red(term__bold(msg))) : (msg));
  eprintln(_STR("%.*s:%d:%d: %.*s", fullpath.len, fullpath.str, s->line_nr + 1,
                col, final_message.len, final_message.str));
  if (s->print_line_on_error && s->nlines > 0) {
    int context_start_line =
        compiler__imax(0, (s->line_nr - compiler__error_context_before));
    int context_end_line = compiler__imin(
        s->nlines - 1, (s->line_nr + compiler__error_context_after + 1));
    for (int cline = context_start_line; cline < context_end_line; cline++) {

      string line = string_add(_STR("%5d| ", (cline + 1)),
                               compiler__Scanner_line(*s, cline));
      string coloredline =
          ((cline == s->line_nr && color_on) ? (term__red(line)) : (line));
      eprintln(coloredline);
      if (cline != s->line_nr) {
        continue;
      };
      array_string pointerline = new_array_from_c_array(
          0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
      string tmp5 = line;
      ;
      for (int i = 0; i < tmp5.len; i++) {
        byte c = tmp5.str[i];

        if (i < col) {
          byte x = ((byte_is_space(c)) ? (c) : (' '));
          _PUSH(&pointerline,
                (/*typ = array_string   tmp_typ=string*/ byte_str(x)), tmp6,
                string);
          continue;
        };
        _PUSH(&pointerline,
              (/*typ = array_string   tmp_typ=string*/ (
                  (color_on) ? (term__bold(term__blue(tos3("^"))))
                             : (tos3("^")))),
              tmp7, string);
        break;
      };
      eprintln(
          string_add(tos3("      "), array_string_join(pointerline, tos3(""))));
    };
  };
  v_exit(1);
}
static inline int compiler__Parser_cur_tok_index(compiler__Parser *p) {
  return p->token_idx - 1;
}
static inline int compiler__imax(int a, int b) { return ((a > b) ? (a) : (b)); }
static inline int compiler__imin(int a, int b) { return ((a < b) ? (a) : (b)); }
string compiler__Scanner_get_error_filepath(compiler__Scanner *s) {
  string verror_paths_override = os__getenv(tos3("VERROR_PATHS"));
  string tmp8 = verror_paths_override;

  bool use_relative_paths = ((string_eq(tmp8, tos3("relative")))
                                 ? (1)
                                 : ((string_eq(tmp8, tos3("absolute")))
                                        ? (0)
                                        : (s->print_rel_paths_on_error)));
  if (use_relative_paths) {
    string workdir = string_add(os__getwd(), os__path_separator);
    if (string_starts_with(s->file_path, workdir)) {
      return string_replace(s->file_path, workdir, tos3(""));
    };
    return s->file_path;
  };
  return os__realpath(s->file_path);
}
bool compiler__Scanner_is_color_output_on(compiler__Scanner *s) {
  return s->print_colored_error && term__can_show_color_on_stderr();
}
void compiler__Parser_print_error_context(compiler__Parser *p) {
  if (p->pref->is_debug) {
    os__write_file(tos3("fns.txt"),
                   compiler__Table_debug_fns(&/* ? */ *p->table));
  };
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          p->pref->verbosity,
          v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
    printf("pass=%d fn=`%.*s`\n\n", p->pass, p->cur_fn.name.len,
           p->cur_fn.name.str);
  };
  compiler__CGen_save(p->cgen);
  string cur_path = os__getwd();
  if (!p->pref->is_repl && !p->pref->is_test &&
      (string_contains(p->file_path, tos3("v/compiler")) ||
       string_contains(cur_path, tos3("v/compiler")))) {
    println(tos3("\n========================="));
    println(tos3("It looks like you are building V. It is being frequently "
                 "updated every day."));
    println(tos3("If you didn\'t modify V\'s code, most likely there was a "
                 "change that "));
    println(tos3("lead to this error."));
    println(tos3("\nRun `v up`, that will most likely fix it."));
    println(tos3("\nIf this doesn\'t help, please create a GitHub issue."));
    println(tos3("=========================\n"));
  };
  if (p->pref->is_debug) {
    print_backtrace();
  };
}
int compiler__ienv_default(string ename, int idefault) {
  string es = os__getenv(ename);
  if (es.len == 0) {
    return idefault;
  };
  return v_string_int(es);
}
void compiler__Parser_print_current_tokens(compiler__Parser *p, string label) {
  int btokens = compiler__ienv_default(tos3("V_BTOKENS"), 5);
  int atokens = compiler__ienv_default(tos3("V_ATOKENS"), 5);
  int ctoken_idx = p->token_idx;
  int stoken_idx = compiler__imax(0, ctoken_idx - btokens);
  int etoken_idx = compiler__imin(ctoken_idx + atokens + 1, p->tokens.len);
  for (int i = stoken_idx; i < etoken_idx; i++) {

    string idx = ((i == ctoken_idx) ? (_STR(">%3d", i)) : (_STR(" %3d", i)));
    eprintln(string_add(
        _STR("%.*s: tokens[%.*s] = ", label.len, label.str, idx.len, idx.str),
        compiler__Token_detailed_str(
            (*(compiler__Token *)array_get(p->tokens, i)))));
  };
}
string compiler__normalized_error(string s) {
  string res = s;
  if (!string_contains(res, tos3("__"))) {
    res = string_replace(res, tos3("array_"), tos3("[]"));
  };
  res = string_replace(res, tos3("__"), tos3("."));
  res = string_replace(res, tos3("Option_"), tos3("?"));
  res = string_replace(res, tos3("main."), tos3(""));
  res = string_replace(res, tos3("ptr_"), tos3("&"));
  res = string_replace(res, tos3("_dot_"), tos3("."));
  if (string_contains(res, tos3("_V_MulRet_"))) {
    res = string_replace(res, tos3("_V_MulRet_"), tos3("("));
    res = string_replace(res, tos3("_V_"), tos3(", "));
    res = string_add(string_substr2(res, 0, res.len - 1, false), tos3(")\""));
  };
  return res;
}
string compiler__ScannerPos_str(compiler__ScannerPos s) {
  return _STR("ScannerPos{ %5d , %5d , %5d }", s.pos, s.line_nr, s.last_nl_pos);
}
compiler__ScannerPos compiler__Scanner_get_scanner_pos(compiler__Scanner *s) {
  return (compiler__ScannerPos){
      .pos = s->pos, .line_nr = s->line_nr, .last_nl_pos = s->last_nl_pos};
}
void compiler__Scanner_goto_scanner_position(compiler__Scanner *s,
                                             compiler__ScannerPos scp) {
  s->pos = scp.pos;
  s->line_nr = scp.line_nr;
  s->last_nl_pos = scp.last_nl_pos;
}
int compiler__Scanner_get_last_nl_from_pos(compiler__Scanner *s, int _pos) {
  int pos = ((_pos >= s->text.len) ? (s->text.len - 1) : (_pos));
  for (int i = pos; i >= 0; i--) {

    if (string_at(s->text, i) == '\n') {
      return i;
    };
  };
  return 0;
}
compiler__ScannerPos
compiler__Scanner_get_scanner_pos_of_token(compiler__Scanner *s,
                                           compiler__Token *tok) {
  return (compiler__ScannerPos){
      .pos = tok->pos,
      .line_nr = tok->line_nr,
      .last_nl_pos =
          compiler__Scanner_get_last_nl_from_pos(&/* ? */ *s, tok->pos)};
}
void compiler__Parser_mutable_arg_error(compiler__Parser *p, int i,
                                        compiler__Var arg, compiler__Fn f) {
  string dots_example = _STR("mut %.*s", p->lit.len, p->lit.str);
  if (i > 0) {
    dots_example = string_add(tos3(".., "), dots_example);
  };
  if (i < f.args.len - 1) {
    dots_example = string_add(dots_example, tos3(",.."));
  };
  compiler__Parser_error(
      p, string_add(
             _STR("`%.*s` is a mutable argument, you need to provide `mut`: ",
                  arg.name.len, arg.name.str),
             _STR("`%.*s (%.*s)`", f.name.len, f.name.str, dots_example.len,
                  dots_example.str)));
}
_V_MulRet_array_string_V_string
compiler__get_v_options_and_main_command(array_string args) {
  array_string options = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_string potential_commands = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  for (int i = 0; i < args.len; i++) {

    string a = (*(string *)array_get(args, i));
    if (!string_starts_with(a, tos3("-"))) {
      _PUSH(&potential_commands, (/*typ = array_string   tmp_typ=string*/ a),
            tmp3, string);
      continue;
    } else {
      _PUSH(&options, (/*typ = array_string   tmp_typ=string*/ a), tmp4,
            string);
      if ((string_eq(a, tos3("-o")) || string_eq(a, tos3("-os")) ||
           string_eq(a, tos3("-cc")) || string_eq(a, tos3("-cflags")) ||
           string_eq(a, tos3("-d")))) {
        i++;
      };
    };
  };
  string command = ((potential_commands.len > 1)
                        ? ((*(string *)array_get(potential_commands, 1)))
                        : (tos3("")));
  return (_V_MulRet_array_string_V_string){.var_0 = options, .var_1 = command};
}
void compiler__Parser_comp_time(compiler__Parser *p) {
  compiler__Parser_check(p, compiler__compiler__TokenKind_dollar);
  if (p->tok == compiler__compiler__TokenKind_key_if) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_if);
    ;
    bool not = p->tok == compiler__compiler__TokenKind_not;
    if (not) {
      compiler__Parser_check(p, compiler__compiler__TokenKind_not);
    };
    string name = compiler__Parser_check_name(p);
    ;
    if ((_IN(string, (name), compiler__supported_platforms))) {
      v_dot_pref__OS os = compiler__os_from_string(name);
      string ifdef_name = compiler__os_name_to_ifdef(name);
      if (string_eq(name, tos3("mac"))) {
        compiler__Parser_warn(p, tos3("use `macos` instead of `mac`"));
      };
      if (not) {
        if (string_eq(name, tos3("linux_or_macos"))) {
          compiler__Parser_genln(
              p, tos3("#if !defined(__linux__) && !defined(__APPLE__)"));
        } else {
          compiler__Parser_genln(
              p, _STR("#ifndef %.*s", ifdef_name.len, ifdef_name.str));
        };
      } else {
        if (string_eq(name, tos3("linux_or_macos"))) {
          compiler__Parser_genln(
              p, tos3("#if defined(__linux__) || defined(__APPLE__)"));
        } else {
          compiler__Parser_genln(
              p, _STR("#ifdef %.*s", ifdef_name.len, ifdef_name.str));
        };
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
      if (((!not&&os != p->os) || (not&&os == p->os)) &&
          !string_contains(name, tos3("_or_")) && !p->scanner->is_fmt &&
          !p->pref->output_cross_c) {
        int stack = 1;
        while (1) {
          if (p->tok == compiler__compiler__TokenKind_key_return) {
            p->returns = 1;
          };
          if (p->tok == compiler__compiler__TokenKind_lcbr) {
            stack++;
          } else if (p->tok == compiler__compiler__TokenKind_rcbr) {
            stack--;
          };
          if (p->tok == compiler__compiler__TokenKind_eof) {
            break;
          };
          if (stack <= 0 && p->tok == compiler__compiler__TokenKind_rcbr) {
            compiler__Parser_next(p);
            break;
          };
          compiler__Parser_next(p);
        };
      } else {
        compiler__Parser_statements_no_rcbr(p);
      };
      if (!(p->tok == compiler__compiler__TokenKind_dollar &&
            compiler__Parser_peek(&/* ? */ *p) ==
                compiler__compiler__TokenKind_key_else)) {
        compiler__Parser_genln(p, tos3("#endif"));
      };
    } else if (string_eq(name, tos3("x64"))) {
      compiler__Parser_comptime_if_block(p, tos3("TARGET_IS_64BIT"), not);
    } else if (string_eq(name, tos3("x32"))) {
      compiler__Parser_comptime_if_block(p, tos3("TARGET_IS_32BIT"), not);
    } else if (string_eq(name, tos3("big_endian"))) {
      compiler__Parser_comptime_if_block(p, tos3("TARGET_ORDER_IS_BIG"), not);
    } else if (string_eq(name, tos3("little_endian"))) {
      compiler__Parser_comptime_if_block(p, tos3("TARGET_ORDER_IS_LITTLE"),
                                         not);
    } else if (string_eq(name, tos3("debug"))) {
      compiler__Parser_comptime_if_block(p, tos3("VDEBUG"), not);
    } else if (string_eq(name, tos3("prealloc"))) {
      compiler__Parser_comptime_if_block(p, tos3("VPREALLOC"), not);
    } else if (string_eq(name, tos3("tinyc"))) {
      compiler__Parser_comptime_if_block(p, tos3("__TINYC__"), not);
    } else if (string_eq(name, tos3("glibc"))) {
      compiler__Parser_comptime_if_block(p, tos3("__GLIBC__"), not);
    } else if (string_eq(name, tos3("mingw"))) {
      compiler__Parser_comptime_if_block(p, tos3("__MINGW32__"), not);
    } else if (string_eq(name, tos3("msvc"))) {
      compiler__Parser_comptime_if_block(p, tos3("_MSC_VER"), not);
    } else if (string_eq(name, tos3("clang"))) {
      compiler__Parser_comptime_if_block(p, tos3("__clang__"), not);
    } else if (p->v->pref->compile_defines_all.len > 0 &&
               (_IN(string, (name), p->v->pref->compile_defines_all))) {
      if (p->tok == compiler__compiler__TokenKind_question) {
        compiler__Parser_next(p);
      };
      compiler__Parser_comptime_if_block(
          p, _STR("CUSTOM_DEFINE_%.*s", name.len, name.str), not);
    } else {
      if (p->tok == compiler__compiler__TokenKind_question) {
        compiler__Parser_next(p);
        compiler__Parser_comptime_if_block(
            p, _STR("CUSTOM_DEFINE_%.*s", name.len, name.str), not);
      } else {
        println(tos3("Supported platforms:"));
        println(array_string_str(compiler__supported_platforms));
        compiler__Parser_error(
            p, _STR("unknown platform `%.*s`", name.len, name.str));
      };
    };
    bool if_returns = p->returns;
    p->returns = 0;
    if (p->tok == compiler__compiler__TokenKind_dollar &&
        compiler__Parser_peek(&/* ? */ *p) ==
            compiler__compiler__TokenKind_key_else) {
      ;
      compiler__Parser_next(p);
      compiler__Parser_next(p);
      ;
      compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
      compiler__Parser_genln(p, tos3("#else"));
      compiler__Parser_statements_no_rcbr(p);
      compiler__Parser_genln(p, tos3("#endif"));
      bool else_returns = p->returns;
      p->returns = if_returns && else_returns;
    } else if (p->tok == compiler__compiler__TokenKind_key_else) {
      compiler__Parser_error(
          p, string_add(
                 tos3("use `$"),
                 tos3("else` instead of `else` in comptime if statements")));
    };
  } else if (p->tok == compiler__compiler__TokenKind_key_for) {
    compiler__Parser_next(p);
    string name = compiler__Parser_check_name(p);
    if (string_ne(name, tos3("field"))) {
      compiler__Parser_error(p, tos3("for field only"));
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_in);
    compiler__Parser_check_name(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
    compiler__Parser_check_name(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
    string res_name = compiler__Parser_check_name(p);
    println(res_name);
    compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
    compiler__Parser_check(p, compiler__compiler__TokenKind_dollar);
    compiler__Parser_check(p, compiler__compiler__TokenKind_name);
    compiler__Parser_check(p, compiler__compiler__TokenKind_assign);
    _V_MulRet_string_V_string _V_mret_804___val = compiler__Parser_tmp_expr(p);
    string val = _V_mret_804___val.var_1;
    compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
  } else if (p->tok == compiler__compiler__TokenKind_name &&
             string_eq(p->lit, tos3("vweb"))) {
    string path = string_add(p->cur_fn.name, tos3(".html"));
    if (p->pref->is_debug) {
      printf(">>> compiling vweb HTML template \"%.*s\"\n", path.len, path.str);
    };
    if (!os__exists(path)) {
      path = string_add(string_add(os__dir(p->scanner->file_path), tos3("/")),
                        path);
      if (!os__exists(path)) {
        compiler__Parser_error(p, _STR("vweb HTML template \"%.*s\" not found",
                                       path.len, path.str));
      };
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_name);
    compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
    compiler__Parser_check(p, compiler__compiler__TokenKind_name);
    compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
    compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
    string v_code = vweb_dot_tmpl__compile_template(path);
    if (v_dot_pref__VerboseLevel_is_higher_or_equal(
            p->pref->verbosity,
            v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
      println(tos3("\n\n"));
      printf(">>> vweb template for %.*s:\n", path.len, path.str);
      println(v_code);
      println(tos3(">>> vweb template END"));
      println(tos3("\n\n"));
    };
    bool is_strings_imorted = compiler__ImportTable_known_import(
        &/* ? */ p->import_table, tos3("strings"));
    if (!is_strings_imorted) {
      compiler__Parser_register_import(p, tos3("strings"), 0);
    };
    compiler__ImportTable_register_used_import(&/* ? */ p->import_table,
                                               tos3("strings"));
    compiler__Parser_genln(p, tos3("/////////////////// tmpl start"));
    compiler__Parser_statements_from_text(p, v_code, 0, path);
    compiler__Parser_genln(p, tos3("/////////////////// tmpl end"));
    compiler__Var receiver = (*(compiler__Var *)array_get(p->cur_fn.args, 0));
    string dot = ((receiver.is_mut || receiver.ptr ||
                   string_ends_with(receiver.typ, tos3("*")))
                      ? (tos3("->"))
                      : (tos3(".")));
    compiler__Parser_genln(
        p, _STR("vweb__Context_html( & %.*s /*!*/%.*s vweb, tmpl_res)",
                receiver.name.len, receiver.name.str, dot.len, dot.str));
  } else {
    compiler__Parser_error(p, tos3("bad comp_time expression"));
  };
}
void compiler__Parser_chash(compiler__Parser *p) {
  string hash = string_trim_space(p->lit);
  compiler__Parser_next(p);
  ;
  if (string_starts_with(hash, tos3("flag "))) {
    if (compiler__Parser_first_pass(&/* ? */ *p)) {
      string flag = string_substr2(hash, 5, -1, true);
      if (string_contains(flag, tos3("@VROOT"))) {
        compiler__ModFileAndFolder vmod_file_location =
            compiler__ModFileCacher_get(p->v->mod_file_cacher,
                                        p->file_path_dir);
        if (vmod_file_location.vmod_file.len == 0) {
          compiler__Parser_error_with_token_index(
              p,
              string_add(
                  string_add(tos3("To use @VROOT, you need"),
                             _STR(" to have a \"v.mod\" file in %.*s,",
                                  p->file_path_dir.len, p->file_path_dir.str)),
                  tos3(" or in one of its parent folders.")),
              compiler__Parser_cur_tok_index(&/* ? */ *p) - 1);
        };
        flag = string_replace(flag, tos3("@VROOT"),
                              vmod_file_location.vmod_folder);
      };
      array_string tmp5 = new_array_from_c_array(
          4, 4, sizeof(string),
          EMPTY_ARRAY_OF_ELEMS(string, 4){tos3("@VMOD"), tos3("@VMODULE"),
                                          tos3("@VPATH"), tos3("@VLIB_PATH")});
      for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
        string deprecated = ((string *)tmp5.data)[tmp6];

        if (string_contains(flag, deprecated)) {
          compiler__Parser_error(
              p, _STR("%.*s had been deprecated, use @VROOT instead.",
                      deprecated.len, deprecated.str));
        };
      };
      Option_bool tmp7 = compiler__Table_parse_cflag(
          p->table, flag, p->mod, p->v->pref->compile_defines_all);
      if (!tmp7.ok) {
        string err = tmp7.error;
        int errcode = tmp7.ecode;
        compiler__Parser_error_with_token_index(
            p, err, compiler__Parser_cur_tok_index(&/* ? */ *p) - 1);

        return;
      };
    };

    return;
  };
  if (string_starts_with(hash, tos3("include"))) {
    if (compiler__Parser_first_pass(&/* ? */ *p) && !p->is_vh) {
      if (p->file_pcguard.len != 0) {
        _PUSH(&p->cgen->includes,
              (/*typ = array_string   tmp_typ=string*/ _STR(
                  "%.*s\n#%.*s\n#endif", p->file_pcguard.len,
                  p->file_pcguard.str, hash.len, hash.str)),
              tmp8, string);

        return;
      };
      _PUSH(&p->cgen->includes,
            (/*typ = array_string   tmp_typ=string*/ _STR("#%.*s", hash.len,
                                                          hash.str)),
            tmp9, string);

      return;
    };
  } else if (string_contains(hash, tos3("embed"))) {
    Option_int tmp10 = string_index(hash, tos3("embed"));
    int pos;
    if (!tmp10.ok) {
      string err = tmp10.error;
      int errcode = tmp10.ecode;

      return;
    }
    pos = *(int *)tmp10.data;
    ;
    string file = string_substr2(hash, pos + 5, -1, true);
    compiler__Parser_genln(p, _STR("#include %.*s", file.len, file.str));
  } else if (string_contains(hash, tos3("define"))) {
    if (compiler__Parser_first_pass(&/* ? */ *p)) {
      _PUSH(&p->cgen->includes,
            (/*typ = array_string   tmp_typ=string*/ _STR("#%.*s", hash.len,
                                                          hash.str)),
            tmp13, string);
    };
  } else if (string_eq(hash, tos3("-js"))) {
#ifdef _VJS
#else
    compiler__Parser_next(p);
#endif
    ;
  } else {
#ifndef _VJS
    if (!p->can_chash) {
      printf("hash=\"%.*s\"\n", hash.len, hash.str);
      if (string_starts_with(hash, tos3("include"))) {
        println(tos3("include"));
      } else {
      };
      compiler__Parser_error(
          p, tos3("bad token `#` (embedding C code is no longer supported)"));
    };
#endif
    ;
    compiler__Parser_genln(p, hash);
  };
}
void compiler__Parser_comptime_method_call(compiler__Parser *p,
                                           compiler__Type typ) {
  p->cgen->cur_line = tos3("");
  compiler__Parser_check(p, compiler__compiler__TokenKind_dollar);
  string var = compiler__Parser_check_name(p);
  int j = 0;
  array_compiler__Fn tmp14 = typ.methods;
  for (int tmp15 = 0; tmp15 < tmp14.len; tmp15++) {
    compiler__Fn method = ((compiler__Fn *)tmp14.data)[tmp15];

    if (string_ne(method.typ, tos3("void"))) {
      continue;
    };
    compiler__Var receiver = (*(compiler__Var *)array_get(method.args, 0));
    if (!p->expr_var.ptr) {
      compiler__Parser_error(p,
                             _STR("`%.*s` needs to be a reference",
                                  p->expr_var.name.len, p->expr_var.name.str));
    };
    string amp =
        ((receiver.is_mut && !p->expr_var.ptr) ? (tos3("&")) : (tos3("")));
    if (j > 0) {
      compiler__Parser_gen(p, tos3(" else "));
    };
    compiler__Parser_genln(
        p, string_add(_STR("if ( string_eq(%.*s, _STR(\"%.*s\")) ) ", var.len,
                           var.str, method.name.len, method.name.str),
                      _STR("%.*s_%.*s (%.*s %.*s);", typ.name.len, typ.name.str,
                           method.name.len, method.name.str, amp.len, amp.str,
                           p->expr_var.name.len, p->expr_var.name.str)));
    j++;
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
  compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
  if (p->tok == compiler__compiler__TokenKind_key_orelse) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_orelse);
    compiler__Parser_genln(p, tos3("else {"));
    compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
    compiler__Parser_statements(p);
  };
}
_V_MulRet_bool_V_string
compiler__Parser_gen_default_str_method_if_missing(compiler__Parser *p,
                                                   string typename) {
  string string_type_name = typename;
  compiler__Type typ = compiler__Table_find_type(&/* ? */ *p->table, typename);
  bool is_varg = string_starts_with(typename, tos3("varg_"));
  bool is_array = string_starts_with(typename, tos3("array_"));
  bool is_struct = typ.cat == compiler__compiler__TypeCategory_struct_;
  bool has_str_method = compiler__Table_type_has_method(
      &/* ? */ *p->table, &/*114*/ typ, tos3("str"));
  if (!has_str_method) {
    if (is_varg) {
      compiler__Parser_gen_varg_str(p, typ);
      has_str_method = 1;
    } else if (is_array) {
      compiler__Parser_gen_array_str(p, typ);
      has_str_method = 1;
    } else if (is_struct) {
      compiler__Parser_gen_struct_str(p, typ);
      has_str_method = 1;
    } else {
      string btypename = compiler__Parser_base_type(p, typ.name);
      if (string_ne(btypename, typ.name)) {
        compiler__Type base_type =
            compiler__Parser_find_type(&/* ? */ *p, btypename);
        if (compiler__Type_has_method(&/* ? */ base_type, tos3("str"))) {
          string_type_name = base_type.name;
          has_str_method = 1;
        };
      };
    };
  };
  return (_V_MulRet_bool_V_string){.var_0 = has_str_method,
                                   .var_1 = string_type_name};
}
void compiler__Parser_gen_array_str(compiler__Parser *p, compiler__Type typ) {
  if (compiler__Type_has_method(&/* ? */ typ, tos3("str"))) {

    return;
  };
  compiler__Parser_add_method(
      p, typ.name,
      (compiler__Fn){.name = tos3("str"),
                     .typ = tos3("string"),
                     .args = new_array_from_c_array(
                         1, 1, sizeof(compiler__Var),
                         EMPTY_ARRAY_OF_ELEMS(compiler__Var, 1){(compiler__Var){
                             .typ = typ.name,
                             .is_arg = 1,
                             .name = tos3(""),
                             .idx = 0,
                             .is_const = 0,
                             .args = new_array(0, 1, sizeof(compiler__Var)),
                             .attr = tos3(""),
                             .is_mut = 0,
                             .is_alloc = 0,
                             .is_returned = 0,
                             .ptr = 0,
                             .ref = 0,
                             .parent_fn = tos3(""),
                             .mod = tos3(""),
                             .is_global = 0,
                             .is_used = 0,
                             .is_changed = 0,
                             .scope_level = 0,
                             .is_c = 0,
                             .is_moved = 0,
                             .line_nr = 0,
                             .token_idx = 0,
                             .is_for_var = 0,
                             .is_public = 0}}),
                     .is_method = 1,
                     .is_public = 1,
                     .receiver_typ = typ.name,
                     .mod = tos3(""),
                     .is_interface = 0,
                     .scope_level = 0,
                     .is_c = 0,
                     .is_decl = 0,
                     .is_unsafe = 0,
                     .is_deprecated = 0,
                     .is_variadic = 0,
                     .is_generic = 0,
                     .returns_error = 0,
                     .defer_text = new_array(0, 1, sizeof(string)),
                     .type_pars = new_array(0, 1, sizeof(string)),
                     .type_inst = new_array(0, 1, sizeof(compiler__TypeInst)),
                     .generic_fn_idx = 0,
                     .parser_idx = 0,
                     .fn_name_token_idx = 0,
                     .comptime_define = tos3(""),
                     .is_used = 0});
  string elm_type =
      compiler__parse_pointer(string_substr2(typ.name, 6, -1, true));
  compiler__Type elm_type2 =
      compiler__Table_find_type(&/* ? */ *p->table, elm_type);
  bool is_array = string_starts_with(elm_type, tos3("array_"));
  if (is_array) {
    compiler__Parser_gen_array_str(p, elm_type2);
  } else if (string_eq(compiler__Parser_typ_to_fmt(p, elm_type, 0), tos3("")) &&
             !compiler__Table_type_has_method(
                 &/* ? */ *p->table, &/*114*/ elm_type2, tos3("str"))) {
    _V_MulRet_bool_V_string _V_mret_2008_has_str_method__ =
        compiler__Parser_gen_default_str_method_if_missing(p, elm_type);
    bool has_str_method = _V_mret_2008_has_str_method__.var_0;
    if (!has_str_method) {
      compiler__Parser_error(
          p, _STR("cant print []%.*s, unhandled print of %.*s", elm_type.len,
                  elm_type.str, elm_type.len, elm_type.str));
    };
  };
  strings__Builder_writeln(
      &/* ? */ p->v->vgen_buf,
      _STR(
          "\npub fn (a %.*s) str() string {\n	mut sb := "
          "strings.new_builder(a.len * 3)\n	sb.write(\"[\")\n	for i, "
          "elm in a {\n		sb.write(elm.str())\n		if i < a.len - "
          "1 {\n			sb.write(\", \")\n		"
          "}\n	}\n	sb.write(\"]\")\n	return sb.str()\n}\n	",
          typ.name.len, typ.name.str));
  _PUSH(&p->cgen->fns,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "string %.*s_str();", typ.name.len, typ.name.str)),
        tmp20, string);
}
void compiler__Parser_gen_struct_str(compiler__Parser *p, compiler__Type typ) {
  compiler__Parser_add_method(
      p, typ.name,
      (compiler__Fn){.name = tos3("str"),
                     .typ = tos3("string"),
                     .args = new_array_from_c_array(
                         1, 1, sizeof(compiler__Var),
                         EMPTY_ARRAY_OF_ELEMS(compiler__Var, 1){(compiler__Var){
                             .typ = typ.name,
                             .is_arg = 1,
                             .name = tos3(""),
                             .idx = 0,
                             .is_const = 0,
                             .args = new_array(0, 1, sizeof(compiler__Var)),
                             .attr = tos3(""),
                             .is_mut = 0,
                             .is_alloc = 0,
                             .is_returned = 0,
                             .ptr = 0,
                             .ref = 0,
                             .parent_fn = tos3(""),
                             .mod = tos3(""),
                             .is_global = 0,
                             .is_used = 0,
                             .is_changed = 0,
                             .scope_level = 0,
                             .is_c = 0,
                             .is_moved = 0,
                             .line_nr = 0,
                             .token_idx = 0,
                             .is_for_var = 0,
                             .is_public = 0}}),
                     .is_method = 1,
                     .is_public = 1,
                     .receiver_typ = typ.name,
                     .mod = tos3(""),
                     .is_interface = 0,
                     .scope_level = 0,
                     .is_c = 0,
                     .is_decl = 0,
                     .is_unsafe = 0,
                     .is_deprecated = 0,
                     .is_variadic = 0,
                     .is_generic = 0,
                     .returns_error = 0,
                     .defer_text = new_array(0, 1, sizeof(string)),
                     .type_pars = new_array(0, 1, sizeof(string)),
                     .type_inst = new_array(0, 1, sizeof(compiler__TypeInst)),
                     .generic_fn_idx = 0,
                     .parser_idx = 0,
                     .fn_name_token_idx = 0,
                     .comptime_define = tos3(""),
                     .is_used = 0});
  strings__Builder sb = strings__new_builder(typ.fields.len * 20);
  strings__Builder_writeln(&/* ? */ sb,
                           _STR("pub fn (a %.*s) str() string {\nreturn",
                                typ.name.len, typ.name.str));
  string short_struct_name = string_all_after(typ.name, tos3("__"));
  strings__Builder_writeln(&/* ? */ sb, _STR("'%.*s {", short_struct_name.len,
                                             short_struct_name.str));
  array_compiler__Var tmp21 = typ.fields;
  for (int tmp22 = 0; tmp22 < tmp21.len; tmp22++) {
    compiler__Var field = ((compiler__Var *)tmp21.data)[tmp22];

    strings__Builder_writeln(
        &/* ? */ sb,
        string_add(_STR("\t%.*s: $", field.name.len, field.name.str),
                   _STR("a.%.*s", field.name.len, field.name.str)));
  };
  strings__Builder_writeln(&/* ? */ sb, tos3("}'"));
  strings__Builder_writeln(&/* ? */ sb, tos3("}"));
  strings__Builder_writeln(&/* ? */ p->v->vgen_buf,
                           strings__Builder_str(&/* ? */ sb));
  _PUSH(&p->cgen->fns,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "string %.*s_str();", typ.name.len, typ.name.str)),
        tmp23, string);
}
void compiler__Parser_gen_varg_str(compiler__Parser *p, compiler__Type typ) {
  string elm_type = string_substr2(typ.name, 5, -1, true);
  compiler__Type elm_type2 =
      compiler__Table_find_type(&/* ? */ *p->table, elm_type);
  bool is_array = string_starts_with(elm_type, tos3("array_"));
  if (is_array) {
    compiler__Parser_gen_array_str(p, elm_type2);
  } else if (elm_type2.cat == compiler__compiler__TypeCategory_struct_) {
    compiler__Parser_gen_struct_str(p, elm_type2);
  };
  strings__Builder_writeln(
      &/* ? */ p->v->vgen_buf,
      _STR("\npub fn (a %.*s) str() string {\n	mut sb := "
           "strings.new_builder(a.len * 3)\n	sb.write(\"[\")\n	for i, "
           "elm in a {\n		sb.write(elm.str())\n		if i < "
           "a.len - 1 {\n			sb.write(\", \")\n	"
           "	}\n	}\n	sb.write(\"]\")\n	return sb.str()\n}",
           typ.name.len, typ.name.str));
  _PUSH(&p->cgen->fns,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "string %.*s_str();", typ.name.len, typ.name.str)),
        tmp26, string);
}
void compiler__Parser_gen_array_filter(compiler__Parser *p, string str_typ,
                                       int method_ph) {
  string val_type =
      compiler__parse_pointer(string_substr2(str_typ, 6, -1, true));
  compiler__Parser_open_scope(p);
  compiler__Parser_register_var(
      p, (compiler__Var){.name = tos3("it"),
                         .typ = val_type,
                         .idx = 0,
                         .is_arg = 0,
                         .is_const = 0,
                         .args = new_array(0, 1, sizeof(compiler__Var)),
                         .attr = tos3(""),
                         .is_mut = 0,
                         .is_alloc = 0,
                         .is_returned = 0,
                         .ptr = 0,
                         .ref = 0,
                         .parent_fn = tos3(""),
                         .mod = tos3(""),
                         .is_global = 0,
                         .is_used = 0,
                         .is_changed = 0,
                         .scope_level = 0,
                         .is_c = 0,
                         .is_moved = 0,
                         .line_nr = 0,
                         .token_idx = 0,
                         .is_for_var = 0,
                         .is_public = 0});
  compiler__Parser_next(p);
  compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
  compiler__CGen_resetln(p->cgen, tos3(""));
  string tmp = compiler__Parser_get_tmp(p);
  string a = p->expr_var.name;
  compiler__CGen_set_placeholder(
      p->cgen, method_ph,
      _STR("\n%.*s %.*s = new_array(0, %.*s .len,sizeof(%.*s));\n", str_typ.len,
           str_typ.str, tmp.len, tmp.str, a.len, a.str, val_type.len,
           val_type.str));
  compiler__Parser_genln(
      p, _STR("for (int i = 0; i < %.*s.len; i++) {", a.len, a.str));
  compiler__Parser_genln(p, _STR("%.*s it = ((%.*s*)%.*s.data)[i];",
                                 val_type.len, val_type.str, val_type.len,
                                 val_type.str, a.len, a.str));
  compiler__Parser_gen(p, tos3("if ("));
  compiler__Parser_bool_expression(p);
  compiler__Parser_genln(p,
                         _STR(") array_push(&%.*s, &it);", tmp.len, tmp.str));
  compiler__Parser_genln(p, tos3("}"));
  compiler__Parser_gen(p, tmp);
  compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
  compiler__Parser_close_scope(p);
}
string compiler__Parser_gen_array_map(compiler__Parser *p, string str_typ,
                                      int method_ph) {
  string val_type =
      compiler__parse_pointer(string_substr2(str_typ, 6, -1, true));
  compiler__Parser_open_scope(p);
  compiler__Parser_register_var(
      p, (compiler__Var){.name = tos3("it"),
                         .typ = val_type,
                         .idx = 0,
                         .is_arg = 0,
                         .is_const = 0,
                         .args = new_array(0, 1, sizeof(compiler__Var)),
                         .attr = tos3(""),
                         .is_mut = 0,
                         .is_alloc = 0,
                         .is_returned = 0,
                         .ptr = 0,
                         .ref = 0,
                         .parent_fn = tos3(""),
                         .mod = tos3(""),
                         .is_global = 0,
                         .is_used = 0,
                         .is_changed = 0,
                         .scope_level = 0,
                         .is_c = 0,
                         .is_moved = 0,
                         .line_nr = 0,
                         .token_idx = 0,
                         .is_for_var = 0,
                         .is_public = 0});
  compiler__Parser_next(p);
  compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
  compiler__CGen_resetln(p->cgen, tos3(""));
  string tmp = compiler__Parser_get_tmp(p);
  string tmp_elm = compiler__Parser_get_tmp(p);
  string a = p->expr_var.name;
  _V_MulRet_string_V_string _V_mret_2578_map_type_expr =
      compiler__Parser_tmp_expr(p);
  string map_type = _V_mret_2578_map_type_expr.var_0;
  string expr = _V_mret_2578_map_type_expr.var_1;
  compiler__CGen_set_placeholder(
      p->cgen, method_ph,
      string_add(_STR("\narray %.*s = new_array(0, %.*s .len, ", tmp.len,
                      tmp.str, a.len, a.str),
                 _STR("sizeof(%.*s));\n", map_type.len, map_type.str)));
  compiler__Parser_genln(
      p, _STR("for (int i = 0; i < %.*s.len; i++) {", a.len, a.str));
  compiler__Parser_genln(p, _STR("%.*s it = ((%.*s*)%.*s.data)[i];",
                                 val_type.len, val_type.str, val_type.len,
                                 val_type.str, a.len, a.str));
  compiler__Parser_genln(p, _STR("_PUSH(&%.*s, %.*s, %.*s, %.*s)", tmp.len,
                                 tmp.str, expr.len, expr.str, tmp_elm.len,
                                 tmp_elm.str, map_type.len, map_type.str));
  compiler__Parser_genln(p, tos3("}"));
  compiler__Parser_gen(p, tmp);
  compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
  compiler__Parser_close_scope(p);
  return string_add(tos3("array_"), compiler__stringify_pointer(map_type));
}
void compiler__Parser_comptime_if_block(compiler__Parser *p, string name,
                                        bool not) {
  if (not) {
    compiler__Parser_genln(p, _STR("#ifndef %.*s", name.len, name.str));
  } else {
    compiler__Parser_genln(p, _STR("#ifdef %.*s", name.len, name.str));
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
  compiler__Parser_statements_no_rcbr(p);
  if (!(p->tok == compiler__compiler__TokenKind_dollar &&
        compiler__Parser_peek(&/* ? */ *p) ==
            compiler__compiler__TokenKind_key_else)) {
    compiler__Parser_genln(p, tos3("#endif"));
  };
}
void compiler__Parser_gen_enum_flag_methods(compiler__Parser *p,
                                            compiler__Type *typ) {
  array_string tmp31 = new_array_from_c_array(
      4, 4, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 4){tos3("set"), tos3("clear"),
                                      tos3("toggle"), tos3("has")});
  for (int tmp32 = 0; tmp32 < tmp31.len; tmp32++) {
    string method = ((string *)tmp31.data)[tmp32];

    _PUSH(&typ->methods,
          (/*typ = array_compiler__Fn   tmp_typ=compiler__Fn*/ (compiler__Fn){
              .name = method,
              .typ = ((string_eq(method, tos3("has"))) ? (tos3("bool"))
                                                       : (tos3("void"))),
              .args = new_array_from_c_array(
                  2, 2, sizeof(compiler__Var),
                  EMPTY_ARRAY_OF_ELEMS(compiler__Var, 2){
                      (compiler__Var){
                          .typ = typ->name,
                          .is_mut = 1,
                          .is_arg = 1,
                          .name = tos3(""),
                          .idx = 0,
                          .is_const = 0,
                          .args = new_array(0, 1, sizeof(compiler__Var)),
                          .attr = tos3(""),
                          .is_alloc = 0,
                          .is_returned = 0,
                          .ptr = 0,
                          .ref = 0,
                          .parent_fn = tos3(""),
                          .mod = tos3(""),
                          .is_global = 0,
                          .is_used = 0,
                          .is_changed = 0,
                          .scope_level = 0,
                          .is_c = 0,
                          .is_moved = 0,
                          .line_nr = 0,
                          .token_idx = 0,
                          .is_for_var = 0,
                          .is_public = 0},
                      (compiler__Var){
                          .typ = typ->name,
                          .is_arg = 1,
                          .name = tos3(""),
                          .idx = 0,
                          .is_const = 0,
                          .args = new_array(0, 1, sizeof(compiler__Var)),
                          .attr = tos3(""),
                          .is_mut = 0,
                          .is_alloc = 0,
                          .is_returned = 0,
                          .ptr = 0,
                          .ref = 0,
                          .parent_fn = tos3(""),
                          .mod = tos3(""),
                          .is_global = 0,
                          .is_used = 0,
                          .is_changed = 0,
                          .scope_level = 0,
                          .is_c = 0,
                          .is_moved = 0,
                          .line_nr = 0,
                          .token_idx = 0,
                          .is_for_var = 0,
                          .is_public = 0}}),
              .is_method = 1,
              .is_public = 1,
              .receiver_typ = typ->name,
              .mod = tos3(""),
              .is_interface = 0,
              .scope_level = 0,
              .is_c = 0,
              .is_decl = 0,
              .is_unsafe = 0,
              .is_deprecated = 0,
              .is_variadic = 0,
              .is_generic = 0,
              .returns_error = 0,
              .defer_text = new_array(0, 1, sizeof(string)),
              .type_pars = new_array(0, 1, sizeof(string)),
              .type_inst = new_array(0, 1, sizeof(compiler__TypeInst)),
              .generic_fn_idx = 0,
              .parser_idx = 0,
              .fn_name_token_idx = 0,
              .comptime_define = tos3(""),
              .is_used = 0}),
          tmp33, compiler__Fn);
  };
  strings__Builder_writeln(
      &/* ? */ p->v->vgen_buf,
      _STR("\npub fn (e mut %.*s) set(flag %.*s)      { *e = int(*e) | (1 << "
           "int(flag)) }\npub fn (e mut %.*s) clear(flag %.*s)    { *e = "
           "int(*e) &~ (1 << int(flag)) }\npub fn (e mut %.*s) toggle(flag "
           "%.*s)   { *e = int(*e) ^ (1 << int(flag)) }\npub fn (e &%.*s) "
           "has(flag %.*s) bool { return int(*e)&(1 << int(flag)) != 0 }",
           typ->name.len, typ->name.str, typ->name.len, typ->name.str,
           typ->name.len, typ->name.str, typ->name.len, typ->name.str,
           typ->name.len, typ->name.str, typ->name.len, typ->name.str,
           typ->name.len, typ->name.str, typ->name.len, typ->name.str));
  _PUSH(&p->cgen->fns,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "void %.*s_set(%.*s *e, %.*s flag);", typ->name.len, typ->name.str,
            typ->name.len, typ->name.str, typ->name.len, typ->name.str)),
        tmp34, string);
  _PUSH(
      &p->cgen->fns,
      (/*typ = array_string   tmp_typ=string*/ _STR(
          "void %.*s_clear(%.*s *e, %.*s flag);", typ->name.len, typ->name.str,
          typ->name.len, typ->name.str, typ->name.len, typ->name.str)),
      tmp35, string);
  _PUSH(
      &p->cgen->fns,
      (/*typ = array_string   tmp_typ=string*/ _STR(
          "void %.*s_toggle(%.*s *e, %.*s flag);", typ->name.len, typ->name.str,
          typ->name.len, typ->name.str, typ->name.len, typ->name.str)),
      tmp36, string);
  _PUSH(&p->cgen->fns,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "bool %.*s_has(%.*s *e, %.*s flag);", typ->name.len, typ->name.str,
            typ->name.len, typ->name.str, typ->name.len, typ->name.str)),
        tmp37, string);
}
void compiler__OrderedDepMap_set(compiler__OrderedDepMap *o, string name,
                                 array_string deps) {
  if (!((_IN_MAP((name), o->data)))) {
    _PUSH(&o->keys, (/*typ = array_string   tmp_typ=string*/ name), tmp1,
          string);
  };
  map_set(&o->data, name, &(array_string[]){deps});
}
void compiler__OrderedDepMap_add(compiler__OrderedDepMap *o, string name,
                                 array_string deps) {
  array_string tmp2 = new_array(0, 1, sizeof(string));
  bool tmp3 = map_get(/*depgraph.v : 34*/ o->data, name, &tmp2);

  array_string d = tmp2;
  array_string tmp4 = deps;
  for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
    string dep = ((string *)tmp4.data)[tmp5];

    if (!((_IN(string, (dep), d)))) {
      _PUSH(&d, (/*typ = array_string   tmp_typ=string*/ dep), tmp6, string);
    };
  };
  compiler__OrderedDepMap_set(o, name, d);
}
array_string compiler__OrderedDepMap_get(compiler__OrderedDepMap *o,
                                         string name) {
  array_string tmp7 = new_array(0, 1, sizeof(string));
  bool tmp8 = map_get(/*depgraph.v : 44*/ o->data, name, &tmp7);

  return tmp7;
}
void compiler__OrderedDepMap_delete(compiler__OrderedDepMap *o, string name) {
  if (!((_IN_MAP((name), o->data)))) {
    v_panic(_STR("delete: no such key: %.*s", name.len, name.str));
  };
  array_string tmp9 = o->keys;
  for (int i = 0; i < tmp9.len; i++) {

    if (string_eq((*(string *)array_get(o->keys, i)), name)) {
      v_array_delete(&/* ? */ o->keys, i);
      break;
    };
  };
  v_map_delete(&/* ? */ o->data, name);
}
void compiler__OrderedDepMap_apply_diff(compiler__OrderedDepMap *o, string name,
                                        array_string deps) {
  array_string diff = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_string tmp13 = new_array(0, 1, sizeof(string));
  bool tmp14 = map_get(/*depgraph.v : 61*/ o->data, name, &tmp13);

  array_string tmp12 = tmp13;
  for (int tmp15 = 0; tmp15 < tmp12.len; tmp15++) {
    string dep = ((string *)tmp12.data)[tmp15];

    if (!((_IN(string, (dep), deps)))) {
      _PUSH(&diff, (/*typ = array_string   tmp_typ=string*/ dep), tmp16,
            string);
    };
  };
  compiler__OrderedDepMap_set(o, name, diff);
}
int compiler__OrderedDepMap_size(compiler__OrderedDepMap *o) {
  return o->data.size;
}
compiler__DepGraph *compiler__new_dep_graph() {
  return (compiler__DepGraph *)memdup(
      &(compiler__DepGraph){
          .acyclic = 1,
          .nodes = new_array(0, 1, sizeof(compiler__DepGraphNode))},
      sizeof(compiler__DepGraph));
}
void compiler__DepGraph_add(compiler__DepGraph *graph, string mod,
                            array_string deps) {
  _PUSH(
      &graph->nodes,
      (/*typ = array_compiler__DepGraphNode   tmp_typ=compiler__DepGraphNode*/ (
          compiler__DepGraphNode){.name = mod,
                                  .deps = array_clone(&/* ? */ deps)}),
      tmp17, compiler__DepGraphNode);
}
compiler__DepGraph *compiler__DepGraph_resolve(compiler__DepGraph *graph) {
  compiler__OrderedDepMap node_names =
      (compiler__OrderedDepMap){.keys = new_array(0, 1, sizeof(string)),
                                .data = new_map(1, sizeof(array_string))};
  array_compiler__DepGraphNode tmp18 = graph->nodes;
  for (int tmp19 = 0; tmp19 < tmp18.len; tmp19++) {
    compiler__DepGraphNode node = ((compiler__DepGraphNode *)tmp18.data)[tmp19];

    compiler__OrderedDepMap_add(&/* ? */ node_names, node.name, node.deps);
  };
  compiler__OrderedDepMap node_deps = node_names;
  compiler__DepGraph *resolved = compiler__new_dep_graph();
  while (compiler__OrderedDepMap_size(&/* ? */ node_deps) != 0) {

    array_string ready_set = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    array_string tmp20 = node_deps.keys;
    for (int tmp21 = 0; tmp21 < tmp20.len; tmp21++) {
      string name = ((string *)tmp20.data)[tmp21];

      array_string tmp22 = new_array(0, 1, sizeof(string));
      bool tmp23 = map_get(/*depgraph.v : 97*/ node_deps.data, name, &tmp22);

      array_string deps = tmp22;
      if (deps.len == 0) {
        _PUSH(&ready_set, (/*typ = array_string   tmp_typ=string*/ name), tmp24,
              string);
      };
    };
    if (ready_set.len == 0) {
      compiler__DepGraph *g = compiler__new_dep_graph();
      g->acyclic = 0;
      array_string tmp25 = node_deps.keys;
      for (int tmp26 = 0; tmp26 < tmp25.len; tmp26++) {
        string name = ((string *)tmp25.data)[tmp26];

        array_string tmp27 = new_array(0, 1, sizeof(string));
        bool tmp28 =
            map_get(/*depgraph.v : 105*/ node_names.data, name, &tmp27);

        compiler__DepGraph_add(g, name, tmp27);
      };
      return g;
    };
    array_string tmp29 = ready_set;
    for (int tmp30 = 0; tmp30 < tmp29.len; tmp30++) {
      string name = ((string *)tmp29.data)[tmp30];

      compiler__OrderedDepMap_delete(&/* ? */ node_deps, name);
      array_string tmp31 = new_array(0, 1, sizeof(string));
      bool tmp32 = map_get(/*depgraph.v : 111*/ node_names.data, name, &tmp31);

      compiler__DepGraph_add(resolved, name, tmp31);
    };
    array_string tmp33 = node_deps.keys;
    for (int tmp34 = 0; tmp34 < tmp33.len; tmp34++) {
      string name = ((string *)tmp33.data)[tmp34];

      compiler__OrderedDepMap_apply_diff(&/* ? */ node_deps, name, ready_set);
    };
  };
  return resolved;
}
compiler__DepGraphNode compiler__DepGraph_last_node(compiler__DepGraph *graph) {
  return (
      *(compiler__DepGraphNode *)array_get(graph->nodes, graph->nodes.len - 1));
}
string compiler__DepGraph_display(compiler__DepGraph *graph) {
  string out = tos3("\n");
  array_compiler__DepGraphNode tmp37 = graph->nodes;
  for (int tmp38 = 0; tmp38 < tmp37.len; tmp38++) {
    compiler__DepGraphNode node = ((compiler__DepGraphNode *)tmp37.data)[tmp38];

    array_string tmp39 = node.deps;
    for (int tmp40 = 0; tmp40 < tmp39.len; tmp40++) {
      string dep = ((string *)tmp39.data)[tmp40];

      out = string_add(out, _STR(" * %.*s -> %.*s\n", node.name.len,
                                 node.name.str, dep.len, dep.str));
    };
  };
  return out;
}
string compiler__DepGraph_display_cycles(compiler__DepGraph *graph) {
  map_compiler__DepGraphNode node_names =
      new_map(1, sizeof(compiler__DepGraphNode));
  array_compiler__DepGraphNode tmp41 = graph->nodes;
  for (int tmp42 = 0; tmp42 < tmp41.len; tmp42++) {
    compiler__DepGraphNode node = ((compiler__DepGraphNode *)tmp41.data)[tmp42];

    map_set(&node_names, node.name, &(compiler__DepGraphNode[]){node});
  };
  string out = tos3("\n");
  array_compiler__DepGraphNode tmp43 = graph->nodes;
  for (int tmp44 = 0; tmp44 < tmp43.len; tmp44++) {
    compiler__DepGraphNode node = ((compiler__DepGraphNode *)tmp43.data)[tmp44];

    array_string tmp45 = node.deps;
    for (int tmp46 = 0; tmp46 < tmp45.len; tmp46++) {
      string dep = ((string *)tmp45.data)[tmp46];

      if (!((_IN_MAP((dep), node_names)))) {
        continue;
      };
      compiler__DepGraphNode tmp47 = {0};
      bool tmp48 = map_get(/*depgraph.v : 146*/ node_names, dep, &tmp47);

      compiler__DepGraphNode dn = tmp47;
      if ((_IN(string, (node.name), dn.deps))) {
        out = string_add(out, _STR(" * %.*s -> %.*s\n", node.name.len,
                                   node.name.str, dep.len, dep.str));
      };
    };
  };
  return out;
}
void compiler__Parser_enum_decl(compiler__Parser *p, bool no_name) {
  bool is_pub = p->tok == compiler__compiler__TokenKind_key_pub;
  if (is_pub) {
    compiler__Parser_next(p);
    ;
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_key_enum);
  ;
  string enum_name = compiler__Parser_check_name(p);
  bool is_c = string_eq(enum_name, tos3("C")) &&
              p->tok == compiler__compiler__TokenKind_dot;
  if (is_c) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
    enum_name = compiler__Parser_check_name(p);
  };
  if (!p->builtin_mod && string_ne(p->mod, tos3("main"))) {
    enum_name = compiler__Parser_prepend_mod(&/* ? */ *p, enum_name);
  };
  ;
  compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
  int val = 0;
  array_string fields = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_string tuple_variants = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  while (p->tok == compiler__compiler__TokenKind_name) {

    string field = compiler__Parser_check_name(p);
    if (p->pass == compiler__compiler__Pass_decl &&
        p->tok != compiler__compiler__TokenKind_lpar &&
        compiler__contains_capital(field)) {
      compiler__Parser_warn(p, _STR("enum values cannot contain uppercase "
                                    "letters, use snake_case instead (`%.*s`)",
                                    field.len, field.str));
    };
    _PUSH(&fields, (/*typ = array_string   tmp_typ=string*/ field), tmp1,
          string);
    string name = _STR("%.*s__%.*s_%.*s", compiler__mod_gen_name(p->mod).len,
                       compiler__mod_gen_name(p->mod).str, enum_name.len,
                       enum_name.str, field.len, field.str);
    if (p->tok == compiler__compiler__TokenKind_assign) {
      ;
      int enum_assign_tidx = compiler__Parser_cur_tok_index(&/* ? */ *p);
      compiler__TokenKind next = compiler__Parser_peek(&/* ? */ *p);
      if ((next == compiler__compiler__TokenKind_number ||
           next == compiler__compiler__TokenKind_minus)) {
        compiler__Parser_next(p);
        ;
        bool is_neg = p->tok == compiler__compiler__TokenKind_minus;
        if (is_neg) {
          compiler__Parser_next(p);
        };
        val = v_string_int(p->lit);
        if (is_neg) {
          val = -val;
        };
        compiler__Parser_next(p);
      } else {
        compiler__Parser_next(p);
        enum_assign_tidx = compiler__Parser_cur_tok_index(&/* ? */ *p);
        compiler__Parser_error_with_token_index(
            p, tos3("only numbers are allowed in enum initializations"),
            enum_assign_tidx);
      };
    } else if (p->tok == compiler__compiler__TokenKind_lpar) {
      if (!byte_is_capital(string_at(field, 0))) {
        compiler__Parser_error(p, tos3("sum types must be capitalized"));
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
      _PUSH(&tuple_variants,
            (/*typ = array_string   tmp_typ=string*/ compiler__Parser_get_type(
                p)),
            tmp4, string);
      compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
      if (p->pass == compiler__compiler__Pass_main) {
        _PUSH(&p->cgen->consts,
              (/*typ = array_string   tmp_typ=string*/ _STR(
                  "#define %.*s_type %d // LOL", field.len, field.str, val)),
              tmp5, string);
      };
    };
    if (p->pass == compiler__compiler__Pass_main) {
      _PUSH(&p->cgen->consts,
            (/*typ = array_string   tmp_typ=string*/ _STR(
                "#define %.*s %d", name.len, name.str, val)),
            tmp6, string);
    };
    if (p->tok == compiler__compiler__TokenKind_comma) {
      compiler__Parser_next(p);
      ;
    };
    ;
    val++;
  };
  bool is_flag = string_eq(p->attr, tos3("flag"));
  if (is_flag && fields.len > 32) {
    compiler__Parser_error(p, tos3("when an enum is used as bit field, it must "
                                   "have a max of 32 fields"));
  };
  compiler__Type T =
      (compiler__Type){.name = enum_name,
                       .mod = p->mod,
                       .parent = tos3("int"),
                       .cat = compiler__compiler__TypeCategory_enum_,
                       .enum_vals = array_clone(&/* ? */ fields),
                       .is_public = is_pub,
                       .is_flag = is_flag,
                       .fields = new_array(0, 1, sizeof(compiler__Var)),
                       .methods = new_array(0, 1, sizeof(compiler__Fn)),
                       .is_c = 0,
                       .gen_types = new_array(0, 1, sizeof(string)),
                       .default_vals = new_array(0, 1, sizeof(string)),
                       .parser_idx = 0,
                       .decl_tok_idx = 0,
                       .is_placeholder = 0,
                       .gen_str = 0,
                       .is_generic = 0,
                       .ctype_names = new_array(0, 1, sizeof(string))};
  map_set(&p->table->tuple_variants, enum_name,
          &(array_string[]){tuple_variants});
  if (is_flag && !compiler__Parser_first_pass(&/* ? */ *p)) {
    compiler__Parser_gen_enum_flag_methods(p, &/*114*/ T);
  };
  if (p->pass == compiler__compiler__Pass_decl || is_flag) {
    compiler__Table_register_type(p->table, T);
  };
  if (tuple_variants.len > 0 && p->pass == compiler__compiler__Pass_main) {
    _PUSH(&p->cgen->typedefs,
          (/*typ = array_string   tmp_typ=string*/ _STR(
              "typedef struct {\nvoid* obj;\nint typ;\n} %.*s;\n",
              enum_name.len, enum_name.str)),
          tmp7, string);
  } else if (!no_name && !compiler__Parser_first_pass(&/* ? */ *p)) {
    _PUSH(&p->cgen->typedefs,
          (/*typ = array_string   tmp_typ=string*/ _STR(
              "typedef int %.*s;", enum_name.len, enum_name.str)),
          tmp8, string);
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
  ;
  ;
  if (!no_name && fields.len == 0) {
    compiler__Parser_error(p, tos3("Empty enums are not allowed."));
  };
}
void compiler__Parser_check_enum_member_access(compiler__Parser *p) {
  if (string_starts_with(p->expected_type, tos3("Option_"))) {
    p->expected_type = string_substr2(p->expected_type, 7, -1, true);
  };
  compiler__Type tt = compiler__Parser_find_type(&/* ? */ *p, p->expected_type);
  if (tt.cat == compiler__compiler__TypeCategory_enum_) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
    string val = compiler__Parser_check_name(p);
    if (!compiler__Type_has_enum_val(&/* ? */ tt, val)) {
      compiler__Parser_error(p,
                             _STR("enum `%.*s` does not have value `%.*s`",
                                  tt.name.len, tt.name.str, val.len, val.str));
    };
    compiler__Parser_gen(
        p, string_add(
               string_add(string_add(string_add(compiler__mod_gen_name(tt.mod),
                                                tos3("__")),
                                     p->expected_type),
                          tos3("_")),
               val));
  } else {
    compiler__Parser_error(
        p, _STR("`%.*s` is not an enum", tt.name.len, tt.name.str));
  };
}
string compiler__Parser_bool_expression(compiler__Parser *p) {
  int start_ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
  string expected = p->expected_type;
  compiler__TokenKind tok = p->tok;
  string typ = compiler__Parser_bterm(p);
  bool got_and = 0;
  bool got_or = 0;
  while (p->tok == compiler__compiler__TokenKind_and ||
         p->tok == compiler__compiler__TokenKind_logical_or) {

    if (p->tok == compiler__compiler__TokenKind_and) {
      got_and = 1;
      if (got_or) {
        compiler__Parser_error(p, compiler__and_or_error);
      };
    };
    if (p->tok == compiler__compiler__TokenKind_logical_or) {
      got_or = 1;
      if (got_and) {
        compiler__Parser_error(p, compiler__and_or_error);
      };
    };
    if (p->is_sql) {
      if (p->tok == compiler__compiler__TokenKind_and) {
        compiler__Parser_gen(p, tos3(" and "));
      } else if (p->tok == compiler__compiler__TokenKind_logical_or) {
        compiler__Parser_gen(p, tos3(" or "));
      };
    } else {
      compiler__Parser_gen(p,
                           _STR(" %.*s ", compiler__TokenKind_str(p->tok).len,
                                compiler__TokenKind_str(p->tok).str));
    };
    compiler__Parser_check_space(p, p->tok);
    compiler__Parser_check_types(p, compiler__Parser_bterm(p), typ);
    if (string_ne(typ, tos3("bool"))) {
      compiler__Parser_error(
          p, tos3("logical operators `&&` and `||` require booleans"));
    };
  };
  if (string_eq(typ, tos3(""))) {
    println(tos3("curline:"));
    println(p->cgen->cur_line);
    println(compiler__TokenKind_str(tok));
    compiler__Parser_error(p, tos3("expr() returns empty type"));
  };
  if (p->inside_return_expr &&
      string_contains(p->expected_type, tos3("_MulRet_"))) {
    expected = p->expected_type;
  };
  if (string_ne(expected, typ) && string_ends_with(expected, tos3("er")) &&
      string_contains(expected, tos3("I"))) {
    string tt = string_replace(typ, tos3("*"), tos3("_ptr"));
    compiler__CGen_set_placeholder(
        p->cgen, start_ph,
        _STR(
            "(%.*s) { ._interface_idx = /* :) */ _%.*s_%.*s_index, ._object = ",
            expected.len, expected.str, expected.len, expected.str, tt.len,
            tt.str));
    compiler__Parser_gen(p, tos3("}"));
  };
  if (string_ne(expected, typ) && (_IN_MAP((expected), p->table->sum_types))) {
    array_string tmp1 = new_array(0, 1, sizeof(string));
    bool tmp2 =
        map_get(/*expression.v : 68*/ p->table->sum_types, expected, &tmp1);

    if ((_IN(string, (typ), tmp1))) {
      compiler__CGen_set_placeholder(
          p->cgen, start_ph,
          _STR("/*SUM TYPE CAST2*/ (%.*s) { .obj = memdup( &(%.*s[]) { ",
               expected.len, expected.str, typ.len, typ.str));
      string tt = string_all_after(typ, tos3("_"));
      compiler__Parser_gen(
          p, _STR("}, sizeof(%.*s) ), .typ = SumType_%.*s_%.*s }", typ.len,
                  typ.str, expected.len, expected.str, tt.len, tt.str));
    };
  };
  if (p->tok == compiler__compiler__TokenKind_key_as) {
    return compiler__Parser_key_as(p, typ, start_ph);
  };
  return typ;
}
string compiler__Parser_key_as(compiler__Parser *p, string typ, int start_ph) {
  ;
  compiler__Parser_next(p);
  ;
  string cast_typ = compiler__Parser_get_type(p);
  if (string_eq(typ, cast_typ)) {
    compiler__Parser_error(p,
                           _STR("casting `%.*s` to `%.*s` is not needed",
                                typ.len, typ.str, cast_typ.len, cast_typ.str));
  };
  if ((_IN_MAP((typ), p->table->sum_types))) {
    array_string tmp3 = new_array(0, 1, sizeof(string));
    bool tmp4 = map_get(/*expression.v : 91*/ p->table->sum_types, typ, &tmp3);

    if (!((_IN(string, (cast_typ), tmp3)))) {
      compiler__Parser_error(
          p,
          _STR(
              "cannot cast `%.*s` to `%.*s`. `%.*s` is not a variant of `%.*s`",
              typ.len, typ.str, cast_typ.len, cast_typ.str, cast_typ.len,
              cast_typ.str, typ.len, typ.str));
    };
    compiler__CGen_set_placeholder(
        p->cgen, start_ph, _STR("*(%.*s*)", cast_typ.len, cast_typ.str));
    compiler__Parser_gen(p, tos3(".obj"));
  } else {
    compiler__Parser_error(
        p,
        tos3("`as` casts have been removed, use the old syntax: `Type(val)`"));
  };
  return cast_typ;
}
string compiler__Parser_bterm(compiler__Parser *p) {
  int ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
  string typ = compiler__Parser_expression(p);
  p->expected_type = typ;
  bool is_str = string_eq(typ, tos3("string")) && !p->is_sql;
  bool is_ustr = string_eq(typ, tos3("ustring"));
  string base = compiler__Parser_base_type(p, typ);
  bool is_float =
      string_at(base, 0) == 'f' &&
      ((string_eq(base, tos3("f64")) || string_eq(base, tos3("f32")))) &&
      !((string_eq(p->cur_fn.name, tos3("f64_abs")) ||
         string_eq(p->cur_fn.name, tos3("f32_abs")))) &&
      string_ne(p->cur_fn.name, tos3("eq"));
  bool is_array = string_starts_with(typ, tos3("array_"));
  string expr_type = base;
  compiler__TokenKind tok = p->tok;
  if ((tok == compiler__compiler__TokenKind_eq ||
       tok == compiler__compiler__TokenKind_gt ||
       tok == compiler__compiler__TokenKind_lt ||
       tok == compiler__compiler__TokenKind_le ||
       tok == compiler__compiler__TokenKind_ge ||
       tok == compiler__compiler__TokenKind_ne)) {
    if (is_array) {
      compiler__Parser_error(p, tos3("array comparison is not supported yet"));
    };
    ;
    if ((is_float || is_str || is_ustr) && !p->is_js) {
      compiler__Parser_gen(p, tos3(","));
    } else if (p->is_sql && tok == compiler__compiler__TokenKind_eq) {
      compiler__Parser_gen(p, tos3("="));
    } else {
      compiler__Parser_gen(p, compiler__TokenKind_str(tok));
    };
    compiler__Parser_next(p);
    ;
    if (p->is_sql) {
      p->sql_i++;
      compiler__Parser_gen(p, string_add(tos3("$"), int_str(p->sql_i)));
      compiler__CGen_start_cut(p->cgen);
      compiler__Parser_check_types(p, compiler__Parser_expression(p), typ);
      string sql_param = compiler__CGen_cut(p->cgen);
      _PUSH(&p->sql_params, (/*typ = array_string   tmp_typ=string*/ sql_param),
            tmp7, string);
      _PUSH(&p->sql_types, (/*typ = array_string   tmp_typ=string*/ typ), tmp8,
            string);
    } else {
      compiler__Parser_check_types(p, compiler__Parser_expression(p), typ);
    };
    typ = tos3("bool");
    if (is_str && !p->is_js) {
      compiler__Parser_gen(p, tos3(")"));
      compiler__TokenKind tmp9 = tok;

      if (tmp9 == compiler__compiler__TokenKind_eq) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("string_eq("));
      } else if (tmp9 == compiler__compiler__TokenKind_ne) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("string_ne("));
      } else if (tmp9 == compiler__compiler__TokenKind_le) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("string_le("));
      } else if (tmp9 == compiler__compiler__TokenKind_ge) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("string_ge("));
      } else if (tmp9 == compiler__compiler__TokenKind_gt) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("string_gt("));
      } else if (tmp9 == compiler__compiler__TokenKind_lt) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("string_lt("));
      } else // default:
      {
      };
    };
    if (is_ustr) {
      compiler__Parser_gen(p, tos3(")"));
      compiler__TokenKind tmp10 = tok;

      if (tmp10 == compiler__compiler__TokenKind_eq) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("ustring_eq("));
      } else if (tmp10 == compiler__compiler__TokenKind_ne) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("ustring_ne("));
      } else if (tmp10 == compiler__compiler__TokenKind_le) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("ustring_le("));
      } else if (tmp10 == compiler__compiler__TokenKind_ge) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("ustring_ge("));
      } else if (tmp10 == compiler__compiler__TokenKind_gt) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("ustring_gt("));
      } else if (tmp10 == compiler__compiler__TokenKind_lt) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("ustring_lt("));
      } else // default:
      {
      };
    };
    if (is_float && string_ne(p->cur_fn.name, tos3("f32_abs")) &&
        string_ne(p->cur_fn.name, tos3("f64_abs"))) {
      compiler__Parser_gen(p, tos3(")"));
      compiler__TokenKind tmp11 = tok;

      if (tmp11 == compiler__compiler__TokenKind_eq) {
        compiler__CGen_set_placeholder(
            p->cgen, ph, _STR("%.*s_eq(", expr_type.len, expr_type.str));
      } else if (tmp11 == compiler__compiler__TokenKind_ne) {
        compiler__CGen_set_placeholder(
            p->cgen, ph, _STR("%.*s_ne(", expr_type.len, expr_type.str));
      } else if (tmp11 == compiler__compiler__TokenKind_le) {
        compiler__CGen_set_placeholder(
            p->cgen, ph, _STR("macro_%.*s_le(", expr_type.len, expr_type.str));
      } else if (tmp11 == compiler__compiler__TokenKind_ge) {
        compiler__CGen_set_placeholder(
            p->cgen, ph, _STR("macro_%.*s_ge(", expr_type.len, expr_type.str));
      } else if (tmp11 == compiler__compiler__TokenKind_gt) {
        compiler__CGen_set_placeholder(
            p->cgen, ph, _STR("macro_%.*s_gt(", expr_type.len, expr_type.str));
      } else if (tmp11 == compiler__compiler__TokenKind_lt) {
        compiler__CGen_set_placeholder(
            p->cgen, ph, _STR("macro_%.*s_lt(", expr_type.len, expr_type.str));
      } else // default:
      {
      };
    };
  };
  return typ;
}
string compiler__Parser_name_expr(compiler__Parser *p) {
  p->has_immutable_field = 0;
  p->is_const_literal = 0;
  int ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
  bool ptr = p->tok == compiler__compiler__TokenKind_amp;
  bool deref = p->tok == compiler__compiler__TokenKind_mul;
  int mul_nr = 0;
  int deref_nr = 0;
  while (1) {
    if (p->tok == compiler__compiler__TokenKind_amp) {
      mul_nr++;
    } else if (p->tok == compiler__compiler__TokenKind_mul) {
      deref_nr++;
    } else {
      break;
    };
    compiler__Parser_next(p);
  };
  if (p->tok == compiler__compiler__TokenKind_lpar) {
    compiler__Parser_gen(p, string_repeat(tos3("*"), deref_nr));
    compiler__Parser_gen(p, tos3("("));
    compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
    string temp_type = compiler__Parser_bool_expression(p);
    compiler__Parser_gen(p, tos3(")"));
    compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
    int tmp12 = 0;
    ;
    for (int tmp13 = tmp12; tmp13 < deref_nr; tmp13++) {

      temp_type = string_replace_once(temp_type, tos3("*"), tos3(""));
    };
    return temp_type;
  };
  string name = p->lit;
  if (string_eq(name, tos3("_"))) {
    compiler__Parser_error(p, tos3("cannot use `_` as value"));
  };
  if ((_IN(string, (name), map_keys(&/* ? */ p->generic_dispatch.inst)))) {
    string tmp14 = tos3("");
    bool tmp15 =
        map_get(/*expression.v : 286*/ p->generic_dispatch.inst, name, &tmp14);

    if (!tmp15)
      tmp14 = tos((byte *)"", 0);

    name = tmp14;
  };
  if (string_eq(name, tos3("r")) &&
      compiler__Parser_peek(&/* ? */ *p) ==
          compiler__compiler__TokenKind_string &&
      p->prev_tok != compiler__compiler__TokenKind_str_dollar) {
    compiler__Parser_string_expr(p);
    return tos3("string");
  };
  if (string_eq(name, tos3("c")) &&
      compiler__Parser_peek(&/* ? */ *p) ==
          compiler__compiler__TokenKind_string &&
      p->prev_tok != compiler__compiler__TokenKind_str_dollar) {
    compiler__Parser_string_expr(p);
    return tos3("charptr");
  };
  string orig_name = name;
  bool is_c =
      string_eq(name, tos3("C")) &&
      compiler__Parser_peek(&/* ? */ *p) == compiler__compiler__TokenKind_dot;
  if (is_c) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_name);
    compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
    name = p->lit;
    if (compiler__Parser_peek(&/* ? */ *p) ==
            compiler__compiler__TokenKind_lcbr &&
        string_eq(p->expected_type, tos3(""))) {
      if (!compiler__Table_known_type(&/* ? */ *p->table, name)) {
        compiler__Parser_error(
            p, string_add(_STR("unknown C type `%.*s`, ", name.len, name.str),
                          _STR("define it with `struct C.%.*s { ... }`",
                               name.len, name.str)));
      };
      return compiler__Parser_get_struct_type(p, name, 1, ptr);
    };
    if (ptr && compiler__Parser_peek(&/* ? */ *p) ==
                   compiler__compiler__TokenKind_lpar) {
      compiler__Token peek2 =
          (*(compiler__Token *)array_get(p->tokens, p->token_idx + 1));
      if (peek2.tok == compiler__compiler__TokenKind_number &&
          string_eq(peek2.lit, tos3("0"))) {
        compiler__CGen_insert_before(p->cgen, tos3("struct /*C.Foo(0)*/ "));
        compiler__Parser_gen(p, tos3("0"));
        compiler__Parser_next(p);
        compiler__Parser_next(p);
        compiler__Parser_next(p);
        compiler__Parser_next(p);
        return string_add(name, tos3("*"));
      };
      compiler__Parser_cast(p, string_add(name, tos3("*")));
      return string_add(name, tos3("*"));
    };
    if (compiler__Parser_peek(&/* ? */ *p) ==
        compiler__compiler__TokenKind_lpar) {
      return compiler__Parser_get_c_func_type(p, name);
    };
    compiler__Parser_gen(p, name);
    compiler__Parser_next(p);
    return tos3("int");
  };
  if (p->tok == compiler__compiler__TokenKind_dot) {
    if (compiler__Table_known_type(&/* ? */ *p->table, p->expected_type)) {
      compiler__Parser_check_enum_member_access(p);
      return p->expected_type;
    } else {
      compiler__Parser_error(p,
                             _STR("unknown enum: `%.*s`", p->expected_type.len,
                                  p->expected_type.str));
    };
  };
  if (compiler__Parser_known_var_check_new_var(&/* ? */ *p, name)) {
    return compiler__Parser_get_var_type(p, name, ptr, deref_nr);
  };
  if (compiler__Parser_peek(&/* ? */ *p) == compiler__compiler__TokenKind_dot &&
      (string_eq(name, p->mod) ||
       compiler__ImportTable_known_alias(&/* ? */ p->import_table, name)) &&
      !is_c) {
    string mod = name;
    if (string_ne(name, p->mod) &&
        compiler__ImportTable_known_alias(&/* ? */ p->import_table, name)) {
      compiler__ImportTable_register_used_import(&/* ? */ p->import_table,
                                                 name);
      mod = compiler__ImportTable_resolve_alias(&/* ? */ p->import_table, name);
    };
    compiler__Parser_next(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
    name = p->lit;
    name = compiler__prepend_mod(compiler__mod_gen_name(mod), name);
  } else if (!compiler__Table_known_type(&/* ? */ *p->table, name) &&
             !compiler__Table_known_fn(&/* ? */ *p->table, name) &&
             !compiler__Table_known_const(&/* ? */ *p->table, name) && !is_c) {
    name = compiler__Parser_prepend_mod(&/* ? */ *p, name);
  };
  if (compiler__Parser_known_var_check_new_var(&/* ? */ *p, name)) {
    return compiler__Parser_get_var_type(p, name, ptr, deref_nr);
  };
  if (compiler__Table_known_type(&/* ? */ *p->table, name)) {
    if (compiler__Parser_peek(&/* ? */ *p) ==
            compiler__compiler__TokenKind_lpar ||
        (deref && compiler__Parser_peek(&/* ? */ *p) ==
                      compiler__compiler__TokenKind_rpar)) {
      if (deref) {
        name = string_add(name, string_repeat(tos3("*"), deref_nr));
      } else if (ptr) {
        name = string_add(name, string_repeat(tos3("*"), mul_nr));
      };
      string typ = name;
      compiler__Parser_cast(p, typ);
      while (p->tok == compiler__compiler__TokenKind_dot) {

        typ = compiler__Parser_dot(p, typ, ph);
      };
      return typ;
    } else if (compiler__Parser_peek(&/* ? */ *p) ==
               compiler__compiler__TokenKind_dot) {
      bool is_arr_start = p->prev_tok == compiler__compiler__TokenKind_lsbr;
      compiler__Type enum_type =
          compiler__Table_find_type(&/* ? */ *p->table, name);
      if (enum_type.cat != compiler__compiler__TypeCategory_enum_) {
        compiler__Parser_error(
            p, _STR("`%.*s` is not an enum", name.len, name.str));
      };
      compiler__Parser_next(p);
      compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
      string val = p->lit;
      if (!compiler__Type_has_enum_val(&/* ? */ enum_type, val)) {
        compiler__Parser_error(p, _STR("enum `%.*s` does not have value `%.*s`",
                                       enum_type.name.len, enum_type.name.str,
                                       val.len, val.str));
      };
      if (string_eq(p->expected_type, enum_type.name) && !is_arr_start) {
        compiler__Parser_warn(p, _STR("`%.*s.%.*s` is unnecessary, use `.%.*s`",
                                      enum_type.name.len, enum_type.name.str,
                                      val.len, val.str, val.len, val.str));
      };
      if (byte_is_capital(string_at(val, 0))) {
        compiler__Parser_next(p);
        compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
        int idx = 0;
        array_string tmp20 = enum_type.enum_vals;
        for (int i = 0; i < tmp20.len; i++) {
          string val_ = ((string *)tmp20.data)[i];

          if (string_eq(val_, val)) {
            idx = i;
          };
        };
        array_string tmp21 = new_array(0, 1, sizeof(string));
        bool tmp22 = map_get(/*expression.v : 432*/ p->table->tuple_variants,
                             enum_type.name, &tmp21);

        array_string q = tmp21;
        string arg_type = (*(string *)array_get(q, idx));
        compiler__Parser_gen(p, _STR("(%.*s) { .obj = (%.*s[]) { ",
                                     enum_type.name.len, enum_type.name.str,
                                     arg_type.len, arg_type.str));
        compiler__Parser_bool_expression(p);
        compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
        compiler__Parser_gen(p,
                             _STR("}, .typ = %.*s_type }", val.len, val.str));
        return enum_type.name;
      };
      compiler__Parser_gen(
          p, string_add(string_add(string_add(string_add(compiler__mod_gen_name(
                                                             enum_type.mod),
                                                         tos3("__")),
                                              enum_type.name),
                                   tos3("_")),
                        val));
      compiler__Parser_next(p);
      return enum_type.name;
    } else if (compiler__Parser_peek(&/* ? */ *p) ==
                   compiler__compiler__TokenKind_lcbr ||
               compiler__Parser_peek(&/* ? */ *p) ==
                   compiler__compiler__TokenKind_lt) {
      return compiler__Parser_get_struct_type(p, name, 0, ptr);
    };
  };
  if (compiler__Table_known_const(&/* ? */ *p->table, name)) {
    return compiler__Parser_get_const_type(p, name, ptr);
  };
  Option_compiler__Fn tmp25 =
      compiler__Table_find_fn_is_script(&/* ? */ *p->table, name, p->v_script);
  compiler__Fn f;
  if (!tmp25.ok) {
    string err = tmp25.error;
    int errcode = tmp25.ecode;
    if (compiler__Parser_first_pass(&/* ? */ *p)) {
      compiler__Parser_next(p);
      return tos3("void");
    };
    compiler__Parser_undefined_error(p, name, orig_name);
    return tos3("");
  }
  f = *(compiler__Fn *)tmp25.data;
  ;
  compiler__TokenKind peek = compiler__Parser_peek(&/* ? */ *p);
  if (peek != compiler__compiler__TokenKind_lpar &&
      peek != compiler__compiler__TokenKind_lt) {
    compiler__Type fn_typ =
        (compiler__Type){.name = compiler__Fn_typ_str(&/* ? */ f),
                         .mod = p->mod,
                         .func = f,
                         .is_public = 0,
                         .fields = new_array(0, 1, sizeof(compiler__Var)),
                         .methods = new_array(0, 1, sizeof(compiler__Fn)),
                         .parent = tos3(""),
                         .is_c = 0,
                         .enum_vals = new_array(0, 1, sizeof(string)),
                         .gen_types = new_array(0, 1, sizeof(string)),
                         .default_vals = new_array(0, 1, sizeof(string)),
                         .parser_idx = 0,
                         .decl_tok_idx = 0,
                         .is_placeholder = 0,
                         .gen_str = 0,
                         .is_flag = 0,
                         .is_generic = 0,
                         .ctype_names = new_array(0, 1, sizeof(string))};
    compiler__Table_register_type(p->table, fn_typ);
    compiler__Parser_gen(p, compiler__Table_fn_gen_name(p->table, &/*114*/ f));
    compiler__Parser_next(p);
    return compiler__Fn_typ_str(&/* ? */ f);
  };
  if (string_eq(f.typ, tos3("void")) && !p->inside_if_expr) {
  };
  int fn_call_ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
  compiler__Fn new_f = f;
  compiler__Parser_fn_call(p, &/*114*/ new_f, 0, tos3(""), tos3(""));
  if (f.is_generic) {
    Option_compiler__Fn tmp26 =
        compiler__Table_find_fn(&/* ? */ *p->table, f.name);
    if (!tmp26.ok) {
      string err = tmp26.error;
      int errcode = tmp26.ecode;
      return tos3("");
    };
  };
  f = new_f;
  bool is_or_else = p->tok == compiler__compiler__TokenKind_key_orelse;
  if (p->tok == compiler__compiler__TokenKind_question) {
    return compiler__Parser_gen_handle_question_suffix(p, f, fn_call_ph);
  } else if (!p->is_var_decl && is_or_else) {
    f.typ = compiler__Parser_gen_handle_option_or_else(p, f.typ, tos3(""),
                                                       fn_call_ph);
  } else if (!p->is_var_decl && !is_or_else && !p->inside_return_expr &&
             string_starts_with(f.typ, tos3("Option_"))) {
    string opt_type = string_replace(string_substr2(f.typ, 7, -1, true),
                                     tos3("ptr_"), tos3("&"));
    compiler__Parser_error(
        p, _STR("unhandled option type: `?%.*s`", opt_type.len, opt_type.str));
  };
  if (p->tok == compiler__compiler__TokenKind_dot) {
    string typ = tos3("");
    while (p->tok == compiler__compiler__TokenKind_dot) {

      typ = compiler__Parser_dot(p, f.typ, ph);
    };
    return typ;
  };
  if (string_ends_with(f.typ, tos3("*"))) {
    p->is_alloc = 1;
  };
  return f.typ;
}
string compiler__Parser_expression(compiler__Parser *p) {
  p->is_const_literal = 1;
  int ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
  string typ = compiler__Parser_indot_expr(p);
  bool is_str = string_eq(typ, tos3("string"));
  bool is_ustr = string_eq(typ, tos3("ustring"));
  if (p->tok == compiler__compiler__TokenKind_left_shift) {
    if (string_contains(typ, tos3("array_"))) {
      string tmp = compiler__Parser_get_tmp(p);
      string tmp_typ =
          compiler__parse_pointer(string_substr2(typ, 6, -1, true));
      p->expected_type = tmp_typ;
      compiler__Parser_check_space(p, compiler__compiler__TokenKind_left_shift);
      compiler__Parser_gen(p, tos3(", ("));
      if (!p->expr_var.is_mut && !p->pref->translated) {
        compiler__Parser_error(p, _STR("`%.*s` is immutable (can\'t <<)",
                                       p->expr_var.name.len,
                                       p->expr_var.name.str));
      };
      if (p->expr_var.is_arg &&
          string_starts_with(p->expr_var.typ, tos3("array_"))) {
        compiler__Parser_error(
            p, string_add(
                   tos3("for now it's not possible to append an element to "),
                   _STR("a mutable array argument `%.*s`", p->expr_var.name.len,
                        p->expr_var.name.str)));
      };
      if (!p->expr_var.is_changed) {
        compiler__Parser_mark_var_changed(p, p->expr_var);
      };
      compiler__Parser_gen(p, _STR("/*typ = %.*s   tmp_typ=%.*s*/", typ.len,
                                   typ.str, tmp_typ.len, tmp_typ.str));
      int ph_clone = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
      string expr_type = compiler__Parser_bool_expression(p);
      if (p->pref->autofree && string_eq(typ, tos3("array_string")) &&
          string_eq(expr_type, tos3("string"))) {
        compiler__CGen_set_placeholder(p->cgen, ph_clone,
                                       tos3("string_clone("));
        compiler__Parser_gen(p, tos3(")"));
      };
      compiler__Parser_gen_array_push(p, ph, typ, expr_type, tmp, tmp_typ);
      return tos3("void");
    } else {
      if (!compiler__is_integer_type(typ)) {
        compiler__Type t = compiler__Table_find_type(&/* ? */ *p->table, typ);
        if (t.cat != compiler__compiler__TypeCategory_enum_) {
          compiler__Parser_error(
              p, _STR("cannot use shift operator on non-integer type `%.*s`",
                      typ.len, typ.str));
        };
      };
      compiler__Parser_next(p);
      compiler__Parser_gen(p, tos3(" << "));
      compiler__Parser_check_types(p, compiler__Parser_expression(p),
                                   tos3("integer"));
      return typ;
    };
  };
  if (p->tok == compiler__compiler__TokenKind_righ_shift) {
    if (!compiler__is_integer_type(typ)) {
      compiler__Type t = compiler__Table_find_type(&/* ? */ *p->table, typ);
      if (t.cat != compiler__compiler__TypeCategory_enum_) {
        compiler__Parser_error(
            p, _STR("cannot use shift operator on non-integer type `%.*s`",
                    typ.len, typ.str));
      };
    };
    compiler__Parser_next(p);
    compiler__Parser_gen(p, tos3(" >> "));
    compiler__Parser_check_types(p, compiler__Parser_expression(p),
                                 tos3("integer"));
    return typ;
  };
  while ((p->tok == compiler__compiler__TokenKind_plus ||
          p->tok == compiler__compiler__TokenKind_minus ||
          p->tok == compiler__compiler__TokenKind_pipe ||
          p->tok == compiler__compiler__TokenKind_amp ||
          p->tok == compiler__compiler__TokenKind_xor)) {

    compiler__TokenKind tok_op = p->tok;
    if (string_eq(typ, tos3("bool"))) {
      compiler__Parser_error(p, _STR("operator %.*s not defined on bool ",
                                     compiler__TokenKind_str(p->tok).len,
                                     compiler__TokenKind_str(p->tok).str));
    };
    bool is_num = string_contains(typ, tos3("*")) ||
                  compiler__is_number_type(typ) ||
                  compiler__is_number_type(compiler__Parser_base_type(p, typ));
    compiler__Parser_check_space(p, p->tok);
    if (is_str && tok_op == compiler__compiler__TokenKind_plus && !p->is_js) {
      p->is_alloc = 1;
      compiler__CGen_set_placeholder(p->cgen, ph, tos3("string_add("));
      compiler__Parser_gen(p, tos3(","));
    } else if (is_ustr && tok_op == compiler__compiler__TokenKind_plus) {
      compiler__CGen_set_placeholder(p->cgen, ph, tos3("ustring_add("));
      compiler__Parser_gen(p, tos3(","));
    } else if (is_num || p->is_js) {
      if (string_eq(typ, tos3("void*"))) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("(byte*)"));
      } else if (string_contains(typ, tos3("*"))) {
        compiler__CGen_set_placeholder(p->cgen, ph,
                                       _STR("(%.*s)", typ.len, typ.str));
      };
      compiler__Parser_gen(p, compiler__TokenKind_str(tok_op));
    } else {
      if (p->pref->translated) {
        compiler__Parser_gen(p, string_add(compiler__TokenKind_str(tok_op),
                                           tos3(" /*doom hack*/")));
      } else {
        compiler__Parser_gen(p, tos3(","));
      };
    };
    if (is_str && tok_op != compiler__compiler__TokenKind_plus) {
      compiler__Parser_error(p, tos3("strings only support `+` operator"));
    };
    string expr_type = compiler__Parser_term(p);
    bool open = tok_op == compiler__compiler__TokenKind_amp &&
                (p->tok == compiler__compiler__TokenKind_eq ||
                 p->tok == compiler__compiler__TokenKind_ne);
    if ((tok_op == compiler__compiler__TokenKind_pipe ||
         tok_op == compiler__compiler__TokenKind_amp ||
         tok_op == compiler__compiler__TokenKind_xor)) {
      if (!(compiler__is_integer_type(expr_type) &&
            compiler__is_integer_type(typ))) {
        compiler__Parser_error(
            p, _STR("operator %.*s is defined only on integer types",
                    compiler__TokenKind_str(tok_op).len,
                    compiler__TokenKind_str(tok_op).str));
      };
    };
    if (open) {
      compiler__CGen_set_placeholder(p->cgen, ph, tos3("("));
    };
    compiler__Parser_check_types(p, expr_type, typ);
    if ((is_str || is_ustr) && tok_op == compiler__compiler__TokenKind_plus &&
        !p->is_js) {
      compiler__Parser_gen(p, tos3(")"));
    };
    if (open) {
      compiler__Parser_gen(p, tos3(")"));
    };
    if (!p->pref->translated && !is_str && !is_ustr && !is_num) {
      compiler__Type T = compiler__Table_find_type(&/* ? */ *p->table, typ);
      if (tok_op == compiler__compiler__TokenKind_plus) {
        compiler__Parser_handle_operator(p, tos3("+"), typ, tos3("op_plus"), ph,
                                         &/*114*/ T);
      } else if (tok_op == compiler__compiler__TokenKind_minus) {
        compiler__Parser_handle_operator(p, tos3("-"), typ, tos3("op_minus"),
                                         ph, &/*114*/ T);
      };
    };
  };
  if (p->tok == compiler__compiler__TokenKind_key_as) {
    return compiler__Parser_key_as(p, typ, ph);
  };
  return typ;
}
void compiler__Parser_handle_operator(compiler__Parser *p, string op,
                                      string typ, string cpostfix, int ph,
                                      compiler__Type *tt) {
  if (compiler__Type_has_method(&/* ? */ *tt, op)) {
    compiler__CGen_set_placeholder(
        p->cgen, ph,
        _STR("%.*s_%.*s(", typ.len, typ.str, cpostfix.len, cpostfix.str));
    compiler__Parser_gen(p, tos3(")"));
  } else {
    compiler__Parser_error(p, _STR("operator %.*s not defined on `%.*s`",
                                   op.len, op.str, typ.len, typ.str));
  };
}
string compiler__Parser_term(compiler__Parser *p) {
  int line_nr = p->scanner->line_nr;
  int ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
  string typ = compiler__Parser_unary(p);
  if (p->tok == compiler__compiler__TokenKind_mul &&
      line_nr != p->scanner->line_nr) {
    return typ;
  };
  while ((p->tok == compiler__compiler__TokenKind_mul ||
          p->tok == compiler__compiler__TokenKind_div ||
          p->tok == compiler__compiler__TokenKind_mod)) {

    compiler__TokenKind tok = p->tok;
    bool is_mul = tok == compiler__compiler__TokenKind_mul;
    bool is_div = tok == compiler__compiler__TokenKind_div;
    bool is_mod = tok == compiler__compiler__TokenKind_mod;
    ;
    compiler__Parser_next(p);
    compiler__Parser_gen(p, compiler__TokenKind_str(tok));
    int oph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
    ;
    if ((is_div || is_mod) && p->tok == compiler__compiler__TokenKind_number &&
        string_eq(p->lit, tos3("0"))) {
      compiler__Parser_error(p, tos3("division or modulo by zero"));
    };
    string expr_type = compiler__Parser_unary(p);
    if ((is_mul || is_div) && string_eq(expr_type, tos3("string"))) {
      compiler__Parser_error(p, _STR("operator %.*s cannot be used on strings",
                                     compiler__TokenKind_str(tok).len,
                                     compiler__TokenKind_str(tok).str));
    };
    if (!compiler__is_primitive_type(expr_type) && string_eq(expr_type, typ)) {
      compiler__Parser_check_types(p, expr_type, typ);
      compiler__Type T = compiler__Table_find_type(&/* ? */ *p->table, typ);
      string before_oph = string_substr2(p->cgen->cur_line, 0, oph - 1, false);
      string after_oph = string_substr2(p->cgen->cur_line, oph, -1, true);
      p->cgen->cur_line =
          string_add(string_add(before_oph, tos3(",")), after_oph);
      compiler__TokenKind tmp35 = tok;

      if (tmp35 == compiler__compiler__TokenKind_mul) {
        compiler__Parser_handle_operator(p, tos3("*"), typ, tos3("op_mul"), ph,
                                         &/*114*/ T);
      } else if (tmp35 == compiler__compiler__TokenKind_div) {
        compiler__Parser_handle_operator(p, tos3("/"), typ, tos3("op_div"), ph,
                                         &/*114*/ T);
      } else if (tmp35 == compiler__compiler__TokenKind_mod) {
        compiler__Parser_handle_operator(p, tos3("%"), typ, tos3("op_mod"), ph,
                                         &/*114*/ T);
      } else // default:
      {
      };
      continue;
    };
    if (is_mod) {
      if (!(compiler__is_integer_type(expr_type) &&
            compiler__is_integer_type(typ))) {
        compiler__Parser_error(p,
                               tos3("operator `mod` requires integer types"));
      };
    } else {
      compiler__Parser_check_types(p, expr_type, typ);
    };
  };
  return typ;
}
string compiler__Parser_unary(compiler__Parser *p) {
  string typ = tos3("");
  compiler__TokenKind tok = p->tok;
  compiler__TokenKind tmp36 = tok;

  if (tmp36 == compiler__compiler__TokenKind_not) {
    compiler__Parser_gen(p, tos3("!"));
    compiler__Parser_check(p, compiler__compiler__TokenKind_not);
    typ = compiler__Parser_indot_expr(p);
    if (string_ne(typ, tos3("bool"))) {
      compiler__Parser_error(
          p,
          _STR("operator ! requires bool type, not `%.*s`", typ.len, typ.str));
    };
  } else if (tmp36 == compiler__compiler__TokenKind_bit_not) {
    compiler__Parser_gen(p, tos3("~"));
    compiler__Parser_check(p, compiler__compiler__TokenKind_bit_not);
    typ = compiler__Parser_bool_expression(p);
  } else // default:
  {
    typ = compiler__Parser_factor(p);
  };
  return typ;
}
string compiler__Parser_factor(compiler__Parser *p) {
  string typ = tos3("");
  compiler__TokenKind tok = p->tok;
  compiler__TokenKind tmp37 = tok;

  if (tmp37 == compiler__compiler__TokenKind_key_none) {
    if (!string_starts_with(p->expected_type, tos3("Option_"))) {
      compiler__Parser_error(p,
                             _STR("need \"%.*s\" got none",
                                  p->expected_type.len, p->expected_type.str));
    };
    compiler__Parser_gen(p, tos3("opt_none()"));
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_none);
    return p->expected_type;
  } else if (tmp37 == compiler__compiler__TokenKind_number) {
    typ = tos3("int");
    if ((string_contains(p->lit, tos3(".")) ||
         (string_contains(p->lit, tos3("e")) ||
          string_contains(p->lit, tos3("E")))) &&
        !(string_at(p->lit, 0) == '0' &&
          (string_at(p->lit, 1) == 'x' || string_at(p->lit, 1) == 'X'))) {
      typ = tos3("f32");
    } else {
      u64 v_u64 = string_u64(p->lit);
      if (((u64)(((u32)(v_u64)))) < v_u64) {
        typ = tos3("u64");
      };
    };
    if (string_ne(p->expected_type, tos3("")) &&
        !compiler__is_valid_int_const(p->lit, p->expected_type)) {
      compiler__Parser_error(
          p, _STR("constant `%.*s` overflows `%.*s`", p->lit.len, p->lit.str,
                  p->expected_type.len, p->expected_type.str));
    };
    compiler__Parser_gen(p, p->lit);
  } else if (tmp37 == compiler__compiler__TokenKind_minus) {
    compiler__Parser_gen(p, tos3("-"));
    compiler__Parser_next(p);
    return compiler__Parser_factor(p);
  } else if (tmp37 == compiler__compiler__TokenKind_key_sizeof) {
    compiler__Parser_gen(p, tos3("sizeof("));
    compiler__Parser_next(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
    string sizeof_typ = compiler__Parser_get_type(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
    compiler__Parser_gen(p, _STR("%.*s)", sizeof_typ.len, sizeof_typ.str));
    return tos3("int");
  } else if (tmp37 == compiler__compiler__TokenKind_key_typeof) {
    compiler__Parser_next(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
    p->cgen->nogen = 1;
    string vname = ((p->tok == compiler__compiler__TokenKind_name &&
                     compiler__Parser_peek(&/* ? */ *p) ==
                         compiler__compiler__TokenKind_rpar)
                        ? (p->lit)
                        : (tos3("")));
    string type_of_var = compiler__Parser_expression(p);
    p->cgen->nogen = 0;
    compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
    bool is_sum_type = (_IN_MAP((type_of_var), p->table->sum_types));
    if (is_sum_type && vname.len > 0) {
      compiler__Parser_gen(p, _STR("tos3(__SumTypeNames__%.*s[%.*s.typ])",
                                   type_of_var.len, type_of_var.str, vname.len,
                                   vname.str));
    } else {
      compiler__Parser_gen(
          p, _STR("tos3(\"%.*s\")", type_of_var.len, type_of_var.str));
    };
    return tos3("string");
  } else if (tmp37 == compiler__compiler__TokenKind_key_nameof) {
    compiler__Parser_next(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
    string nameof_typ = compiler__Parser_get_type(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
    compiler__Parser_gen(
        p, _STR("tos3(\"%.*s\")", nameof_typ.len, nameof_typ.str));
    return tos3("string");
  } else if (tmp37 == compiler__compiler__TokenKind_key_offsetof) {
    compiler__Parser_next(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
    string offsetof_typ = compiler__Parser_get_type(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
    string member = compiler__Parser_check_name(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
    compiler__Parser_gen(p, _STR("__offsetof(%.*s, %.*s)", offsetof_typ.len,
                                 offsetof_typ.str, member.len, member.str));
    return tos3("int");
  } else if ((tmp37 == compiler__compiler__TokenKind_amp) ||
             (tmp37 == compiler__compiler__TokenKind_dot) ||
             (tmp37 == compiler__compiler__TokenKind_mul)) {
    return compiler__Parser_name_expr(p);
  } else if (tmp37 == compiler__compiler__TokenKind_name) {
    if (string_eq(p->lit, tos3("map")) &&
        compiler__Parser_peek(&/* ? */ *p) ==
            compiler__compiler__TokenKind_lsbr) {
      return compiler__Parser_map_init(p);
    };
    if (string_eq(p->lit, tos3("json")) &&
        compiler__Parser_peek(&/* ? */ *p) ==
            compiler__compiler__TokenKind_dot) {
      if (!((_IN(string, (tos3("json")), p->table->imports)))) {
        compiler__Parser_error(p, tos3("undefined: `json`, use `import json`"));
      };
      compiler__ImportTable_register_used_import(&/* ? */ p->import_table,
                                                 tos3("json"));
      return compiler__Parser_js_decode(p);
    };
    typ = compiler__Parser_name_expr(p);
    return typ;
  } else if (tmp37 == compiler__compiler__TokenKind_lpar) {
    compiler__Parser_gen(p, tos3("("));
    compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
    typ = compiler__Parser_bool_expression(p);
    if (!p->ptr_cast) {
      compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
    };
    p->ptr_cast = 0;
    compiler__Parser_gen(p, tos3(")"));
    return typ;
  } else if (tmp37 == compiler__compiler__TokenKind_chartoken) {
    compiler__Parser_char_expr(p);
    typ = tos3("byte");
    return typ;
  } else if (tmp37 == compiler__compiler__TokenKind_string) {
    compiler__Parser_string_expr(p);
    typ = tos3("string");
    return typ;
  } else if (tmp37 == compiler__compiler__TokenKind_key_false) {
    typ = tos3("bool");
    compiler__Parser_gen(p, tos3("0"));
  } else if (tmp37 == compiler__compiler__TokenKind_key_true) {
    typ = tos3("bool");
    compiler__Parser_gen(p, tos3("1"));
  } else if (tmp37 == compiler__compiler__TokenKind_lsbr) {
    return compiler__Parser_array_init(p);
  } else if (tmp37 == compiler__compiler__TokenKind_lcbr) {
    if (compiler__Parser_peek(&/* ? */ *p) ==
        compiler__compiler__TokenKind_string) {
      return compiler__Parser_map_init(p);
    };
    compiler__Token peek2 =
        (*(compiler__Token *)array_get(p->tokens, p->token_idx + 1));
    if (compiler__Parser_peek(&/* ? */ *p) ==
            compiler__compiler__TokenKind_rcbr ||
        (compiler__Parser_peek(&/* ? */ *p) ==
             compiler__compiler__TokenKind_name &&
         peek2.tok == compiler__compiler__TokenKind_colon)) {
      return compiler__Parser_struct_init(p, p->expected_type);
    };
    return compiler__Parser_assoc(p);
  } else if (tmp37 == compiler__compiler__TokenKind_key_if) {
    typ = compiler__Parser_if_statement(p, 1, 0);
    return typ;
  } else if (tmp37 == compiler__compiler__TokenKind_key_match) {
    typ = compiler__Parser_match_statement(p, 1);
    return typ;
  } else // default:
  {
    if (v_dot_pref__VerboseLevel_is_higher_or_equal(
            p->pref->verbosity,
            v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
      compiler__TokenKind next = compiler__Parser_peek(&/* ? */ *p);
      printf("prev=%.*s\n", compiler__TokenKind_str(p->prev_tok).len,
             compiler__TokenKind_str(p->prev_tok).str);
      printf("next=%.*s\n", compiler__TokenKind_str(next).len,
             compiler__TokenKind_str(next).str);
    };
    compiler__Parser_error(p, _STR("unexpected token: `%.*s`",
                                   compiler__TokenKind_str(p->tok).len,
                                   compiler__TokenKind_str(p->tok).str));
  };
  compiler__Parser_next(p);
  return typ;
}
string array_compiler__TypeInst_str(array_compiler__TypeInst a) {
  array_string r = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_compiler__TypeInst tmp1 = a;
  for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
    compiler__TypeInst t = ((compiler__TypeInst *)tmp1.data)[tmp2];

    string s = tos3(" | ");
    array_string tmp3 = map_keys(&/* ? */ t.inst);
    for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
      string k = ((string *)tmp3.data)[tmp4];

      string tmp5 = tos3("");
      bool tmp6 = map_get(/*fn.v : 68*/ t.inst, k, &tmp5);

      if (!tmp6)
        tmp5 = tos((byte *)"", 0);

      s = string_add(s,
                     string_add(string_add(string_add(k, tos3(" -> ")), tmp5),
                                tos3(" | ")));
    };
    _PUSH(&r, (/*typ = array_string   tmp_typ=string*/ s), tmp7, string);
  };
  return array_string_str(r);
}
Option_compiler__Var compiler__Parser_find_var_or_const(compiler__Parser *p,
                                                        string name) {
  if (compiler__Parser_known_var(&/* ? */ *p, name)) {
    Option_compiler__Var tmp8 = OPTION_CAST(Option_compiler__Var)(
        compiler__Parser_find_var(&/* ? */ *p, name));
    return opt_ok(&tmp8, sizeof(compiler__Var));
  };
  if (compiler__Table_known_const(&/* ? */ *p->table, name)) {
    Option_compiler__Var tmp9 = OPTION_CAST(Option_compiler__Var)(
        compiler__Table_find_const(&/* ? */ *p->table, name));
    return opt_ok(&tmp9, sizeof(compiler__Var));
  };
  string modname = compiler__Parser_prepend_mod(&/* ? */ *p, name);
  if (compiler__Table_known_const(&/* ? */ *p->table, modname)) {
    Option_compiler__Var tmp10 = OPTION_CAST(Option_compiler__Var)(
        compiler__Table_find_const(&/* ? */ *p->table, modname));
    return opt_ok(&tmp10, sizeof(compiler__Var));
  };
  return opt_none();
}
Option_compiler__Var compiler__Parser_find_var(compiler__Parser *p,
                                               string name) {
  int tmp11 = 0;
  ;
  for (int tmp12 = tmp11; tmp12 < p->var_idx; tmp12++) {
    int i = tmp12;

    if (string_eq((*(compiler__Var *)array_get(p->local_vars, i)).name, name)) {
      compiler__Var tmp17 = OPTION_CAST(compiler__Var)(
          (*(compiler__Var *)array_get(p->local_vars, i)));
      return opt_ok(&tmp17, sizeof(compiler__Var));
    };
  };
  return opt_none();
}
Option_compiler__Var
compiler__Parser_find_var_check_new_var(compiler__Parser *p, string name) {
  int tmp18 = 0;
  ;
  for (int tmp19 = tmp18; tmp19 < p->var_idx; tmp19++) {
    int i = tmp19;

    if (string_eq((*(compiler__Var *)array_get(p->local_vars, i)).name, name)) {
      compiler__Var tmp24 = OPTION_CAST(compiler__Var)(
          (*(compiler__Var *)array_get(p->local_vars, i)));
      return opt_ok(&tmp24, sizeof(compiler__Var));
    };
  };
  if (string_eq(name, string_add(tos3("main__"), p->var_decl_name))) {
    compiler__Var tmp25 = OPTION_CAST(compiler__Var)(
        (compiler__Var){.name = p->var_decl_name,
                        .typ = tos3("voidptr"),
                        .is_mut = 1,
                        .idx = 0,
                        .is_arg = 0,
                        .is_const = 0,
                        .args = new_array(0, 1, sizeof(compiler__Var)),
                        .attr = tos3(""),
                        .is_alloc = 0,
                        .is_returned = 0,
                        .ptr = 0,
                        .ref = 0,
                        .parent_fn = tos3(""),
                        .mod = tos3(""),
                        .is_global = 0,
                        .is_used = 0,
                        .is_changed = 0,
                        .scope_level = 0,
                        .is_c = 0,
                        .is_moved = 0,
                        .line_nr = 0,
                        .token_idx = 0,
                        .is_for_var = 0,
                        .is_public = 0});
    return opt_ok(&tmp25, sizeof(compiler__Var));
  };
  return opt_none();
}
void compiler__Parser_open_scope(compiler__Parser *p) {
  _PUSH(&p->cur_fn.defer_text,
        (/*typ = array_string   tmp_typ=string*/ tos3("")), tmp26, string);
  p->cur_fn.scope_level++;
}
void compiler__Parser_mark_var_used(compiler__Parser *p, compiler__Var v) {
  if (v.idx == -1 || v.idx >= p->local_vars.len) {

    return;
  };
  (*(compiler__Var *)array_get(p->local_vars, v.idx)).is_used = 1;
}
void compiler__Parser_mark_var_returned(compiler__Parser *p, compiler__Var v) {
  if (v.idx == -1 || v.idx >= p->local_vars.len) {

    return;
  };
  (*(compiler__Var *)array_get(p->local_vars, v.idx)).is_returned = 1;
}
void compiler__Parser_mark_var_changed(compiler__Parser *p, compiler__Var v) {
  if (v.idx == -1 || v.idx >= p->local_vars.len) {

    return;
  };
  (*(compiler__Var *)array_get(p->local_vars, v.idx)).is_changed = 1;
}
void compiler__Parser_mark_arg_moved(compiler__Parser *p, compiler__Var v) {
  array_compiler__Var tmp33 = p->cur_fn.args;
  for (int i = 0; i < tmp33.len; i++) {
    compiler__Var arg = ((compiler__Var *)tmp33.data)[i];

    if (string_eq(arg.name, v.name)) {
      (*(compiler__Var *)array_get(p->cur_fn.args, i)).is_moved = 1;
      break;
    };
  };
  map_set(&p->table->fns, p->cur_fn.name, &(compiler__Fn[]){p->cur_fn});
}
bool compiler__Parser_known_var(compiler__Parser *p, string name) {
  Option_compiler__Var tmp36 = compiler__Parser_find_var(&/* ? */ *p, name);
  if (!tmp36.ok) {
    string err = tmp36.error;
    int errcode = tmp36.ecode;
    return 0;
  };
  return 1;
}
bool compiler__Parser_known_var_check_new_var(compiler__Parser *p,
                                              string name) {
  Option_compiler__Var tmp37 =
      compiler__Parser_find_var_check_new_var(&/* ? */ *p, name);
  if (!tmp37.ok) {
    string err = tmp37.error;
    int errcode = tmp37.ecode;
    return 0;
  };
  return 1;
}
void compiler__Parser_register_var(compiler__Parser *p, compiler__Var v) {
  compiler__Var new_var = (compiler__Var){
      .idx = p->var_idx,
      .scope_level = p->cur_fn.scope_level,
      .typ = v.typ,
      .name = v.name,
      .is_arg = v.is_arg,
      .is_const = v.is_const,
      .args = v.args,
      .attr = v.attr,
      .is_mut = v.is_mut,
      .is_alloc = v.is_alloc,
      .is_returned = v.is_returned,
      .ptr = v.ptr,
      .ref = v.ref,
      .parent_fn = v.parent_fn,
      .mod = v.mod,
      .access_mod = v.access_mod,
      .is_global = v.is_global,
      .is_used = v.is_used,
      .is_changed = v.is_changed,
      .is_c = v.is_c,
      .is_moved = v.is_moved,
      .line_nr = v.line_nr,
      .token_idx = v.token_idx,
      .is_for_var = v.is_for_var,
      .is_public = v.is_public,
  };
  if (v.line_nr == 0) {
    new_var.token_idx = compiler__Parser_cur_tok_index(&/* ? */ *p);
    new_var.line_nr = compiler__Parser_cur_tok(&/* ? */ *p).line_nr;
  };
  if (p->var_idx >= p->local_vars.len) {
    _PUSH(&p->local_vars,
          (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ new_var),
          tmp38, compiler__Var);
  } else {
    array_set(&/*q*/ p->local_vars, p->var_idx, &(compiler__Var[]){new_var});
  };
  p->var_idx++;
}
void compiler__Parser_clear_vars(compiler__Parser *p) {
  p->var_idx = 0;
  if (p->local_vars.len > 0) {
    if (p->pref->autofree) {
    };
    p->local_vars = new_array_from_c_array(
        0, 0, sizeof(compiler__Var),
        EMPTY_ARRAY_OF_ELEMS(compiler__Var, 0){TCCSKIP(0)});
  };
}
void compiler__Parser_fn_decl(compiler__Parser *p) {
  compiler__Parser_clear_vars(p);
  int fn_start_idx = compiler__Parser_cur_tok_index(&/* ? */ *p);
  bool is_pub = p->tok == compiler__compiler__TokenKind_key_pub;
  compiler__Fn f = (compiler__Fn){
      .mod = p->mod,
      .is_public = is_pub || p->is_vh,
      .is_unsafe = string_eq(p->attr, tos3("unsafe_fn")),
      .is_deprecated = string_eq(p->attr, tos3("deprecated")),
      .comptime_define = ((string_starts_with(p->attr, tos3("if ")))
                              ? (string_substr2(p->attr, 3, -1, true))
                              : (tos3(""))),
      .name = tos3(""),
      .args = new_array(0, 1, sizeof(compiler__Var)),
      .is_interface = 0,
      .scope_level = 0,
      .typ = tos3(""),
      .receiver_typ = tos3(""),
      .is_c = 0,
      .is_method = 0,
      .is_decl = 0,
      .is_variadic = 0,
      .is_generic = 0,
      .returns_error = 0,
      .defer_text = new_array(0, 1, sizeof(string)),
      .type_pars = new_array(0, 1, sizeof(string)),
      .type_inst = new_array(0, 1, sizeof(compiler__TypeInst)),
      .generic_fn_idx = 0,
      .parser_idx = 0,
      .fn_name_token_idx = 0,
      .is_used = 0};
  bool is_live = p->pref->is_live && string_eq(p->attr, tos3("live"));
  bool is_solive = p->pref->is_solive && string_eq(p->attr, tos3("live"));
  if (is_pub) {
    compiler__Parser_next(p);
    ;
  };
  p->returns = 0;
  compiler__Parser_next(p);
  ;
  string receiver_typ = tos3("");
  if (p->tok == compiler__compiler__TokenKind_lpar) {
    f.is_method = 1;
    compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
    string receiver_name = compiler__Parser_check_name(p);
    ;
    bool is_mut = p->tok == compiler__compiler__TokenKind_key_mut;
    bool is_amp = p->tok == compiler__compiler__TokenKind_amp;
    if (is_mut || is_amp) {
      compiler__Parser_check(p, p->tok);
      if (!is_amp) {
        ;
      };
    };
    receiver_typ = compiler__Parser_get_type(p);
    compiler__Type t =
        compiler__Table_find_type(&/* ? */ *p->table, receiver_typ);
    if ((string_eq(t.name, tos3("")) || t.is_placeholder) &&
        !compiler__Parser_first_pass(&/* ? */ *p)) {
      compiler__Parser_error(p, _STR("unknown receiver type `%.*s`",
                                     receiver_typ.len, receiver_typ.str));
    };
    if (t.cat == compiler__compiler__TypeCategory_interface_) {
      compiler__Parser_error(
          p, _STR("invalid receiver type `%.*s` (`%.*s` is an interface)",
                  receiver_typ.len, receiver_typ.str, receiver_typ.len,
                  receiver_typ.str));
    };
    if (!compiler__Parser_first_pass(&/* ? */ *p) && !p->builtin_mod &&
        string_ne(t.mod, p->mod) && !p->is_vgen) {
      compiler__Parser_error(
          p, _STR("cannot define new methods on non-local type `%.*s`",
                  receiver_typ.len, receiver_typ.str));
    };
    if (string_ends_with(receiver_typ, tos3("*"))) {
      string tt = string_replace(receiver_typ, tos3("*"), tos3(""));
      compiler__Parser_error(
          p, _STR("use `(%.*s mut %.*s)` instead of `(%.*s *%.*s)`",
                  receiver_name.len, receiver_name.str, tt.len, tt.str,
                  receiver_name.len, receiver_name.str, tt.len, tt.str));
    };
    f.receiver_typ = receiver_typ;
    if (is_mut || is_amp) {
      receiver_typ = string_add(receiver_typ, tos3("*"));
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
    ;
    compiler__Var receiver = (compiler__Var){
        .name = receiver_name,
        .is_arg = 1,
        .typ = receiver_typ,
        .is_mut = is_mut,
        .ref = is_amp,
        .ptr = is_mut,
        .line_nr = p->scanner->line_nr,
        .token_idx = compiler__Parser_cur_tok_index(&/* ? */ *p),
        .idx = 0,
        .is_const = 0,
        .args = new_array(0, 1, sizeof(compiler__Var)),
        .attr = tos3(""),
        .is_alloc = 0,
        .is_returned = 0,
        .parent_fn = tos3(""),
        .mod = tos3(""),
        .is_global = 0,
        .is_used = 0,
        .is_changed = 0,
        .scope_level = 0,
        .is_c = 0,
        .is_moved = 0,
        .is_for_var = 0,
        .is_public = 0};
    _PUSH(&f.args,
          (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ receiver),
          tmp41, compiler__Var);
    compiler__Parser_register_var(p, receiver);
  };
  bool is_op = 0;
  if ((p->tok == compiler__compiler__TokenKind_plus ||
       p->tok == compiler__compiler__TokenKind_minus ||
       p->tok == compiler__compiler__TokenKind_mul ||
       p->tok == compiler__compiler__TokenKind_div ||
       p->tok == compiler__compiler__TokenKind_mod)) {
    f.name = compiler__TokenKind_str(p->tok);
    compiler__Parser_next(p);
    is_op = 1;
  } else {
    f.name = compiler__Parser_check_name(p);
  };
  f.fn_name_token_idx = compiler__Parser_cur_tok_index(&/* ? */ *p);
  if (string_eq(f.name, tos3("init")) && !f.is_method && f.is_public &&
      !p->is_vh) {
    compiler__Parser_error(p, tos3("init function cannot be public"));
  };
  if (f.is_method && string_eq(f.name, tos3("str")) && !f.is_public) {
    compiler__Parser_error(p,
                           tos3(".str() methods must be declared as public"));
  };
  bool is_c = string_eq(f.name, tos3("C")) &&
              p->tok == compiler__compiler__TokenKind_dot;
  if (is_c) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
    f.name = compiler__Parser_check_name(p);
    f.is_c = 1;
  };
  string orig_name = f.name;
  bool has_receiver = receiver_typ.len > 0;
  if (string_ne(receiver_typ, tos3(""))) {
  };
  if (!is_c && !has_receiver &&
      (!p->builtin_mod ||
       (p->builtin_mod && string_eq(f.name, tos3("init"))))) {
    f.name = compiler__Parser_prepend_mod(&/* ? */ *p, f.name);
  };
  if (compiler__Parser_first_pass(&/* ? */ *p) && receiver_typ.len == 0) {
    Option_compiler__Fn tmp42 =
        compiler__Table_find_fn(&/* ? */ *p->table, f.name);

    if (tmp42.ok) {
      compiler__Fn existing_fn = *(compiler__Fn *)tmp42.data;
      if (!existing_fn.is_decl) {
        compiler__Parser_error(
            p, _STR("redefinition of `%.*s`", f.name.len, f.name.str));
      };
    };
  };
  if (p->tok == compiler__compiler__TokenKind_lt) {
    if (p->generic_dispatch.inst.size > 0) {
      compiler__rename_generic_fn_instance(&/*114*/ f, &p->generic_dispatch);
    } else {
      f.is_generic = 1;
    };
    compiler__Parser_next(p);
    while (1) {
      string type_par = compiler__Parser_check_name(p);
      if (type_par.len > 1 ||
          !((_IN(string, (type_par), compiler__reserved_type_param_names)))) {
        string tmp43 = array_string_str(compiler__reserved_type_param_names);

        compiler__Parser_error(
            p, _STR("type parameters must be single-character, upper-case "
                    "letters of the following set: %.*s ",
                    tmp43.len, tmp43.str));
      };
      if ((_IN(string, (type_par), f.type_pars))) {
        compiler__Parser_error(p, _STR("redeclaration of type parameter `%.*s`",
                                       type_par.len, type_par.str));
      };
      _PUSH(&f.type_pars, (/*typ = array_string   tmp_typ=string*/ type_par),
            tmp44, string);
      if (p->tok == compiler__compiler__TokenKind_gt) {
        break;
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_gt);
    compiler__Parser_set_current_fn(p, f);
  };
  compiler__Parser_fn_args(p, &/*114*/ f);
  if (is_op) {
    if (f.args.len != 1 + 1) {
      compiler__Parser_error(
          p, tos3("operator overloading methods must have only 1 argument"));
    };
    if (string_ne((*(compiler__Var *)array_get(f.args, 0)).typ,
                  (*(compiler__Var *)array_get(f.args, 1)).typ)) {
      compiler__Parser_error(
          p, tos3("operators must have the same types on both sides"));
    };
  };
  if (p->tok == compiler__compiler__TokenKind_not) {
    compiler__Parser_next(p);
    f.returns_error = 1;
  };
  string typ = tos3("void");
  if ((p->tok == compiler__compiler__TokenKind_name ||
       p->tok == compiler__compiler__TokenKind_mul ||
       p->tok == compiler__compiler__TokenKind_amp ||
       p->tok == compiler__compiler__TokenKind_lsbr ||
       p->tok == compiler__compiler__TokenKind_question ||
       p->tok == compiler__compiler__TokenKind_lpar)) {
    ;
    typ = compiler__Parser_get_type(p);
  };
  bool is_fn_header =
      !is_c && !p->is_vh && p->tok != compiler__compiler__TokenKind_lcbr;
  if (is_fn_header) {
    f.name = orig_name;
    f.is_decl = 1;
  };
  if (!is_c && !p->pref->translated && !is_fn_header) {
    if (compiler__contains_capital(orig_name) &&
        !compiler__Parser_fileis(&/* ? */ *p, tos3("view.v")) && !p->is_vgen) {
      compiler__Parser_error(p, tos3("function names cannot contain uppercase "
                                     "letters, use snake_case instead"));
    };
    if (string_at(f.name, 0) == '_') {
      compiler__Parser_error(
          p,
          tos3("function names cannot start with `_`, use snake_case instead"));
    };
    if (string_contains(orig_name, tos3("__"))) {
      compiler__Parser_error(
          p, tos3("function names cannot contain double underscores, use "
                  "single underscores instead"));
    };
  };
  if (!is_c && !p->is_vh && !is_fn_header) {
    ;
    compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
  };
  if (string_starts_with(typ, tos3("Option_"))) {
    _PUSH(&p->cgen->typedefs,
          (/*typ = array_string   tmp_typ=string*/ _STR("typedef Option %.*s;",
                                                        typ.len, typ.str)),
          tmp51, string);
  };
  array_compiler__Var tmp52 = f.args;
  for (int tmp53 = 0; tmp53 < tmp52.len; tmp53++) {
    compiler__Var arg = ((compiler__Var *)tmp52.data)[tmp53];

    if (string_starts_with(arg.typ, tos3("Option_"))) {
      _PUSH(&p->cgen->typedefs,
            (/*typ = array_string   tmp_typ=string*/ _STR(
                "typedef Option %.*s;", arg.typ.len, arg.typ.str)),
            tmp54, string);
    };
  };
  f.typ = typ;
  string str_args = compiler__Fn_str_args(&/* ? */ f, p->table);
  if (string_eq(f.name, tos3("main__main")) && !has_receiver) {
    if (p->pref->backend == v_dot_pref__v_dot_pref__Backend_x64 &&
        !compiler__Parser_first_pass(&/* ? */ *p)) {
    };
    if (string_ne(str_args, tos3("")) || string_ne(typ, tos3("void"))) {
      compiler__Parser_error_with_token_index(
          p, tos3("fn main must have no arguments and no return values"),
          f.fn_name_token_idx);
    };
  };
  string dll_export_linkage = compiler__Parser_get_linkage_prefix(&/* ? */ *p);
  compiler__Parser_set_current_fn(p, f);
  string fn_name_cgen = compiler__Table_fn_gen_name(p->table, &/*114*/ f);
  bool skip_main_in_test = 0;
  if (!is_c && !is_live && !p->is_vh && !is_fn_header && !skip_main_in_test) {
    if (p->pref->obfuscate) {
      compiler__Parser_genln(p, _STR("; // %.*s", f.name.len, f.name.str));
    };
    if (f.is_generic && !p->scanner->is_fmt) {
      if (compiler__Parser_first_pass(&/* ? */ *p)) {
        if (!p->scanner->is_vh) {
          Option_int tmp55 =
              compiler__V_get_file_parser_index(&/* ? */ *p->v, p->file_path);
          int gpidx;
          if (!tmp55.ok) {
            string err = tmp55.error;
            int errcode = tmp55.ecode;
            v_panic(_STR("error finding parser for: %.*s", p->file_path.len,
                         p->file_path.str));
          }
          gpidx = *(int *)tmp55.data;
          ;
          f.parser_idx = gpidx;
        };
        f.generic_fn_idx = fn_start_idx;
        if (f.is_method) {
          compiler__Type rcv =
              compiler__Table_find_type(&/* ? */ *p->table, receiver_typ);
          if (compiler__Parser_first_pass(&/* ? */ *p) &&
              string_eq(rcv.name, tos3(""))) {
            compiler__Parser_error(
                p, tos3("cannot currently add generic method to a type "
                        "declared after it or in another module"));
          };
          compiler__Parser_add_method(p, rcv.name, f);
        } else {
          compiler__Table_register_fn(p->table, f);
        };
      };
      compiler__Parser_set_current_fn(p, compiler__EmptyFn);
      compiler__Parser_skip_fn_body(p);
      {
        ;
        ;
      }
      return;
    } else {
      compiler__Parser_gen_fn_decl(p, f, typ, str_args);
    };
  };
  if (is_fn_header) {
    compiler__Parser_genln(p, _STR("%.*s %.*s (%.*s);", typ.len, typ.str,
                                   fn_name_cgen.len, fn_name_cgen.str,
                                   str_args.len, str_args.str));
    ;
  };
  if (is_c) {
    ;
  };
  if (string_ne(receiver_typ, tos3(""))) {
    compiler__Type receiver_t =
        compiler__Table_find_type(&/* ? */ *p->table, receiver_typ);
    if (compiler__Parser_first_pass(&/* ? */ *p) &&
        string_eq(receiver_t.name, tos3(""))) {
      receiver_t = (compiler__Type){
          .name = string_replace(receiver_typ, tos3("*"), tos3("")),
          .mod = p->mod,
          .is_placeholder = 1,
          .is_public = 0,
          .fields = new_array(0, 1, sizeof(compiler__Var)),
          .methods = new_array(0, 1, sizeof(compiler__Fn)),
          .parent = tos3(""),
          .is_c = 0,
          .enum_vals = new_array(0, 1, sizeof(string)),
          .gen_types = new_array(0, 1, sizeof(string)),
          .default_vals = new_array(0, 1, sizeof(string)),
          .parser_idx = 0,
          .decl_tok_idx = 0,
          .gen_str = 0,
          .is_flag = 0,
          .is_generic = 0,
          .ctype_names = new_array(0, 1, sizeof(string))};
      compiler__Table_register_type(p->table, receiver_t);
    };
    compiler__Parser_add_method(p, receiver_t.name, f);
  } else if (compiler__Parser_first_pass(&/* ? */ *p)) {
    compiler__Table_register_fn(p->table, f);
  };
  if (compiler__Parser_first_pass(&/* ? */ *p) &&
      string_eq(p->attr, tos3("live")) && !(is_live || is_solive)) {
    printf("INFO: run `v -live %.*s `, if you want to use [live] function %.*s "
           ".\n",
           p->v->pref->path.len, p->v->pref->path.str, f.name.len, f.name.str);
  };
  if (p->is_vh || compiler__Parser_first_pass(&/* ? */ *p) || is_live ||
      is_fn_header || skip_main_in_test) {
    if (!p->is_vh && !is_fn_header) {
      compiler__Parser_skip_fn_body(p);
    };
    if (is_live && compiler__Parser_first_pass(&/* ? */ *p) &&
        string_eq(p->mod, tos3("main"))) {
      _PUSH(&p->cgen->so_fns,
            (/*typ = array_string   tmp_typ=string*/ fn_name_cgen), tmp56,
            string);
      fn_name_cgen = _STR("(* %.*s )", fn_name_cgen.len, fn_name_cgen.str);
    };
    string fn_decl =
        _STR("%.*s%.*s %.*s (%.*s)", dll_export_linkage.len,
             dll_export_linkage.str, typ.len, typ.str, fn_name_cgen.len,
             fn_name_cgen.str, str_args.len, str_args.str);
    if (p->pref->obfuscate) {
      fn_decl = string_add(fn_decl, _STR("; // %.*s", f.name.len, f.name.str));
    };
    if (!is_c && compiler__Parser_first_pass(&/* ? */ *p)) {
      _PUSH(&p->cgen->fns,
            (/*typ = array_string   tmp_typ=string*/ string_add(fn_decl,
                                                                tos3(";"))),
            tmp57, string);
    };
    {
      ;
      ;
    }
    return;
  };
  if (is_solive) {
    string function_args =
        compiler__Fn_str_args_without_types(&/* ? */ f, p->table);
    string live_fncall =
        _STR("impl_live_%.*s(%.*s);", fn_name_cgen.len, fn_name_cgen.str,
             function_args.len, function_args.str);
    string live_fnreturn = tos3("");
    if (string_ne(typ, tos3("void"))) {
      live_fncall = _STR("%.*s res = %.*s", typ.len, typ.str, live_fncall.len,
                         live_fncall.str);
      live_fnreturn = tos3("return res;");
    };
    compiler__Parser_genln(p, tos3("  pthread_mutex_lock(&live_fn_mutex);"));
    compiler__Parser_genln(p, _STR("  %.*s", live_fncall.len, live_fncall.str));
    compiler__Parser_genln(p, tos3("  pthread_mutex_unlock(&live_fn_mutex);"));
    compiler__Parser_genln(
        p, _STR("  %.*s", live_fnreturn.len, live_fnreturn.str));
    compiler__Parser_genln(p, tos3("}"));
    compiler__Parser_genln(p, _STR("%.*s impl_live_%.*s (%.*s){", typ.len,
                                   typ.str, fn_name_cgen.len, fn_name_cgen.str,
                                   str_args.len, str_args.str));
  };
  if ((string_eq(f.name, tos3("main__main")) ||
       string_eq(f.name, tos3("main")) || string_eq(f.name, tos3("WinMain")))) {
    if (p->pref->is_test) {
      compiler__Parser_error_with_token_index(
          p, tos3("tests cannot have function `main`"), f.fn_name_token_idx);
    };
  };
  if (is_c || p->is_vh || is_fn_header) {
    {
      ;
      ;
    }
    return;
  };
  if (p->pref->is_prof && string_ne(f.name, tos3("time__ticks"))) {
    compiler__Parser_genln(p, _STR("double _PROF_START = time__ticks();//%.*s",
                                   f.name.len, f.name.str));
    string cgen_name = compiler__Table_fn_gen_name(p->table, &/*114*/ f);
    if (f.defer_text.len > f.scope_level) {
      array_set(&/*q*/ f.defer_text, f.scope_level,
                &(string[]){_STR("  %.*s_time += time__ticks() - _PROF_START;",
                                 cgen_name.len, cgen_name.str)});
    };
  };
  if (p->pref->backend == v_dot_pref__v_dot_pref__Backend_x64) {
  };
  compiler__Parser_statements_no_rcbr(p);
  if (p->pref->is_prof && string_eq(f.name, tos3("main"))) {
    compiler__Parser_genln(p,
                           compiler__Parser_print_prof_counters(&/* ? */ *p));
  };
  if (f.defer_text.len > f.scope_level) {
    compiler__Parser_genln(p,
                           (*(string *)array_get(f.defer_text, f.scope_level)));
  };
  if (string_ne(typ, tos3("void")) && !p->returns) {
    compiler__Parser_error_with_token_index(p,
                                            _STR("%.*s must return \"%.*s\"",
                                                 f.name.len, f.name.str,
                                                 typ.len, typ.str),
                                            f.fn_name_token_idx);
  };
  if (p->pref->backend == v_dot_pref__v_dot_pref__Backend_x64 &&
      string_eq(f.name, tos3("main__main")) &&
      !compiler__Parser_first_pass(&/* ? */ *p)) {
  };
  if (p->pref->backend == v_dot_pref__v_dot_pref__Backend_x64 &&
      !compiler__Parser_first_pass(&/* ? */ *p)) {
  };
  if (string_eq(p->mod, tos3("main"))) {
  };
  if (p->cur_fn.scope_level > 2) {
  };
  compiler__Parser_genln(p, tos3("}"));
  if (!p->builtin_mod && string_ne(p->mod, tos3("os"))) {
    compiler__Parser_check_unused_and_mut_vars(p);
  };
  compiler__Parser_set_current_fn(p, compiler__EmptyFn);
  p->returns = 0;
  {
    ;
    ;
  }
}
static inline void compiler__Parser_skip_fn_body(compiler__Parser *p) {
  int opened_scopes = 0;
  int closed_scopes = 0;
  while (1) {
    if (p->tok == compiler__compiler__TokenKind_lcbr) {
      opened_scopes++;
    };
    if (p->tok == compiler__compiler__TokenKind_rcbr) {
      closed_scopes++;
    };
    if (compiler__TokenKind_is_decl(p->tok)) {
      break;
    };
    if (closed_scopes > opened_scopes &&
        p->prev_tok == compiler__compiler__TokenKind_rcbr) {
      if (p->tok == compiler__compiler__TokenKind_lsbr) {
        break;
      };
    };
    compiler__Parser_next(p);
  };
}
string compiler__Parser_get_linkage_prefix(compiler__Parser *p) {
  return (
      (string_eq(p->pref->ccompiler, tos3("msvc")) &&
       string_eq(p->attr, tos3("live")) && p->pref->is_so)
          ? (tos3("__declspec(dllexport) "))
          : (((string_eq(p->attr, tos3("inline"))) ? (tos3("static inline "))
                                                   : (tos3("")))));
}
void compiler__Parser_check_unused_and_mut_vars(compiler__Parser *p) {
  array_compiler__Var tmp60 = p->local_vars;
  for (int tmp61 = 0; tmp61 < tmp60.len; tmp61++) {
    compiler__Var var = ((compiler__Var *)tmp60.data)[tmp61];

    if (string_eq(var.name, tos3(""))) {
      break;
    };
    if (!var.is_used && !p->pref->is_repl && !var.is_arg &&
        !p->pref->translated && string_ne(var.name, tos3("tmpl_res")) &&
        string_ne(p->mod, tos3("vweb")) && string_ne(var.name, tos3("it")) &&
        !p->cur_fn.is_unsafe) {
      compiler__Parser_production_error_with_token_index(
          p, _STR("`%.*s` declared and not used", var.name.len, var.name.str),
          var.token_idx);
    };
    if (!var.is_changed && var.is_mut && !p->pref->is_repl &&
        !p->pref->translated && string_ne(var.name, tos3("it")) &&
        string_ne(var.typ, tos3("T*")) && string_ne(p->mod, tos3("ui")) &&
        string_ne(var.typ, tos3("App*"))) {
      compiler__Parser_warn_or_error(
          p, _STR("`%.*s` is declared as mutable, but it was never changed",
                  var.name.len, var.name.str));
    };
  };
}
void compiler__Parser_async_fn_call(compiler__Parser *p, compiler__Fn f,
                                    int method_ph, string receiver_var,
                                    string receiver_type) {
  compiler__Parser_verify_fn_before_call(p, &/*114*/ f);
  string thread_name = tos3("");
  string fn_name = f.name;
  if (f.is_method) {
    fn_name = string_add(
        string_add(string_replace(receiver_type, tos3("*"), tos3("")),
                   tos3("_")),
        f.name);
  };
  string arg_struct_name = _STR("thread_arg_%.*s", fn_name.len, fn_name.str);
  string tmp_struct = compiler__Parser_get_tmp(p);
  compiler__Parser_genln(p, _STR("%.*s * %.*s = malloc(sizeof(%.*s));",
                                 arg_struct_name.len, arg_struct_name.str,
                                 tmp_struct.len, tmp_struct.str,
                                 arg_struct_name.len, arg_struct_name.str));
  string arg_struct = _STR("typedef struct  %.*s   { ", arg_struct_name.len,
                           arg_struct_name.str);
  compiler__Parser_next(p);
  compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
  string str_args = tos3("");
  bool did_gen_something = 0;
  array_compiler__Var tmp62 = f.args;
  for (int i = 0; i < tmp62.len; i++) {
    compiler__Var arg = ((compiler__Var *)tmp62.data)[i];

    arg_struct =
        string_add(arg_struct, _STR("%.*s %.*s ;", arg.typ.len, arg.typ.str,
                                    arg.name.len, arg.name.str));
    str_args = string_add(str_args, _STR("arg %.*s %.*s", compiler__dot_ptr.len,
                                         compiler__dot_ptr.str, arg.name.len,
                                         arg.name.str));
    if (i == 0 && f.is_method) {
      compiler__Parser_genln(
          p, _STR("%.*s %.*s %.*s =  %.*s ;", tmp_struct.len, tmp_struct.str,
                  compiler__dot_ptr.len, compiler__dot_ptr.str, arg.name.len,
                  arg.name.str, receiver_var.len, receiver_var.str));
      if (i < f.args.len - 1) {
        str_args = string_add(str_args, tos3(","));
      };
      did_gen_something = 1;
      continue;
    };
    compiler__Parser_genln(p, _STR("%.*s %.*s %.*s =  ", tmp_struct.len,
                                   tmp_struct.str, compiler__dot_ptr.len,
                                   compiler__dot_ptr.str, arg.name.len,
                                   arg.name.str));
    compiler__Parser_expression(p);
    compiler__Parser_genln(p, tos3(";"));
    if (i < f.args.len - 1) {
      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
      str_args = string_add(str_args, tos3(","));
    };
    did_gen_something = 1;
  };
  if (!did_gen_something) {
    arg_struct = string_add(arg_struct, tos3("EMPTY_STRUCT_DECLARATION;"));
  };
  arg_struct = string_add(
      arg_struct, _STR("} %.*s ;", arg_struct_name.len, arg_struct_name.str));
  fn_name = compiler__Table_fn_gen_name(p->table, &/*114*/ f);
  string wrapper_name = _STR("%.*s_thread_wrapper", fn_name.len, fn_name.str);
  string wrapper_type = tos3("void*");
  if (p->os == v_dot_pref__v_dot_pref__OS_windows) {
    wrapper_type = tos3("DWORD WINAPI");
  };
  string wrapper_text =
      _STR("%.*s %.*s (%.*s * arg) {%.*s ( /*f*/%.*s ); return 0; }",
           wrapper_type.len, wrapper_type.str, wrapper_name.len,
           wrapper_name.str, arg_struct_name.len, arg_struct_name.str,
           fn_name.len, fn_name.str, str_args.len, str_args.str);
  compiler__CGen_register_thread_fn(p->cgen, wrapper_name, wrapper_text,
                                    arg_struct);
  int tmp_nr = compiler__Parser_get_tmp_counter(p);
  thread_name = _STR("_thread%d", tmp_nr);
  if (p->os != v_dot_pref__v_dot_pref__OS_windows) {
    compiler__Parser_genln(
        p, _STR("pthread_t %.*s;", thread_name.len, thread_name.str));
  };
  string tmp2 = compiler__Parser_get_tmp(p);
  string parg = tos3("NULL");
  if (f.args.len > 0) {
    parg = _STR(" %.*s", tmp_struct.len, tmp_struct.str);
  };
  if (p->os == v_dot_pref__v_dot_pref__OS_windows) {
    compiler__Parser_genln(
        p, _STR(" CreateThread(0,0, (LPTHREAD_START_ROUTINE)%.*s, %.*s, 0,0);",
                wrapper_name.len, wrapper_name.str, parg.len, parg.str));
  } else {
    compiler__Parser_genln(
        p, _STR("int %.*s = pthread_create(& %.*s, NULL, (void *)%.*s, %.*s);",
                tmp2.len, tmp2.str, thread_name.len, thread_name.str,
                wrapper_name.len, wrapper_name.str, parg.len, parg.str));
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
}
void compiler__Parser_verify_fn_before_call(compiler__Parser *p,
                                            compiler__Fn *f) {
  if (f->is_unsafe && !p->builtin_mod && !p->inside_unsafe) {
    compiler__Parser_warn(
        p,
        tos3("you are calling an unsafe function outside of an unsafe block"));
  };
  if (f->is_deprecated) {
    compiler__Parser_warn(p,
                          _STR("%.*s is deprecated", f->name.len, f->name.str));
  };
  if (!f->is_public && !f->is_c && !p->pref->is_test && !f->is_interface &&
      string_ne(f->mod, p->mod)) {
    if (string_eq(f->name, tos3("contains"))) {
      println(
          tos3("use `value in numbers` instead of `numbers.contains(value)`"));
    };
    compiler__Parser_error(
        p, _STR("function `%.*s` is private", f->name.len, f->name.str));
  };
}
void compiler__Parser_fn_call(compiler__Parser *p, compiler__Fn *f,
                              int method_ph, string receiver_var,
                              string receiver_type) {
  compiler__Parser_verify_fn_before_call(p, f);
  bool is_comptime_define =
      string_ne(f->comptime_define, tos3("")) &&
      !((_IN(string, (f->comptime_define), p->v->pref->compile_defines)));
  if (is_comptime_define) {
    p->cgen->nogen = 1;
  };
  if (p->pref->backend == v_dot_pref__v_dot_pref__Backend_x64 &&
      !compiler__Parser_first_pass(&/* ? */ *p)) {
  };
  p->calling_c = f->is_c;
  if (f->is_c && !p->builtin_mod) {
    if (string_eq(f->name, tos3("free"))) {
      compiler__Parser_error(p, tos3("use `free()` instead of `C.free()`"));
    } else if (string_eq(f->name, tos3("malloc"))) {
      compiler__Parser_error(p, tos3("use `malloc()` instead of `C.malloc()`"));
    };
  };
  f->is_used = 1;
  string cgen_name = compiler__Table_fn_gen_name(p->table, f);
  compiler__Parser_next(p);
  array_string generic_param_types = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  if (p->tok == compiler__compiler__TokenKind_lt) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_lt);
    while (1) {
      string param_type = compiler__Parser_check_name(p);
      _PUSH(&generic_param_types,
            (/*typ = array_string   tmp_typ=string*/ param_type), tmp63,
            string);
      if (p->tok != compiler__compiler__TokenKind_comma) {
        break;
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_gt);
  };
  if (f->is_method) {
    compiler__Var receiver = *(compiler__Var *)array_first(f->args);
    bool receiver_is_interface = 0;
    if (string_ends_with(receiver.typ, tos3("er")) ||
        string_at(receiver.typ, 0) == 'I') {
      compiler__Type t =
          compiler__Table_find_type(&/* ? */ *p->table, receiver.typ);
      if (t.cat == compiler__compiler__TypeCategory_interface_) {
        int idx = 0;
        array_compiler__Fn tmp66 = t.methods;
        for (int i = 0; i < tmp66.len; i++) {
          compiler__Fn method = ((compiler__Fn *)tmp66.data)[i];

          if (string_eq(method.name, f->name)) {
            idx = i;
          };
        };
        string var = p->expr_var.name;
        string iname = (*(compiler__Var *)array_get(f->args, 0)).typ;
        if (p->cgen->is_tmp) {
          p->cgen->tmp_line = string_replace(
              p->cgen->tmp_line, _STR(" %.*s", var.len, var.str), tos3(""));
        } else {
          p->cgen->cur_line = string_replace(
              p->cgen->cur_line, _STR(" %.*s", var.len, var.str), tos3(""));
        };
        compiler__Parser_gen(p,
                             _STR("((%.*s "
                                  "(*)())(%.*s_name_table[%.*s._interface_idx]["
                                  "%d]))(%.*s._object",
                                  f->typ.len, f->typ.str, iname.len, iname.str,
                                  var.len, var.str, idx, var.len, var.str));
        receiver_is_interface = 1;
      };
    };
    if (receiver.is_mut && !p->expr_var.is_mut) {
      if (p->expr_var.is_for_var) {
        compiler__Parser_error(
            p, string_add(_STR("`%.*s` is immutable, `for` variables",
                               p->expr_var.name.len, p->expr_var.name.str),
                          tos3(" always are")));
      } else {
        compiler__Parser_error(
            p, _STR("`%.*s` is immutable, declare it with `mut`",
                    p->expr_var.name.len, p->expr_var.name.str));
      };
    };
    if (!p->expr_var.is_changed && receiver.is_mut) {
      compiler__Parser_mark_var_changed(p, p->expr_var);
    };
    if (!receiver_is_interface) {
      compiler__Parser_gen_method_call(p, &/*114*/ receiver, receiver_type,
                                       cgen_name, f->typ, method_ph);
    };
  } else {
    compiler__Parser_gen(p, _STR("%.*s (", cgen_name.len, cgen_name.str));
  };
  bool generic = f->is_generic;
  compiler__Parser_fn_call_args(p, f, generic_param_types);
  if (generic) {
    string line =
        ((p->cgen->is_tmp) ? (p->cgen->tmp_line) : (p->cgen->cur_line));
    compiler__CGen_resetln(
        p->cgen,
        string_replace(line, _STR("%.*s (", cgen_name.len, cgen_name.str),
                       _STR("%.*s (", f->name.len, f->name.str)));
  };
  compiler__Parser_gen(p, tos3(")"));
  p->calling_c = 0;
  if (is_comptime_define) {
    p->cgen->nogen = 0;
    compiler__CGen_resetln(p->cgen, tos3(""));
  };
}
void compiler__Parser_fn_args(compiler__Parser *p, compiler__Fn *f) {
  compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
  if (f->is_interface) {
    compiler__Var interface_arg = (compiler__Var){
        .typ = f->receiver_typ,
        .token_idx = compiler__Parser_cur_tok_index(&/* ? */ *p),
        .name = tos3(""),
        .idx = 0,
        .is_arg = 0,
        .is_const = 0,
        .args = new_array(0, 1, sizeof(compiler__Var)),
        .attr = tos3(""),
        .is_mut = 0,
        .is_alloc = 0,
        .is_returned = 0,
        .ptr = 0,
        .ref = 0,
        .parent_fn = tos3(""),
        .mod = tos3(""),
        .is_global = 0,
        .is_used = 0,
        .is_changed = 0,
        .scope_level = 0,
        .is_c = 0,
        .is_moved = 0,
        .line_nr = 0,
        .is_for_var = 0,
        .is_public = 0};
    _PUSH(&f->args,
          (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ interface_arg),
          tmp69, compiler__Var);
  };
  bool types_only =
      p->tok == compiler__compiler__TokenKind_mul ||
      p->tok == compiler__compiler__TokenKind_amp ||
      (compiler__Parser_peek(&/* ? */ *p) ==
           compiler__compiler__TokenKind_comma &&
       compiler__Table_known_type(&/* ? */ *p->table, p->lit)) ||
      compiler__Parser_peek(&/* ? */ *p) == compiler__compiler__TokenKind_rpar;
  if (types_only) {
    while (p->tok != compiler__compiler__TokenKind_rpar) {

      bool is_mut = p->tok == compiler__compiler__TokenKind_key_mut;
      if (is_mut) {
        compiler__Parser_check(p, compiler__compiler__TokenKind_key_mut);
        ;
      };
      string typ = compiler__Parser_get_type(p);
      if (string_eq(typ, tos3(""))) {
        if (p->prev_tok != compiler__compiler__TokenKind_ellipsis) {
          compiler__Parser_error(p, tos3("bad fn arg type"));
        };
      };
      compiler__Parser_check_and_register_used_imported_type(p, typ);
      compiler__Var v = (compiler__Var){
          .typ = typ,
          .is_arg = 1,
          .is_mut = is_mut,
          .line_nr = p->scanner->line_nr,
          .token_idx = compiler__Parser_cur_tok_index(&/* ? */ *p),
          .name = tos3(""),
          .idx = 0,
          .is_const = 0,
          .args = new_array(0, 1, sizeof(compiler__Var)),
          .attr = tos3(""),
          .is_alloc = 0,
          .is_returned = 0,
          .ptr = 0,
          .ref = 0,
          .parent_fn = tos3(""),
          .mod = tos3(""),
          .is_global = 0,
          .is_used = 0,
          .is_changed = 0,
          .scope_level = 0,
          .is_c = 0,
          .is_moved = 0,
          .is_for_var = 0,
          .is_public = 0};
      _PUSH(&f->args, (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ v),
            tmp70, compiler__Var);
      if (p->tok == compiler__compiler__TokenKind_comma) {
        compiler__Parser_next(p);
        ;
      };
    };
  };
  while (p->tok != compiler__compiler__TokenKind_rpar) {

    array_string names = new_array_from_c_array(
        1, 1, sizeof(string),
        EMPTY_ARRAY_OF_ELEMS(string, 1){compiler__Parser_check_name(p)});
    while (p->tok == compiler__compiler__TokenKind_comma) {

      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
      ;
      _PUSH(
          &names,
          (/*typ = array_string   tmp_typ=string*/ compiler__Parser_check_name(
              p)),
          tmp71, string);
    };
    ;
    bool is_mut = p->tok == compiler__compiler__TokenKind_key_mut;
    if (is_mut) {
      compiler__Parser_check(p, compiler__compiler__TokenKind_key_mut);
      ;
    };
    if (p->tok == compiler__compiler__TokenKind_ellipsis) {
      compiler__Parser_check(p, compiler__compiler__TokenKind_ellipsis);
      if (p->tok == compiler__compiler__TokenKind_rpar) {
        compiler__Parser_error(
            p, tos3("you must provide a type for vargs: eg `...string`. "
                    "multiple types `...` are not supported yet."));
      };
      f->is_variadic = 1;
    };
    string typ = compiler__Parser_get_type(p);
    if (!compiler__Parser_first_pass(&/* ? */ *p) &&
        !compiler__Table_known_type(&/* ? */ *p->table, typ)) {
      compiler__Parser_error(
          p, _STR("fn_args: unknown type %.*s", typ.len, typ.str));
    };
    if (f->is_variadic) {
      if (!f->is_c) {
        if (compiler__Parser_first_pass(&/* ? */ *p) && !f->is_generic) {
          compiler__Parser_register_vargs_stuct(p, typ, 0);
        };
        typ = _STR("varg_%.*s", typ.len, typ.str);
      } else {
        typ = _STR("...%.*s", typ.len, typ.str);
      };
    };
    compiler__Parser_check_and_register_used_imported_type(p, typ);
    if (is_mut && compiler__is_primitive_type(typ)) {
      compiler__Parser_error(
          p, string_add(tos3("mutable arguments are only allowed for arrays, "
                             "maps, and structs."),
                        tos3("\nreturn values instead: `fn foo(n mut int) {` "
                             "=> `fn foo(n int) int {`")));
    };
    array_string tmp72 = names;
    for (int tmp73 = 0; tmp73 < tmp72.len; tmp73++) {
      string name = ((string *)tmp72.data)[tmp73];

      if (is_mut) {
        typ = string_add(typ, tos3("*"));
      };
      compiler__Var v = (compiler__Var){
          .name = name,
          .typ = typ,
          .is_arg = 1,
          .is_mut = is_mut,
          .ptr = is_mut,
          .line_nr = p->scanner->line_nr,
          .token_idx = compiler__Parser_cur_tok_index(&/* ? */ *p),
          .idx = 0,
          .is_const = 0,
          .args = new_array(0, 1, sizeof(compiler__Var)),
          .attr = tos3(""),
          .is_alloc = 0,
          .is_returned = 0,
          .ref = 0,
          .parent_fn = tos3(""),
          .mod = tos3(""),
          .is_global = 0,
          .is_used = 0,
          .is_changed = 0,
          .scope_level = 0,
          .is_c = 0,
          .is_moved = 0,
          .is_for_var = 0,
          .is_public = 0};
      compiler__Parser_register_var(p, v);
      _PUSH(&f->args, (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ v),
            tmp74, compiler__Var);
    };
    if (p->tok == compiler__compiler__TokenKind_comma) {
      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
      ;
    };
    if (p->tok == compiler__compiler__TokenKind_ellipsis) {
      if (!f->is_c) {
        compiler__Parser_error(
            p, tos3("variadic argument syntax must be `arg_name ...type` eg "
                    "`argname ...string`."));
      };
      _PUSH(&f->args,
            (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ (
                compiler__Var){.typ = tos3("..."),
                               .name = tos3(""),
                               .idx = 0,
                               .is_arg = 0,
                               .is_const = 0,
                               .args = new_array(0, 1, sizeof(compiler__Var)),
                               .attr = tos3(""),
                               .is_mut = 0,
                               .is_alloc = 0,
                               .is_returned = 0,
                               .ptr = 0,
                               .ref = 0,
                               .parent_fn = tos3(""),
                               .mod = tos3(""),
                               .is_global = 0,
                               .is_used = 0,
                               .is_changed = 0,
                               .scope_level = 0,
                               .is_c = 0,
                               .is_moved = 0,
                               .line_nr = 0,
                               .token_idx = 0,
                               .is_for_var = 0,
                               .is_public = 0}),
            tmp75, compiler__Var);
      compiler__Parser_next(p);
    };
  };
  { compiler__Parser_check(p, compiler__compiler__TokenKind_rpar); }
}
void compiler__Parser_fn_call_args(compiler__Parser *p, compiler__Fn *f,
                                   array_string generic_param_types) {
  compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
  if (f->is_c) {
    while (p->tok != compiler__compiler__TokenKind_rpar) {

      p->calling_c = 1;
      int ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
      string typ = compiler__Parser_bool_expression(p);
      if (string_eq(typ, tos3("byte*"))) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("(char*)"));
      };
      if (p->tok == compiler__compiler__TokenKind_comma) {
        compiler__Parser_gen(p, tos3(", "));
        compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
        ;
      };
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);

    return;
  };
  if (p->v->pref->is_debug && string_eq(f->name, tos3("panic")) && !p->is_js) {
    string mod_name = string_replace(p->mod, tos3("_dot_"), tos3("."));
    string fn_name = string_replace(
        p->cur_fn.name, _STR("%.*s__", p->mod.len, p->mod.str), tos3(""));
    string file_path = compiler__cescaped_path(p->file_path);
    compiler__CGen_resetln(
        p->cgen, string_replace(p->cgen->cur_line, tos3("v_panic ("),
                                _STR("panic_debug (%d, tos3(\"%.*s\"), "
                                     "tos3(\"%.*s\"), tos2((byte *)\"%.*s\"), ",
                                     p->scanner->line_nr, file_path.len,
                                     file_path.str, mod_name.len, mod_name.str,
                                     fn_name.len, fn_name.str)));
  };
  array_string saved_args = generic_param_types;
  array_compiler__Var tmp76 = f->args;
  for (int i = 0; i < tmp76.len; i++) {
    compiler__Var arg = ((compiler__Var *)tmp76.data)[i];

    if (i == 0 && f->is_method) {
      if (f->args.len > 1) {
        compiler__Parser_gen(p, tos3(", "));
      };
      continue;
    };
    if (i == f->args.len - 1 && string_starts_with(arg.typ, tos3("varg_"))) {
      break;
    };
    int ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
    if (p->tok == compiler__compiler__TokenKind_rpar) {
      compiler__Parser_error(p,
                             _STR("not enough arguments in call to `%.*s`",
                                  compiler__Fn_str_for_error(&/* ? */ *f).len,
                                  compiler__Fn_str_for_error(&/* ? */ *f).str));
    };
    if (arg.is_mut) {
      if (p->tok != compiler__compiler__TokenKind_key_mut &&
          p->tok == compiler__compiler__TokenKind_name) {
        compiler__Parser_mutable_arg_error(p, i, arg, *f);
      };
      if (compiler__Parser_peek(&/* ? */ *p) !=
          compiler__compiler__TokenKind_name) {
        compiler__Parser_error(
            p, string_add(
                   _STR("`%.*s` is a mutable argument, you need to ",
                        arg.name.len, arg.name.str),
                   _STR("provide a variable to modify: `%.*s(... mut a...)`",
                        f->name.len, f->name.str)));
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_key_mut);
      ;
      string var_name = p->lit;
      Option_compiler__Var tmp77 =
          compiler__Parser_find_var(&/* ? */ *p, var_name);
      compiler__Var v;
      if (!tmp77.ok) {
        string err = tmp77.error;
        int errcode = tmp77.ecode;
        compiler__Parser_error(
            p, string_add(
                   _STR("`%.*s` is a mutable argument, you need to ",
                        arg.name.len, arg.name.str),
                   _STR("provide a variable to modify: `%.*s(... mut a...)`",
                        f->name.len, f->name.str)));
        v_exit(1);
      }
      v = *(compiler__Var *)tmp77.data;
      ;
      if (!v.is_changed) {
        compiler__Parser_mark_var_changed(p, v);
      };
    };
    p->expected_type = arg.typ;
    bool clone = p->pref->autofree && string_ne(p->mod, tos3("string")) &&
                 string_eq(arg.typ, tos3("string")) && !p->builtin_mod;
    if (clone) {
      compiler__Parser_gen(
          p,
          _STR("/*YY f=%.*s arg=%.*s is_moved=%d*/string_clone(", f->name.len,
               f->name.str, arg.name.len, arg.name.str, arg.is_moved));
    };
    if (p->pref->backend == v_dot_pref__v_dot_pref__Backend_x64 && i == 0 &&
        string_eq(f->name, tos3("println")) &&
        p->tok == compiler__compiler__TokenKind_string &&
        compiler__Parser_peek(&/* ? */ *p) ==
            compiler__compiler__TokenKind_rpar) {
    };
    string typ = compiler__Parser_bool_expression(p);
    if (string_ends_with(arg.typ, tos3("er")) || string_at(arg.typ, 0) == 'I') {
      compiler__Type t = compiler__Table_find_type(&/* ? */ *p->table, arg.typ);
      if (t.cat == compiler__compiler__TypeCategory_interface_) {
        string concrete_type_name =
            string_replace(typ, tos3("*"), tos3("_ptr"));
        if (!string_ends_with(concrete_type_name, tos3("_ptr"))) {
          compiler__CGen_set_placeholder(
              p->cgen, ph,
              _STR("I_%.*s_to_%.*s(", concrete_type_name.len,
                   concrete_type_name.str, arg.typ.len, arg.typ.str));
          compiler__Parser_gen(p, tos3(")"));
        };
        compiler__Table_add_gen_type(p->table, arg.typ, typ);
      };
    };
    if (clone) {
      compiler__Parser_gen(p, tos3(")"));
    };
    if (i == 0 &&
        (string_eq(f->name, tos3("println")) ||
         string_eq(f->name, tos3("print"))) &&
        string_eq(typ, tos3("ustring"))) {
      if (string_eq(typ, tos3("ustring"))) {
        compiler__Parser_gen(p, tos3(".s"));
      };
      typ = tos3("string");
    };
    if (i == 0 &&
        (string_eq(f->name, tos3("println")) ||
         string_eq(f->name, tos3("print"))) &&
        !((string_eq(typ, tos3("string")) || string_eq(typ, tos3("ustring")) ||
           string_eq(typ, tos3("void"))))) {
      compiler__Type tt = compiler__Table_find_type(&/* ? */ *p->table, typ);
#ifndef _WIN32
#endif
      ;
      if (string_ends_with(typ, tos3("*"))) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("ptr_str("));
        compiler__Parser_gen(p, tos3(")"));
        continue;
      };
#ifndef _VJS
      if (!compiler__Type_has_method(&/* ? */ tt, tos3("str"))) {
        if (string_starts_with(tt.name, tos3("varg_"))) {
          compiler__Parser_gen_varg_str(p, tt);
          compiler__CGen_set_placeholder(p->cgen, ph,
                                         _STR("%.*s_str(", typ.len, typ.str));
          compiler__Parser_gen(p, tos3(")"));
          continue;
        } else if (string_starts_with(tt.name, tos3("array_"))) {
          compiler__Parser_gen_array_str(p, tt);
          compiler__CGen_set_placeholder(p->cgen, ph,
                                         _STR("%.*s_str(", typ.len, typ.str));
          compiler__Parser_gen(p, tos3(")"));
          continue;
        } else if (tt.cat == compiler__compiler__TypeCategory_struct_) {
          compiler__Parser_gen_struct_str(p, tt);
          compiler__CGen_set_placeholder(p->cgen, ph,
                                         _STR("%.*s_str(", typ.len, typ.str));
          compiler__Parser_gen(p, tos3(")"));
          continue;
        } else {
          string base = compiler__Parser_base_type(p, tt.name);
          if (string_ne(base, tt.name)) {
            compiler__Type base_type =
                compiler__Parser_find_type(&/* ? */ *p, base);
            if (compiler__Type_has_method(&/* ? */ base_type, tos3("str"))) {
              compiler__CGen_set_placeholder(
                  p->cgen, ph,
                  _STR("%.*s_str(", base_type.name.len, base_type.name.str));
              compiler__Parser_gen(p, tos3(")"));
              continue;
            };
          };
        };
        string error_msg =
            (_STR("`%.*s` needs to have method `str() string` to be printable",
                  typ.len, typ.str));
        compiler__Parser_error(p, error_msg);
      };
      compiler__CGen_set_placeholder(p->cgen, ph,
                                     _STR("%.*s_str(", typ.len, typ.str));
      compiler__Parser_gen(p, tos3(")"));
#endif
      ;
      continue;
    };
    string got = typ;
    string expected = arg.typ;
    bool got_ptr = string_ends_with(got, tos3("*"));
    bool exp_ptr = string_ends_with(expected, tos3("*"));
    bool type_mismatch =
        !compiler__Parser_check_types_no_throw(p, got, expected);
    if (type_mismatch && f->is_generic) {
      _PUSH(&saved_args, (/*typ = array_string   tmp_typ=string*/ got), tmp80,
            string);
    } else if (type_mismatch) {
      int j = i;
      if (f->is_method) {
        j--;
      };
      string nr = _STR("%dth", j + 1);
      if (j == 0) {
        nr = tos3("first");
      } else if (j == 1) {
        nr = tos3("second");
      } else if (j == 2) {
        nr = tos3("third");
      };
      compiler__Parser_error(
          p, string_add(
                 _STR("cannot use type `%.*s` as type `%.*s` in %.*s ", typ.len,
                      typ.str, arg.typ.len, arg.typ.str, nr.len, nr.str),
                 _STR("argument to `%.*s()`", f->name.len, f->name.str)));
    } else {
      _PUSH(&saved_args, (/*typ = array_string   tmp_typ=string*/ tos3("")),
            tmp81, string);
    };
    bool is_interface =
        compiler__Table_is_interface(&/* ? */ *p->table, arg.typ);
    if (!is_interface) {
      if (got_ptr && !exp_ptr) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3("*"));
      };
      if (!got_ptr && exp_ptr && string_ne(got, tos3("voidptr"))) {
        if (string_starts_with(expected, tos3("array_")) && exp_ptr) {
          compiler__CGen_set_placeholder(p->cgen, ph,
                                         tos3("& /*111*/ (array[]){"));
          compiler__Parser_gen(p, tos3("}[0] "));
        } else if (exp_ptr && string_eq(expected, string_add(got, tos3("*")))) {
#ifndef __TINYC__
          string expr = string_substr2(p->cgen->cur_line, ph, -1, true);
          if (string_contains(expr, tos3("("))) {
            compiler__CGen_set_placeholder(
                p->cgen, ph,
                _STR("& /*113 e=\"%.*s\" g=\"%.*s\"*/ (%.*s[]){", expected.len,
                     expected.str, got.len, got.str, got.len, got.str));
            compiler__Parser_gen(p, tos3("}[0] "));
          } else {
            compiler__CGen_set_placeholder(p->cgen, ph, tos3("& /*114*/"));
          };
#else
          compiler__CGen_set_placeholder(p->cgen, ph, tos3("& /*114*/"));
#endif
          ;
        } else if (!(string_eq(expected, tos3("void*")) &&
                     string_eq(got, tos3("int"))) &&
                   !(string_eq(expected, tos3("void*")) &&
                     string_eq(got, tos3("byteptr"))) &&
                   !(string_eq(expected, tos3("byte*")) &&
                     string_contains(got, tos3("]byte"))) &&
                   !(string_eq(expected, tos3("byte*")) &&
                     string_eq(got, tos3("string"))) &&
                   !(string_eq(expected, tos3("byte*")) &&
                     string_eq(got, tos3("byteptr"))) &&
                   !p->pref->is_bare) {
          compiler__CGen_set_placeholder(
              p->cgen, ph,
              _STR("& /*112 e=\"%.*s\" g=\"%.*s\" */", expected.len,
                   expected.str, got.len, got.str));
        };
      };
    } else if (is_interface) {
      if (!got_ptr) {
      };
    };
    if (i < f->args.len - 1) {
      if (p->tok != compiler__compiler__TokenKind_comma && !f->is_variadic) {
        compiler__Parser_error(
            p, _STR("wrong number of arguments in call to `%.*s`",
                    compiler__Fn_str_for_error(&/* ? */ *f).len,
                    compiler__Fn_str_for_error(&/* ? */ *f).str));
      };
      if (p->tok == compiler__compiler__TokenKind_comma &&
          (!f->is_variadic || (f->is_variadic && i < f->args.len - 2))) {
        compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
        ;
        compiler__Parser_gen(p, tos3(","));
      } else if (p->tok != compiler__compiler__TokenKind_comma) {
        compiler__Parser_gen(p, tos3(","));
      };
    };
  };
  _V_MulRet_string_V_array_string _V_mret_6377_varg_type_varg_values =
      compiler__Parser_fn_call_vargs(p, *f);
  string varg_type = _V_mret_6377_varg_type_varg_values.var_0;
  array_string varg_values = _V_mret_6377_varg_type_varg_values.var_1;
  if (f->is_variadic) {
    _PUSH(&saved_args, (/*typ = array_string   tmp_typ=string*/ varg_type),
          tmp84, string);
  };
  if (p->tok == compiler__compiler__TokenKind_comma) {
    compiler__Parser_error(p,
                           _STR("wrong number of arguments in call to `%.*s`",
                                compiler__Fn_str_for_error(&/* ? */ *f).len,
                                compiler__Fn_str_for_error(&/* ? */ *f).str));
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
  if (f->is_generic && !p->scanner->is_fmt) {
    compiler__TypeInst type_map =
        compiler__Parser_extract_type_inst(p, f, saved_args);
    compiler__Parser_dispatch_generic_fn_instance(p, f, &type_map);
  };
  if (f->is_variadic) {
    compiler__Parser_fn_gen_caller_vargs(p, f, varg_type, varg_values);
  };
}
compiler__TypeInst compiler__Parser_extract_type_inst(compiler__Parser *p,
                                                      compiler__Fn *f,
                                                      array_string args_) {
  compiler__TypeInst r =
      (compiler__TypeInst){.inst = new_map(1, sizeof(string)), .done = 0};
  int i = 0;
  array_string args = args_;
  if (string_ne(f->typ, tos3("void"))) {
    _PUSH(&args, (/*typ = array_string   tmp_typ=string*/ f->typ), tmp85,
          string);
  };
  array_string tmp86 = args;
  for (int tmp87 = 0; tmp87 < tmp86.len; tmp87++) {
    string e = ((string *)tmp86.data)[tmp87];

    if (string_eq(e, tos3(""))) {
      continue;
    };
    string tp = (*(string *)array_get(f->type_pars, i));
    string ti = e;
    if (string_starts_with(ti, tos3("fn ("))) {
      array_string fn_args = string_split(
          string_all_before(string_substr2(ti, 4, -1, true), tos3(") ")),
          tos3(","));
      bool found = 0;
      array_string tmp92 = fn_args;
      for (int tmp93 = 0; tmp93 < tmp92.len; tmp93++) {
        string fa_ = ((string *)tmp92.data)[tmp93];

        string fa = fa_;
        while (string_starts_with(fa, tos3("array_"))) {

          fa = string_substr2(fa, 6, -1, true);
        };
        if (string_eq(fa, tp)) {
          map_set(&r.inst, tp, &(string[]){fa});
          found = 1;
          i++;
          break;
        };
      };
      if (found) {
        continue;
      };
      ti = string_all_after(ti, tos3(") "));
    };
    while (string_starts_with(ti, tos3("array_"))) {

      ti = string_substr2(ti, 6, -1, true);
    };
    string tmp98 = tos3("");
    bool tmp99 = map_get(/*fn.v : 1378*/ r.inst, tp, &tmp98);

    if (!tmp99)
      tmp98 = tos((byte *)"", 0);

    if (string_ne(tmp98, tos3(""))) {
      string tmp100 = tos3("");
      bool tmp101 = map_get(/*fn.v : 1379*/ r.inst, tp, &tmp100);

      if (!tmp101)
        tmp100 = tos((byte *)"", 0);

      if (string_ne(tmp100, ti)) {
        string tmp102 = tos3("");
        bool tmp103 = map_get(/*fn.v : 1380*/ r.inst, tp, &tmp102);

        if (!tmp103)
          tmp102 = tos((byte *)"", 0);

        compiler__Parser_error(
            p, _STR("type parameter `%.*s` has type %.*s, not `%.*s`", tp.len,
                    tp.str, tmp102.len, tmp102.str, ti.len, ti.str));
      };
      continue;
    };
    map_set(&r.inst, tp, &(string[]){ti});
    i++;
    if (i >= f->type_pars.len) {
      break;
    };
  };
  string tmp104 = tos3("");
  bool tmp105 = map_get(/*fn.v : 1391*/ r.inst, f->typ, &tmp104);

  if (!tmp105)
    tmp104 = tos((byte *)"", 0);

  if (string_eq(tmp104, tos3("")) && (_IN(string, (f->typ), f->type_pars))) {
    map_set(&r.inst, f->typ, &(string[]){tos3("_ANYTYPE_")});
  };
  array_string tmp106 = f->type_pars;
  for (int tmp107 = 0; tmp107 < tmp106.len; tmp107++) {
    string tp = ((string *)tmp106.data)[tmp107];

    string tmp108 = tos3("");
    bool tmp109 = map_get(/*fn.v : 1395*/ r.inst, tp, &tmp108);

    if (!tmp109)
      tmp108 = tos((byte *)"", 0);

    if (string_eq(tmp108, tos3(""))) {
      compiler__Parser_error(
          p, _STR("unused type parameter `%.*s`", tp.len, tp.str));
    };
  };
  return r;
}
string compiler__replace_generic_type(string gen_type, compiler__TypeInst *ti) {
  string typ = string_replace(
      string_trim_right(
          string_replace(string_replace(gen_type, tos3("map_"), tos3("")),
                         tos3("varg_"), tos3("")),
          tos3("*")),
      tos3("ptr_"), tos3(""));
  while (string_starts_with(typ, tos3("array_"))) {

    typ = string_substr2(typ, 6, -1, true);
  };
  if ((_IN_MAP((typ), ti->inst))) {
    string tmp112 = tos3("");
    bool tmp113 = map_get(/*fn.v : 1410*/ ti->inst, typ, &tmp112);

    if (!tmp113)
      tmp112 = tos((byte *)"", 0);

    typ = string_replace(gen_type, typ, tmp112);
    return typ;
  };
  typ = gen_type;
  if (string_starts_with(typ, tos3("fn ("))) {
    array_string args = string_split(
        string_all_before_last(string_substr2(typ, 4, -1, true), tos3(")")),
        tos3(","));
    string ret_t = string_trim_space(string_all_after(typ, tos3(")")));
    array_string args_r = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    array_string tmp116 = args;
    for (int tmp117 = 0; tmp117 < tmp116.len; tmp117++) {
      string arg = ((string *)tmp116.data)[tmp117];

      _PUSH(&args_r,
            (/*typ = array_string   tmp_typ=string*/
             compiler__replace_generic_type(arg, ti)),
            tmp118, string);
    };
    string t = string_add(
        string_add(tos3("fn ("), array_string_join(args_r, tos3(","))),
        tos3(")"));
    if (ret_t.len > 0) {
      t = string_add(
          t, string_add(tos3(" "), compiler__replace_generic_type(ret_t, ti)));
    };
    typ = t;
  };
  return typ;
}
void compiler__replace_generic_type_params(compiler__Fn *f,
                                           compiler__TypeInst *ti) {
  array_compiler__Var args = new_array_from_c_array(
      0, 0, sizeof(compiler__Var),
      EMPTY_ARRAY_OF_ELEMS(compiler__Var, 0){TCCSKIP(0)});
  array_compiler__Var tmp119 = f->args;
  for (int i = 0; i < tmp119.len; i++) {

    compiler__Var arg = (*(compiler__Var *)array_get(f->args, i));
    arg.typ = compiler__replace_generic_type(arg.typ, ti);
    _PUSH(&args, (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ arg),
          tmp122, compiler__Var);
  };
  f->args = args;
  f->typ = compiler__replace_generic_type(f->typ, ti);
  if (string_ends_with(f->typ, tos3("_T"))) {
    string par = (*(string *)array_get(map_keys(&/* ? */ ti->inst), 0));
    string tmp125 = tos3("");
    bool tmp126 = map_get(/*fn.v : 1443*/ ti->inst, par, &tmp125);

    if (!tmp126)
      tmp125 = tos((byte *)"", 0);

    f->typ = string_add(string_add(f->typ, tos3("_")), tmp125);
  };
}
string compiler__Parser_register_vargs_stuct(compiler__Parser *p, string typ,
                                             int len) {
  string vargs_struct = _STR("varg_%.*s", typ.len, typ.str);
  compiler__Type varg_type =
      (compiler__Type){.cat = compiler__compiler__TypeCategory_struct_,
                       .name = vargs_struct,
                       .mod = p->mod,
                       .is_public = 0,
                       .fields = new_array(0, 1, sizeof(compiler__Var)),
                       .methods = new_array(0, 1, sizeof(compiler__Fn)),
                       .parent = tos3(""),
                       .is_c = 0,
                       .enum_vals = new_array(0, 1, sizeof(string)),
                       .gen_types = new_array(0, 1, sizeof(string)),
                       .default_vals = new_array(0, 1, sizeof(string)),
                       .parser_idx = 0,
                       .decl_tok_idx = 0,
                       .is_placeholder = 0,
                       .gen_str = 0,
                       .is_flag = 0,
                       .is_generic = 0,
                       .ctype_names = new_array(0, 1, sizeof(string))};
  int varg_len = len;
  if (!compiler__Table_known_type(&/* ? */ *p->table, vargs_struct)) {
    compiler__Table_register_type(p->table, varg_type);
    _PUSH(&p->cgen->typedefs,
          (/*typ = array_string   tmp_typ=string*/ _STR(
              "typedef struct %.*s %.*s;\n", vargs_struct.len, vargs_struct.str,
              vargs_struct.len, vargs_struct.str)),
          tmp127, string);
  } else {
    compiler__Type ex_typ =
        compiler__Table_find_type(&/* ? */ *p->table, vargs_struct);
    int ex_len = v_string_int(string_substr2(
        (*(compiler__Var *)array_get(ex_typ.fields, 1)).name, 5,
        (*(compiler__Var *)array_get(ex_typ.fields, 1)).name.len - 1, false));
    if (ex_len > varg_len) {
      varg_len = ex_len;
    };
    compiler__Table_rewrite_type(p->table, varg_type);
  };
  compiler__Table_add_field(p->table, vargs_struct, tos3("len"), tos3("int"), 0,
                            tos3(""), compiler__compiler__AccessMod_public);
  compiler__Table_add_field(p->table, vargs_struct, _STR("args[%d]", varg_len),
                            typ, 0, tos3(""),
                            compiler__compiler__AccessMod_public);
  return vargs_struct;
}
_V_MulRet_string_V_array_string
compiler__Parser_fn_call_vargs(compiler__Parser *p, compiler__Fn f) {
  if (!f.is_variadic) {
    return (_V_MulRet_string_V_array_string){
        .var_0 = tos3(""),
        .var_1 = new_array_from_c_array(
            0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)})};
  };
  compiler__Var last_arg = *(compiler__Var *)array_last(f.args);
  array_string types = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_string values = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  while (p->tok != compiler__compiler__TokenKind_rpar) {

    if (p->tok == compiler__compiler__TokenKind_comma) {
      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
    };
    _V_MulRet_string_V_string _V_mret_7324_varg_type_varg_value =
        compiler__Parser_tmp_expr(p);
    string varg_type = _V_mret_7324_varg_type_varg_value.var_0;
    string varg_value = _V_mret_7324_varg_type_varg_value.var_1;
    if (string_starts_with(varg_type, tos3("varg_")) &&
        (values.len > 0 || p->tok == compiler__compiler__TokenKind_comma)) {
      compiler__Parser_error(
          p, tos3("You cannot pass additional vargs when forwarding vargs to "
                  "another function/method"));
    };
    if (!f.is_generic) {
      compiler__Parser_check_types(p, last_arg.typ, varg_type);
    } else {
      if (types.len > 0) {
        array_string tmp134 = types;
        for (int tmp135 = 0; tmp135 < tmp134.len; tmp135++) {
          string t = ((string *)tmp134.data)[tmp135];

          compiler__Parser_check_types(p, varg_type, t);
        };
      };
    };
    string ref_deref = ((string_ends_with(last_arg.typ, tos3("*")) &&
                         !string_ends_with(varg_type, tos3("*")))
                            ? (tos3("&"))
                            : (((!string_ends_with(last_arg.typ, tos3("*")) &&
                                 string_ends_with(varg_type, tos3("*")))
                                    ? (tos3("*"))
                                    : (tos3("")))));
    _PUSH(&types, (/*typ = array_string   tmp_typ=string*/ varg_type), tmp136,
          string);
    _PUSH(&values,
          (/*typ = array_string   tmp_typ=string*/ _STR(
              "%.*s%.*s", ref_deref.len, ref_deref.str, varg_value.len,
              varg_value.str)),
          tmp137, string);
  };
  array_compiler__VargAccess tmp138 = p->table->varg_access;
  for (int tmp139 = 0; tmp139 < tmp138.len; tmp139++) {
    compiler__VargAccess va = ((compiler__VargAccess *)tmp138.data)[tmp139];

    if (string_ne(va.fn_name, f.name)) {
      continue;
    };
    if (va.index >= values.len) {
      compiler__Parser_error_with_token_index(
          p,
          _STR("variadic arg index out of range: %d/%d, vargs are 0 indexed",
               va.index, values.len - 1),
          va.tok_idx);
    };
  };
  if (types.len == 0) {
    return (_V_MulRet_string_V_array_string){
        .var_0 = last_arg.typ,
        .var_1 = new_array_from_c_array(
            0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)})};
  };
  int insert_comma_after_arg = ((f.is_method) ? (2) : (1));
  if (f.args.len > insert_comma_after_arg) {
    compiler__CGen_gen(p->cgen, tos3(","));
  };
  return (_V_MulRet_string_V_array_string){
      .var_0 = (*(string *)array_get(types, 0)), .var_1 = values};
}
void compiler__Parser_fn_gen_caller_vargs(compiler__Parser *p, compiler__Fn *f,
                                          string varg_type,
                                          array_string values) {
  bool is_varg = string_starts_with(varg_type, tos3("varg_"));
  if (is_varg) {
    if (values.len == 0) {
      string vargs_struct =
          compiler__Parser_register_vargs_stuct(p, varg_type, 1);
      compiler__CGen_gen(
          p->cgen, _STR("&(%.*s){.len=0}", vargs_struct.len, vargs_struct.str));
    } else {
      compiler__CGen_gen(p->cgen,
                         _STR("%.*s", (*(string *)array_get(values, 0)).len,
                              (*(string *)array_get(values, 0)).str));
    };
  } else {
    string vargs_struct =
        compiler__Parser_register_vargs_stuct(p, varg_type, values.len);
    compiler__CGen_gen(
        p->cgen,
        string_add(string_add(_STR("&(%.*s){.len=%d,.args={", vargs_struct.len,
                                   vargs_struct.str, values.len),
                              array_string_join(values, tos3(","))),
                   tos3("}}")));
  };
}
string compiler__Parser_register_multi_return_stuct(compiler__Parser *p,
                                                    array_string types) {
  string typ = string_add(tos3("_V_MulRet_"),
                          string_replace(array_string_join(types, tos3("_V_")),
                                         tos3("*"), tos3("_PTR_")));
  if (compiler__Table_known_type(&/* ? */ *p->table, typ)) {
    return typ;
  };
  compiler__Table_register_type(
      p->table,
      (compiler__Type){.cat = compiler__compiler__TypeCategory_struct_,
                       .name = typ,
                       .mod = p->mod,
                       .is_public = 0,
                       .fields = new_array(0, 1, sizeof(compiler__Var)),
                       .methods = new_array(0, 1, sizeof(compiler__Fn)),
                       .parent = tos3(""),
                       .is_c = 0,
                       .enum_vals = new_array(0, 1, sizeof(string)),
                       .gen_types = new_array(0, 1, sizeof(string)),
                       .default_vals = new_array(0, 1, sizeof(string)),
                       .parser_idx = 0,
                       .decl_tok_idx = 0,
                       .is_placeholder = 0,
                       .gen_str = 0,
                       .is_flag = 0,
                       .is_generic = 0,
                       .ctype_names = new_array(0, 1, sizeof(string))});
  array_string tmp144 = string_split(
      string_replace(string_replace(typ, tos3("_V_MulRet_"), tos3("")),
                     tos3("_PTR_"), tos3("*")),
      tos3("_V_"));
  for (int i = 0; i < tmp144.len; i++) {
    string t = ((string *)tmp144.data)[i];

    compiler__Table_add_field(p->table, typ, _STR("var_%d", i), t, 0, tos3(""),
                              compiler__compiler__AccessMod_public);
  };
  _PUSH(&p->cgen->typedefs,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "typedef struct %.*s %.*s;", typ.len, typ.str, typ.len, typ.str)),
        tmp145, string);
  return typ;
}
void compiler__rename_generic_fn_instance(compiler__Fn *f,
                                          compiler__TypeInst *ti) {
  f->name = string_add(f->name, tos3("_T"));
  array_string tmp146 = map_keys(&/* ? */ ti->inst);
  for (int tmp147 = 0; tmp147 < tmp146.len; tmp147++) {
    string k = ((string *)tmp146.data)[tmp147];

    string tmp148 = tos3("");
    bool tmp149 = map_get(/*fn.v : 1560*/ ti->inst, k, &tmp148);

    if (!tmp149)
      tmp148 = tos((byte *)"", 0);

    f->name = string_add(string_add(f->name, tos3("_")),
                         compiler__type_to_safe_str(tmp148));
  };
}
void compiler__Parser_dispatch_generic_fn_instance(compiler__Parser *p,
                                                   compiler__Fn *f,
                                                   compiler__TypeInst *ti) {
  bool new_inst = 1;
  array_compiler__TypeInst tmp150 = f->type_inst;
  for (int tmp151 = 0; tmp151 < tmp150.len; tmp151++) {
    compiler__TypeInst e = ((compiler__TypeInst *)tmp150.data)[tmp151];

    if (string_eq(map_string_str(e.inst), map_string_str(ti->inst))) {
      new_inst = 0;
      break;
    };
  };
  if (!new_inst) {
    compiler__rename_generic_fn_instance(f, ti);
    compiler__replace_generic_type_params(f, ti);
    Option_compiler__Fn tmp152 =
        compiler__Table_find_fn(&/* ? */ *p->table, f->name);
    if (!tmp152.ok) {
      string err = tmp152.error;
      int errcode = tmp152.ecode;
      compiler__Parser_error(p, _STR("function instance `%.*s` not found",
                                     f->name.len, f->name.str));

      return;
    };

    return;
  };
  _PUSH(&f->type_inst,
        (/*typ = array_compiler__TypeInst   tmp_typ=compiler__TypeInst*/ *ti),
        tmp153, compiler__TypeInst);
  compiler__Table_register_fn(p->table, *f);
  if (f->is_method) {
    f->name = string_add(string_add(f->receiver_typ, tos3("_")), f->name);
  };
  compiler__rename_generic_fn_instance(f, ti);
  compiler__replace_generic_type_params(f, ti);
  if (f->is_method) {
  } else {
    compiler__Table_register_fn(p->table, *f);
  };
  compiler__Parser gp =
      (*(compiler__Parser *)array_get(p->v->parsers, f->parser_idx));
  gp.is_vgen = 1;
  compiler__ParserState saved_state = compiler__Parser_save_state(&/* ? */ *p);
  compiler__Parser_clear_state(p, 0, 1);
  gp.token_idx = f->generic_fn_idx;
  gp.generic_dispatch = *ti;
  compiler__Parser_next(&/* ? */ gp);
  compiler__Parser_fn_decl(&/* ? */ gp);
  gp.generic_dispatch =
      (compiler__TypeInst){.inst = new_map(1, sizeof(string)), .done = 0};
  _PUSH_MANY(&p->cgen->lines_extra,
             (/*typ = array_string   tmp_typ=string*/ p->cgen->lines), tmp156,
             array_string);
  compiler__Parser_restore_state(p, saved_state, 0, 1);
  _PUSH(&p->cgen->fns,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "%.*s;", compiler__Parser_fn_signature(&/* ? */ *p, f).len,
            compiler__Parser_fn_signature(&/* ? */ *p, f).str)),
        tmp157, string);
}
string compiler__Fn_typ_str(compiler__Fn *f) {
  strings__Builder sb = strings__new_builder(50);
  strings__Builder_write(&/* ? */ sb, tos3("fn ("));
  array_compiler__Var tmp158 = f->args;
  for (int i = 0; i < tmp158.len; i++) {
    compiler__Var arg = ((compiler__Var *)tmp158.data)[i];

    strings__Builder_write(&/* ? */ sb, arg.typ);
    if (i < f->args.len - 1) {
      strings__Builder_write(&/* ? */ sb, tos3(","));
    };
  };
  strings__Builder_write(&/* ? */ sb, tos3(")"));
  if (string_ne(f->typ, tos3("void"))) {
    strings__Builder_write(&/* ? */ sb, _STR(" %.*s", f->typ.len, f->typ.str));
  };
  return strings__Builder_str(&/* ? */ sb);
}
string compiler__Fn_str_args(compiler__Fn *f, compiler__Table *table) {
  string s = tos3("");
  array_compiler__Var tmp159 = f->args;
  for (int i = 0; i < tmp159.len; i++) {
    compiler__Var arg = ((compiler__Var *)tmp159.data)[i];

    if (string_starts_with(arg.typ, tos3("varg_"))) {
      s = string_add(s, _STR("%.*s *%.*s", arg.typ.len, arg.typ.str,
                             arg.name.len, arg.name.str));
    } else {
      s = string_add(s, compiler__Table_cgen_name_type_pair(&/* ? */ *table,
                                                            arg.name, arg.typ));
    };
    if (i < f->args.len - 1) {
      s = string_add(s, tos3(", "));
    };
  };
  return s;
}
string compiler__Fn_str_args_without_types(compiler__Fn *f,
                                           compiler__Table *table) {
  array_string res = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_compiler__Var tmp160 = f->args;
  for (int tmp161 = 0; tmp161 < tmp160.len; tmp161++) {
    compiler__Var arg = ((compiler__Var *)tmp160.data)[tmp161];

    _PUSH(&res, (/*typ = array_string   tmp_typ=string*/ arg.name), tmp162,
          string);
  };
  return array_string_join(res, tos3(", "));
}
string compiler__Parser_find_misspelled_local_var(compiler__Parser *p,
                                                  string name, f32 min_match) {
  f32 closest = ((f32)(0));
  string closest_var = tos3("");
  array_compiler__Var tmp163 = p->local_vars;
  for (int tmp164 = 0; tmp164 < tmp163.len; tmp164++) {
    compiler__Var var = ((compiler__Var *)tmp163.data)[tmp164];

    if (var.scope_level > p->cur_fn.scope_level) {
      continue;
    };
    string n = string_all_after(name, tos3("."));
    if (string_eq(var.name, tos3("")) ||
        (n.len - var.name.len > 2 || var.name.len - n.len > 2)) {
      continue;
    };
    f32 c = strings__dice_coefficient(var.name, n);
    if (macro_f32_gt(c, closest)) {
      closest = c;
      closest_var = var.name;
    };
  };
  return ((macro_f32_ge(closest, min_match)) ? (closest_var) : (tos3("")));
}
bool array_compiler__Fn_contains(array_compiler__Fn fns, compiler__Fn f) {
  array_compiler__Fn tmp165 = fns;
  for (int tmp166 = 0; tmp166 < tmp165.len; tmp166++) {
    compiler__Fn ff = ((compiler__Fn *)tmp165.data)[tmp166];

    if (string_eq(ff.name, f.name)) {
      return 1;
    };
  };
  return 0;
}
string compiler__Parser_fn_signature(compiler__Parser *p, compiler__Fn *f) {
  return _STR("%.*s %.*s(%.*s)", f->typ.len, f->typ.str, f->name.len,
              f->name.str, compiler__Fn_str_args(&/* ? */ *f, p->table).len,
              compiler__Fn_str_args(&/* ? */ *f, p->table).str);
}
string compiler__Fn_v_fn_module(compiler__Fn *f) { return f->mod; }
string compiler__Fn_v_fn_name(compiler__Fn *f) {
  return string_replace(f->name, _STR("%.*s__", f->mod.len, f->mod.str),
                        tos3(""));
}
string compiler__Fn_str_for_error(compiler__Fn *f) {
  string s = tos3("");
  array_compiler__Var tmp167 = f->args;
  for (int i = 0; i < tmp167.len; i++) {
    compiler__Var a = ((compiler__Var *)tmp167.data)[i];

    if (i == 0) {
      if (f->is_method) {
        s = string_add(
            s, string_add(string_add(string_add(a.typ, tos3(".")), f->name),
                          tos3("(")));
        continue;
      };
      s = string_add(s, string_add(f->name, tos3("(")));
    };
    s = string_add(s, a.typ);
    if (i < f->args.len - 1) {
      s = string_add(s, tos3(", "));
    };
  };
  return string_add(s, tos3(")"));
}
void compiler__Parser_for_st(compiler__Parser *p) {
  compiler__Parser_check(p, compiler__compiler__TokenKind_key_for);
  p->for_expr_cnt++;
  compiler__TokenKind next_tok = compiler__Parser_peek(&/* ? */ *p);
  if (p->tok != compiler__compiler__TokenKind_lcbr) {
    ;
  };
  compiler__Parser_open_scope(p);
  int to = 0;
  if (p->tok == compiler__compiler__TokenKind_lcbr) {
    compiler__Parser_gen(p, tos3("while (1) {"));
  } else if (p->tok == compiler__compiler__TokenKind_key_mut) {
    compiler__Parser_error(p, tos3("`mut` is not required in for loops"));
  } else if (next_tok == compiler__compiler__TokenKind_decl_assign ||
             next_tok == compiler__compiler__TokenKind_assign ||
             p->tok == compiler__compiler__TokenKind_semicolon) {
    compiler__Parser_genln(p, tos3("for ("));
    if (next_tok == compiler__compiler__TokenKind_decl_assign) {
      compiler__Parser_check_not_reserved(p);
      compiler__Parser_var_decl(p);
    } else if (p->tok != compiler__compiler__TokenKind_semicolon) {
      compiler__Parser_statement(p, 0);
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_semicolon);
    compiler__Parser_gen(p, tos3(" ; "));
    ;
    if (p->tok != compiler__compiler__TokenKind_semicolon) {
      compiler__Parser_bool_expression(p);
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_semicolon);
    compiler__Parser_gen(p, tos3(" ; "));
    ;
    if (p->tok != compiler__compiler__TokenKind_lcbr) {
      compiler__Parser_statement(p, 0);
    };
    compiler__Parser_genln(p, tos3(") { "));
  } else if (compiler__Parser_peek(&/* ? */ *p) ==
             compiler__compiler__TokenKind_comma) {
    string i = compiler__Parser_check_name(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
    ;
    string val = compiler__Parser_check_name(p);
    if (string_eq(i, tos3("_")) && string_eq(val, tos3("_"))) {
      compiler__Parser_error(p,
                             tos3("no new variables on the left side of `in`"));
    };
    ;
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_in);
    ;
    string tmp = compiler__Parser_get_tmp(p);
    _V_MulRet_string_V_string _V_mret_297_typ_expr =
        compiler__Parser_tmp_expr(p);
    string typ = _V_mret_297_typ_expr.var_0;
    string expr = _V_mret_297_typ_expr.var_1;
    bool is_arr = string_starts_with(typ, tos3("array_"));
    bool is_map = string_starts_with(typ, tos3("map_"));
    bool is_str = string_eq(typ, tos3("string"));
    bool is_variadic_arg = string_starts_with(typ, tos3("varg_"));
    if (!is_arr && !is_str && !is_map && !is_variadic_arg) {
      compiler__Parser_error(
          p, _STR("cannot range over type `%.*s`", typ.len, typ.str));
    };
    if (!is_variadic_arg) {
      if (p->is_js) {
        compiler__Parser_genln(
            p, _STR("var %.*s = %.*s;", tmp.len, tmp.str, expr.len, expr.str));
      } else {
        compiler__Parser_genln(p, _STR("%.*s %.*s = %.*s;", typ.len, typ.str,
                                       tmp.len, tmp.str, expr.len, expr.str));
      };
    };
    string i_var_type = tos3("int");
    if (is_variadic_arg) {
      typ = string_substr2(typ, 5, -1, true);
      compiler__Parser_gen_for_varg_header(p, i, expr, typ, val);
    } else if (is_arr) {
      typ = compiler__parse_pointer(string_substr2(typ, 6, -1, true));
      compiler__Parser_gen_for_header(p, i, tmp, typ, val);
    } else if (is_map) {
      i_var_type = tos3("string");
      typ = compiler__parse_pointer(string_substr2(typ, 4, -1, true));
      compiler__Parser_gen_for_map_header(p, i, tmp, typ, val, typ);
    } else if (is_str) {
      typ = tos3("byte");
      compiler__Parser_gen_for_str_header(p, i, tmp, typ, val);
    };
    if (string_ne(i, tos3("_"))) {
      if (compiler__Parser_known_var(&/* ? */ *p, i)) {
        compiler__Parser_error(p, _STR("redefinition of `%.*s`", i.len, i.str));
      };
      compiler__Parser_register_var(
          p, (compiler__Var){.name = i,
                             .typ = i_var_type,
                             .is_mut = 1,
                             .is_changed = 1,
                             .idx = 0,
                             .is_arg = 0,
                             .is_const = 0,
                             .args = new_array(0, 1, sizeof(compiler__Var)),
                             .attr = tos3(""),
                             .is_alloc = 0,
                             .is_returned = 0,
                             .ptr = 0,
                             .ref = 0,
                             .parent_fn = tos3(""),
                             .mod = tos3(""),
                             .is_global = 0,
                             .is_used = 0,
                             .scope_level = 0,
                             .is_c = 0,
                             .is_moved = 0,
                             .line_nr = 0,
                             .token_idx = 0,
                             .is_for_var = 0,
                             .is_public = 0});
    };
    if (string_ne(val, tos3("_"))) {
      if (compiler__Parser_known_var(&/* ? */ *p, val)) {
        compiler__Parser_error(
            p, _STR("redefinition of `%.*s`", val.len, val.str));
      };
      compiler__Parser_register_var(
          p, (compiler__Var){.name = val,
                             .typ = typ,
                             .ptr = string_contains(typ, tos3("*")),
                             .idx = 0,
                             .is_arg = 0,
                             .is_const = 0,
                             .args = new_array(0, 1, sizeof(compiler__Var)),
                             .attr = tos3(""),
                             .is_mut = 0,
                             .is_alloc = 0,
                             .is_returned = 0,
                             .ref = 0,
                             .parent_fn = tos3(""),
                             .mod = tos3(""),
                             .is_global = 0,
                             .is_used = 0,
                             .is_changed = 0,
                             .scope_level = 0,
                             .is_c = 0,
                             .is_moved = 0,
                             .line_nr = 0,
                             .token_idx = 0,
                             .is_for_var = 0,
                             .is_public = 0});
    };
  } else if (compiler__Parser_peek(&/* ? */ *p) ==
                 compiler__compiler__TokenKind_key_in ||
             compiler__Parser_peek(&/* ? */ *p) ==
                 compiler__compiler__TokenKind_left_arrow) {
    compiler__Parser_check_not_reserved(p);
    string val = compiler__Parser_check_name(p);
    ;
    compiler__Parser_next(p);
    ;
    string tmp = compiler__Parser_get_tmp(p);
    _V_MulRet_string_V_string _V_mret_651_typ_expr =
        compiler__Parser_tmp_expr(p);
    string typ = _V_mret_651_typ_expr.var_0;
    string expr = _V_mret_651_typ_expr.var_1;
    bool is_range = p->tok == compiler__compiler__TokenKind_dotdot;
    bool is_variadic_arg = string_starts_with(typ, tos3("varg_"));
    string range_end = tos3("");
    if (is_range) {
      compiler__Parser_check_types(p, typ, tos3("int"));
      compiler__Parser_check_space(p, compiler__compiler__TokenKind_dotdot);
      if (p->pref->backend == v_dot_pref__v_dot_pref__Backend_x64) {
        to = v_string_int(p->lit);
      };
      _V_MulRet_string_V_string _V_mret_718_range_typ_range_expr =
          compiler__Parser_tmp_expr(p);
      string range_typ = _V_mret_718_range_typ_range_expr.var_0;
      string range_expr = _V_mret_718_range_typ_range_expr.var_1;
      compiler__Parser_check_types(p, range_typ, tos3("int"));
      range_end = range_expr;
      if (p->pref->backend == v_dot_pref__v_dot_pref__Backend_x64) {
      };
    };
    bool is_arr = string_contains(typ, tos3("array"));
    bool is_fixed = string_starts_with(typ, tos3("["));
    bool is_str = string_eq(typ, tos3("string"));
    if (!is_arr && !is_str && !is_range && !is_fixed && !is_variadic_arg) {
      compiler__Parser_error(
          p, _STR("cannot range over type `%.*s`", typ.len, typ.str));
    };
    if (!is_variadic_arg) {
      if (p->is_js) {
        compiler__Parser_genln(
            p, _STR("var %.*s = %.*s;", tmp.len, tmp.str, expr.len, expr.str));
      } else if (!is_fixed) {
        compiler__Parser_genln(p, _STR("%.*s %.*s = %.*s;", typ.len, typ.str,
                                       tmp.len, tmp.str, expr.len, expr.str));
      };
    };
    string i = compiler__Parser_get_tmp(p);
    if (is_variadic_arg) {
      typ = string_substr2(typ, 5, -1, true);
      compiler__Parser_gen_for_varg_header(p, i, expr, typ, val);
    } else if (is_range) {
      typ = tos3("int");
      compiler__Parser_gen_for_range_header(p, i, range_end, tmp, typ, val);
    } else if (is_arr) {
      typ = compiler__parse_pointer(string_substr2(typ, 6, -1, true));
      compiler__Parser_gen_for_header(p, i, tmp, typ, val);
    } else if (is_str) {
      typ = tos3("byte");
      compiler__Parser_gen_for_str_header(p, i, tmp, typ, val);
    } else if (is_fixed) {
      typ = string_all_after(typ, tos3("]"));
      compiler__Parser_gen_for_fixed_header(p, i, expr, typ, val);
    };
    if (string_ne(val, tos3("_"))) {
      if (compiler__Parser_known_var(&/* ? */ *p, val)) {
        compiler__Parser_error(
            p, _STR("redefinition of `%.*s`", val.len, val.str));
      };
      compiler__Parser_register_var(
          p, (compiler__Var){.name = val,
                             .typ = typ,
                             .ptr = string_contains(typ, tos3("*")),
                             .is_changed = 1,
                             .is_mut = 0,
                             .is_for_var = 1,
                             .idx = 0,
                             .is_arg = 0,
                             .is_const = 0,
                             .args = new_array(0, 1, sizeof(compiler__Var)),
                             .attr = tos3(""),
                             .is_alloc = 0,
                             .is_returned = 0,
                             .ref = 0,
                             .parent_fn = tos3(""),
                             .mod = tos3(""),
                             .is_global = 0,
                             .is_used = 0,
                             .scope_level = 0,
                             .is_c = 0,
                             .is_moved = 0,
                             .line_nr = 0,
                             .token_idx = 0,
                             .is_public = 0});
    };
  } else {
    compiler__Parser_gen(p, tos3("while ("));
    compiler__Parser_check_types(p, compiler__Parser_bool_expression(p),
                                 tos3("bool"));
    compiler__Parser_genln(p, tos3(") {"));
  };
  ;
  compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
  compiler__Parser_genln(p, tos3(""));
  compiler__Parser_statements(p);
  compiler__Parser_close_scope(p);
  p->for_expr_cnt--;
  p->returns = 0;
}
string compiler__Parser_gen_var_decl(compiler__Parser *p, string name,
                                     bool is_static) {
  p->is_var_decl = 1;
  string typ = compiler__Parser_bool_expression(p);
  p->is_var_decl = 0;
  if (string_starts_with(typ, tos3("..."))) {
    typ = string_substr2(typ, 3, -1, true);
  };
  bool or_else = p->tok == compiler__compiler__TokenKind_key_orelse;
  if (or_else) {
    return compiler__Parser_gen_handle_option_or_else(p, typ, name, 0);
  };
  string gen_name = compiler__Table_var_cgen_name(&/* ? */ *p->table, name);
  string nt_gen =
      compiler__Table_cgen_name_type_pair(&/* ? */ *p->table, gen_name, typ);
  if (!p->is_empty_c_struct_init && !string_starts_with(typ, tos3("["))) {
    nt_gen = string_add(nt_gen, tos3("="));
  } else if (string_starts_with(typ, tos3("[")) &&
             string_at(typ, typ.len - 1) != '*') {
    string initializer = p->cgen->cur_line;
    if (initializer.len > 0) {
      compiler__CGen_resetln(
          p->cgen,
          string_add(tos3(" = {"), string_all_after(initializer, tos3("{"))));
    } else if (initializer.len == 0) {
      compiler__CGen_resetln(p->cgen, tos3(" = { 0 }"));
    };
  };
  if (is_static) {
    nt_gen = _STR("static %.*s", nt_gen.len, nt_gen.str);
  };
  compiler__CGen_set_placeholder(p->cgen, 0, nt_gen);
  return typ;
}
void compiler__Parser_gen_fn_decl(compiler__Parser *p, compiler__Fn f,
                                  string typ, string str_args) {
  string dll_export_linkage =
      ((string_eq(p->pref->ccompiler, tos3("msvc")) &&
        string_eq(p->attr, tos3("live")) && p->pref->is_so)
           ? (tos3("__declspec(dllexport) "))
           : (((string_eq(p->attr, tos3("inline"))) ? (tos3("static inline "))
                                                    : (tos3("")))));
  string fn_name_cgen = compiler__Table_fn_gen_name(p->table, &/*114*/ f);
  if (string_eq(p->attr, tos3("live")) && p->pref->is_so) {
    compiler__Parser_genln(p, _STR("%.*s impl_live_%.*s (%.*s);", typ.len,
                                   typ.str, fn_name_cgen.len, fn_name_cgen.str,
                                   str_args.len, str_args.str));
  };
  compiler__Parser_genln(p, _STR("%.*s%.*s %.*s (%.*s) {",
                                 dll_export_linkage.len, dll_export_linkage.str,
                                 typ.len, typ.str, fn_name_cgen.len,
                                 fn_name_cgen.str, str_args.len, str_args.str));
}
void compiler__Parser_gen_blank_identifier_assign(compiler__Parser *p) {
  int assign_error_tok_idx = p->token_idx;
  compiler__Parser_check_name(p);
  compiler__Parser_check_space(p, compiler__compiler__TokenKind_assign);
  bool is_indexer =
      compiler__Parser_peek(&/* ? */ *p) == compiler__compiler__TokenKind_lsbr;
  _V_MulRet_bool_V_string _V_mret_371_is_fn_call_next_expr =
      compiler__Parser_is_expr_fn_call(&/* ? */ *p, p->token_idx);
  bool is_fn_call = _V_mret_371_is_fn_call_next_expr.var_0;
  string next_expr = _V_mret_371_is_fn_call_next_expr.var_1;
  int pos = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
  int expr_tok = compiler__Parser_cur_tok_index(&/* ? */ *p);
  p->is_var_decl = 1;
  string typ = compiler__Parser_bool_expression(p);
  if (string_eq(typ, tos3("void"))) {
    compiler__Parser_error_with_token_index(
        p,
        _STR("%.*s() %.*s", next_expr.len, next_expr.str,
             compiler__err_used_as_value.len, compiler__err_used_as_value.str),
        expr_tok);
  };
  p->is_var_decl = 0;
  if (!is_indexer && !is_fn_call) {
    compiler__Parser_error_with_token_index(
        p,
        _STR("assigning `%.*s` to `_` is redundant", next_expr.len,
             next_expr.str),
        assign_error_tok_idx);
  };
  if (p->tok == compiler__compiler__TokenKind_key_orelse) {
    compiler__Parser_gen_handle_option_or_else(p, typ, tos3(""), pos);
  } else {
    if (is_fn_call) {
      compiler__Parser_gen(p, tos3(";"));
    } else {
      compiler__CGen_resetln(p->cgen, _STR("{%.*s _ = %.*s;}", typ.len, typ.str,
                                           p->cgen->cur_line.len,
                                           p->cgen->cur_line.str));
    };
  };
}
string compiler__Parser_gen_handle_option_or_else(compiler__Parser *p,
                                                  string _typ, string name,
                                                  int fn_call_ph) {
  string typ = _typ;
  if (!string_starts_with(typ, tos3("Option_"))) {
    compiler__Parser_error(
        p, tos3("`or` block cannot be applied to non-optional type"));
  };
  bool is_assign = name.len > 0;
  string tmp = compiler__Parser_get_tmp(p);
  compiler__CGen_set_placeholder(
      p->cgen, fn_call_ph,
      _STR("%.*s %.*s = ", typ.len, typ.str, tmp.len, tmp.str));
  typ = compiler__parse_pointer(string_substr2(typ, 7, -1, true));
  compiler__Parser_genln(p, tos3(";"));
  int or_tok_idx = p->token_idx;
  ;
  compiler__Parser_check(p, compiler__compiler__TokenKind_key_orelse);
  ;
  compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
  ;
  compiler__Parser_register_var(
      p, (compiler__Var){.name = tos3("err"),
                         .typ = tos3("string"),
                         .is_mut = 0,
                         .is_used = 1,
                         .idx = 0,
                         .is_arg = 0,
                         .is_const = 0,
                         .args = new_array(0, 1, sizeof(compiler__Var)),
                         .attr = tos3(""),
                         .is_alloc = 0,
                         .is_returned = 0,
                         .ptr = 0,
                         .ref = 0,
                         .parent_fn = tos3(""),
                         .mod = tos3(""),
                         .is_global = 0,
                         .is_changed = 0,
                         .scope_level = 0,
                         .is_c = 0,
                         .is_moved = 0,
                         .line_nr = 0,
                         .token_idx = 0,
                         .is_for_var = 0,
                         .is_public = 0});
  compiler__Parser_register_var(
      p, (compiler__Var){.name = tos3("errcode"),
                         .typ = tos3("int"),
                         .is_mut = 0,
                         .is_used = 1,
                         .idx = 0,
                         .is_arg = 0,
                         .is_const = 0,
                         .args = new_array(0, 1, sizeof(compiler__Var)),
                         .attr = tos3(""),
                         .is_alloc = 0,
                         .is_returned = 0,
                         .ptr = 0,
                         .ref = 0,
                         .parent_fn = tos3(""),
                         .mod = tos3(""),
                         .is_global = 0,
                         .is_changed = 0,
                         .scope_level = 0,
                         .is_c = 0,
                         .is_moved = 0,
                         .line_nr = 0,
                         .token_idx = 0,
                         .is_for_var = 0,
                         .is_public = 0});
  if (is_assign && !string_contains(name, tos3(".")) && !p->is_var_decl) {
    compiler__Parser_genln(
        p, _STR("%.*s %.*s;", typ.len, typ.str, name.len, name.str));
  };
  compiler__Parser_genln(p, _STR("if (!%.*s .ok) {", tmp.len, tmp.str));
  compiler__Parser_genln(p,
                         _STR("string err = %.*s . error;", tmp.len, tmp.str));
  compiler__Parser_genln(p,
                         _STR("int errcode = %.*s . ecode;", tmp.len, tmp.str));
  int last_ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
  string last_typ = compiler__Parser_statements(p);
  if (is_assign && string_eq(last_typ, typ)) {
    string expr_line =
        ((p->cgen->line_directives)
             ? ((*(string *)array_get(p->cgen->lines, p->cgen->lines.len - 3)))
             : ((*(string *)array_get(p->cgen->lines,
                                      p->cgen->lines.len - 2))));
    string last_expr = string_substr2(expr_line, last_ph, -1, true);
    array_set(&/*q*/ p->cgen->lines, p->cgen->lines.len - 2,
              &(string[]){tos3("")});
    if (p->cgen->line_directives) {
      array_set(&/*q*/ p->cgen->lines, p->cgen->lines.len - 3,
                &(string[]){tos3("")});
    };
    compiler__Parser_genln(p, _STR("if (%.*s .ok) {", tmp.len, tmp.str));
    compiler__Parser_genln(p,
                           _STR("%.*s = *(%.*s*) %.*s . data;", name.len,
                                name.str, typ.len, typ.str, tmp.len, tmp.str));
    compiler__Parser_genln(p, tos3("} else {"));
    compiler__Parser_genln(p, _STR("%.*s = %.*s", name.len, name.str,
                                   last_expr.len, last_expr.str));
    compiler__Parser_genln(p, tos3("}"));
  } else if (is_assign) {
    compiler__Parser_genln(p,
                           _STR("%.*s = *(%.*s*)%.*s.data;", name.len, name.str,
                                typ.len, typ.str, tmp.len, tmp.str));
  };
  if (!p->returns && string_ne(last_typ, typ) && is_assign &&
      !((p->prev_tok2 == compiler__compiler__TokenKind_key_continue ||
         p->prev_tok2 == compiler__compiler__TokenKind_key_break))) {
    compiler__Parser_error_with_token_index(
        p,
        tos3("`or` block must provide a default value or "
             "return/exit/continue/break/panic"),
        or_tok_idx);
  };
  p->returns = 0;
  return typ;
}
string compiler__Parser_gen_handle_question_suffix(compiler__Parser *p,
                                                   compiler__Fn f, int ph) {
  if (string_ne(p->cur_fn.name, tos3("main__main"))) {
    compiler__Parser_error(
        p,
        tos3("`func()?` syntax can only be used inside `fn main()` for now"));
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_question);
  string tmp = compiler__Parser_get_tmp(p);
  compiler__CGen_set_placeholder(
      p->cgen, ph,
      _STR("%.*s %.*s = ", f.typ.len, f.typ.str, tmp.len, tmp.str));
  compiler__Parser_genln(p, tos3(";"));
  compiler__Parser_genln(p, _STR("if (!%.*s.ok) v_panic(%.*s.error);", tmp.len,
                                 tmp.str, tmp.len, tmp.str));
  string typ = string_substr2(f.typ, 7, -1, true);
  compiler__Parser_gen(
      p, _STR("*(%.*s*) %.*s.data;", typ.len, typ.str, tmp.len, tmp.str));
  return typ;
}
string compiler__types_to_c(array_compiler__Type types,
                            compiler__Table *table) {
  strings__Builder sb = strings__new_builder(10);
  array_compiler__Type tmp15 = types;
  for (int tmp16 = 0; tmp16 < tmp15.len; tmp16++) {
    compiler__Type t = ((compiler__Type *)tmp15.data)[tmp16];

    if (!((t.cat == compiler__compiler__TypeCategory_union_ ||
           t.cat == compiler__compiler__TypeCategory_struct_ ||
           t.cat == compiler__compiler__TypeCategory_objc_interface ||
           t.cat == compiler__compiler__TypeCategory_interface_))) {
      continue;
    };
    if (t.cat == compiler__compiler__TypeCategory_objc_interface) {
      strings__Builder_writeln(
          &/* ? */ sb, _STR("@interface %.*s : %.*s { @public", t.name.len,
                            t.name.str, t.parent.len, t.parent.str));
    } else {
      string kind = ((t.cat == compiler__compiler__TypeCategory_union_)
                         ? (tos3("union"))
                         : (tos3("struct")));
      strings__Builder_writeln(
          &/* ? */ sb,
          _STR("%.*s %.*s {", kind.len, kind.str, t.name.len, t.name.str));
      if (t.cat == compiler__compiler__TypeCategory_interface_) {
        strings__Builder_writeln(&/* ? */ sb, tos3("\tvoid* _object;"));
        strings__Builder_writeln(&/* ? */ sb,
                                 tos3("\tint _interface_idx; // int t"));
      };
    };
    array_compiler__Var tmp17 = t.fields;
    for (int tmp18 = 0; tmp18 < tmp17.len; tmp18++) {
      compiler__Var field = ((compiler__Var *)tmp17.data)[tmp18];

      strings__Builder_write(&/* ? */ sb, tos3("\t"));
      strings__Builder_writeln(
          &/* ? */ sb, string_add(compiler__Table_cgen_name_type_pair(
                                      &/* ? */ *table, field.name, field.typ),
                                  tos3(";")));
    };
    strings__Builder_writeln(&/* ? */ sb, tos3("};\n"));
    if (t.cat == compiler__compiler__TypeCategory_objc_interface) {
      strings__Builder_writeln(&/* ? */ sb, tos3("@end"));
    };
  };
  return strings__Builder_str(&/* ? */ sb);
}
void compiler__Parser_index_get(compiler__Parser *p, string typ, int fn_ph,
                                compiler__IndexConfig cfg) {
  string index_expr = tos3("");
  if (p->cgen->is_tmp) {
    index_expr = string_substr2(p->cgen->tmp_line, fn_ph, -1, true);
    compiler__CGen_resetln(p->cgen,
                           string_substr2(p->cgen->tmp_line, 0, fn_ph, false));
  } else {
    index_expr = string_substr2(p->cgen->cur_line, fn_ph, -1, true);
    compiler__CGen_resetln(p->cgen,
                           string_substr2(p->cgen->cur_line, 0, fn_ph, false));
  };
  string tmp = compiler__Parser_get_tmp(p);
  string tmp_ok = compiler__Parser_get_tmp(p);
  if (cfg.is_map) {
    compiler__Parser_gen(p, _STR("%.*s", tmp.len, tmp.str));
    string def = compiler__type_default(typ);
    compiler__CGen_insert_before(
        p->cgen,
        string_add(_STR("%.*s %.*s = %.*s; ", typ.len, typ.str, tmp.len,
                        tmp.str, def.len, def.str),
                   _STR("bool %.*s = map_get(/*%.*s : %d*/%.*s, & %.*s);",
                        tmp_ok.len, tmp_ok.str, p->file_name.len,
                        p->file_name.str, p->scanner->line_nr, index_expr.len,
                        index_expr.str, tmp.len, tmp.str)));
  } else if (cfg.is_arr) {
    if (p->pref->translated && !p->builtin_mod) {
      compiler__Parser_gen(p, _STR("%.*s ]", index_expr.len, index_expr.str));
    } else {
      string ref = ((cfg.is_ptr) ? (tos3("*")) : (tos3("")));
      if (cfg.is_slice) {
        compiler__Parser_gen(p, _STR(" array_slice2(%.*s %.*s) ", ref.len,
                                     ref.str, index_expr.len, index_expr.str));
      } else {
        compiler__Parser_gen(p, _STR("( *(%.*s*) array_get(%.*s %.*s) )",
                                     typ.len, typ.str, ref.len, ref.str,
                                     index_expr.len, index_expr.str));
      };
    };
  } else if (cfg.is_str && !p->builtin_mod) {
    if (p->pref->is_bare) {
      compiler__Parser_gen(p, index_expr);
    } else if (cfg.is_slice) {
      compiler__Parser_gen(
          p, _STR("string_substr2(%.*s)", index_expr.len, index_expr.str));
    } else {
      compiler__Parser_gen(
          p, _STR("string_at(%.*s)", index_expr.len, index_expr.str));
    };
  };
  if (cfg.is_map && string_eq(typ, tos3("string"))) {
    compiler__CGen_insert_before(
        p->cgen, _STR("if (!%.*s) %.*s = tos((byte *)\"\", 0);", tmp_ok.len,
                      tmp_ok.str, tmp.len, tmp.str));
  };
}
string compiler__Table_fn_gen_name(compiler__Table *table, compiler__Fn *f) {
  string name = f->name;
  if (f->is_method) {
    name = _STR("%.*s_%.*s", f->receiver_typ.len, f->receiver_typ.str,
                f->name.len, f->name.str);
    name = string_replace(name, tos3(" "), tos3(""));
    if (f->name.len == 1) {
      byte tmp29 = string_at(f->name, 0);

      if (tmp29 == '+') {
        name = string_replace(name, tos3("+"), tos3("op_plus"));
      } else if (tmp29 == '-') {
        name = string_replace(name, tos3("-"), tos3("op_minus"));
      } else if (tmp29 == '*') {
        name = string_replace(name, tos3("*"), tos3("op_mul"));
      } else if (tmp29 == '/') {
        name = string_replace(name, tos3("/"), tos3("op_div"));
      } else if (tmp29 == '%') {
        name = string_replace(name, tos3("%"), tos3("op_mod"));
      } else // default:
      {
      };
    };
  };
  if (f->is_interface) {
    return tos3("");
  };
  if (string_eq(f->mod, tos3("builtin")) &&
      (_IN(string, (f->name), compiler__c_reserved))) {
    return _STR("v_%.*s", name.len, name.str);
  };
  if (table->obfuscate && !f->is_c &&
      !((string_eq(f->name, tos3("main")) ||
         string_eq(f->name, tos3("WinMain")) ||
         string_eq(f->name, tos3("main__main")) ||
         string_eq(f->name, tos3("gg__vec2")) ||
         string_eq(f->name, tos3("build_token_str")) ||
         string_eq(f->name, tos3("build_keys")))) &&
      !((string_eq(f->mod, tos3("builtin")) ||
         string_eq(f->mod, tos3("darwin")) || string_eq(f->mod, tos3("os")) ||
         string_eq(f->mod, tos3("json")))) &&
      !string_ends_with(f->name, tos3("_init")) &&
      !string_contains(f->name, tos3("window_proc")) &&
      !string_ends_with(name, tos3("_str")) &&
      !string_contains(name, tos3("contains"))) {
    int tmp30 = 0;
    bool tmp31 = map_get(/*gen_c.v : 306*/ table->obf_ids, name, &tmp30);

    int idx = tmp30;
    if (idx == 0) {
      table->fn_cnt++;
      map_set(&table->obf_ids, name, &(int[]){table->fn_cnt});
      idx = table->fn_cnt;
    };
    string old = name;
    name = _STR("f_%d", idx);
    printf("%.*s ==> %.*s\n", old.len, old.str, name.len, name.str);
  };
  return name;
}
void compiler__Parser_gen_method_call(compiler__Parser *p,
                                      compiler__Var *receiver,
                                      string receiver_type, string cgen_name,
                                      string ftyp, int method_ph) {
  string method_call = string_add(cgen_name, tos3(" ("));
  if (receiver->ref ||
      (receiver->is_mut && !string_contains(receiver_type, tos3("*")))) {
    method_call = string_add(method_call, tos3("& /* ? */"));
  };
  if (!receiver->is_mut && string_contains(receiver_type, tos3("*"))) {
    method_call = string_add(method_call, tos3("*"));
  };
  string cast = tos3("");
  if (string_eq(ftyp, tos3("void*"))) {
    if (string_starts_with(receiver_type, tos3("array_"))) {
      cast = compiler__parse_pointer(
          string_all_after(receiver_type, tos3("array_")));
      cast = _STR("*(%.*s*) ", cast.len, cast.str);
    } else {
      cast = tos3("(voidptr) ");
    };
  };
  compiler__CGen_set_placeholder(
      p->cgen, method_ph,
      _STR("%.*s %.*s", cast.len, cast.str, method_call.len, method_call.str));
}
void compiler__Parser_gen_array_at(compiler__Parser *p, string typ_,
                                   bool is_arr0, int fn_ph) {
  string typ = typ_;
  if (string_eq(typ, tos3("array"))) {
    typ = tos3("void*");
  };
  if (p->pref->translated && !p->builtin_mod) {
    compiler__CGen_set_placeholder(p->cgen, fn_ph,
                                   _STR("((%.*s*)(", typ.len, typ.str));
    compiler__Parser_gen(p, tos3(".data))["));
  } else {
    compiler__Parser_gen(p, tos3(","));
  };
}
void compiler__Parser_gen_for_header(compiler__Parser *p, string i, string tmp,
                                     string var_typ, string val) {
  compiler__Parser_genln(
      p, _STR("for (int %.*s = 0; %.*s < %.*s.len; %.*s++) {", i.len, i.str,
              i.len, i.str, tmp.len, tmp.str, i.len, i.str));
  if (string_eq(val, tos3("_"))) {

    return;
  };
  compiler__Parser_genln(p, _STR("%.*s %.*s = ((%.*s *) %.*s . data)[%.*s];",
                                 var_typ.len, var_typ.str, val.len, val.str,
                                 var_typ.len, var_typ.str, tmp.len, tmp.str,
                                 i.len, i.str));
}
void compiler__Parser_gen_for_fixed_header(compiler__Parser *p, string i,
                                           string tmp, string var_typ,
                                           string val) {
  compiler__Parser_genln(p, _STR("for (int %.*s = 0; %.*s < sizeof(%.*s) / "
                                 "sizeof(%.*s [0]); %.*s++) {",
                                 i.len, i.str, i.len, i.str, tmp.len, tmp.str,
                                 tmp.len, tmp.str, i.len, i.str));
  if (string_eq(val, tos3("_"))) {

    return;
  };
  compiler__Parser_genln(p, _STR("%.*s %.*s = %.*s[%.*s];", var_typ.len,
                                 var_typ.str, val.len, val.str, tmp.len,
                                 tmp.str, i.len, i.str));
}
void compiler__Parser_gen_for_str_header(compiler__Parser *p, string i,
                                         string tmp, string var_typ,
                                         string val) {
  compiler__Parser_genln(
      p, _STR(";\nfor (int %.*s = 0; %.*s < %.*s .len; %.*s ++) {", i.len,
              i.str, i.len, i.str, tmp.len, tmp.str, i.len, i.str));
  if (string_eq(val, tos3("_"))) {

    return;
  };
  compiler__Parser_genln(p, _STR("%.*s %.*s = %.*s.str[%.*s];", var_typ.len,
                                 var_typ.str, val.len, val.str, tmp.len,
                                 tmp.str, i.len, i.str));
}
void compiler__Parser_gen_for_range_header(compiler__Parser *p, string i,
                                           string range_end, string tmp,
                                           string var_type, string val) {
  compiler__Parser_genln(p,
                         _STR(";\nfor (int %.*s = %.*s; %.*s < %.*s; %.*s++) {",
                              i.len, i.str, tmp.len, tmp.str, i.len, i.str,
                              range_end.len, range_end.str, i.len, i.str));
  if (string_eq(val, tos3("_"))) {

    return;
  };
  compiler__Parser_genln(p, _STR("%.*s %.*s = %.*s;", var_type.len,
                                 var_type.str, val.len, val.str, i.len, i.str));
}
void compiler__Parser_gen_for_map_header(compiler__Parser *p, string i,
                                         string tmp, string var_typ, string val,
                                         string typ) {
  string def = compiler__type_default(typ);
  compiler__Parser_genln(p, _STR("array_string keys_%.*s = map_keys(& %.*s ); ",
                                 tmp.len, tmp.str, tmp.len, tmp.str));
  compiler__Parser_genln(
      p, _STR("for (int l = 0; l < keys_%.*s .len; l++) {", tmp.len, tmp.str));
  compiler__Parser_genln(p, _STR("string %.*s = ((string*)keys_%.*s .data)[l];",
                                 i.len, i.str, tmp.len, tmp.str));
  if (string_eq(val, tos3("_"))) {

    return;
  };
  compiler__Parser_genln(
      p, _STR("%.*s %.*s = %.*s; map_get(%.*s, %.*s, & %.*s);", var_typ.len,
              var_typ.str, val.len, val.str, def.len, def.str, tmp.len, tmp.str,
              i.len, i.str, val.len, val.str));
}
void compiler__Parser_gen_for_varg_header(compiler__Parser *p, string i,
                                          string varg, string var_typ,
                                          string val) {
  compiler__Parser_genln(
      p, _STR("for (int %.*s = 0; %.*s < %.*s->len; %.*s++) {", i.len, i.str,
              i.len, i.str, varg.len, varg.str, i.len, i.str));
  if (string_eq(val, tos3("_"))) {

    return;
  };
  compiler__Parser_genln(p, _STR("%.*s %.*s = ((%.*s *) %.*s->args)[%.*s];",
                                 var_typ.len, var_typ.str, val.len, val.str,
                                 var_typ.len, var_typ.str, varg.len, varg.str,
                                 i.len, i.str));
}
void compiler__Parser_gen_array_init(compiler__Parser *p, string typ,
                                     bool no_alloc, int new_arr_ph,
                                     int nr_elems) {
  string new_arr = tos3("new_array_from_c_array");
  if (no_alloc) {
    new_arr = string_add(new_arr, tos3("_no_alloc"));
  };
  if (nr_elems == 0) {
    compiler__Parser_gen(p, tos3(" TCCSKIP(0) })"));
  } else {
    compiler__Parser_gen(p, tos3(" })"));
  };
  if (!compiler__Parser_first_pass(&/* ? */ *p)) {
    compiler__CGen_set_placeholder(
        p->cgen, new_arr_ph,
        _STR("%.*s(%d, %d, sizeof(%.*s), EMPTY_ARRAY_OF_ELEMS( %.*s, %d ) { ",
             new_arr.len, new_arr.str, nr_elems, nr_elems, typ.len, typ.str,
             typ.len, typ.str, nr_elems));
  };
}
void compiler__Parser_gen_array_set(compiler__Parser *p, string typ,
                                    bool is_ptr, bool is_map, int fn_ph,
                                    int assign_pos, bool is_cao) {
  string val = string_substr2(p->cgen->cur_line, assign_pos, -1, true);
  compiler__CGen_resetln(
      p->cgen, string_substr2(p->cgen->cur_line, 0, assign_pos, false));
  string cao_tmp = p->cgen->cur_line;
  string func = tos3("");
  if (is_map) {
    if (is_ptr) {
      func = tos3("map_set(");
    } else {
      func = tos3("map_set(&");
    };
  } else {
    if (is_ptr) {
      func = tos3("array_set(");
      if (is_cao) {
        cao_tmp = _STR("*(%.*s *) array_get(*%.*s)", p->expected_type.len,
                       p->expected_type.str, cao_tmp.len, cao_tmp.str);
      };
    } else {
      func = tos3("array_set(&/*q*/");
      if (is_cao) {
        cao_tmp = _STR("*(%.*s *) array_get(%.*s)", p->expected_type.len,
                       p->expected_type.str, cao_tmp.len, cao_tmp.str);
      };
    };
  };
  compiler__CGen_set_placeholder(p->cgen, fn_ph, func);
  if (is_cao) {
    val = string_add(string_add(cao_tmp, string_all_before(val, tos3("="))),
                     string_all_after(val, tos3("=")));
  };
  compiler__Parser_gen(
      p, _STR(", & (%.*s []) { %.*s })", typ.len, typ.str, val.len, val.str));
}
bool compiler__Parser_gen_struct_init(compiler__Parser *p, string typ,
                                      compiler__Type *t) {
  if (p->is_c_struct_init) {
    if (t->cat != compiler__compiler__TypeCategory_c_typedef) {
      compiler__CGen_insert_before(p->cgen, tos3("struct /*c struct init*/"));
    };
  };
  if (string_eq(typ, tos3("tm"))) {
    array_set(&/*q*/ p->cgen->lines, p->cgen->lines.len - 1,
              &(string[]){tos3("")});
  };
  bool is_config = 0;
  if (p->tok != compiler__compiler__TokenKind_lcbr) {
    compiler__Parser_next(p);
  } else {
    is_config = 1;
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
  if (is_config && p->tok == compiler__compiler__TokenKind_rcbr) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
    compiler__Parser_gen(
        p, _STR("(%.*s) {EMPTY_STRUCT_INITIALIZATION}", typ.len, typ.str));
    return 1;
  };
  bool ptr = string_contains(typ, tos3("*"));
  if (!ptr) {
    if (p->is_c_struct_init) {
      if (p->tok == compiler__compiler__TokenKind_rcbr) {
        p->is_empty_c_struct_init = 1;
        compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
        return 1;
      };
      compiler__Parser_gen(p, _STR("(struct %.*s) {", typ.len, typ.str));
      p->is_c_struct_init = 0;
    } else {
      compiler__Parser_gen(p, _STR("(%.*s) {", typ.len, typ.str));
    };
  } else {
    if (p->tok == compiler__compiler__TokenKind_not) {
      compiler__Parser_error(p, _STR("use `%.*s(0)` instead of `&%.*s{!}`",
                                     t->name.len, t->name.str, t->name.len,
                                     t->name.str));
    };
    compiler__Parser_gen(p, _STR("(%.*s*)memdup(&(%.*s) {", t->name.len,
                                 t->name.str, t->name.len, t->name.str));
  };
  return 0;
}
void compiler__Parser_gen_struct_field_init(compiler__Parser *p, string field) {
  compiler__Parser_gen(p, _STR(".%.*s = ", field.len, field.str));
}
void compiler__Parser_gen_empty_map(compiler__Parser *p, string typ) {
  compiler__Parser_gen(p, _STR("new_map(1, sizeof(%.*s))", typ.len, typ.str));
}
void compiler__Parser_cast(compiler__Parser *p, string typ) {
  compiler__Parser_gen(p, tos3("("));
  compiler__Parser_next(p);
  int pos = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
  if (p->tok == compiler__compiler__TokenKind_rpar) {
    p->ptr_cast = 1;
    compiler__Parser_next(p);
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
  p->expected_type = typ;
  string expr_typ = compiler__Parser_bool_expression(p);
  if (string_eq(expr_typ, typ)) {
    compiler__Parser_warn(p,
                          _STR("casting `%.*s` to `%.*s` is not needed",
                               typ.len, typ.str, expr_typ.len, expr_typ.str));
  };
  bool casting_voidptr_to_value =
      string_eq(expr_typ, tos3("void*")) &&
      !((string_eq(typ, tos3("int")) || string_eq(typ, tos3("byteptr")))) &&
      !string_ends_with(typ, tos3("*"));
  p->expected_type = tos3("");
  bool is_byteptr = (string_eq(expr_typ, tos3("byte*")) ||
                     string_eq(expr_typ, tos3("byteptr")));
  bool is_bytearr = string_eq(expr_typ, tos3("array_byte"));
  if (string_eq(typ, tos3("string"))) {
    if (is_byteptr || is_bytearr) {
      if (p->tok == compiler__compiler__TokenKind_comma) {
        compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
        compiler__CGen_set_placeholder(p->cgen, pos, tos3("tos((byte *)"));
        if (is_bytearr) {
          compiler__Parser_gen(p, tos3(".data"));
        };
        compiler__Parser_gen(p, tos3(", "));
        compiler__Parser_check_types(p, compiler__Parser_expression(p),
                                     tos3("int"));
      } else {
        if (is_bytearr) {
          compiler__Parser_gen(p, tos3(".data"));
        };
        compiler__CGen_set_placeholder(p->cgen, pos, tos3("tos2((byte *)"));
      };
    } else if (string_eq(expr_typ, tos3("int"))) {
      compiler__Parser_error(
          p, _STR("cannot cast `%.*s` to `%.*s`, use `str()` method instead",
                  expr_typ.len, expr_typ.str, typ.len, typ.str));
    } else {
      compiler__Parser_error(p,
                             _STR("cannot cast `%.*s` to `%.*s`", expr_typ.len,
                                  expr_typ.str, typ.len, typ.str));
    };
  } else if (string_eq(typ, tos3("byte")) &&
             string_eq(expr_typ, tos3("string"))) {
    compiler__Parser_error(
        p, _STR("cannot cast `%.*s` to `%.*s`, use backquotes `` to create a "
                "`%.*s` or access the value of an index of `%.*s` using []",
                expr_typ.len, expr_typ.str, typ.len, typ.str, typ.len, typ.str,
                expr_typ.len, expr_typ.str));
  } else if (casting_voidptr_to_value) {
    compiler__CGen_set_placeholder(p->cgen, pos,
                                   _STR("(%.*s)(", typ.len, typ.str));
  } else {
    if (string_eq(typ, tos3("bool"))) {
      if (compiler__is_number_type(expr_typ)) {
        compiler__Parser_error(p, tos3("cannot cast a number to `bool`"));
      };
      compiler__Parser_error(
          p, _STR("cannot cast `%.*s` to `bool`", expr_typ.len, expr_typ.str));
    };
    if (string_eq(expr_typ, tos3("string"))) {
      if (compiler__is_number_type(typ)) {
        compiler__Parser_error(
            p, _STR("cannot cast `string` to `%.*s`, use `%.*s.%.*s()` instead",
                    typ.len, typ.str, expr_typ.len, expr_typ.str, typ.len,
                    typ.str));
      };
      compiler__Parser_error(p,
                             _STR("cannot cast `%.*s` to `%.*s`", expr_typ.len,
                                  expr_typ.str, typ.len, typ.str));
    };
    if (string_eq(expr_typ, tos3("bool"))) {
      compiler__Parser_error(
          p, _STR("cannot cast `bool` to `%.*s`", typ.len, typ.str));
    };
    if (string_ne(typ, expr_typ) && (_IN_MAP((typ), p->table->sum_types))) {
      compiler__Type tt = compiler__Table_find_type(&/* ? */ *p->table, typ);
      if ((_IN(string, (expr_typ), tt.ctype_names))) {
        compiler__CGen_set_placeholder(p->cgen, pos, tos3("("));
      } else {
        string tmp36 = array_string_str(tt.ctype_names);

        compiler__Parser_warn(p, _STR("only %.*s  can be casted to `%.*s`",
                                      tmp36.len, tmp36.str, typ.len, typ.str));
        compiler__Parser_error(p, _STR("cannot cast `%.*s` to `%.*s`",
                                       expr_typ.len, expr_typ.str, typ.len,
                                       typ.str));
      };
    } else {
      compiler__CGen_set_placeholder(p->cgen, pos,
                                     _STR("(%.*s)(", typ.len, typ.str));
    };
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
  compiler__Parser_gen(p, tos3(")"));
  { compiler__Parser_gen(p, tos3(")")); }
}
string compiler__type_default(string typ) {
  if (string_starts_with(typ, tos3("array_"))) {
    return _STR("new_array(0, 1, sizeof( %.*s ))",
                compiler__parse_pointer(string_substr2(typ, 6, -1, true)).len,
                compiler__parse_pointer(string_substr2(typ, 6, -1, true)).str);
  };
  if (string_ends_with(typ, tos3("*"))) {
    return tos3("0");
  };
  if (string_contains(typ, tos3("__"))) {
    return tos3("{0}");
  };
  if (string_ends_with(typ, tos3("Fn"))) {
    return tos3("0");
  };
  string tmp39 = typ;

  if (string_eq(tmp39, tos3("bool"))) {
    return tos3("0");
  } else if (string_eq(tmp39, tos3("string"))) {
    return tos3("tos3(\"\")");
  } else if (string_eq(tmp39, tos3("i8"))) {
    return tos3("0");
  } else if (string_eq(tmp39, tos3("i16"))) {
    return tos3("0");
  } else if (string_eq(tmp39, tos3("i64"))) {
    return tos3("0");
  } else if (string_eq(tmp39, tos3("u16"))) {
    return tos3("0");
  } else if (string_eq(tmp39, tos3("u32"))) {
    return tos3("0");
  } else if (string_eq(tmp39, tos3("u64"))) {
    return tos3("0");
  } else if (string_eq(tmp39, tos3("byte"))) {
    return tos3("0");
  } else if (string_eq(tmp39, tos3("int"))) {
    return tos3("0");
  } else if (string_eq(tmp39, tos3("rune"))) {
    return tos3("0");
  } else if (string_eq(tmp39, tos3("f32"))) {
    return tos3("0.0");
  } else if (string_eq(tmp39, tos3("f64"))) {
    return tos3("0.0");
  } else if (string_eq(tmp39, tos3("byteptr"))) {
    return tos3("0");
  } else if (string_eq(tmp39, tos3("voidptr"))) {
    return tos3("0");
  } else // default:
  {
  };
  return tos3("{0}");
}
void compiler__Parser_gen_array_push(compiler__Parser *p, int ph, string typ,
                                     string expr_type, string tmp,
                                     string elm_type) {
  bool push_array = string_eq(typ, expr_type);
  if (push_array) {
    compiler__CGen_set_placeholder(p->cgen, ph, tos3("_PUSH_MANY(&"));
    compiler__Parser_gen(
        p, _STR("), %.*s, %.*s)", tmp.len, tmp.str, typ.len, typ.str));
  } else {
    compiler__Parser_check_types(p, expr_type, elm_type);
    string push_call = ((string_contains(typ, tos3("*"))) ? (tos3("_PUSH("))
                                                          : (tos3("_PUSH(&")));
    compiler__CGen_set_placeholder(p->cgen, ph, push_call);
    compiler__Parser_gen(p, _STR("), %.*s, %.*s)", tmp.len, tmp.str,
                                 elm_type.len, elm_type.str));
  };
}
compiler__Type compiler__Parser_get_type2(compiler__Parser *p) {
  bool mul = 0;
  int nr_muls = 0;
  string typ = tos3("");
  compiler__TypeCategory cat = compiler__compiler__TypeCategory_struct_;
  if (p->tok == compiler__compiler__TokenKind_key_fn) {
    compiler__Fn f =
        (compiler__Fn){.name = tos3("_"),
                       .mod = p->mod,
                       .args = new_array(0, 1, sizeof(compiler__Var)),
                       .is_interface = 0,
                       .scope_level = 0,
                       .typ = tos3(""),
                       .receiver_typ = tos3(""),
                       .is_c = 0,
                       .is_public = 0,
                       .is_method = 0,
                       .is_decl = 0,
                       .is_unsafe = 0,
                       .is_deprecated = 0,
                       .is_variadic = 0,
                       .is_generic = 0,
                       .returns_error = 0,
                       .defer_text = new_array(0, 1, sizeof(string)),
                       .type_pars = new_array(0, 1, sizeof(string)),
                       .type_inst = new_array(0, 1, sizeof(compiler__TypeInst)),
                       .generic_fn_idx = 0,
                       .parser_idx = 0,
                       .fn_name_token_idx = 0,
                       .comptime_define = tos3(""),
                       .is_used = 0};
    compiler__Parser_next(p);
    int line_nr = p->scanner->line_nr;
    compiler__Parser_fn_args(p, &/*114*/ f);
    if (p->scanner->line_nr == line_nr) {
      if ((p->tok == compiler__compiler__TokenKind_name ||
           p->tok == compiler__compiler__TokenKind_mul ||
           p->tok == compiler__compiler__TokenKind_amp ||
           p->tok == compiler__compiler__TokenKind_lsbr ||
           p->tok == compiler__compiler__TokenKind_question ||
           p->tok == compiler__compiler__TokenKind_lpar)) {
        f.typ = compiler__Parser_get_type(p);
      } else {
        f.typ = tos3("void");
      };
    } else {
      f.typ = tos3("void");
    };
    compiler__Type fn_typ =
        (compiler__Type){.name = compiler__Fn_typ_str(&/* ? */ f),
                         .mod = p->mod,
                         .func = f,
                         .cat = compiler__compiler__TypeCategory_func,
                         .is_public = 0,
                         .fields = new_array(0, 1, sizeof(compiler__Var)),
                         .methods = new_array(0, 1, sizeof(compiler__Fn)),
                         .parent = tos3(""),
                         .is_c = 0,
                         .enum_vals = new_array(0, 1, sizeof(string)),
                         .gen_types = new_array(0, 1, sizeof(string)),
                         .default_vals = new_array(0, 1, sizeof(string)),
                         .parser_idx = 0,
                         .decl_tok_idx = 0,
                         .is_placeholder = 0,
                         .gen_str = 0,
                         .is_flag = 0,
                         .is_generic = 0,
                         .ctype_names = new_array(0, 1, sizeof(string))};
    compiler__Table_register_type(p->table, fn_typ);
    return fn_typ;
  };
  bool is_question = p->tok == compiler__compiler__TokenKind_question;
  if (is_question) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_question);
  };
  if (p->tok == compiler__compiler__TokenKind_lpar) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
    array_string types = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    while (1) {
      _PUSH(&types,
            (/*typ = array_string   tmp_typ=string*/ compiler__Parser_get_type(
                p)),
            tmp1, string);
      if (p->tok != compiler__compiler__TokenKind_comma) {
        break;
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
      ;
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
    typ = compiler__Parser_register_multi_return_stuct(p, types);
    if (is_question) {
      typ = compiler__stringify_pointer(typ);
      typ = _STR("Option_%.*s", typ.len, typ.str);
      compiler__Table_register_type_with_parent(p->table, typ, tos3("Option"));
    };
    return (compiler__Type){.name = typ,
                            .mod = p->mod,
                            .cat = cat,
                            .is_public = 0,
                            .fields = new_array(0, 1, sizeof(compiler__Var)),
                            .methods = new_array(0, 1, sizeof(compiler__Fn)),
                            .parent = tos3(""),
                            .is_c = 0,
                            .enum_vals = new_array(0, 1, sizeof(string)),
                            .gen_types = new_array(0, 1, sizeof(string)),
                            .default_vals = new_array(0, 1, sizeof(string)),
                            .parser_idx = 0,
                            .decl_tok_idx = 0,
                            .is_placeholder = 0,
                            .gen_str = 0,
                            .is_flag = 0,
                            .is_generic = 0,
                            .ctype_names = new_array(0, 1, sizeof(string))};
  };
  int arr_level = 0;
  while (p->tok == compiler__compiler__TokenKind_lsbr) {

    compiler__Parser_check(p, compiler__compiler__TokenKind_lsbr);
    if (p->tok == compiler__compiler__TokenKind_number ||
        (p->tok == compiler__compiler__TokenKind_name && !p->inside_const)) {
      if (p->tok == compiler__compiler__TokenKind_name) {
        typ = string_add(typ, _STR("[%.*s__%.*s]", p->mod.len, p->mod.str,
                                   p->lit.len, p->lit.str));
      } else {
        typ = string_add(typ, _STR("[%.*s]", p->lit.len, p->lit.str));
      };
      compiler__Parser_next(p);
    } else {
      arr_level++;
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_rsbr);
  };
  if (!p->builtin_mod && p->tok == compiler__compiler__TokenKind_name &&
      string_eq(p->lit, tos3("map"))) {
    compiler__Parser_next(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_lsbr);
    string key_type = compiler__Parser_check_name(p);
    if (string_ne(key_type, tos3("string"))) {
      compiler__Parser_error(p, tos3("maps only support string keys for now"));
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_rsbr);
    string val_type = compiler__stringify_pointer(compiler__Parser_get_type(p));
    typ = _STR("map_%.*s", val_type.len, val_type.str);
    compiler__Parser_register_map(p, typ);
    return (compiler__Type){.name = typ,
                            .mod = tos3(""),
                            .is_public = 0,
                            .fields = new_array(0, 1, sizeof(compiler__Var)),
                            .methods = new_array(0, 1, sizeof(compiler__Fn)),
                            .parent = tos3(""),
                            .is_c = 0,
                            .enum_vals = new_array(0, 1, sizeof(string)),
                            .gen_types = new_array(0, 1, sizeof(string)),
                            .default_vals = new_array(0, 1, sizeof(string)),
                            .parser_idx = 0,
                            .decl_tok_idx = 0,
                            .is_placeholder = 0,
                            .gen_str = 0,
                            .is_flag = 0,
                            .is_generic = 0,
                            .ctype_names = new_array(0, 1, sizeof(string))};
  };
  bool warn = 0;
  while (p->tok == compiler__compiler__TokenKind_mul) {

    if (compiler__Parser_first_pass(&/* ? */ *p)) {
      warn = 1;
    };
    mul = 1;
    nr_muls++;
    compiler__Parser_check(p, compiler__compiler__TokenKind_mul);
  };
  if (p->tok == compiler__compiler__TokenKind_amp) {
    mul = 1;
    nr_muls++;
    compiler__Parser_check(p, compiler__compiler__TokenKind_amp);
  };
  map_string ti = p->generic_dispatch.inst;
  if ((_IN(string, (p->lit), map_keys(&/* ? */ ti)))) {
    string tmp2 = tos3("");
    bool tmp3 = map_get(/*get_type.v : 137*/ ti, p->lit, &tmp2);

    if (!tmp3)
      tmp2 = tos((byte *)"", 0);

    typ = string_add(typ, tmp2);
  } else {
    typ = string_add(typ, p->lit);
  };
  if (string_eq(p->lit, tos3("C")) &&
      compiler__Parser_peek(&/* ? */ *p) == compiler__compiler__TokenKind_dot) {
    compiler__Parser_next(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
    typ = p->lit;
  } else {
    if (warn && string_ne(p->mod, tos3("ui"))) {
      compiler__Parser_warn(p, tos3("use `&Foo` instead of `*Foo`"));
    };
    if (compiler__Parser_peek(&/* ? */ *p) ==
        compiler__compiler__TokenKind_dot) {
      if (!p->builtin_mod &&
          compiler__ImportTable_known_alias(&/* ? */ p->import_table, typ)) {
        string mod =
            compiler__ImportTable_resolve_alias(&/* ? */ p->import_table, typ);
        typ = ((string_contains(mod, tos3("."))) ? (compiler__mod_gen_name(mod))
                                                 : (mod));
      };
      compiler__Parser_next(p);
      compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
      typ = string_add(typ, _STR("__%.*s", p->lit.len, p->lit.str));
    };
    compiler__Type t = compiler__Table_find_type(&/* ? */ *p->table, typ);
    if (string_eq(t.name, tos3("")) && !p->builtin_mod) {
      if (!string_contains(typ, tos3("array_")) &&
          string_ne(p->mod, tos3("main")) &&
          !string_contains(typ, tos3("__")) &&
          !string_starts_with(typ, tos3("["))) {
        typ = compiler__Parser_prepend_mod(&/* ? */ *p, typ);
      };
      t = compiler__Table_find_type(&/* ? */ *p->table, typ);
      if (string_eq(t.name, tos3("")) && !p->pref->translated &&
          !compiler__Parser_first_pass(&/* ? */ *p) &&
          !string_starts_with(typ, tos3("["))) {
        _V_MulRet_string_V_string _V_mret_808_t_suggest_tc_suggest =
            compiler__Table_find_misspelled_type(&/* ? */ *p->table, typ, p,
                                                 0.50);
        string t_suggest = _V_mret_808_t_suggest_tc_suggest.var_0;
        string tc_suggest = _V_mret_808_t_suggest_tc_suggest.var_1;
        if (t_suggest.len > 0) {
          t_suggest = _STR(". did you mean: (%.*s) `%.*s`", tc_suggest.len,
                           tc_suggest.str, t_suggest.len, t_suggest.str);
        };
        string econtext =
            ((p->pref->is_debug)
                 ? (string_add(
                       string_add(
                           string_add(string_add(tos3("("),
                                                 tos3("/tmp/gen_vc/v/vlib/"
                                                      "compiler/get_type.v")),
                                      tos3(":")),
                           tos3("185")),
                       tos3(")")))
                 : (tos3("")));
        compiler__Parser_error(p, _STR("unknown type `%.*s`%.*s %.*s", typ.len,
                                       typ.str, t_suggest.len, t_suggest.str,
                                       econtext.len, econtext.str));
      };
    } else if (!t.is_public && string_ne(t.mod, p->mod) && !p->is_vgen &&
               string_ne(t.name, tos3("")) &&
               !compiler__Parser_first_pass(&/* ? */ *p)) {
      compiler__Parser_error(
          p, _STR("type `%.*s` is private", t.name.len, t.name.str));
    };
  };
  if (string_eq(typ, tos3("void"))) {
    compiler__Parser_error(p, _STR("unknown type `%.*s`", typ.len, typ.str));
  };
  if (mul) {
    typ = string_add(typ, strings__repeat('*', nr_muls));
  };
  if (arr_level > 0) {
    typ = compiler__stringify_pointer(typ);
    for (int i = 0; i < arr_level; i++) {

      typ = _STR("array_%.*s", typ.len, typ.str);
    };
    compiler__Parser_register_array(p, typ);
  };
  compiler__Parser_next(p);
  if (is_question) {
    typ = compiler__stringify_pointer(typ);
    typ = _STR("Option_%.*s", typ.len, typ.str);
    compiler__Table_register_type_with_parent(p->table, typ, tos3("Option"));
  };
  if (string_eq(typ, tos3("byteptr"))) {
    typ = tos3("byte*");
  };
  if (string_eq(typ, tos3("voidptr"))) {
    typ = tos3("void*");
  };
  return (compiler__Type){.name = typ,
                          .cat = cat,
                          .mod = tos3(""),
                          .is_public = 0,
                          .fields = new_array(0, 1, sizeof(compiler__Var)),
                          .methods = new_array(0, 1, sizeof(compiler__Fn)),
                          .parent = tos3(""),
                          .is_c = 0,
                          .enum_vals = new_array(0, 1, sizeof(string)),
                          .gen_types = new_array(0, 1, sizeof(string)),
                          .default_vals = new_array(0, 1, sizeof(string)),
                          .parser_idx = 0,
                          .decl_tok_idx = 0,
                          .is_placeholder = 0,
                          .gen_str = 0,
                          .is_flag = 0,
                          .is_generic = 0,
                          .ctype_names = new_array(0, 1, sizeof(string))};
}
string compiler__parse_pointer(string _typ) {
  if (!string_starts_with(_typ, tos3("ptr_"))) {
    return _typ;
  };
  string typ = string_clone(_typ);
  while (string_starts_with(typ, tos3("ptr_"))) {

    typ = string_add(string_substr2(typ, 4, -1, true), tos3("*"));
  };
  return typ;
}
string compiler__stringify_pointer(string typ) {
  if (!string_ends_with(typ, tos3("*"))) {
    return typ;
  };
  int count = string_count(typ, tos3("*"));
  return string_add(string_repeat(tos3("ptr_"), count),
                    string_trim_right(typ, tos3("*")));
}
string compiler__Parser_match_statement(compiler__Parser *p, bool is_expr) {
  compiler__Parser_check(p, compiler__compiler__TokenKind_key_match);
  ;
  bool is_mut = p->tok == compiler__compiler__TokenKind_key_mut;
  if (is_mut) {
    compiler__Parser_next(p);
    ;
  };
  _V_MulRet_string_V_string _V_mret_58_typ_expr = compiler__Parser_tmp_expr(p);
  string typ = _V_mret_58_typ_expr.var_0;
  string expr = _V_mret_58_typ_expr.var_1;
  if (string_starts_with(typ, tos3("array_"))) {
    compiler__Parser_error(p, tos3("arrays cannot be compared"));
  };
  bool is_sum_type = (_IN_MAP((typ), p->table->sum_types));
  string sum_child_type = tos3("");
  string tmp_var = compiler__Parser_get_tmp(p);
  compiler__CGen_insert_before(p->cgen, _STR("%.*s %.*s = %.*s;", typ.len,
                                             typ.str, tmp_var.len, tmp_var.str,
                                             expr.len, expr.str));
  ;
  compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
  int i = 0;
  bool all_cases_return = 1;
  string res_typ = tos3("");
  while (p->tok != compiler__compiler__TokenKind_rcbr) {

    if (p->tok == compiler__compiler__TokenKind_key_else) {
      compiler__Parser_check(p, compiler__compiler__TokenKind_key_else);
      if (p->tok == compiler__compiler__TokenKind_arrow) {
        compiler__Parser_error(p, compiler__warn_match_arrow);
      };
      if (i == 0) {
        ;
        if (is_expr) {
          bool got_brace = p->tok == compiler__compiler__TokenKind_lcbr;
          if (got_brace) {
            ;
            compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
          };
          compiler__Parser_gen(p, tos3("( "));
          res_typ = compiler__Parser_bool_expression(p);
          compiler__Parser_gen(p, tos3(" )"));
          if (got_brace) {
            compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
          };
          string tmp1 = res_typ;
          { compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr); }
          return tmp1;
          ;
        } else {
          p->returns = 0;
          compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
          compiler__Parser_genln(p, tos3("{ "));
          compiler__Parser_statements(p);
          p->returns = all_cases_return && p->returns;
          string tmp2 = tos3("");
          { compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr); }
          return tmp2;
          ;
        };
      };
      if (is_expr) {
        compiler__Parser_gen(p, tos3(":("));
        bool got_brace = p->tok == compiler__compiler__TokenKind_lcbr;
        if (got_brace) {
          ;
          compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
        };
        compiler__Parser_check_types(p, compiler__Parser_bool_expression(p),
                                     res_typ);
        if (got_brace) {
          compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
        };
        compiler__Parser_gen(p, strings__repeat(')', i + 1));
        string tmp3 = res_typ;
        { compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr); }
        return tmp3;
        ;
      } else {
        p->returns = 0;
        compiler__Parser_genln(p, tos3("else // default:"));
        ;
        compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
        compiler__Parser_genln(p, tos3("{ "));
        compiler__Parser_statements(p);
        p->returns = all_cases_return && p->returns;
        string tmp4 = tos3("");
        { compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr); }
        return tmp4;
        ;
      };
    };
    if (i > 0) {
      if (is_expr) {
        compiler__Parser_gen(p, tos3(": ("));
      } else {
        compiler__Parser_gen(p, tos3("else "));
      };
    } else if (is_expr) {
      compiler__Parser_gen(p, tos3("("));
    };
    if (is_expr) {
      compiler__Parser_gen(p, tos3("("));
    } else {
      compiler__Parser_gen(p, tos3("if ("));
    };
    int ph = compiler__CGen_add_placeholder(&/* ? */ *p->cgen);
    compiler__Parser_open_scope(p);
    bool got_comma = 0;
    while (1) {
      if (got_comma) {
        compiler__Parser_gen(p, tos3(") || ("));
      };
      bool got_string = 0;
      if (string_eq(typ, tos3("string"))) {
        got_string = 1;
        compiler__Parser_gen(
            p, _STR("string_eq(%.*s, ", tmp_var.len, tmp_var.str));
      } else if (is_sum_type) {
        compiler__Parser_gen(p, _STR("%.*s.typ == ", tmp_var.len, tmp_var.str));
      } else {
        compiler__Parser_gen(p, _STR("%.*s == ", tmp_var.len, tmp_var.str));
      };
      p->expected_type = typ;
      if (is_sum_type) {
        sum_child_type = compiler__Parser_get_type2(p).name;
        string tt = string_all_after(sum_child_type, tos3("_"));
        compiler__Parser_gen(
            p, _STR("SumType_%.*s_%.*s", typ.len, typ.str, tt.len, tt.str));
        compiler__Parser_register_var(
            p, (compiler__Var){.name = tos3("it"),
                               .typ = string_add(sum_child_type, tos3("*")),
                               .is_mut = is_mut,
                               .ptr = 1,
                               .idx = 0,
                               .is_arg = 0,
                               .is_const = 0,
                               .args = new_array(0, 1, sizeof(compiler__Var)),
                               .attr = tos3(""),
                               .is_alloc = 0,
                               .is_returned = 0,
                               .ref = 0,
                               .parent_fn = tos3(""),
                               .mod = tos3(""),
                               .is_global = 0,
                               .is_used = 0,
                               .is_changed = 0,
                               .scope_level = 0,
                               .is_c = 0,
                               .is_moved = 0,
                               .line_nr = 0,
                               .token_idx = 0,
                               .is_for_var = 0,
                               .is_public = 0});
      } else {
        compiler__Parser_check_types(p, compiler__Parser_bool_expression(p),
                                     typ);
      };
      p->expected_type = tos3("");
      if (got_string) {
        compiler__Parser_gen(p, tos3(")"));
      };
      if (p->tok != compiler__compiler__TokenKind_comma) {
        if (got_comma) {
          compiler__Parser_gen(p, tos3(") "));
          compiler__CGen_set_placeholder(p->cgen, ph, tos3("("));
        };
        break;
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
      ;
      got_comma = 1;
    };
    compiler__Parser_gen(p, tos3(")"));
    if (p->tok == compiler__compiler__TokenKind_arrow) {
      compiler__Parser_error(p, compiler__warn_match_arrow);
      compiler__Parser_check(p, compiler__compiler__TokenKind_arrow);
    };
    if (is_expr) {
      compiler__Parser_gen(p, tos3("? ("));
      compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
      if (i == 0) {
        res_typ = compiler__Parser_bool_expression(p);
      } else {
        compiler__Parser_check_types(p, compiler__Parser_bool_expression(p),
                                     res_typ);
      };
      ;
      compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
      compiler__Parser_gen(p, tos3(")"));
    } else {
      p->returns = 0;
      ;
      compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
      compiler__Parser_genln(p, tos3("{ "));
      if (is_sum_type) {
        compiler__Parser_genln(p, _STR(" %.*s* it = (%.*s*)%.*s.obj ;",
                                       sum_child_type.len, sum_child_type.str,
                                       sum_child_type.len, sum_child_type.str,
                                       tmp_var.len, tmp_var.str));
      };
      compiler__Parser_statements(p);
      all_cases_return = all_cases_return && p->returns;
    };
    i++;
    ;
    compiler__Parser_close_scope(p);
  };
  compiler__Parser_error(p, tos3("match must be exhaustive"));
  string tmp5 = tos3("");
  { compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr); }
  return tmp5;
  ;
  { compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr); }
}
void compiler__Parser_switch_statement(compiler__Parser *p) {
  compiler__Parser_error(
      p,
      string_add(
          tos3("`switch` statement has been removed, use `match` instead:\n"),
          tos3("https://vlang.io/docs#match")));
}
string compiler__Parser_if_statement(compiler__Parser *p, bool is_expr,
                                     int elif_depth) {
  if (is_expr) {
    p->inside_if_expr = 1;
    compiler__Parser_gen(p, tos3("(("));
  } else {
    compiler__Parser_gen(p, tos3("if ("));
  };
  compiler__Parser_next(p);
  ;
  if (p->tok == compiler__compiler__TokenKind_name &&
      compiler__Parser_peek(&/* ? */ *p) ==
          compiler__compiler__TokenKind_assign) {
    compiler__Parser_error(p, tos3("cannot assign on if-else statement"));
  };
  if (p->tok == compiler__compiler__TokenKind_name &&
      (compiler__Parser_peek(&/* ? */ *p) ==
           compiler__compiler__TokenKind_inc ||
       compiler__Parser_peek(&/* ? */ *p) ==
           compiler__compiler__TokenKind_dec)) {
    compiler__Parser_error(
        p,
        _STR("`%.*s` is a statement",
             compiler__TokenKind_str(compiler__Parser_peek(&/* ? */ *p)).len,
             compiler__TokenKind_str(compiler__Parser_peek(&/* ? */ *p)).str));
  };
  if (p->tok == compiler__compiler__TokenKind_name &&
      compiler__Parser_peek(&/* ? */ *p) ==
          compiler__compiler__TokenKind_decl_assign) {
    compiler__Parser_check_not_reserved(p);
    string option_tmp = compiler__Parser_get_tmp(p);
    string var_name = p->lit;
    if (compiler__Parser_known_var(&/* ? */ *p, var_name)) {
      compiler__Parser_error(
          p, _STR("redefinition of `%.*s`", var_name.len, var_name.str));
    };
    compiler__Parser_open_scope(p);
    compiler__Parser_next(p);
    ;
    compiler__Parser_check(p, compiler__compiler__TokenKind_decl_assign);
    ;
    p->is_var_decl = 1;
    _V_MulRet_string_V_string _V_mret_1084_option_type_expr =
        compiler__Parser_tmp_expr(p);
    string option_type = _V_mret_1084_option_type_expr.var_0;
    string expr = _V_mret_1084_option_type_expr.var_1;
    if (!string_starts_with(option_type, tos3("Option_"))) {
      compiler__Parser_error(p,
                             tos3("`if x := opt() {` syntax requires a "
                                  "function that returns an optional value"));
    };
    p->is_var_decl = 0;
    string typ =
        compiler__parse_pointer(string_substr2(option_type, 7, -1, true));
    compiler__CGen_insert_before(
        p->cgen, _STR("%.*s %.*s = %.*s; ", option_type.len, option_type.str,
                      option_tmp.len, option_tmp.str, expr.len, expr.str));
    ;
    compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
    compiler__Parser_genln(p, string_add(option_tmp, tos3(".ok) {")));
    compiler__Parser_genln(p, _STR("%.*s %.*s = *(%.*s*) %.*s . data;", typ.len,
                                   typ.str, var_name.len, var_name.str, typ.len,
                                   typ.str, option_tmp.len, option_tmp.str));
    compiler__Parser_register_var(
        p, (compiler__Var){.name = var_name,
                           .typ = typ,
                           .is_mut = 0,
                           .is_used = 1,
                           .idx = 0,
                           .is_arg = 0,
                           .is_const = 0,
                           .args = new_array(0, 1, sizeof(compiler__Var)),
                           .attr = tos3(""),
                           .is_alloc = 0,
                           .is_returned = 0,
                           .ptr = 0,
                           .ref = 0,
                           .parent_fn = tos3(""),
                           .mod = tos3(""),
                           .is_global = 0,
                           .is_changed = 0,
                           .scope_level = 0,
                           .is_c = 0,
                           .is_moved = 0,
                           .line_nr = 0,
                           .token_idx = 0,
                           .is_for_var = 0,
                           .is_public = 0});
    compiler__Parser_statements(p);
    compiler__Parser_close_scope(p);
    p->returns = 0;
    if (p->tok == compiler__compiler__TokenKind_key_else) {
      compiler__Parser_next(p);
      compiler__Parser_genln(p, tos3("else {"));
      compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
      compiler__Parser_statements(p);
    };
    return tos3("void");
  } else {
    compiler__Parser_check_types(p, compiler__Parser_bool_expression(p),
                                 tos3("bool"));
  };
  if (is_expr) {
    compiler__Parser_gen(p, tos3(") ? ("));
  } else {
    compiler__Parser_genln(p, tos3(") {"));
  };
  ;
  compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
  if (p->inside_if_expr) {
    ;
  };
  string typ = tos3("");
  if (p->tok == compiler__compiler__TokenKind_key_if && p->inside_if_expr) {
    typ = compiler__Parser_factor(p);
    compiler__Parser_next(p);
  } else {
    typ = compiler__Parser_statements(p);
  };
  bool if_returns = p->returns;
  p->returns = 0;
  if (p->tok == compiler__compiler__TokenKind_key_else) {
    if (p->inside_if_expr) {
      ;
    } else {
      ;
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_key_else);
    ;
    if (p->tok == compiler__compiler__TokenKind_key_if) {
      if (is_expr) {
        compiler__Parser_gen(p, tos3(") : ("));
        string nested =
            compiler__Parser_if_statement(p, is_expr, elif_depth + 1);
        bool nested_returns = p->returns;
        p->returns = if_returns && nested_returns;
        return nested;
      } else {
        compiler__Parser_gen(p, tos3(" else "));
        string nested = compiler__Parser_if_statement(p, is_expr, 0);
        bool nested_returns = p->returns;
        p->returns = if_returns && nested_returns;
        return nested;
      };
    };
    if (is_expr) {
      compiler__Parser_gen(p, tos3(") : ("));
    } else {
      compiler__Parser_genln(p, tos3(" else { "));
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
    if (is_expr) {
      ;
    };
    string first_typ = typ;
    typ = compiler__Parser_statements(p);
    p->inside_if_expr = 0;
    if (is_expr) {
      compiler__Parser_check_types(p, first_typ, typ);
      compiler__Parser_gen(p, strings__repeat(')', 2 * (elif_depth + 1)));
    };
    bool else_returns = p->returns;
    p->returns = if_returns && else_returns;
    return typ;
  };
  p->inside_if_expr = 0;
  if (compiler__Parser_fileis(&/* ? */ *p, tos3("test_test"))) {
    printf("if ret typ=\"%.*s\" line=%d\n", typ.len, typ.str,
           p->scanner->line_nr);
  };
  return typ;
}
void compiler__Parser_gen_json_for_type(compiler__Parser *p,
                                        compiler__Type typ) {
  string dec = tos3("");
  string enc = tos3("");
  string t = typ.name;
  if (string_eq(t, tos3("int")) || string_eq(t, tos3("string")) ||
      string_eq(t, tos3("bool"))) {

    return;
  };
  if (compiler__Parser_first_pass(&/* ? */ *p)) {

    return;
  };
  compiler__Fn dec_fn =
      (compiler__Fn){.mod = p->mod,
                     .typ = _STR("Option_%.*s", typ.name.len, typ.name.str),
                     .name = compiler__js_dec_name(t),
                     .args = new_array(0, 1, sizeof(compiler__Var)),
                     .is_interface = 0,
                     .scope_level = 0,
                     .receiver_typ = tos3(""),
                     .is_c = 0,
                     .is_public = 0,
                     .is_method = 0,
                     .is_decl = 0,
                     .is_unsafe = 0,
                     .is_deprecated = 0,
                     .is_variadic = 0,
                     .is_generic = 0,
                     .returns_error = 0,
                     .defer_text = new_array(0, 1, sizeof(string)),
                     .type_pars = new_array(0, 1, sizeof(string)),
                     .type_inst = new_array(0, 1, sizeof(compiler__TypeInst)),
                     .generic_fn_idx = 0,
                     .parser_idx = 0,
                     .fn_name_token_idx = 0,
                     .comptime_define = tos3(""),
                     .is_used = 0};
  if (compiler__Table_known_fn(&/* ? */ *p->table, dec_fn.name)) {

    return;
  };
  compiler__Var arg =
      (compiler__Var){.typ = tos3("cJSON*"),
                      .name = tos3(""),
                      .idx = 0,
                      .is_arg = 0,
                      .is_const = 0,
                      .args = new_array(0, 1, sizeof(compiler__Var)),
                      .attr = tos3(""),
                      .is_mut = 0,
                      .is_alloc = 0,
                      .is_returned = 0,
                      .ptr = 0,
                      .ref = 0,
                      .parent_fn = tos3(""),
                      .mod = tos3(""),
                      .is_global = 0,
                      .is_used = 0,
                      .is_changed = 0,
                      .scope_level = 0,
                      .is_c = 0,
                      .is_moved = 0,
                      .line_nr = 0,
                      .token_idx = 0,
                      .is_for_var = 0,
                      .is_public = 0};
  _PUSH(&dec_fn.args,
        (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ arg), tmp1,
        compiler__Var);
  compiler__Table_register_fn(p->table, dec_fn);
  compiler__Fn enc_fn =
      (compiler__Fn){.mod = p->mod,
                     .typ = tos3("cJSON*"),
                     .name = compiler__js_enc_name(t),
                     .args = new_array(0, 1, sizeof(compiler__Var)),
                     .is_interface = 0,
                     .scope_level = 0,
                     .receiver_typ = tos3(""),
                     .is_c = 0,
                     .is_public = 0,
                     .is_method = 0,
                     .is_decl = 0,
                     .is_unsafe = 0,
                     .is_deprecated = 0,
                     .is_variadic = 0,
                     .is_generic = 0,
                     .returns_error = 0,
                     .defer_text = new_array(0, 1, sizeof(string)),
                     .type_pars = new_array(0, 1, sizeof(string)),
                     .type_inst = new_array(0, 1, sizeof(compiler__TypeInst)),
                     .generic_fn_idx = 0,
                     .parser_idx = 0,
                     .fn_name_token_idx = 0,
                     .comptime_define = tos3(""),
                     .is_used = 0};
  compiler__Var enc_arg =
      (compiler__Var){.typ = t,
                      .name = tos3(""),
                      .idx = 0,
                      .is_arg = 0,
                      .is_const = 0,
                      .args = new_array(0, 1, sizeof(compiler__Var)),
                      .attr = tos3(""),
                      .is_mut = 0,
                      .is_alloc = 0,
                      .is_returned = 0,
                      .ptr = 0,
                      .ref = 0,
                      .parent_fn = tos3(""),
                      .mod = tos3(""),
                      .is_global = 0,
                      .is_used = 0,
                      .is_changed = 0,
                      .scope_level = 0,
                      .is_c = 0,
                      .is_moved = 0,
                      .line_nr = 0,
                      .token_idx = 0,
                      .is_for_var = 0,
                      .is_public = 0};
  _PUSH(&enc_fn.args,
        (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ enc_arg), tmp2,
        compiler__Var);
  compiler__Table_register_fn(p->table, enc_fn);
  dec = string_add(
      dec,
      _STR("\n//%.*s %.*s (cJSON* root) {\nOption %.*s(cJSON* root, %.*s* res) "
           "{\n//  %.*s res;\n  if (!root) {\n    const char *error_ptr = "
           "cJSON_GetErrorPtr();\n    if (error_ptr != NULL)	{\n      "
           "fprintf(stderr, \"Error in decode() for %.*s error_ptr=: "
           "%%%%s\\n\", error_ptr);\n//      printf(\"\\nbad js=%%%%s\\n\", "
           "js.str);\n      return v_error(tos2(error_ptr));\n    }\n  }\n",
           t.len, t.str, dec_fn.name.len, dec_fn.name.str, dec_fn.name.len,
           dec_fn.name.str, t.len, t.str, t.len, t.str, t.len, t.str));
  enc =
      string_add(enc, _STR("\ncJSON* %.*s (%.*s val) {\ncJSON *o = "
                           "cJSON_CreateObject();\nstring res = tos2(\"\");\n",
                           enc_fn.name.len, enc_fn.name.str, t.len, t.str));
  if (string_starts_with(t, tos3("array_"))) {
    dec = string_add(dec, compiler__Parser_decode_array(p, t));
    enc = string_add(enc, compiler__Parser_encode_array(&/* ? */ *p, t));
  };
  array_compiler__Var tmp3 = typ.fields;
  for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
    compiler__Var field = ((compiler__Var *)tmp3.data)[tmp4];

    if (string_eq(field.attr, tos3("skip"))) {
      continue;
    };
    string name = ((string_starts_with(field.attr, tos3("json:")))
                       ? (string_substr2(field.attr, 5, -1, true))
                       : (field.name));
    compiler__Type field_type =
        compiler__Table_find_type(&/* ? */ *p->table, field.typ);
    string _typ = string_replace(field.typ, tos3("*"), tos3(""));
    string enc_name = compiler__js_enc_name(_typ);
    if (string_eq(field.attr, tos3("raw"))) {
      dec = string_add(
          dec,
          string_add(_STR(" res->%.*s = tos2(cJSON_PrintUnformatted(",
                          field.name.len, field.name.str),
                     _STR("js_get(root, \"%.*s\")));\n", name.len, name.str)));
    } else {
      compiler__Parser_gen_json_for_type(p, field_type);
      string dec_name = compiler__js_dec_name(_typ);
      if (compiler__is_js_prim(_typ)) {
        dec = string_add(
            dec, string_add(_STR(" res->%.*s = %.*s (js_get(", field.name.len,
                                 field.name.str, dec_name.len, dec_name.str),
                            _STR("root, \"%.*s\"))", name.len, name.str)));
      } else {
        dec = string_add(dec,
                         _STR(" %.*s (js_get(root, \"%.*s\"), & (res->%.*s))",
                              dec_name.len, dec_name.str, name.len, name.str,
                              field.name.len, field.name.str));
      };
      dec = string_add(dec, tos3(";\n"));
    };
    enc = string_add(
        enc, _STR("  cJSON_AddItemToObject(o,  \"%.*s\",%.*s (val.%.*s)); \n",
                  name.len, name.str, enc_name.len, enc_name.str,
                  field.name.len, field.name.str));
  };
  _PUSH(&p->cgen->fns,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "%.*s return opt_ok(res, sizeof(*res)); \n}", dec.len, dec.str)),
        tmp7, string);
  _PUSH(&p->cgen->fns,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "/*enc start*/ %.*s return o;}", enc.len, enc.str)),
        tmp8, string);
}
bool compiler__is_js_prim(string typ) {
  return string_eq(typ, tos3("int")) || string_eq(typ, tos3("string")) ||
         string_eq(typ, tos3("bool")) || string_eq(typ, tos3("f32")) ||
         string_eq(typ, tos3("f64")) || string_eq(typ, tos3("i8")) ||
         string_eq(typ, tos3("i16")) || string_eq(typ, tos3("i64")) ||
         string_eq(typ, tos3("u16")) || string_eq(typ, tos3("u32")) ||
         string_eq(typ, tos3("u64"));
}
string compiler__Parser_decode_array(compiler__Parser *p, string array_type) {
  string typ = string_replace(array_type, tos3("array_"), tos3(""));
  compiler__Type t = compiler__Table_find_type(&/* ? */ *p->table, typ);
  string fn_name = compiler__js_dec_name(typ);
  compiler__Parser_gen_json_for_type(p, t);
  string s = tos3("");
  if (compiler__is_js_prim(typ)) {
    s = _STR("%.*s val= %.*s (jsval); ", typ.len, typ.str, fn_name.len,
             fn_name.str);
  } else {
    s = _STR("  %.*s val; %.*s (jsval, &val); ", typ.len, typ.str, fn_name.len,
             fn_name.str);
  };
  return _STR("\n*res = new_array(0, 0, sizeof(%.*s));\nconst cJSON *jsval = "
              "NULL;\ncJSON_ArrayForEach(jsval, root)\n{\n%.*s\n  "
              "array_push(res, &val);\n}\n",
              typ.len, typ.str, s.len, s.str);
}
string compiler__js_enc_name(string typ) {
  string name = _STR("json__jsencode_%.*s", typ.len, typ.str);
  return name;
}
string compiler__js_dec_name(string typ) {
  string name = _STR("json__jsdecode_%.*s", typ.len, typ.str);
  return name;
}
string compiler__Parser_encode_array(compiler__Parser *p, string array_type) {
  string typ = string_replace(array_type, tos3("array_"), tos3(""));
  string fn_name = compiler__js_enc_name(typ);
  return _STR(
      "\no = cJSON_CreateArray();\nfor (int i = 0; i < val.len; i++){\n  "
      "cJSON_AddItemToArray(o, %.*s (  ((%.*s*)val.data)[i]  ));\n}\n",
      fn_name.len, fn_name.str, typ.len, typ.str);
}
array_string
compiler__V_generate_hotcode_reloading_compiler_flags(compiler__V *v) {
  array_string a = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  if (v->pref->is_live || v->pref->is_so) {
    if ((v->pref->os == v_dot_pref__v_dot_pref__OS_linux ||
         string_eq(os__user_os(), tos3("linux")))) {
      _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("-rdynamic")),
            tmp1, string);
    };
    if ((v->pref->os == v_dot_pref__v_dot_pref__OS_mac ||
         string_eq(os__user_os(), tos3("mac")))) {
      _PUSH(&a,
            (/*typ = array_string   tmp_typ=string*/ tos3("-flat_namespace")),
            tmp2, string);
    };
  };
  return a;
}
void compiler__V_generate_hotcode_reloading_declarations(compiler__V *v) {
  compiler__CGen *cgen = v->cgen;
  if (v->pref->os != v_dot_pref__v_dot_pref__OS_windows) {
    if (v->pref->is_so) {
      compiler__CGen_genln(cgen, tos3("pthread_mutex_t live_fn_mutex;"));
    };
    if (v->pref->is_live) {
      compiler__CGen_genln(
          cgen,
          tos3("pthread_mutex_t live_fn_mutex = PTHREAD_MUTEX_INITIALIZER;"));
    };
  } else {
    if (v->pref->is_so) {
      compiler__CGen_genln(cgen, tos3("HANDLE live_fn_mutex;"));
      compiler__CGen_genln(
          cgen,
          tos3("\nvoid pthread_mutex_lock(HANDLE *m) {\n	"
               "WaitForSingleObject(*m, INFINITE);\n}\n\nvoid "
               "pthread_mutex_unlock(HANDLE *m) {\n	ReleaseMutex(*m);\n}"));
    };
    if (v->pref->is_live) {
      compiler__CGen_genln(cgen, tos3("HANDLE live_fn_mutex = 0;"));
    };
  };
}
void compiler__V_generate_hotcode_reloading_main_caller(compiler__V *v) {
  if (!v->pref->is_live) {

    return;
  };
  compiler__CGen *cgen = v->cgen;
  compiler__CGen_genln(cgen, tos3(""));
  string file_base =
      string_replace(os__filename(v->pref->path), tos3(".v"), tos3(""));
  if (v->pref->os != v_dot_pref__v_dot_pref__OS_windows) {
    string so_name = string_add(file_base, tos3(".so"));
    compiler__CGen_genln(cgen, _STR("  char *live_library_name = \"%.*s\";",
                                    so_name.len, so_name.str));
    compiler__CGen_genln(cgen, tos3("  load_so(live_library_name);"));
    compiler__CGen_genln(cgen, tos3("  pthread_t _thread_so;"));
    compiler__CGen_genln(cgen, tos3("  pthread_create(&_thread_so , NULL, "
                                    "(void *)&reload_so, live_library_name);"));
  } else {
    string so_name =
        string_add(file_base, ((string_eq(v->pref->ccompiler, tos3("msvc")))
                                   ? (tos3(".dll"))
                                   : (tos3(".so"))));
    compiler__CGen_genln(cgen, _STR("  char *live_library_name = \"%.*s\";",
                                    so_name.len, so_name.str));
    compiler__CGen_genln(cgen,
                         tos3("  live_fn_mutex = CreateMutexA(0, 0, 0);"));
    compiler__CGen_genln(cgen, tos3("  load_so(live_library_name);"));
    compiler__CGen_genln(cgen, tos3("  unsigned long _thread_so;"));
    compiler__CGen_genln(cgen,
                         tos3("  _thread_so = CreateThread(0, 0, "
                              "(LPTHREAD_START_ROUTINE)&reload_so, 0, 0, 0);"));
  };
}
void compiler__V_generate_hot_reload_code(compiler__V *v) {
  compiler__CGen *cgen = v->cgen;
  if (v->pref->is_live) {
    string file = os__realpath(v->pref->path);
    string file_base = string_replace(os__filename(file), tos3(".v"), tos3(""));
    string so_name = string_add(file_base, tos3(".so"));
    string vexe = (*(string *)array_get(os__args, 0));
    if (string_eq(os__user_os(), tos3("windows"))) {
      vexe = compiler__cescaped_path(vexe);
      file = compiler__cescaped_path(file);
    };
    string msvc = tos3("");
    if (string_eq(v->pref->ccompiler, tos3("msvc"))) {
      msvc = tos3("-cc msvc");
    };
    string so_debug_flag = ((v->pref->is_debug) ? (tos3("-g")) : (tos3("")));
    string cmd_compile_shared_library =
        _STR("%.*s %.*s %.*s -o %.*s -solive -shared %.*s", vexe.len, vexe.str,
             msvc.len, msvc.str, so_debug_flag.len, so_debug_flag.str,
             file_base.len, file_base.str, file.len, file.str);
    if (v_dot_pref__VerboseLevel_is_higher_or_equal(
            v->pref->verbosity,
            v_dot_pref__v_dot_pref__VerboseLevel_level_one)) {
      println(cmd_compile_shared_library);
    };
    i64 ticks = time__ticks();
    os__system(cmd_compile_shared_library);
    if (v_dot_pref__VerboseLevel_is_higher_or_equal(
            v->pref->verbosity,
            v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
      i64 diff = time__ticks() - ticks;
      printf("compiling shared library took %lld ms\n", diff);
      println(tos3("=========\n"));
    };
    compiler__CGen_genln(
        cgen, tos3("\n\nvoid lfnmutex_print(char *s){\n	if(0){\n	"
                   "	fflush(stderr);\n		fprintf(stderr,\">> "
                   "live_fn_mutex: %p | %s\\n\", &live_fn_mutex, s);\n	"
                   "	fflush(stderr);\n	}\n}\n"));
    if (v->pref->os != v_dot_pref__v_dot_pref__OS_windows) {
      compiler__CGen_genln(
          cgen,
          tos3("\nvoid* live_lib=0;\nint load_so(byteptr path) {\n	char "
               "cpath[1024];\n	sprintf(cpath,\"./%s\", path);\n	"
               "//printf(\"load_so %s\\n\", cpath);\n	if (live_lib) "
               "dlclose(live_lib);\n	live_lib = dlopen(cpath, "
               "RTLD_LAZY);\n	if (!live_lib) {\n		puts(\"open "
               "failed\");\n		exit(1);\n		return "
               "0;\n	}\n"));
      array_string tmp5 = cgen->so_fns;
      for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
        string so_fn = ((string *)tmp5.data)[tmp6];

        compiler__CGen_genln(cgen,
                             _STR("%.*s = dlsym(live_lib, \"%.*s\");  ",
                                  so_fn.len, so_fn.str, so_fn.len, so_fn.str));
      };
    } else {
      compiler__CGen_genln(
          cgen, tos3("\nvoid pthread_mutex_lock(HANDLE *m) {\n	"
                     "WaitForSingleObject(*m, INFINITE);\n}\n\nvoid "
                     "pthread_mutex_unlock(HANDLE *m) {\n	"
                     "ReleaseMutex(*m);\n}\n\nvoid* live_lib=0;\nint "
                     "load_so(byteptr path) {\n	char cpath[1024];\n	"
                     "sprintf(cpath, \"./%s\", path);\n	if (live_lib) "
                     "FreeLibrary(live_lib);\n	live_lib = "
                     "LoadLibraryA(cpath);\n	if (!live_lib) {\n	"
                     "	puts(\"open failed\");\n		"
                     "exit(1);\n		return 0;\n	}\n"));
      array_string tmp7 = cgen->so_fns;
      for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
        string so_fn = ((string *)tmp7.data)[tmp8];

        compiler__CGen_genln(
            cgen, _STR("%.*s = (void *)GetProcAddress(live_lib, \"%.*s\");  ",
                       so_fn.len, so_fn.str, so_fn.len, so_fn.str));
      };
    };
    compiler__CGen_genln(
        cgen,
        _STR("return 1;\n}\n\nint _live_reloads = 0;\nvoid reload_so() "
             "{\n	char new_so_base[1024];\n	char "
             "new_so_name[1024];\n	char compile_cmd[1024];\n	int "
             "last = os__file_last_mod_unix(tos2(\"%.*s\"));\n	while (1) "
             "{\n		// TODO use inotify\n		int now = "
             "os__file_last_mod_unix(tos2(\"%.*s\"));\n		if (now != "
             "last) {\n			last = now;\n			"
             "_live_reloads++;\n\n			//v -o bounce -shared "
             "bounce.v\n			sprintf(new_so_base, "
             "\".tmp.%%d.%.*s\", _live_reloads);\n			#ifdef "
             "_WIN32\n			// We have to make this directory "
             "becuase windows WILL NOT\n			// do it for "
             "us\n			"
             "os__mkdir(string_all_before_last(tos2(new_so_base), "
             "tos2(\"/\")));\n			#endif\n		"
             "	#ifdef _MSC_VER\n			sprintf(new_so_name, "
             "\"%%s.dll\", new_so_base);\n			#else\n	"
             "		sprintf(new_so_name, \"%%s.so\", "
             "new_so_base);\n			#endif\n		"
             "	sprintf(compile_cmd, \"%.*s %.*s -o %%s -solive -shared "
             "%.*s\", new_so_base);\n			"
             "os__system(tos2(compile_cmd));\n\n			if( "
             "!os__exists(tos2(new_so_name)) ) {\n			"
             "	fprintf(stderr, \"Errors while compiling %.*s\\n\");\n	"
             "			continue;\n			}\n\n	"
             "		lfnmutex_print(\"reload_so locking...\");\n	"
             "		pthread_mutex_lock(&live_fn_mutex);\n		"
             "	lfnmutex_print(\"reload_so locked\");\n\n		"
             "	live_lib = 0; // hack: force skipping dlclose/1, the code may "
             "be still used...\n			"
             "load_so(new_so_name);\n			#ifndef "
             "_WIN32\n			unlink(new_so_name); // removing the "
             ".so file from the filesystem after dlopen-ing it is safe, since "
             "it will still be mapped in memory.\n			"
             "#else\n			_unlink(new_so_name);\n		"
             "	#endif\n			//if(0 == rename(new_so_name, "
             "\"%.*s\")){\n			//	"
             "load_so(\"%.*s\");\n			//}\n\n		"
             "	lfnmutex_print(\"reload_so unlocking...\");\n		"
             "	pthread_mutex_unlock(&live_fn_mutex);\n			"
             "lfnmutex_print(\"reload_so unlocked\");\n\n		"
             "}\n		time__sleep_ms(100);\n	}\n}\n",
             file.len, file.str, file.len, file.str, file_base.len,
             file_base.str, vexe.len, vexe.str, msvc.len, msvc.str, file.len,
             file.str, file.len, file.str, so_name.len, so_name.str,
             so_name.len, so_name.str));
  };
  if (v->pref->is_so) {
    compiler__CGen_genln(cgen,
                         tos3(" int load_so(byteptr path) { return 0; }"));
  };
}
compiler__V *compiler__new_v(v_dot_pref__Preferences *pref) {
  string rdir = os__realpath(pref->path);
  string out_name_c =
      compiler__get_vtmp_filename(pref->out_name, tos3(".tmp.c"));
  if (pref->is_so) {
    out_name_c = compiler__get_vtmp_filename(pref->out_name, tos3(".tmp.so.c"));
  };
  strings__Builder vgen_buf = strings__new_builder(1000);
  strings__Builder_writeln(&/* ? */ vgen_buf,
                           tos3("module vgen\nimport strings"));
  string compiled_dir = ((os__is_dir(rdir)) ? (rdir) : (os__dir(rdir)));
  return (compiler__V *)memdup(
      &(compiler__V){.mod_file_cacher = compiler__new_mod_file_cacher(),
                     .compiled_dir = compiled_dir,
                     .table = compiler__new_table(pref->obfuscate),
                     .out_name_c = out_name_c,
                     .cgen = compiler__new_cgen(out_name_c),
                     .pref = pref,
                     .vgen_buf = vgen_buf,
                     .files = new_array(0, 1, sizeof(string)),
                     .parsers = new_array(0, 1, sizeof(compiler__Parser)),
                     .file_parser_idx = new_map(1, sizeof(int)),
                     .gen_parser_idx = new_map(1, sizeof(int)),
                     .cached_mods = new_array(0, 1, sizeof(string)),
                     .module_lookup_paths = new_array(0, 1, sizeof(string)),
                     .v_fmt_all = 0,
                     .v_fmt_file = tos3(""),
                     .v_fmt_file_result = tos3("")},
      sizeof(compiler__V));
}
void compiler__V_finalize_compilation(compiler__V *v) {
  if (v->pref->autofree) {
  };
}
int compiler__V_add_parser(compiler__V *v, compiler__Parser parser) {
  int pidx = v->parsers.len;
  _PUSH(&v->parsers,
        (/*typ = array_compiler__Parser   tmp_typ=compiler__Parser*/ parser),
        tmp1, compiler__Parser);
  string file_path =
      ((os__is_abs_path(parser.file_path)) ? (parser.file_path)
                                           : (os__realpath(parser.file_path)));
  map_set(&v->file_parser_idx, file_path, &(int[]){pidx});
  return pidx;
}
Option_int compiler__V_get_file_parser_index(compiler__V *v, string file) {
  string file_path = ((os__is_abs_path(file)) ? (file) : (os__realpath(file)));
  if ((_IN_MAP((file_path), v->file_parser_idx))) {
    int tmp2 = 0;
    bool tmp3 = map_get(/*main.v : 116*/ v->file_parser_idx, file_path, &tmp2);

    int tmp4 = OPTION_CAST(int)(tmp2);
    return opt_ok(&tmp4, sizeof(int));
  };
  return v_error(_STR("parser for \"%.*s\" not found", file.len, file.str));
}
int compiler__V_parse(compiler__V *v, string file, compiler__Pass pass) {
  Option_int tmp5 = compiler__V_get_file_parser_index(&/* ? */ *v, file);
  int pidx;
  if (!tmp5.ok) {
    string err = tmp5.error;
    int errcode = tmp5.ecode;
    compiler__Parser p = compiler__V_new_parser_from_file(v, file);
    compiler__Parser_parse(&/* ? */ p, pass);
    return compiler__V_add_parser(v, p);
  }
  pidx = *(int *)tmp5.data;
  ;
  compiler__Parser_parse(
      &/* ? */ (*(compiler__Parser *)array_get(v->parsers, pidx)), pass);
  return pidx;
}
void compiler__V_compile(compiler__V *v) {
  if (string_ne(os__user_os(), tos3("windows")) &&
      string_eq(v->pref->ccompiler, tos3("msvc"))) {
    compiler__verror(_STR("Cannot build with msvc on %.*s", os__user_os().len,
                          os__user_os().str));
  };
  compiler__CGen *cgen = v->cgen;
  compiler__CGen_genln(cgen, tos3("// Generated by V"));
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity,
          v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
    println(tos3("all .v files before:"));
    println(array_string_str(v->files));
  };
  compiler__V_add_v_files_to_compile(v);
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity,
          v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
    println(tos3("all .v files:"));
    println(array_string_str(v->files));
  };
  array_string tmp8 = v->files;
  for (int tmp9 = 0; tmp9 < tmp8.len; tmp9++) {
    string file = ((string *)tmp8.data)[tmp9];

    compiler__V_parse(v, file, compiler__compiler__Pass_decl);
  };
  cgen->pass = compiler__compiler__Pass_main;
  if (v->pref->is_debug) {
#ifdef _VJS
#else
    compiler__CGen_genln(cgen, tos3("#define VDEBUG (1)"));
#endif
    ;
  };
  if (v->pref->prealloc) {
    compiler__CGen_genln(cgen, tos3("#define VPREALLOC (1)"));
  };
  if (v->pref->os == v_dot_pref__v_dot_pref__OS_js) {
    compiler__CGen_genln(cgen, tos3("#define _VJS (1) "));
  };
  string v_hash = compiler__vhash();
#ifdef _VJS
#else
  compiler__CGen_genln(cgen, tos3("#ifndef V_COMMIT_HASH"));
  compiler__CGen_genln(
      cgen, _STR("#define V_COMMIT_HASH \"%.*s\"", v_hash.len, v_hash.str));
  compiler__CGen_genln(cgen, tos3("#endif"));
#endif
  ;
  bool q = cgen->nogen;
  cgen->nogen = 0;
#ifdef _VJS
#else
  if (!v->pref->is_bare) {
    compiler__CGen_genln(cgen, tos3("#include <inttypes.h>"));
  } else {
    compiler__CGen_genln(cgen, tos3("#include <stdint.h>"));
  };
  if (v->pref->compile_defines_all.len > 0) {
    compiler__CGen_genln(cgen, tos3(""));
    compiler__CGen_genln(
        cgen,
        string_add(tos3("// All custom defines      : "),
                   array_string_join(v->pref->compile_defines_all, tos3(","))));
    compiler__CGen_genln(
        cgen,
        string_add(tos3("// Turned ON custom defines: "),
                   array_string_join(v->pref->compile_defines, tos3(","))));
    array_string tmp10 = v->pref->compile_defines;
    for (int tmp11 = 0; tmp11 < tmp10.len; tmp11++) {
      string cdefine = ((string *)tmp10.data)[tmp11];

      compiler__CGen_genln(
          cgen, _STR("#define CUSTOM_DEFINE_%.*s", cdefine.len, cdefine.str));
    };
    compiler__CGen_genln(cgen, tos3("//"));
    compiler__CGen_genln(cgen, tos3(""));
  };
  compiler__CGen_genln(cgen, compiler__c_builtin_types);
  if (!v->pref->is_bare) {
    compiler__CGen_genln(cgen, compiler__c_headers);
  } else {
    compiler__CGen_genln(cgen, compiler__bare_c_headers);
  };
#endif
  ;
  compiler__V_generate_hotcode_reloading_declarations(&/* ? */ *v);
  bool imports_json = (_IN(string, (tos3("json")), v->table->imports));
  if (v->pref->build_mode == v_dot_pref__v_dot_pref__BuildMode_default_mode) {
    if (imports_json) {
      compiler__CGen_genln(cgen, tos3("#include \"cJSON.h\""));
    };
  };
  if (v->pref->build_mode == v_dot_pref__v_dot_pref__BuildMode_default_mode) {
#ifndef _VJS
    compiler__CGen_genln(cgen, tos3("int g_test_oks = 0;"));
    compiler__CGen_genln(cgen, tos3("int g_test_fails = 0;"));
#endif
    ;
    if (imports_json) {
      compiler__CGen_genln(
          cgen, tos3("\n#define js_get(object, key) "
                     "cJSON_GetObjectItemCaseSensitive((object), (key))\n"));
    };
  };
  if ((_IN(string, (tos3("-debug_alloc")), os__args))) {
    compiler__CGen_genln(cgen, tos3("#define DEBUG_ALLOC 1"));
  };
  if (v->pref->is_live && v->pref->os != v_dot_pref__v_dot_pref__OS_windows) {
    _PUSH(&cgen->includes,
          (/*typ = array_string   tmp_typ=string*/ tos3("#include <dlfcn.h>")),
          tmp12, string);
  };
  compiler__CGen_genln(cgen,
                       tos3("// this line will be replaced with definitions"));
  int defs_pos = cgen->lines.len - 1;
  if (defs_pos == -1) {
    defs_pos = 0;
  };
  cgen->nogen = q;
  array_string tmp13 = v->files;
  for (int i = 0; i < tmp13.len; i++) {
    string file = ((string *)tmp13.data)[i];

    compiler__V_parse(v, file, compiler__compiler__Pass_main);
  };
  compiler__Parser vgen_parser = compiler__V_new_parser_from_string(
      v, strings__Builder_str(&/* ? */ v->vgen_buf));
  strings__Builder_free(&/* ? */ v->vgen_buf);
  vgen_parser.is_vgen = 1;
  compiler__Parser_parse(&/* ? */ vgen_parser, compiler__compiler__Pass_main);
  if (v->pref->build_mode == v_dot_pref__v_dot_pref__BuildMode_build_module) {
    compiler__generate_vh(v->pref->path);
  };
  strings__Builder def = strings__new_builder(10000);
  strings__Builder_writeln(&/* ? */ def,
                           array_string_join_lines(cgen->const_defines));
#ifndef _VJS
  strings__Builder_writeln(&/* ? */ def,
                           array_string_join_lines(cgen->includes));
  strings__Builder_writeln(&/* ? */ def,
                           array_string_join_lines(cgen->typedefs));
  strings__Builder_writeln(&/* ? */ def,
                           compiler__V_type_definitions(&/* ? */ *v));
  if (!v->pref->is_bare) {
    strings__Builder_writeln(&/* ? */ def,
                             tos3("\nstring _STR(const char*, ...);\n"));
    strings__Builder_writeln(&/* ? */ def,
                             tos3("\nstring _STR_TMP(const char*, ...);\n"));
  };
  strings__Builder_writeln(&/* ? */ def, array_string_join_lines(cgen->fns));
  strings__Builder_writeln(&/* ? */ def,
                           compiler__V_interface_table(&/* ? */ *v));
#else
  strings__Builder_writeln(&/* ? */ def,
                           compiler__V_type_definitions(&/* ? */ *v));
#endif
  ;
  strings__Builder_writeln(&/* ? */ def, array_string_join_lines(cgen->consts));
  strings__Builder_writeln(&/* ? */ def,
                           array_string_join_lines(cgen->thread_args));
  if (v->pref->is_prof) {
    strings__Builder_writeln(&/* ? */ def, tos3("; // Prof counters:"));
    strings__Builder_writeln(&/* ? */ def,
                             compiler__V_prof_counters(&/* ? */ *v));
  };
  array_set(&/*q*/ cgen->lines, defs_pos,
            &(string[]){strings__Builder_str(&/* ? */ def)});
  compiler__V_generate_init(v);
  compiler__V_generate_main(v);
  compiler__V_generate_hot_reload_code(&/* ? */ *v);
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity,
          v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
    compiler__V_log(&/* ? */ *v, tos3("flags="));
    array_compiler__CFlag tmp14 = compiler__V_get_os_cflags(&/* ? */ *v);
    for (int tmp15 = 0; tmp15 < tmp14.len; tmp15++) {
      compiler__CFlag flag = ((compiler__CFlag *)tmp14.data)[tmp15];

      println(string_add(tos3(" * "), compiler__CFlag_format(&/* ? */ flag)));
    };
  };
#ifdef _VJS
#endif
  ;
  compiler__CGen_save(cgen);
  compiler__V_cc(v);
}
void compiler__V_compile2(compiler__V *v) {
  if (string_ne(os__user_os(), tos3("windows")) &&
      string_eq(v->pref->ccompiler, tos3("msvc"))) {
    compiler__verror(_STR("Cannot build with msvc on %.*s", os__user_os().len,
                          os__user_os().str));
  };
  println(tos3("compile2()"));
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity,
          v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
    println(tos3("all .v files before:"));
    println(array_string_str(v->files));
  };
  _PUSH_MANY(
      &v->files,
      (/*typ = array_string   tmp_typ=string*/ compiler__V_get_builtin_files(
          &/* ? */ *v)),
      tmp16, array_string);
  _PUSH_MANY(
      &v->files,
      (/*typ = array_string   tmp_typ=string*/ compiler__V_get_user_files(
          &/* ? */ *v)),
      tmp17, array_string);
  compiler__V_set_module_lookup_paths(v);
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity,
          v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
    println(tos3("all .v files:"));
    println(array_string_str(v->files));
  };
  v_dot_builder__Builder b = compiler__V_new_v2(&/* ? */ *v);
  v_dot_builder__Builder_build_c(&/* ? */ b, v->files, v->out_name_c);
  compiler__V_cc(v);
}
void compiler__V_compile_x64(compiler__V *v) {
#ifndef __linux__
  println(tos3("v -x64 can only generate Linux binaries for now"));
  println(string_add(tos3("You are not on a Linux system, so you will not "),
                     tos3("be able to run the resulting executable")));
#endif
  ;
  _PUSH(&v->files, (/*typ = array_string   tmp_typ=string*/ v->pref->path),
        tmp18, string);
  compiler__V_set_module_lookup_paths(v);
  v_dot_builder__Builder b = compiler__V_new_v2(&/* ? */ *v);
  v_dot_builder__Builder_build_x64(&/* ? */ b, v->files, v->pref->out_name);
}
v_dot_builder__Builder compiler__V_new_v2(compiler__V *v) {
  v_dot_builder__Builder b = v_dot_builder__new_builder(v->pref);
  b = (v_dot_builder__Builder){
      .os = v->pref->os,
      .module_path = compiler__v_modules_path,
      .compiled_dir = v->compiled_dir,
      .module_search_paths = v->module_lookup_paths,
      .pref = b.pref,
      .table = b.table,
      .checker = b.checker,
      .parsed_files = b.parsed_files,
  };
  return b;
}
void compiler__V_generate_init(compiler__V *v) {
#ifdef _VJS
#endif
  ;
  if (v->pref->build_mode == v_dot_pref__v_dot_pref__BuildMode_build_module) {
    bool nogen = v->cgen->nogen;
    v->cgen->nogen = 0;
    string consts_init_body = array_string_join_lines(v->cgen->consts_init);
    string init_fn_name =
        string_add(compiler__mod_gen_name(v->pref->mod), tos3("__init_consts"));
    compiler__CGen_genln(
        v->cgen, _STR("void %.*s();\nvoid %.*s() {\n%.*s\n}", init_fn_name.len,
                      init_fn_name.str, init_fn_name.len, init_fn_name.str,
                      consts_init_body.len, consts_init_body.str));
    v->cgen->nogen = nogen;
  };
  if (v->pref->build_mode == v_dot_pref__v_dot_pref__BuildMode_default_mode) {
    string call_mod_init = tos3("");
    string call_mod_init_consts = tos3("");
    if ((_IN(string, (tos3("builtin")), v->cached_mods))) {
      compiler__CGen_genln(v->cgen, tos3("void builtin__init_consts();"));
      call_mod_init_consts =
          string_add(call_mod_init_consts, tos3("builtin__init_consts();\n"));
    };
    array_string tmp19 = v->table->imports;
    for (int tmp20 = 0; tmp20 < tmp19.len; tmp20++) {
      string mod = ((string *)tmp19.data)[tmp20];

      string init_fn_name =
          string_add(compiler__mod_gen_name(mod), tos3("__init"));
      if (compiler__Table_known_fn(&/* ? */ *v->table, init_fn_name)) {
        call_mod_init =
            string_add(call_mod_init,
                       _STR("%.*s();\n", init_fn_name.len, init_fn_name.str));
      };
      if ((_IN(string, (mod), v->cached_mods))) {
        compiler__CGen_genln(v->cgen, _STR("void %.*s_consts();",
                                           init_fn_name.len, init_fn_name.str));
        call_mod_init_consts = string_add(
            call_mod_init_consts,
            _STR("%.*s_consts();\n", init_fn_name.len, init_fn_name.str));
      };
    };
    string consts_init_body = array_string_join_lines(v->cgen->consts_init);
    if (v->pref->is_bare) {
      compiler__CGen_genln(
          v->cgen, _STR("\n          void init() {\n                %.*s\n     "
                        "           %.*s\n                builtin__init();\n   "
                        "             %.*s\n          }\n      ",
                        call_mod_init_consts.len, call_mod_init_consts.str,
                        consts_init_body.len, consts_init_body.str,
                        call_mod_init.len, call_mod_init.str));
    };
    if (!v->pref->is_bare && !v->pref->is_so) {
      compiler__CGen_genln(
          v->cgen,
          _STR("void init() {\n#if VPREALLOC\ng_m2_buf = malloc(50 * 1000 * "
               "1000);\ng_m2_ptr = g_m2_buf;\nputs(\"allocated 50 "
               "mb\");\n#endif\n%.*s\n%.*s\nbuiltin__init();\n%.*s\n}",
               call_mod_init_consts.len, call_mod_init_consts.str,
               consts_init_body.len, consts_init_body.str, call_mod_init.len,
               call_mod_init.str));
      compiler__CGen_genln(
          v->cgen,
          tos3(
              "\nstring _STR(const char *fmt, ...) {\n	va_list "
              "argptr;\n	va_start(argptr, fmt);\n	size_t len = "
              "vsnprintf(0, 0, fmt, argptr) + 1;\n	"
              "va_end(argptr);\n	byte* buf = malloc(len);\n	"
              "va_start(argptr, fmt);\n	vsprintf((char *)buf, fmt, "
              "argptr);\n	va_end(argptr);\n#ifdef DEBUG_ALLOC\n	"
              "puts(\"_STR:\");\n	puts(buf);\n#endif\n	return "
              "tos2(buf);\n}\n\nstring _STR_TMP(const char *fmt, ...) "
              "{\n	va_list argptr;\n	va_start(argptr, "
              "fmt);\n	//size_t len = vsnprintf(0, 0, fmt, argptr) + "
              "1;\n	va_end(argptr);\n	va_start(argptr, "
              "fmt);\n	vsprintf((char *)g_str_buf, fmt, argptr);\n	"
              "va_end(argptr);\n#ifdef DEBUG_ALLOC\n	"
              "//puts(\"_STR_TMP:\");\n	//puts(g_str_buf);\n#endif\n	return "
              "tos2(g_str_buf);\n}\n\n"));
    };
  };
}
void compiler__V_generate_main(compiler__V *v) {
  compiler__CGen *cgen = v->cgen;
#ifdef _VJS
#endif
  ;
  if (v->pref->is_vlines) {
    int lines_so_far =
        string_count(array_string_join(cgen->lines, tos3("\n")), tos3("\n")) +
        5;
    compiler__CGen_genln(cgen, tos3(""));
    compiler__CGen_genln(cgen, tos3("// Reset the file/line numbers"));
    _PUSH(&cgen->lines,
          (/*typ = array_string   tmp_typ=string*/ _STR(
              "#line %d \"%.*s\"", lines_so_far,
              compiler__cescaped_path(os__realpath(cgen->out_path)).len,
              compiler__cescaped_path(os__realpath(cgen->out_path)).str)),
          tmp21, string);
    compiler__CGen_genln(cgen, tos3(""));
  };
  if (v->pref->build_mode != v_dot_pref__v_dot_pref__BuildMode_build_module) {
    if (!compiler__Table_main_exists(&/* ? */ *v->table) && !v->pref->is_test) {
      if ((v->pref->is_script &&
           string_ne(string_trim_space(cgen->fn_main), tos3(""))) ||
          v->pref->is_repl) {
        compiler__V_gen_main_start(v, 1);
        compiler__CGen_genln(
            cgen, _STR("%.*s;", cgen->fn_main.len, cgen->fn_main.str));
        compiler__V_gen_main_end(v, tos3("return 0"));
      } else if (string_eq(v->v_fmt_file, tos3("")) && !v->pref->is_repl &&
                 !v->pref->is_so) {
        compiler__verror(tos3("function `main` is not declared in the main "
                              "module\nPlease add: \nfn main(){\n}\n... to "
                              "your main program .v file, and try again."));
      };
    } else if (v->pref->is_test) {
      if (compiler__Table_main_exists(&/* ? */ *v->table)) {
        compiler__verror(tos3("test files cannot have function `main`"));
      };
      array_string test_fn_names =
          compiler__Table_all_test_function_names(&/* ? */ *v->table);
      if (test_fn_names.len == 0) {
        compiler__verror(
            tos3("test files need to have at least one test function"));
      };
      compiler__V_gen_main_start(v, 0);
      if (v->pref->is_stats) {
        compiler__CGen_genln(
            cgen,
            _STR("BenchedTests bt = main__start_testing(%d,tos3(\"%.*s\"));",
                 test_fn_names.len, v->pref->path.len, v->pref->path.str));
      };
      array_string tmp22 = test_fn_names;
      for (int tmp23 = 0; tmp23 < tmp22.len; tmp23++) {
        string tfname = ((string *)tmp22.data)[tmp23];

        if (v->pref->is_stats) {
          compiler__CGen_genln(
              cgen,
              _STR("BenchedTests_testing_step_start(&bt, tos3(\"%.*s\"));",
                   tfname.len, tfname.str));
        };
        compiler__CGen_genln(cgen, _STR("%.*s();", tfname.len, tfname.str));
        if (v->pref->is_stats) {
          compiler__CGen_genln(cgen,
                               tos3("BenchedTests_testing_step_end(&bt);"));
        };
      };
      if (v->pref->is_stats) {
        compiler__CGen_genln(cgen, tos3("BenchedTests_end_testing(&bt);"));
      };
      compiler__V_gen_main_end(v, tos3("return g_test_fails > 0"));
    } else if (compiler__Table_main_exists(&/* ? */ *v->table) &&
               !v->pref->is_so) {
      compiler__V_gen_main_start(v, 1);
      compiler__CGen_genln(cgen, tos3("  main__main();"));
      if (!v->pref->is_bare) {
        compiler__CGen_genln(cgen, tos3("#if VPREALLOC"));
        compiler__CGen_genln(cgen, tos3("free(g_m2_buf);"));
        compiler__CGen_genln(cgen, tos3("puts(\"freed mem buf\");"));
        compiler__CGen_genln(cgen, tos3("#endif"));
      };
      compiler__V_gen_main_end(v, tos3("return 0"));
    };
  };
}
void compiler__V_gen_main_start(compiler__V *v, bool add_os_args) {
  if (v->pref->os == v_dot_pref__v_dot_pref__OS_windows) {
    if ((_IN(string, (tos3("glfw")), v->table->imports))) {
      compiler__CGen_genln(
          v->cgen, tos3("int WINAPI wWinMain(HINSTANCE instance, HINSTANCE "
                        "prev_instance, LPWSTR cmd_line, int show_cmd) { "));
      compiler__CGen_genln(
          v->cgen,
          tos3(
              "    typedef LPWSTR*(WINAPI *cmd_line_to_argv)(LPCWSTR, int*);"));
      compiler__CGen_genln(
          v->cgen,
          tos3("    HMODULE shell32_module = LoadLibrary(L\"shell32.dll\");"));
      compiler__CGen_genln(v->cgen,
                           tos3("    cmd_line_to_argv CommandLineToArgvW = "
                                "(cmd_line_to_argv)GetProcAddress(shell32_"
                                "module, \"CommandLineToArgvW\");"));
      compiler__CGen_genln(v->cgen, tos3("    int argc;"));
      compiler__CGen_genln(
          v->cgen,
          tos3("    wchar_t** argv = CommandLineToArgvW(cmd_line, &argc);"));
    } else {
      compiler__CGen_genln(
          v->cgen,
          tos3("int wmain(int argc, wchar_t* argv[], wchar_t* envp[]) { "));
    };
  } else {
    compiler__CGen_genln(v->cgen, tos3("int main(int argc, char** argv) { "));
  };
  compiler__CGen_genln(v->cgen, tos3("  init();"));
  if (add_os_args && (_IN(string, (tos3("os")), v->table->imports))) {
    if (v->pref->os == v_dot_pref__v_dot_pref__OS_windows) {
      compiler__CGen_genln(
          v->cgen, tos3("  os__args = os__init_os_args_wide(argc, argv);"));
    } else {
      compiler__CGen_genln(
          v->cgen,
          tos3("  os__args = os__init_os_args(argc, (byteptr*)argv);"));
    };
  };
  compiler__V_generate_hotcode_reloading_main_caller(&/* ? */ *v);
  compiler__CGen_genln(v->cgen, tos3(""));
}
void compiler__V_gen_main_end(compiler__V *v, string return_statement) {
  compiler__CGen_genln(v->cgen, tos3(""));
  compiler__CGen_genln(
      v->cgen, _STR("  %.*s;", return_statement.len, return_statement.str));
  compiler__CGen_genln(v->cgen, tos3("}"));
}
array_string compiler__V_v_files_from_dir(compiler__V *v, string dir) {
  array_string res = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  if (!os__exists(dir)) {
    if (string_eq(dir, tos3("compiler")) && os__is_dir(tos3("vlib"))) {
      println(tos3("looks like you are trying to build V with an old command"));
      println(tos3("use `v -o v cmd/v` instead of `v -o v compiler`"));
    };
    compiler__verror(_STR("%.*s doesn't exist", dir.len, dir.str));
  } else if (!os__is_dir(dir)) {
    compiler__verror(_STR("%.*s isn't a directory", dir.len, dir.str));
  };
  Option_array_string tmp24 = os__ls(dir);
  array_string files;
  if (!tmp24.ok) {
    string err = tmp24.error;
    int errcode = tmp24.ecode;
    v_panic(err);
  }
  files = *(array_string *)tmp24.data;
  ;
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity,
          v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
    printf("v_files_from_dir (\"%.*s\")\n", dir.len, dir.str);
  };
  array_string_sort(&/* ? */ files);
  array_string tmp25 = files;
  for (int tmp26 = 0; tmp26 < tmp25.len; tmp26++) {
    string file = ((string *)tmp25.data)[tmp26];

    if (!string_ends_with(file, tos3(".v")) &&
        !string_ends_with(file, tos3(".vh"))) {
      continue;
    };
    if (string_ends_with(file, tos3("_test.v"))) {
      continue;
    };
    if ((string_ends_with(file, tos3("_win.v")) ||
         string_ends_with(file, tos3("_windows.v"))) &&
        v->pref->os != v_dot_pref__v_dot_pref__OS_windows) {
      continue;
    };
    if ((string_ends_with(file, tos3("_lin.v")) ||
         string_ends_with(file, tos3("_linux.v"))) &&
        v->pref->os != v_dot_pref__v_dot_pref__OS_linux) {
      continue;
    };
    if ((string_ends_with(file, tos3("_mac.v")) ||
         string_ends_with(file, tos3("_darwin.v"))) &&
        v->pref->os != v_dot_pref__v_dot_pref__OS_mac) {
      continue;
    };
    if (string_ends_with(file, tos3("_nix.v")) &&
        v->pref->os == v_dot_pref__v_dot_pref__OS_windows) {
      continue;
    };
    if (string_ends_with(file, tos3("_js.v")) &&
        v->pref->os != v_dot_pref__v_dot_pref__OS_js) {
      continue;
    };
    if (string_ends_with(file, tos3("_c.v")) &&
        v->pref->os == v_dot_pref__v_dot_pref__OS_js) {
      continue;
    };
    if (v->pref->compile_defines_all.len > 0 &&
        string_contains(file, tos3("_d_"))) {
      bool allowed = 0;
      array_string tmp27 = v->pref->compile_defines;
      for (int tmp28 = 0; tmp28 < tmp27.len; tmp28++) {
        string cdefine = ((string *)tmp27.data)[tmp28];

        string file_postfix = _STR("_d_%.*s.v", cdefine.len, cdefine.str);
        if (string_ends_with(file, file_postfix)) {
          allowed = 1;
          break;
        };
      };
      if (!allowed) {
        continue;
      };
    };
    _PUSH(&res,
          (/*typ = array_string   tmp_typ=string*/ os__join_path(
              dir, &(varg_string){.len = 1, .args = {file}})),
          tmp29, string);
  };
  return res;
}
void compiler__V_add_v_files_to_compile(compiler__V *v) {
  compiler__V_set_module_lookup_paths(v);
  array_string builtin_files = compiler__V_get_builtin_files(&/* ? */ *v);
  if (v->pref->is_bare) {
  };
  if (v->pref->is_cache) {
    string builtin_vh = os__join_path(
        compiler__v_modules_path,
        &(varg_string){.len = 2, .args = {tos3("vlib"), tos3("builtin.vh")}});
    if (os__exists(builtin_vh)) {
      _PUSH(&v->cached_mods,
            (/*typ = array_string   tmp_typ=string*/ tos3("builtin")), tmp30,
            string);
      builtin_files = new_array_from_c_array(
          1, 1, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 1){builtin_vh});
    };
  };
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
    string tmp31 = array_string_str(builtin_files);

    compiler__V_log(&/* ? */ *v,
                    _STR("v.add_v_files_to_compile > builtin_files: %.*s ",
                         tmp31.len, tmp31.str));
  };
  array_string tmp32 = builtin_files;
  for (int tmp33 = 0; tmp33 < tmp32.len; tmp33++) {
    string file = ((string *)tmp32.data)[tmp33];

    _PUSH(&v->files, (/*typ = array_string   tmp_typ=string*/ file), tmp34,
          string);
    compiler__Parser p = compiler__V_new_parser_from_file(v, file);
    compiler__Parser_parse(&/* ? */ p, compiler__compiler__Pass_imports);
    compiler__V_add_parser(v, p);
  };
  array_string tmp35 = compiler__V_get_user_files(&/* ? */ *v);
  for (int tmp36 = 0; tmp36 < tmp35.len; tmp36++) {
    string file = ((string *)tmp35.data)[tmp36];

    compiler__Parser p = compiler__V_new_parser_from_file(v, file);
    compiler__Parser_parse(&/* ? */ p, compiler__compiler__Pass_imports);
    if (p.v_script) {
      compiler__V_log(&/* ? */ *v, tos3("imports0:"));
      println(array_string_str(v->table->imports));
      println(array_string_str(v->files));
      compiler__Parser_register_import(&/* ? */ p, tos3("os"), 0);
      _PUSH(&p.table->imports,
            (/*typ = array_string   tmp_typ=string*/ tos3("os")), tmp37,
            string);
      compiler__Table_register_module(p.table, tos3("os"));
    };
    compiler__V_add_parser(v, p);
  };
  compiler__V_parse_lib_imports(v);
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity,
          v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
    compiler__V_log(&/* ? */ *v, tos3("imports:"));
    println(array_string_str(v->table->imports));
  };
  array_string imported_mods = compiler__DepGraph_imports(
      &/* ? */ *compiler__V_resolve_deps(&/* ? */ *v));
  array_string tmp38 = imported_mods;
  for (int tmp39 = 0; tmp39 < tmp38.len; tmp39++) {
    string mod = ((string *)tmp38.data)[tmp39];

    if (string_eq(mod, tos3("builtin")) || string_eq(mod, tos3("main"))) {
      continue;
    };
    array_string vfiles =
        compiler__V_get_imported_module_files(&/* ? */ *v, mod);
    array_string tmp40 = vfiles;
    for (int tmp41 = 0; tmp41 < tmp40.len; tmp41++) {
      string file = ((string *)tmp40.data)[tmp41];

      _PUSH(&v->files, (/*typ = array_string   tmp_typ=string*/ file), tmp42,
            string);
    };
  };
  array_compiler__Parser tmp43 = v->parsers;
  for (int tmp44 = 0; tmp44 < tmp43.len; tmp44++) {
    compiler__Parser p = ((compiler__Parser *)tmp43.data)[tmp44];

    if (string_ne(p.mod, tos3("main"))) {
      continue;
    };
    if (p.is_vgen) {
      continue;
    };
    _PUSH(&v->files, (/*typ = array_string   tmp_typ=string*/ p.file_path),
          tmp45, string);
  };
}
array_string compiler__V_get_builtin_files(compiler__V *v) {
  array_string tmp46 = v->pref->lookup_path;
  for (int tmp47 = 0; tmp47 < tmp46.len; tmp47++) {
    string location = ((string *)tmp46.data)[tmp47];

    if (!os__exists(os__join_path(
            location, &(varg_string){.len = 1, .args = {tos3("builtin")}}))) {
      continue;
    };
    if (v->pref->is_bare) {
      return compiler__V_v_files_from_dir(
          &/* ? */ *v,
          os__join_path(location, &(varg_string){.len = 2,
                                                 .args = {tos3("builtin"),
                                                          tos3("bare")}}));
    };
#ifdef _VJS
#endif
    ;
    return compiler__V_v_files_from_dir(
        &/* ? */ *v,
        os__join_path(location,
                      &(varg_string){.len = 1, .args = {tos3("builtin")}}));
  };
  compiler__verror(
      tos3("`builtin/` not included on module lookup path.\nDid you forget to "
           "add vlib to the path? (Use @vlib for default vlib)"));
  v_panic(tos3("Unreachable code reached."));
}
array_string compiler__V_get_user_files(compiler__V *v) {
  string dir = v->pref->path;
  compiler__V_log(&/* ? */ *v, _STR("get_v_files(%.*s)", dir.len, dir.str));
  array_string user_files = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  string vroot = os__dir(v_dot_pref__vexe_path());
  string preludes_path = os__join_path(
      vroot,
      &(varg_string){.len = 3,
                     .args = {tos3("cmd"), tos3("tools"), tos3("preludes")}});
  if (v->pref->is_live) {
    _PUSH(&user_files,
          (/*typ = array_string   tmp_typ=string*/ os__join_path(
              preludes_path,
              &(varg_string){.len = 1, .args = {tos3("live_main.v")}})),
          tmp48, string);
  };
  if (v->pref->is_solive) {
    _PUSH(&user_files,
          (/*typ = array_string   tmp_typ=string*/ os__join_path(
              preludes_path,
              &(varg_string){.len = 1, .args = {tos3("live_shared.v")}})),
          tmp49, string);
  };
  if (v->pref->is_test) {
    _PUSH(&user_files,
          (/*typ = array_string   tmp_typ=string*/ os__join_path(
              preludes_path,
              &(varg_string){.len = 1, .args = {tos3("tests_assertions.v")}})),
          tmp50, string);
  };
  if (v->pref->is_test && v->pref->is_stats) {
    _PUSH(&user_files,
          (/*typ = array_string   tmp_typ=string*/ os__join_path(
              preludes_path,
              &(varg_string){.len = 1, .args = {tos3("tests_with_stats.v")}})),
          tmp51, string);
  };
  bool is_test = string_ends_with(dir, tos3("_test.v"));
  bool is_internal_module_test = 0;
  if (is_test) {
    Option_string tmp52 = os__read_file(dir);
    string tcontent;
    if (!tmp52.ok) {
      string err = tmp52.error;
      int errcode = tmp52.ecode;
      v_panic(_STR("%.*s does not exist", dir.len, dir.str));
    }
    tcontent = *(string *)tmp52.data;
    ;
    if (string_contains(tcontent, tos3("module ")) &&
        !string_contains(tcontent, tos3("module main"))) {
      is_internal_module_test = 1;
    };
  };
  if (is_internal_module_test) {
    string single_test_v_file = os__realpath(dir);
    if (v_dot_pref__VerboseLevel_is_higher_or_equal(
            v->pref->verbosity,
            v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
      compiler__V_log(&/* ? */ *v,
                      _STR("> Compiling an internal module _test.v file %.*s .",
                           single_test_v_file.len, single_test_v_file.str));
      compiler__V_log(&/* ? */ *v, tos3("> That brings in all other ordinary "
                                        ".v files in the same module too ."));
    };
    _PUSH(&user_files,
          (/*typ = array_string   tmp_typ=string*/ single_test_v_file), tmp53,
          string);
    dir = os__base_dir(single_test_v_file);
  };
  if (string_ends_with(dir, tos3(".v")) ||
      string_ends_with(dir, tos3(".vsh"))) {
    string single_v_file = dir;
    _PUSH(&user_files, (/*typ = array_string   tmp_typ=string*/ single_v_file),
          tmp54, string);
    if (v_dot_pref__VerboseLevel_is_higher_or_equal(
            v->pref->verbosity,
            v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
      compiler__V_log(&/* ? */ *v, _STR("> just compile one file: \"%.*s\"",
                                        single_v_file.len, single_v_file.str));
    };
  } else {
    if (v_dot_pref__VerboseLevel_is_higher_or_equal(
            v->pref->verbosity,
            v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
      compiler__V_log(&/* ? */ *v,
                      _STR("> add all .v files from directory \"%.*s\" ...",
                           dir.len, dir.str));
    };
    array_string files = compiler__V_v_files_from_dir(&/* ? */ *v, dir);
    array_string tmp55 = files;
    for (int tmp56 = 0; tmp56 < tmp55.len; tmp56++) {
      string file = ((string *)tmp55.data)[tmp56];

      _PUSH(&user_files, (/*typ = array_string   tmp_typ=string*/ file), tmp57,
            string);
    };
  };
  if (user_files.len == 0) {
    println(tos3("No input .v files"));
    v_exit(1);
  };
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
    string tmp58 = array_string_str(user_files);

    compiler__V_log(&/* ? */ *v,
                    _STR("user_files: %.*s ", tmp58.len, tmp58.str));
  };
  return user_files;
}
array_string compiler__V_get_imported_module_files(compiler__V *v, string mod) {
  array_string files = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_compiler__Parser tmp59 = v->parsers;
  for (int tmp60 = 0; tmp60 < tmp59.len; tmp60++) {
    compiler__Parser p = ((compiler__Parser *)tmp59.data)[tmp60];

    if (string_eq(p.mod, mod)) {
      _PUSH(&files, (/*typ = array_string   tmp_typ=string*/ p.file_path),
            tmp61, string);
    };
  };
  return files;
}
void compiler__V_parse_lib_imports(compiler__V *v) {
  array_string done_imports = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  int tmp62 = 0;
  ;
  for (int tmp63 = tmp62; tmp63 < v->parsers.len; tmp63++) {
    int i = tmp63;

    map_string tmp64 =
        (*(compiler__Parser *)array_get(v->parsers, i)).import_table.imports;
    array_string keys_tmp64 = map_keys(&tmp64);
    for (int l = 0; l < keys_tmp64.len; l++) {
      string _ = ((string *)keys_tmp64.data)[l];
      string mod = tos3("");
      map_get(tmp64, _, &mod);

      if ((_IN(string, (mod), done_imports))) {
        continue;
      };
      Option_string tmp69 = compiler__Parser_find_module_path(
          &/* ? */ (*(compiler__Parser *)array_get(v->parsers, i)), mod);
      string import_path;
      if (!tmp69.ok) {
        string err = tmp69.error;
        int errcode = tmp69.ecode;
        compiler__Parser_error_with_token_index(
            &/* ? */ (*(compiler__Parser *)array_get(v->parsers, i)),
            _STR("cannot import module \"%.*s\" (not found)\n%.*s", mod.len,
                 mod.str, err.len, err.str),
            compiler__ImportTable_get_import_tok_idx(
                &/* ? */ (*(compiler__Parser *)array_get(v->parsers, i))
                     .import_table,
                mod));
        break;
      }
      import_path = *(string *)tmp69.data;
      ;
      array_string vfiles =
          compiler__V_v_files_from_dir(&/* ? */ *v, import_path);
      if (vfiles.len == 0) {
        compiler__Parser_error_with_token_index(
            &/* ? */ (*(compiler__Parser *)array_get(v->parsers, i)),
            _STR("cannot import module \"%.*s\" (no .v files in \"%.*s\")",
                 mod.len, mod.str, import_path.len, import_path.str),
            compiler__ImportTable_get_import_tok_idx(
                &/* ? */ (*(compiler__Parser *)array_get(v->parsers, i))
                     .import_table,
                mod));
      };
      array_string tmp78 = vfiles;
      for (int tmp79 = 0; tmp79 < tmp78.len; tmp79++) {
        string file = ((string *)tmp78.data)[tmp79];

        int pidx = compiler__V_parse(v, file, compiler__compiler__Pass_imports);
        string p_mod = (*(compiler__Parser *)array_get(v->parsers, pidx)).mod;
        if (string_ne(p_mod, mod)) {
          compiler__Parser_error_with_token_index(
              &/* ? */ (*(compiler__Parser *)array_get(v->parsers, pidx)),
              _STR("bad module definition: %.*s imports module \"%.*s\" but "
                   "%.*s is defined as module `%.*s`",
                   (*(compiler__Parser *)array_get(v->parsers, pidx))
                       .file_path.len,
                   (*(compiler__Parser *)array_get(v->parsers, pidx))
                       .file_path.str,
                   mod.len, mod.str, file.len, file.str, p_mod.len, p_mod.str),
              0);
        };
      };
      _PUSH(&done_imports, (/*typ = array_string   tmp_typ=string*/ mod), tmp86,
            string);
    };
  };
}
void compiler__V_log(compiler__V *v, string s) {
  if (!v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {

    return;
  };
  println(s);
}
void compiler__verror(string s) {
  printf("V error: %.*s\n", s.len, s.str);
  os__flush();
  v_exit(1);
}
string compiler__vhash() {
  byte buf[50] = {0};
  buf[0] /*rbyte 1*/ = 0;
  snprintf(((charptr)(buf)), 50, "%s", V_COMMIT_HASH);
  return tos_clone(buf);
}
string compiler__cescaped_path(string s) {
  return string_replace(s, tos3("\\"), tos3("\\\\"));
}
v_dot_pref__OS compiler__os_from_string(string os) {
  string tmp87 = os;

  if (string_eq(tmp87, tos3("linux"))) {
    return v_dot_pref__v_dot_pref__OS_linux;
  } else if (string_eq(tmp87, tos3("windows"))) {
    return v_dot_pref__v_dot_pref__OS_windows;
  } else if (string_eq(tmp87, tos3("mac"))) {
    return v_dot_pref__v_dot_pref__OS_mac;
  } else if (string_eq(tmp87, tos3("macos"))) {
    return v_dot_pref__v_dot_pref__OS_mac;
  } else if (string_eq(tmp87, tos3("freebsd"))) {
    return v_dot_pref__v_dot_pref__OS_freebsd;
  } else if (string_eq(tmp87, tos3("openbsd"))) {
    return v_dot_pref__v_dot_pref__OS_openbsd;
  } else if (string_eq(tmp87, tos3("netbsd"))) {
    return v_dot_pref__v_dot_pref__OS_netbsd;
  } else if (string_eq(tmp87, tos3("dragonfly"))) {
    return v_dot_pref__v_dot_pref__OS_dragonfly;
  } else if (string_eq(tmp87, tos3("js"))) {
    return v_dot_pref__v_dot_pref__OS_js;
  } else if (string_eq(tmp87, tos3("solaris"))) {
    return v_dot_pref__v_dot_pref__OS_solaris;
  } else if (string_eq(tmp87, tos3("android"))) {
    return v_dot_pref__v_dot_pref__OS_android;
  } else if (string_eq(tmp87, tos3("msvc"))) {
    compiler__verror(tos3("use the flag `-cc msvc` to build using msvc"));
  } else if (string_eq(tmp87, tos3("haiku"))) {
    return v_dot_pref__v_dot_pref__OS_haiku;
  } else if (string_eq(tmp87, tos3("linux_or_macos"))) {
    return v_dot_pref__v_dot_pref__OS_linux;
  } else // default:
  {
    v_panic(_STR("bad os %.*s", os.len, os.str));
  };
  return v_dot_pref__v_dot_pref__OS_linux;
}
void compiler__set_vroot_folder(string vroot_path) {
  string vname = ((string_eq(os__user_os(), tos3("windows"))) ? (tos3("v.exe"))
                                                              : (tos3("v")));
  os__setenv(tos3("VEXE"),
             os__realpath(array_string_join(
                 new_array_from_c_array(
                     2, 2, sizeof(string),
                     EMPTY_ARRAY_OF_ELEMS(string, 2){vroot_path, vname}),
                 os__path_separator)),
             1);
}
void compiler__generate_vh(string mod) {
  printf("\n\n\n\nGenerating a V header file for module `%.*s`\n", mod.len,
         mod.str);
  string vexe = v_dot_pref__vexe_path();
  string full_mod_path =
      os__join_path(os__dir(vexe), &(varg_string){.len = 1, .args = {mod}});
  string dir =
      ((string_starts_with(mod, tos3("vlib")))
           ? (_STR("%.*s%.*s%.*s", compiler__v_modules_path.len,
                   compiler__v_modules_path.str, os__path_separator.len,
                   os__path_separator.str, mod.len, mod.str))
           : (mod));
  string path = string_add(dir, tos3(".vh"));
  string pdir = string_all_before_last(dir, os__path_separator);
  if (!os__is_dir(pdir)) {
    os__mkdir_all(pdir);
  };
  Option_os__File tmp1 = os__create(path);
  os__File out;
  if (!tmp1.ok) {
    string err = tmp1.error;
    int errcode = tmp1.ecode;
    v_panic(err);
  }
  out = *(os__File *)tmp1.data;
  ;
  string mod_path = string_replace(mod, tos3("\\"), tos3("/"));
  os__File_writeln(&/* ? */ out,
                   _STR("// %.*s module header\n", mod_path.len, mod_path.str));
  string mod_def = ((string_contains(mod_path, tos3("/")))
                        ? (string_all_after(mod_path, tos3("/")))
                        : (mod_path));
  os__File_writeln(&/* ? */ out,
                   _STR("module %.*s\n", mod_def.len, mod_def.str));
  println(full_mod_path);
  array_string vfiles = os__walk_ext(full_mod_path, tos3(".v"));

  array_string tmp2 = new_array(0, vfiles.len, sizeof(string));
  for (int i = 0; i < vfiles.len; i++) {
    string it = ((string *)vfiles.data)[i];
    if (string_ends_with(it, tos3(".v")) &&
        !string_ends_with(it, tos3("test.v")) &&
        !string_ends_with(it, tos3("_windows.v")) &&
        !string_ends_with(it, tos3("_win.v")) &&
        !string_ends_with(it, tos3("_lin.v")) &&
        !string_contains(it, _STR("%.*sexamples", os__path_separator.len,
                                  os__path_separator.str)) &&
        !string_contains(it, tos3("_js.v")) &&
        !string_contains(it, tos3("_bare.v")) &&
        !string_contains(
            it, _STR("%.*sjs", os__path_separator.len, os__path_separator.str)))
      array_push(&tmp2, &it);
  }
  array_string filtered = tmp2;
  v_dot_pref__Preferences *pref = (v_dot_pref__Preferences *)memdup(
      &(v_dot_pref__Preferences){
          .path = tos3("foo.v"),
          .is_test = 0,
          .is_script = 0,
          .is_live = 0,
          .is_solive = 0,
          .is_so = 0,
          .is_prof = 0,
          .translated = 0,
          .is_prod = 0,
          .obfuscate = 0,
          .is_repl = 0,
          .is_run = 0,
          .sanitize = 0,
          .is_debug = 0,
          .is_vlines = 0,
          .is_keep_c = 0,
          .is_pretty_c = 0,
          .is_cache = 0,
          .is_stats = 0,
          .no_auto_free = 0,
          .cflags = tos3(""),
          .ccompiler = tos3(""),
          .third_party_option = tos3(""),
          .building_v = 0,
          .autofree = 0,
          .compress = 0,
          .fast = 0,
          .enable_globals = 0,
          .is_bare = 0,
          .lookup_path = new_array(0, 1, sizeof(string)),
          .output_cross_c = 0,
          .prealloc = 0,
          .vroot = tos3(""),
          .out_name = tos3(""),
          .compile_defines = new_array(0, 1, sizeof(string)),
          .compile_defines_all = new_array(0, 1, sizeof(string)),
          .mod = tos3("")},
      sizeof(v_dot_pref__Preferences));
  v_dot_pref__Preferences_fill_with_defaults(pref);
  compiler__V *v = compiler__new_v(pref);
  compiler__VhGen g =
      (compiler__VhGen){.consts = strings__new_builder(1000),
                        .fns = strings__new_builder(1000),
                        .types = strings__new_builder(1000),
                        .i = 0,
                        .tokens = new_array(0, 1, sizeof(compiler__Token))};
  array_string tmp3 = filtered;
  for (int tmp4 = 0; tmp4 < tmp3.len; tmp4++) {
    string file = ((string *)tmp3.data)[tmp4];

    compiler__Parser p = compiler__V_new_parser_from_file(v, file);
    p.scanner->is_vh = 1;
    compiler__Parser_parse(&/* ? */ p, compiler__compiler__Pass_decl);
    g.tokens = p.tokens;
    g.i = 0;
    for (; g.i < p.tokens.len; g.i++) {

      if (!compiler__TokenKind_is_decl(
              (*(compiler__Token *)array_get(p.tokens, g.i)).tok)) {
        continue;
      };
      compiler__TokenKind tmp9 =
          (*(compiler__Token *)array_get(g.tokens, g.i)).tok;

      if (tmp9 == compiler__compiler__TokenKind_key_fn) {
        compiler__VhGen_generate_fn(&/* ? */ g);
      } else if (tmp9 == compiler__compiler__TokenKind_key_const) {
        compiler__VhGen_generate_const(&/* ? */ g);
      } else if (tmp9 == compiler__compiler__TokenKind_key_struct) {
        compiler__VhGen_generate_type(&/* ? */ g);
      } else if (tmp9 == compiler__compiler__TokenKind_key_type) {
        compiler__VhGen_generate_alias(&/* ? */ g);
      } else // default:
      {
      };
    };
  };
  string result = string_add(
      string_add(strings__Builder_str(&/* ? */ g.types),
                 strings__Builder_str(&/* ? */ g.consts)),
      string_replace(string_replace(strings__Builder_str(&/* ? */ g.fns),
                                    tos3("\n\n\n"), tos3("\n")),
                     tos3("\n\n"), tos3("\n")));
  os__File_writeln(
      &/* ? */ out,
      string_replace(string_replace(result, tos3("[ ] "), tos3("[]")),
                     tos3("? "), tos3("?")));
  os__File_close(&/* ? */ out);
}
void compiler__VhGen_generate_fn(compiler__VhGen *g) {
  if (g->i >= g->tokens.len - 2) {

    return;
  };
  compiler__Token next = (*(compiler__Token *)array_get(g->tokens, g->i + 1));
  if (g->i > 0 && (*(compiler__Token *)array_get(g->tokens, g->i - 1)).tok !=
                      compiler__compiler__TokenKind_key_pub) {
  };
  if (next.tok == compiler__compiler__TokenKind_name &&
      string_eq(next.lit, tos3("C"))) {

    return;
  };
  compiler__Token tok = (*(compiler__Token *)array_get(g->tokens, g->i));
  while (g->i < g->tokens.len - 1 &&
         tok.tok != compiler__compiler__TokenKind_lcbr) {

    next = (*(compiler__Token *)array_get(g->tokens, g->i + 1));
    strings__Builder_write(&/* ? */ g->fns, compiler__Token_str(tok));
    if (tok.tok != compiler__compiler__TokenKind_lpar &&
        !((next.tok == compiler__compiler__TokenKind_comma ||
           next.tok == compiler__compiler__TokenKind_rpar))) {
      strings__Builder_write(&/* ? */ g->fns, tos3(" "));
    };
    g->i++;
    tok = (*(compiler__Token *)array_get(g->tokens, g->i));
  };
  strings__Builder_writeln(&/* ? */ g->fns, tos3(""));
}
void compiler__VhGen_generate_alias(compiler__VhGen *g) {
  compiler__Token tok = (*(compiler__Token *)array_get(g->tokens, g->i));
  while (g->i < g->tokens.len - 1) {

    strings__Builder_write(&/* ? */ g->types, compiler__Token_str(tok));
    strings__Builder_write(&/* ? */ g->types, tos3(" "));
    if (tok.line_nr !=
        (*(compiler__Token *)array_get(g->tokens, g->i + 1)).line_nr) {
      break;
    };
    g->i++;
    tok = (*(compiler__Token *)array_get(g->tokens, g->i));
  };
  strings__Builder_writeln(&/* ? */ g->types, tos3("\n"));
}
void compiler__VhGen_generate_const(compiler__VhGen *g) {
  compiler__Token tok = (*(compiler__Token *)array_get(g->tokens, g->i));
  while (g->i < g->tokens.len &&
         tok.tok != compiler__compiler__TokenKind_rpar) {

    strings__Builder_write(&/* ? */ g->consts, compiler__Token_str(tok));
    strings__Builder_write(&/* ? */ g->consts, tos3(" "));
    if ((*(compiler__Token *)array_get(g->tokens, g->i + 2)).tok ==
        compiler__compiler__TokenKind_assign) {
      strings__Builder_write(&/* ? */ g->consts, tos3("\n\t"));
    };
    g->i++;
    tok = (*(compiler__Token *)array_get(g->tokens, g->i));
  };
  strings__Builder_writeln(&/* ? */ g->consts, tos3("\n)"));
}
void compiler__VhGen_generate_type(compiler__VhGen *g) {
  compiler__Token tok = (*(compiler__Token *)array_get(g->tokens, g->i));
  while (g->i < g->tokens.len &&
         tok.tok != compiler__compiler__TokenKind_rcbr) {

    strings__Builder_write(&/* ? */ g->types, compiler__Token_str(tok));
    strings__Builder_write(&/* ? */ g->types, tos3(" "));
    if ((*(compiler__Token *)array_get(g->tokens, g->i + 1)).line_nr !=
        (*(compiler__Token *)array_get(g->tokens, g->i)).line_nr) {
      strings__Builder_write(&/* ? */ g->types, tos3("\n\t"));
    };
    g->i++;
    tok = (*(compiler__Token *)array_get(g->tokens, g->i));
  };
  strings__Builder_writeln(&/* ? */ g->types, tos3("\n}"));
}
string compiler__Table_qualify_module(compiler__Table *table, string mod,
                                      string file_path) {
  array_string tmp1 = table->imports;
  for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
    string m = ((string *)tmp1.data)[tmp2];

    if (string_contains(m, tos3(".")) && string_contains(m, mod)) {
      array_string m_parts = string_split(m, tos3("."));
      string m_path = array_string_join(m_parts, os__path_separator);
      if (string_eq(mod, (*(string *)array_get(m_parts, m_parts.len - 1))) &&
          string_contains(file_path, m_path)) {
        return m;
      };
    };
  };
  return mod;
}
compiler__ImportTable compiler__new_import_table() {
  return (compiler__ImportTable){.imports = new_map(1, sizeof(string)),
                                 .used_imports =
                                     new_array(0, 1, sizeof(string)),
                                 .import_tok_idx = new_map(1, sizeof(int))};
}
void compiler__Parser_register_import(compiler__Parser *p, string mod,
                                      int tok_idx) {
  compiler__Parser_register_import_alias(p, mod, mod, tok_idx);
}
void compiler__Parser_register_import_alias(compiler__Parser *p, string alias,
                                            string mod, int tok_idx) {
  string tmp5 = tos3("");
  bool tmp6 = map_get(/*modules.v : 48*/ p->import_table.imports, alias, &tmp5);

  if (!tmp6)
    tmp5 = tos((byte *)"", 0);

  if ((_IN_MAP((alias), p->import_table.imports)) && string_ne(tmp5, mod)) {
    compiler__Parser_error(
        p, _STR("cannot import %.*s as %.*s: import name %.*s already in use",
                mod.len, mod.str, alias.len, alias.str, alias.len, alias.str));
  };
  if (string_contains(mod, tos3(".internal.")) && !p->is_vgen) {
    array_string mod_parts = string_split(mod, tos3("."));
    array_string internal_mod_parts = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    array_string tmp7 = mod_parts;
    for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
      string part = ((string *)tmp7.data)[tmp8];

      if (string_eq(part, tos3("internal"))) {
        break;
      };
      _PUSH(&internal_mod_parts, (/*typ = array_string   tmp_typ=string*/ part),
            tmp9, string);
    };
    string internal_parent = array_string_join(internal_mod_parts, tos3("."));
    if (!string_starts_with(p->mod, internal_parent)) {
      compiler__Parser_error(
          p, _STR("module %.*s can only be imported internally by libs",
                  mod.len, mod.str));
    };
  };
  map_set(&p->import_table.imports, alias, &(string[]){mod});
  map_set(&p->import_table.import_tok_idx, mod, &(int[]){tok_idx});
}
int compiler__ImportTable_get_import_tok_idx(compiler__ImportTable *it,
                                             string mod) {
  int tmp10 = 0;
  bool tmp11 = map_get(/*modules.v : 71*/ it->import_tok_idx, mod, &tmp10);

  return tmp10;
}
bool compiler__ImportTable_known_import(compiler__ImportTable *it, string mod) {
  return (_IN_MAP((mod), it->imports)) ||
         compiler__ImportTable_is_aliased(&/* ? */ *it, mod);
}
bool compiler__ImportTable_known_alias(compiler__ImportTable *it,
                                       string alias) {
  return (_IN_MAP((alias), it->imports));
}
bool compiler__ImportTable_is_aliased(compiler__ImportTable *it, string mod) {
  map_string tmp12 = it->imports;
  array_string keys_tmp12 = map_keys(&tmp12);
  for (int l = 0; l < keys_tmp12.len; l++) {
    string _ = ((string *)keys_tmp12.data)[l];
    string val = tos3("");
    map_get(tmp12, _, &val);

    if (string_eq(val, mod)) {
      return 1;
    };
  };
  return 0;
}
string compiler__ImportTable_resolve_alias(compiler__ImportTable *it,
                                           string alias) {
  string tmp13 = tos3("");
  bool tmp14 = map_get(/*modules.v : 92*/ it->imports, alias, &tmp13);

  if (!tmp14)
    tmp13 = tos((byte *)"", 0);

  return tmp13;
}
void compiler__ImportTable_register_used_import(compiler__ImportTable *it,
                                                string alias) {
  if (!((_IN(string, (alias), it->used_imports)))) {
    _PUSH(&it->used_imports, (/*typ = array_string   tmp_typ=string*/ alias),
          tmp15, string);
  };
}
bool compiler__ImportTable_is_used_import(compiler__ImportTable *it,
                                          string alias) {
  return (_IN(string, (alias), it->used_imports));
}
bool compiler__Parser_is_mod_in_scope(compiler__Parser *p, string mod) {
  array_string mods_in_scope = new_array_from_c_array(
      4, 4, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 4){tos3(""), tos3("builtin"), tos3("main"),
                                      p->mod});
  map_string tmp16 = p->import_table.imports;
  array_string keys_tmp16 = map_keys(&tmp16);
  for (int l = 0; l < keys_tmp16.len; l++) {
    string _ = ((string *)keys_tmp16.data)[l];
    string m = tos3("");
    map_get(tmp16, _, &m);

    _PUSH(&mods_in_scope, (/*typ = array_string   tmp_typ=string*/ m), tmp17,
          string);
  };
  return (_IN(string, (mod), mods_in_scope));
}
compiler__DepGraph *compiler__V_resolve_deps(compiler__V *v) {
  compiler__DepGraph *graph = compiler__V_import_graph(&/* ? */ *v);
  compiler__DepGraph *deps_resolved =
      compiler__DepGraph_resolve(&/* ? */ *graph);
  if (!deps_resolved->acyclic) {
    compiler__verror(string_add(
        tos3("import cycle detected between the following modules: \n"),
        compiler__DepGraph_display_cycles(&/* ? */ *deps_resolved)));
  };
  return deps_resolved;
}
compiler__DepGraph *compiler__V_import_graph(compiler__V *v) {
  compiler__DepGraph *graph = compiler__new_dep_graph();
  array_compiler__Parser tmp18 = v->parsers;
  for (int tmp19 = 0; tmp19 < tmp18.len; tmp19++) {
    compiler__Parser p = ((compiler__Parser *)tmp18.data)[tmp19];

    array_string deps = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    map_string tmp20 = p.import_table.imports;
    array_string keys_tmp20 = map_keys(&tmp20);
    for (int l = 0; l < keys_tmp20.len; l++) {
      string _ = ((string *)keys_tmp20.data)[l];
      string m = tos3("");
      map_get(tmp20, _, &m);

      _PUSH(&deps, (/*typ = array_string   tmp_typ=string*/ m), tmp21, string);
    };
    compiler__DepGraph_add(graph, p.mod, deps);
  };
  return graph;
}
array_string compiler__DepGraph_imports(compiler__DepGraph *graph) {
  array_string mods = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_compiler__DepGraphNode tmp22 = graph->nodes;
  for (int tmp23 = 0; tmp23 < tmp22.len; tmp23++) {
    compiler__DepGraphNode node = ((compiler__DepGraphNode *)tmp22.data)[tmp23];

    _PUSH(&mods, (/*typ = array_string   tmp_typ=string*/ node.name), tmp24,
          string);
  };
  return mods;
}
static inline string compiler__V_module_path(compiler__V *v, string mod) {
  return string_replace(mod, tos3("."), os__path_separator);
}
void compiler__V_set_module_lookup_paths(compiler__V *v) {
  v->module_lookup_paths = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  if (v->pref->is_test) {
    _PUSH(
        &v->module_lookup_paths,
        (/*typ = array_string   tmp_typ=string*/ os__base_dir(v->compiled_dir)),
        tmp25, string);
  };
  _PUSH(&v->module_lookup_paths,
        (/*typ = array_string   tmp_typ=string*/ v->compiled_dir), tmp26,
        string);
  _PUSH(&v->module_lookup_paths,
        (/*typ = array_string   tmp_typ=string*/ os__join_path(
            v->compiled_dir,
            &(varg_string){.len = 1, .args = {tos3("modules")}})),
        tmp27, string);
  _PUSH_MANY(&v->module_lookup_paths,
             (/*typ = array_string   tmp_typ=string*/ v->pref->lookup_path),
             tmp28, array_string);
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
    string tmp29 = array_string_str(v->module_lookup_paths);

    compiler__V_log(&/* ? */ *v,
                    _STR("v.module_lookup_paths: %.*s ", tmp29.len, tmp29.str));
  };
}
Option_string compiler__Parser_find_module_path(compiler__Parser *p,
                                                string mod) {
  compiler__ModFileAndFolder vmod_file_location =
      compiler__ModFileCacher_get(p->v->mod_file_cacher, p->file_path_dir);
  array_string module_lookup_paths = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  if (vmod_file_location.vmod_file.len != 0) {
    if (!(_IN(string, (vmod_file_location.vmod_folder),
              p->v->module_lookup_paths))) {
      _PUSH(&module_lookup_paths,
            (/*typ = array_string   tmp_typ=string*/ vmod_file_location
                 .vmod_folder),
            tmp30, string);
    };
  };
  _PUSH_MANY(
      &module_lookup_paths,
      (/*typ = array_string   tmp_typ=string*/ p->v->module_lookup_paths),
      tmp31, array_string);
  string mod_path = compiler__V_module_path(&/* ? */ *p->v, mod);
  array_string tmp32 = module_lookup_paths;
  for (int tmp33 = 0; tmp33 < tmp32.len; tmp33++) {
    string lookup_path = ((string *)tmp32.data)[tmp33];

    string try_path = os__join_path(
        lookup_path, &(varg_string){.len = 1, .args = {mod_path}});
    if (v_dot_pref__VerboseLevel_is_higher_or_equal(
            p->v->pref->verbosity,
            v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
      printf("  >> trying to find %.*s in %.*s ...\n", mod.len, mod.str,
             try_path.len, try_path.str);
    };
    if (os__is_dir(try_path)) {
      if (v_dot_pref__VerboseLevel_is_higher_or_equal(
              p->v->pref->verbosity,
              v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
        printf("  << found %.*s .\n", try_path.len, try_path.str);
      };
      string tmp34 = OPTION_CAST(string)(try_path);
      return opt_ok(&tmp34, sizeof(string));
    };
  };
  string tmp35 = array_string_str(module_lookup_paths);

  return v_error(_STR("module \"%.*s\" not found in %.*s ", mod.len, mod.str,
                      tmp35.len, tmp35.str));
}
static inline string compiler__mod_gen_name(string mod) {
  return string_replace(mod, tos3("."), tos3("_dot_"));
}
static inline string compiler__mod_gen_name_rev(string mod) {
  return string_replace(mod, tos3("_dot_"), tos3("."));
}
Option_string compiler__find_windows_kit_internal(compiler__RegKey key,
                                                  array_string versions) {
#ifdef _WIN32
  {
    array_string tmp1 = versions;
    for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
      string version = ((string *)tmp1.data)[tmp2];

      int required_bytes = 0;
      void *result = RegQueryValueEx(key, string_to_wide(version), 0, 0, 0,
                                     &required_bytes);
      int length = required_bytes / 2;
      if (result != 0) {
        continue;
      };
      int alloc_length = (required_bytes + 2);
      u16 *value = ((u16 *)(v_malloc(alloc_length)));
      if (isnil(value)) {
        continue;
      };
      void *result2 = RegQueryValueEx(key, string_to_wide(version), 0, 0, value,
                                      &alloc_length);
      if (result2 != 0) {
        continue;
      };
      if ((value[/*ptr!*/ length - 1] /*ru16 1*/ != ((u16)(0)))) {
        value[/*ptr!*/ length] /*ru16 1*/ = ((u16)(0));
      };
      string tmp3 = OPTION_CAST(string)(string_from_wide(value));
      return opt_ok(&tmp3, sizeof(string));
    };
  };
#endif
  ;
  return v_error(tos3("windows kit not found"));
}
Option_compiler__WindowsKit compiler__find_windows_kit_root(string host_arch) {
#ifdef _WIN32
  compiler__RegKey root_key = ((compiler__RegKey)(0));
  void *rc =
      RegOpenKeyEx(compiler__HKEY_LOCAL_MACHINE,
                   string_to_wide(tos3(
                       "SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots")),
                   0,
                   compiler__KEY_QUERY_VALUE | compiler__KEY_WOW64_32KEY |
                       compiler__KEY_ENUMERATE_SUB_KEYS,
                   &root_key);
  if (rc != 0) {
    Option tmp4 = v_error(tos3("Unable to open root key"));
    { RegCloseKey(root_key); }
    return tmp4;
    ;
  };
  Option_string tmp5 = compiler__find_windows_kit_internal(
      root_key,
      new_array_from_c_array(2, 2, sizeof(string),
                             EMPTY_ARRAY_OF_ELEMS(string, 2){
                                 tos3("KitsRoot10"), tos3("KitsRoot81")}));
  string kit_root;
  if (!tmp5.ok) {
    string err = tmp5.error;
    int errcode = tmp5.ecode;
    Option tmp6 = v_error(tos3("Unable to find a windows kit"));
    { RegCloseKey(root_key); }
    return tmp6;
    ;
  }
  kit_root = *(string *)tmp5.data;
  ;
  string kit_lib = string_add(kit_root, tos3("Lib"));
  Option_array_string tmp7 = os__ls(kit_lib);
  array_string files;
  if (!tmp7.ok) {
    string err = tmp7.error;
    int errcode = tmp7.ecode;
    v_panic(err);
  }
  files = *(array_string *)tmp7.data;
  ;
  string highest_path = tos3("");
  int highest_int = 0;
  array_string tmp8 = files;
  for (int tmp9 = 0; tmp9 < tmp8.len; tmp9++) {
    string f = ((string *)tmp8.data)[tmp9];

    string no_dot = string_replace(f, tos3("."), tos3(""));
    int v_int = v_string_int(no_dot);
    if (v_int > highest_int) {
      highest_int = v_int;
      highest_path = f;
    };
  };
  string kit_lib_highest =
      string_add(kit_lib, _STR("\\%.*s", highest_path.len, highest_path.str));
  string kit_include_highest =
      string_replace(kit_lib_highest, tos3("Lib"), tos3("Include"));
  compiler__WindowsKit tmp10 = OPTION_CAST(
      compiler__WindowsKit)((compiler__WindowsKit){
      .um_lib_path = string_add(
          kit_lib_highest, _STR("\\um\\%.*s", host_arch.len, host_arch.str)),
      .ucrt_lib_path = string_add(
          kit_lib_highest, _STR("\\ucrt\\%.*s", host_arch.len, host_arch.str)),
      .um_include_path = string_add(kit_include_highest, tos3("\\um")),
      .ucrt_include_path = string_add(kit_include_highest, tos3("\\ucrt")),
      .shared_include_path =
          string_add(kit_include_highest, tos3("\\shared"))});
  { RegCloseKey(root_key); }
  return opt_ok(&tmp10, sizeof(compiler__WindowsKit));
  {
    RegCloseKey(root_key);
  }
#endif
  ;
  return v_error(tos3("Host OS does not support funding a windows kit"));
}
Option_compiler__VsInstallation compiler__find_vs(string vswhere_dir,
                                                  string host_arch) {
#ifndef _WIN32
#endif
  ;
  Option_os__Result tmp11 =
      os__exec(_STR("\"%.*s\\Microsoft Visual Studio\\Installer\\vswhere.exe\" "
                    "-latest -prerelease -products * -requires "
                    "Microsoft.VisualStudio.Component.VC.Tools.x86.x64 "
                    "-property installationPath",
                    vswhere_dir.len, vswhere_dir.str));
  os__Result res;
  if (!tmp11.ok) {
    string err = tmp11.error;
    int errcode = tmp11.ecode;
    return v_error(err);
  }
  res = *(os__Result *)tmp11.data;
  ;
  Option_string tmp12 = os__read_file(
      _STR("%.*s\\VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt",
           res.output.len, res.output.str));
  string version;
  if (!tmp12.ok) {
    string err = tmp12.error;
    int errcode = tmp12.ecode;
    println(tos3("Unable to find msvc version"));
    return v_error(tos3("Unable to find vs installation"));
  }
  version = *(string *)tmp12.data;
  ;
  string v = ((string_ends_with(version, tos3("\n")))
                  ? (string_substr2(version, 0, version.len - 2, false))
                  : (version));
  string lib_path =
      _STR("%.*s\\VC\\Tools\\MSVC\\%.*s\\lib\\%.*s", res.output.len,
           res.output.str, v.len, v.str, host_arch.len, host_arch.str);
  string include_path = _STR("%.*s\\VC\\Tools\\MSVC\\%.*s\\include",
                             res.output.len, res.output.str, v.len, v.str);
  if (os__exists(_STR("%.*s\\vcruntime.lib", lib_path.len, lib_path.str))) {
    string p = _STR("%.*s\\VC\\Tools\\MSVC\\%.*s\\bin\\Host%.*s\\%.*s",
                    res.output.len, res.output.str, v.len, v.str, host_arch.len,
                    host_arch.str, host_arch.len, host_arch.str);
    compiler__VsInstallation tmp15 =
        OPTION_CAST(compiler__VsInstallation)((compiler__VsInstallation){
            .exe_path = p, .lib_path = lib_path, .include_path = include_path});
    return opt_ok(&tmp15, sizeof(compiler__VsInstallation));
  };
  printf(
      "Unable to find vs installation (attempted to use lib path \"%.*s\")\n",
      lib_path.len, lib_path.str);
  return v_error(tos3("Unable to find vs exe folder"));
}
Option_compiler__MsvcResult compiler__find_msvc() {
#ifdef _WIN32
  string processor_architecture = os__getenv(tos3("PROCESSOR_ARCHITECTURE"));
  string vswhere_dir = ((string_eq(processor_architecture, tos3("x86")))
                            ? (tos3("%ProgramFiles%"))
                            : (tos3("%ProgramFiles(x86)%")));
  string host_arch =
      ((string_eq(processor_architecture, tos3("x86"))) ? (tos3("X86"))
                                                        : (tos3("X64")));
  Option_compiler__WindowsKit tmp16 =
      compiler__find_windows_kit_root(host_arch);
  compiler__WindowsKit wk;
  if (!tmp16.ok) {
    string err = tmp16.error;
    int errcode = tmp16.ecode;
    return v_error(tos3("Unable to find windows sdk"));
  }
  wk = *(compiler__WindowsKit *)tmp16.data;
  ;
  Option_compiler__VsInstallation tmp17 =
      compiler__find_vs(vswhere_dir, host_arch);
  compiler__VsInstallation vs;
  if (!tmp17.ok) {
    string err = tmp17.error;
    int errcode = tmp17.ecode;
    return v_error(tos3("Unable to find visual studio"));
  }
  vs = *(compiler__VsInstallation *)tmp17.data;
  ;
  compiler__MsvcResult tmp18 =
      OPTION_CAST(compiler__MsvcResult)((compiler__MsvcResult){
          .full_cl_exe_path = os__realpath(string_add(
              string_add(vs.exe_path, os__path_separator), tos3("cl.exe"))),
          .exe_path = vs.exe_path,
          .um_lib_path = wk.um_lib_path,
          .ucrt_lib_path = wk.ucrt_lib_path,
          .vs_lib_path = vs.lib_path,
          .um_include_path = wk.um_include_path,
          .ucrt_include_path = wk.ucrt_include_path,
          .vs_include_path = vs.include_path,
          .shared_include_path = wk.shared_include_path});
  return opt_ok(&tmp18, sizeof(compiler__MsvcResult));
#else
  compiler__verror(tos3("Cannot find msvc on this OS"));
  return v_error(tos3("msvc not found"));
#endif
  ;
}
void compiler__V_cc_msvc(compiler__V *v) {
  Option_compiler__MsvcResult tmp19 = compiler__find_msvc();
  compiler__MsvcResult r;
  if (!tmp19.ok) {
    string err = tmp19.error;
    int errcode = tmp19.ecode;
    if (!v->pref->is_keep_c && string_ne(v->out_name_c, tos3("v.c")) &&
        string_ne(v->out_name_c, tos3("v_macos.c"))) {
      os__rm(v->out_name_c);
    };
    compiler__verror(tos3("Cannot find MSVC on this OS"));

    return;
  }
  r = *(compiler__MsvcResult *)tmp19.data;
  ;
  string out_name_obj = os__realpath(string_add(v->out_name_c, tos3(".obj")));
  array_string a = new_array_from_c_array(
      4, 4, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 4){
          tos3("-w"), tos3("/we4013"), tos3("/volatile:ms"),
          _STR("/Fo\"%.*s\"", out_name_obj.len, out_name_obj.str)});
  if (v->pref->is_prod) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/O2")), tmp20,
          string);
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/MD")), tmp21,
          string);
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/Zi")), tmp22,
          string);
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/DNDEBUG")), tmp23,
          string);
  } else {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/Zi")), tmp24,
          string);
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/MDd")), tmp25,
          string);
  };
  if (v->pref->is_so) {
    if (!string_ends_with(v->pref->out_name, tos3(".dll"))) {
      v->pref->out_name = string_add(v->pref->out_name, tos3(".dll"));
    };
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/LD")), tmp26,
          string);
  } else if (!string_ends_with(v->pref->out_name, tos3(".exe"))) {
    v->pref->out_name = string_add(v->pref->out_name, tos3(".exe"));
  };
  v->pref->out_name = os__realpath(v->pref->out_name);
  if (v->pref->build_mode == v_dot_pref__v_dot_pref__BuildMode_build_module) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/c")), tmp27,
          string);
  } else if (v->pref->build_mode ==
             v_dot_pref__v_dot_pref__BuildMode_default_mode) {
  };
  if (v->pref->sanitize) {
    println(tos3("Sanitize not supported on msvc."));
  };
  _PUSH(&a,
        (/*typ = array_string   tmp_typ=string*/ string_add(
            string_add(tos3("\""), os__realpath(v->out_name_c)), tos3("\""))),
        tmp28, string);
  array_string real_libs = new_array_from_c_array(
      3, 3, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 3){tos3("kernel32.lib"), tos3("user32.lib"),
                                      tos3("advapi32.lib")});
  compiler__MsvcStringFlags sflags = array_compiler__CFlag_msvc_string_flags(
      compiler__V_get_os_cflags(&/* ? */ *v));
  _PUSH_MANY(&real_libs,
             (/*typ = array_string   tmp_typ=string*/ sflags.real_libs), tmp29,
             array_string);
  array_string inc_paths = sflags.inc_paths;
  array_string lib_paths = sflags.lib_paths;
  array_string other_flags = sflags.other_flags;
  _PUSH(&a,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "-I \"%.*s\"", r.ucrt_include_path.len, r.ucrt_include_path.str)),
        tmp30, string);
  _PUSH(&a,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "-I \"%.*s\"", r.vs_include_path.len, r.vs_include_path.str)),
        tmp31, string);
  _PUSH(&a,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "-I \"%.*s\"", r.um_include_path.len, r.um_include_path.str)),
        tmp32, string);
  _PUSH(
      &a,
      (/*typ = array_string   tmp_typ=string*/ _STR(
          "-I \"%.*s\"", r.shared_include_path.len, r.shared_include_path.str)),
      tmp33, string);
  _PUSH_MANY(&a, (/*typ = array_string   tmp_typ=string*/ inc_paths), tmp34,
             array_string);
  _PUSH_MANY(&a, (/*typ = array_string   tmp_typ=string*/ other_flags), tmp35,
             array_string);
  _PUSH(&a,
        (/*typ = array_string   tmp_typ=string*/ array_string_join(real_libs,
                                                                   tos3(" "))),
        tmp36, string);
  _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/link")), tmp37,
        string);
  _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/NOLOGO")), tmp38,
        string);
  _PUSH(&a,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "/OUT:\"%.*s\"", v->pref->out_name.len, v->pref->out_name.str)),
        tmp39, string);
  _PUSH(&a,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "/LIBPATH:\"%.*s\"", r.ucrt_lib_path.len, r.ucrt_lib_path.str)),
        tmp40, string);
  _PUSH(&a,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "/LIBPATH:\"%.*s\"", r.um_lib_path.len, r.um_lib_path.str)),
        tmp41, string);
  _PUSH(&a,
        (/*typ = array_string   tmp_typ=string*/ _STR(
            "/LIBPATH:\"%.*s\"", r.vs_lib_path.len, r.vs_lib_path.str)),
        tmp42, string);
  _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/DEBUG:FULL")),
        tmp43, string);
  if (v->pref->is_prod) {
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/INCREMENTAL:NO")),
          tmp44, string);
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/OPT:REF")), tmp45,
          string);
    _PUSH(&a, (/*typ = array_string   tmp_typ=string*/ tos3("/OPT:ICF")), tmp46,
          string);
  };
  _PUSH_MANY(&a, (/*typ = array_string   tmp_typ=string*/ lib_paths), tmp47,
             array_string);
  string args = array_string_join(a, tos3(" "));
  string cmd = _STR("\"%.*s\" %.*s", r.full_cl_exe_path.len,
                    r.full_cl_exe_path.str, args.len, args.str);
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_one)) {
    println(tos3("\n========== cl cmd line:"));
    println(cmd);
    println(tos3("==========\n"));
  };
  Option_os__Result tmp48 = os__exec(cmd);
  os__Result res;
  if (!tmp48.ok) {
    string err = tmp48.error;
    int errcode = tmp48.ecode;
    println(err);
    compiler__verror(tos3("msvc error"));

    return;
  }
  res = *(os__Result *)tmp48.data;
  ;
  if (res.exit_code != 0) {
    compiler__verror(res.output);
  };
  if (!v->pref->is_keep_c && string_ne(v->out_name_c, tos3("v.c")) &&
      string_ne(v->out_name_c, tos3("v_macos.c"))) {
    os__rm(v->out_name_c);
  };
  os__rm(out_name_obj);
}
void compiler__build_thirdparty_obj_file_with_msvc(
    string path, array_compiler__CFlag moduleflags) {
  Option_compiler__MsvcResult tmp49 = compiler__find_msvc();
  compiler__MsvcResult msvc;
  if (!tmp49.ok) {
    string err = tmp49.error;
    int errcode = tmp49.ecode;
    println(tos3("Could not find visual studio"));

    return;
  }
  msvc = *(compiler__MsvcResult *)tmp49.data;
  ;
  string obj_path = _STR("%.*sbj", path.len, path.str);
  obj_path = os__realpath(obj_path);
  if (os__exists(obj_path)) {
    printf("%.*s already built.\n", obj_path.len, obj_path.str);

    return;
  };
  printf("%.*s not found, building it (with msvc)...\n", obj_path.len,
         obj_path.str);
  string parent = os__dir(obj_path);
  Option_array_string tmp50 = os__ls(parent);
  array_string files;
  if (!tmp50.ok) {
    string err = tmp50.error;
    int errcode = tmp50.ecode;
    v_panic(err);
  }
  files = *(array_string *)tmp50.data;
  ;
  string cfiles = tos3("");
  array_string tmp51 = files;
  for (int tmp52 = 0; tmp52 < tmp51.len; tmp52++) {
    string file = ((string *)tmp51.data)[tmp52];

    if (string_ends_with(file, tos3(".c"))) {
      cfiles = string_add(
          cfiles,
          string_add(
              string_add(tos3("\""),
                         os__realpath(string_add(
                             string_add(parent, os__path_separator), file))),
              tos3("\" ")));
    };
  };
  string include_string =
      _STR("-I \"%.*s\" -I \"%.*s\" -I \"%.*s\" -I \"%.*s\"",
           msvc.ucrt_include_path.len, msvc.ucrt_include_path.str,
           msvc.vs_include_path.len, msvc.vs_include_path.str,
           msvc.um_include_path.len, msvc.um_include_path.str,
           msvc.shared_include_path.len, msvc.shared_include_path.str);
  string btarget =
      array_compiler__CFlag_c_options_before_target_msvc(moduleflags);
  string atarget =
      array_compiler__CFlag_c_options_after_target_msvc(moduleflags);
  string cmd = _STR(
      "\"%.*s\" /volatile:ms /Zi /DNDEBUG %.*s /c %.*s %.*s %.*s /Fo\"%.*s\"",
      msvc.full_cl_exe_path.len, msvc.full_cl_exe_path.str, include_string.len,
      include_string.str, btarget.len, btarget.str, cfiles.len, cfiles.str,
      atarget.len, atarget.str, obj_path.len, obj_path.str);
  printf("thirdparty cmd line: %.*s\n", cmd.len, cmd.str);
  Option_os__Result tmp53 = os__exec(cmd);
  os__Result res;
  if (!tmp53.ok) {
    string err = tmp53.error;
    int errcode = tmp53.ecode;
    printf("msvc: failed thirdparty object build cmd: %.*s\n", cmd.len,
           cmd.str);
    compiler__verror(err);

    return;
  }
  res = *(os__Result *)tmp53.data;
  ;
  if (res.exit_code != 0) {
    printf("msvc: failed thirdparty object build cmd: %.*s\n", cmd.len,
           cmd.str);
    compiler__verror(res.output);

    return;
  };
  println(res.output);
}
compiler__MsvcStringFlags
array_compiler__CFlag_msvc_string_flags(array_compiler__CFlag cflags) {
  array_string real_libs = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_string inc_paths = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_string lib_paths = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_string other_flags = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_compiler__CFlag tmp54 = cflags;
  for (int tmp55 = 0; tmp55 < tmp54.len; tmp55++) {
    compiler__CFlag flag = ((compiler__CFlag *)tmp54.data)[tmp55];

    if (string_eq(flag.name, tos3("-l"))) {
      if (string_ends_with(flag.value, tos3(".dll"))) {
        compiler__verror(
            _STR("MSVC cannot link against a dll (`#flag -l %.*s`)",
                 flag.value.len, flag.value.str));
      };
      string lib_lib = string_add(flag.value, tos3(".lib"));
      _PUSH(&real_libs, (/*typ = array_string   tmp_typ=string*/ lib_lib),
            tmp56, string);
    } else if (string_eq(flag.name, tos3("-I"))) {
      _PUSH(&inc_paths,
            (/*typ = array_string   tmp_typ=string*/ compiler__CFlag_format(
                &/* ? */ flag)),
            tmp57, string);
    } else if (string_eq(flag.name, tos3("-L"))) {
      _PUSH(&lib_paths, (/*typ = array_string   tmp_typ=string*/ flag.value),
            tmp58, string);
      _PUSH(&lib_paths,
            (/*typ = array_string   tmp_typ=string*/ string_add(
                string_add(flag.value, os__path_separator), tos3("msvc"))),
            tmp59, string);
    } else if (string_ends_with(flag.value, tos3(".o"))) {
      _PUSH(&other_flags,
            (/*typ = array_string   tmp_typ=string*/ _STR(
                "\"%.*sbj\"", flag.value.len, flag.value.str)),
            tmp60, string);
    } else {
      _PUSH(&other_flags, (/*typ = array_string   tmp_typ=string*/ flag.value),
            tmp61, string);
    };
  };
  array_string lpaths = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  array_string tmp62 = lib_paths;
  for (int tmp63 = 0; tmp63 < tmp62.len; tmp63++) {
    string l = ((string *)tmp62.data)[tmp63];

    _PUSH(&lpaths,
          (/*typ = array_string   tmp_typ=string*/ string_add(
              string_add(tos3("/LIBPATH:\""), os__realpath(l)), tos3("\""))),
          tmp64, string);
  };
  return (compiler__MsvcStringFlags){.real_libs = real_libs,
                                     .inc_paths = inc_paths,
                                     .lib_paths = lpaths,
                                     .other_flags = other_flags};
}
void compiler__Parser_in_optimization(compiler__Parser *p, string typ, int ph) {
  compiler__Parser_check(p, compiler__compiler__TokenKind_lsbr);
  if (p->tok == compiler__compiler__TokenKind_rsbr) {
    compiler__Parser_error(p, tos3("`x in []` is always false"));
  };
  int i = 0;
  string expr = string_substr2(p->cgen->cur_line, ph, -1, true);
  bool is_str = string_eq(typ, tos3("string"));
  while (p->tok != compiler__compiler__TokenKind_rsbr &&
         p->tok != compiler__compiler__TokenKind_eof) {

    if (i > 0) {
      if (is_str) {
        compiler__Parser_gen(p,
                             _STR(" || string_eq(%.*s, ", expr.len, expr.str));
      } else {
        compiler__Parser_gen(p, _STR(" || %.*s == ", expr.len, expr.str));
      };
    };
    if (i == 0) {
      if (is_str) {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3(" (string_eq("));
        compiler__Parser_gen(p, tos3(", "));
      } else {
        compiler__CGen_set_placeholder(p->cgen, ph, tos3(" ("));
        compiler__Parser_gen(p, tos3(" =="));
      };
    };
    compiler__Parser_check_types(p, compiler__Parser_bool_expression(p), typ);
    if (is_str) {
      compiler__Parser_gen(p, tos3(")"));
    };
    if (p->tok != compiler__compiler__TokenKind_rsbr) {
      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
      ;
    };
    i++;
  };
  compiler__Parser_gen(p, tos3(")"));
  compiler__Parser_check(p, compiler__compiler__TokenKind_rsbr);
}
string compiler__sql_params2params_gen(array_string sql_params,
                                       array_string sql_types, string qprefix) {
  string params_gen = tos3("");
  array_string tmp1 = sql_params;
  for (int i = 0; i < tmp1.len; i++) {
    string mparam = ((string *)tmp1.data)[i];

    string param = string_trim_space(mparam);
    string paramtype = (*(string *)array_get(sql_types, i));
    if (byte_is_digit(string_at(param, 0))) {
      params_gen = string_add(
          params_gen, _STR("%.*sparams[%d] = int_str(%.*s).str;\n", qprefix.len,
                           qprefix.str, i, param.len, param.str));
    } else if (string_at(param, 0) == '\'') {
      string sparam = string_trim(param, tos3("\'"));
      params_gen = string_add(params_gen,
                              _STR("%.*sparams[%d] = \"%.*s\";\n", qprefix.len,
                                   qprefix.str, i, sparam.len, sparam.str));
    } else {
      if (string_eq(paramtype, tos3("int"))) {
        params_gen =
            string_add(params_gen,
                       _STR("%.*sparams[%d] = int_str( %.*s ).str;\n",
                            qprefix.len, qprefix.str, i, param.len, param.str));
      } else if (string_eq(paramtype, tos3("string"))) {
        params_gen = string_add(params_gen, _STR("%.*sparams[%d] = %.*s.str;\n",
                                                 qprefix.len, qprefix.str, i,
                                                 param.len, param.str));
      } else {
        compiler__verror(tos3("orm: only int and string variable types are "
                              "supported in queries"));
      };
    };
  };
  return params_gen;
}
string compiler__Parser_select_query(compiler__Parser *p, int fn_ph) {
  string qprefix = string_add(
      string_replace(compiler__Parser_get_tmp(p), tos3("tmp"), tos3("sql")),
      tos3("_"));
  p->sql_i = 0;
  p->sql_params = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  if (0) {
  };
  p->sql_types = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  string q = tos3("select ");
  compiler__Parser_check(p, compiler__compiler__TokenKind_key_select);
  ;
  string n = compiler__Parser_check_name(p);
  ;
  if (string_eq(n, tos3("count"))) {
    q = string_add(q, tos3("count(*) from "));
    compiler__Parser_check_name(p);
    ;
  };
  string table_name = compiler__Parser_check_name(p);
  ;
  compiler__Type typ =
      compiler__Table_find_type(&/* ? */ *p->table, table_name);
  if (string_eq(typ.name, tos3(""))) {
    compiler__Parser_error(
        p, _STR("unknown type `%.*s`", table_name.len, table_name.str));
  };
  array_compiler__Var fields = new_array_from_c_array(
      0, 0, sizeof(compiler__Var),
      EMPTY_ARRAY_OF_ELEMS(compiler__Var, 0){TCCSKIP(0)});
  array_compiler__Var tmp8 = typ.fields;
  for (int i = 0; i < tmp8.len; i++) {
    compiler__Var field = ((compiler__Var *)tmp8.data)[i];

    if (!((string_eq(field.typ, tos3("string")) ||
           string_eq(field.typ, tos3("int")) ||
           string_eq(field.typ, tos3("bool"))))) {
      printf("orm: skipping %.*s\n", field.name.len, field.name.str);
      continue;
    };
    if (string_contains(field.attr, tos3("skip"))) {
      continue;
    };
    _PUSH(&fields,
          (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ field), tmp9,
          compiler__Var);
  };
  if (fields.len == 0) {
    compiler__Parser_error(p, _STR("V orm: select: empty fields in `%.*s`",
                                   table_name.len, table_name.str));
  };
  if (string_ne((*(compiler__Var *)array_get(fields, 0)).name, tos3("id"))) {
    compiler__Parser_error(
        p, _STR("V orm: `id int` must be the first field in `%.*s`",
                table_name.len, table_name.str));
  };
  if (string_eq(n, tos3("from"))) {
    array_compiler__Var tmp12 = fields;
    for (int i = 0; i < tmp12.len; i++) {
      compiler__Var field = ((compiler__Var *)tmp12.data)[i];

      q = string_add(q, field.name);
      if (i < fields.len - 1) {
        q = string_add(q, tos3(", "));
      };
    };
    q = string_add(q, tos3(" from "));
  };
  array_compiler__Var tmp13 = fields;
  for (int tmp14 = 0; tmp14 < tmp13.len; tmp14++) {
    compiler__Var field = ((compiler__Var *)tmp13.data)[tmp14];

    if (!((string_eq(field.typ, tos3("string")) ||
           string_eq(field.typ, tos3("int")) ||
           string_eq(field.typ, tos3("bool"))))) {
      printf("orm: skipping %.*s\n", field.name.len, field.name.str);
      continue;
    };
    compiler__Parser_register_var(p, (compiler__Var){
                                         .is_mut = 1,
                                         .is_used = 1,
                                         .is_changed = 1,
                                         .typ = field.typ,
                                         .name = field.name,
                                         .idx = field.idx,
                                         .is_arg = field.is_arg,
                                         .is_const = field.is_const,
                                         .args = field.args,
                                         .attr = field.attr,
                                         .is_alloc = field.is_alloc,
                                         .is_returned = field.is_returned,
                                         .ptr = field.ptr,
                                         .ref = field.ref,
                                         .parent_fn = field.parent_fn,
                                         .mod = field.mod,
                                         .access_mod = field.access_mod,
                                         .is_global = field.is_global,
                                         .scope_level = field.scope_level,
                                         .is_c = field.is_c,
                                         .is_moved = field.is_moved,
                                         .line_nr = field.line_nr,
                                         .token_idx = field.token_idx,
                                         .is_for_var = field.is_for_var,
                                         .is_public = field.is_public,
                                     });
  };
  q = string_add(q, string_add(table_name, tos3("s")));
  if (p->tok == compiler__compiler__TokenKind_name &&
      string_eq(p->lit, tos3("where"))) {
    compiler__Parser_next(p);
    ;
    p->is_sql = 1;
    _V_MulRet_string_V_string _V_mret_508___expr = compiler__Parser_tmp_expr(p);
    string expr = _V_mret_508___expr.var_1;
    p->is_sql = 0;
    q = string_add(q, string_add(tos3(" where "), expr));
  };
  bool query_one = 0;
  if (p->tok == compiler__compiler__TokenKind_name &&
      string_eq(p->lit, tos3("limit"))) {
    ;
    compiler__Parser_next(p);
    ;
    p->is_sql = 1;
    _V_MulRet_string_V_string _V_mret_566___limit =
        compiler__Parser_tmp_expr(p);
    string limit = _V_mret_566___limit.var_1;
    ;
    p->is_sql = 0;
    q = string_add(q, string_add(tos3(" limit "), limit));
    if (string_eq(string_trim_space(limit), tos3("1"))) {
      query_one = 1;
    };
  };
  printf("sql query=\"%.*s\"\n", q.len, q.str);
  compiler__CGen_insert_before(
      p->cgen, _STR("// DEBUG_SQL prefix: %.*s | fn_ph: %d | query: \"%.*s\" ",
                    qprefix.len, qprefix.str, fn_ph, q.len, q.str));
  if (string_eq(n, tos3("count"))) {
    compiler__CGen_set_placeholder(p->cgen, fn_ph, tos3("pg__DB_q_int("));
    compiler__Parser_gen(p, _STR(", tos2(\"%.*s\"))", q.len, q.str));
  } else {
    string tmp = compiler__Parser_get_tmp(p);
    strings__Builder obj_gen = strings__new_builder(300);
    array_compiler__Var tmp15 = fields;
    for (int i = 0; i < tmp15.len; i++) {
      compiler__Var field = ((compiler__Var *)tmp15.data)[i];

      string cast = tos3("");
      if (string_eq(field.typ, tos3("int"))) {
        cast = tos3("v_string_int");
      } else if (string_eq(field.typ, tos3("bool"))) {
        cast = tos3("string_bool");
      };
      strings__Builder_writeln(
          &/* ? */ obj_gen,
          string_add(_STR("%.*s%.*s.%.*s = ", qprefix.len, qprefix.str, tmp.len,
                          tmp.str, field.name.len, field.name.str),
                     _STR("%.*s(*(string*)array_get(%.*srow.vals, %d));",
                          cast.len, cast.str, qprefix.len, qprefix.str, i)));
    };
    if (query_one) {
      string params_gen =
          compiler__sql_params2params_gen(p->sql_params, p->sql_types, qprefix);
      compiler__CGen_insert_before(
          p->cgen,
          _STR("\n\nchar* %.*sparams[%d];\n%.*s\n\nOption_%.*s "
               "opt_%.*s%.*s;\nvoid* %.*sres = PQexecParams(db.conn, \"%.*s\", "
               "%d, 0, %.*sparams, 0, 0, 0)  ;\narray_pg__Row %.*srows = "
               "pg__res_to_rows ( %.*sres ) ;\nOption_pg__Row opt_%.*srow = "
               "pg__rows_first_or_empty( %.*srows );\nif (! opt_%.*srow . ok ) "
               "{\n   opt_%.*s%.*s = v_error( opt_%.*srow . error );\n}else{\n "
               "  %.*s %.*s%.*s;\n   pg__Row %.*srow = *(pg__Row*) opt_%.*srow "
               ". data;\n%.*s\n   opt_%.*s%.*s = opt_ok( & %.*s%.*s, "
               "sizeof(%.*s) );\n}\n\n",
               qprefix.len, qprefix.str, p->sql_i, params_gen.len,
               params_gen.str, table_name.len, table_name.str, qprefix.len,
               qprefix.str, tmp.len, tmp.str, qprefix.len, qprefix.str, q.len,
               q.str, p->sql_i, qprefix.len, qprefix.str, qprefix.len,
               qprefix.str, qprefix.len, qprefix.str, qprefix.len, qprefix.str,
               qprefix.len, qprefix.str, qprefix.len, qprefix.str, qprefix.len,
               qprefix.str, tmp.len, tmp.str, qprefix.len, qprefix.str,
               table_name.len, table_name.str, qprefix.len, qprefix.str,
               tmp.len, tmp.str, qprefix.len, qprefix.str, qprefix.len,
               qprefix.str, strings__Builder_str(&/* ? */ obj_gen).len,
               strings__Builder_str(&/* ? */ obj_gen).str, qprefix.len,
               qprefix.str, tmp.len, tmp.str, qprefix.len, qprefix.str, tmp.len,
               tmp.str, table_name.len, table_name.str));
      compiler__CGen_resetln(p->cgen, _STR("opt_%.*s%.*s", qprefix.len,
                                           qprefix.str, tmp.len, tmp.str));
    } else {
      q = string_add(q, tos3(" order by id"));
      string params_gen =
          compiler__sql_params2params_gen(p->sql_params, p->sql_types, qprefix);
      compiler__CGen_insert_before(
          p->cgen,
          _STR("char* %.*sparams[%d];\n%.*s\n\nvoid* %.*sres = "
               "PQexecParams(db.conn, \"%.*s\", %d, 0, %.*sparams, 0, 0, 0)  "
               ";\narray_pg__Row %.*srows = pg__res_to_rows(%.*sres);\n\n// "
               "TODO preallocate\narray %.*sarr_%.*s = new_array(0, 0, "
               "sizeof(%.*s));\nfor (int i = 0; i < %.*srows.len; i++) {\n    "
               "pg__Row %.*srow = *(pg__Row*)array_get(%.*srows, i);\n    %.*s "
               "%.*s%.*s;\n    %.*s\n    _PUSH(&%.*sarr_%.*s, %.*s%.*s, %.*s2, "
               "%.*s);\n}\n",
               qprefix.len, qprefix.str, p->sql_i, params_gen.len,
               params_gen.str, qprefix.len, qprefix.str, q.len, q.str, p->sql_i,
               qprefix.len, qprefix.str, qprefix.len, qprefix.str, qprefix.len,
               qprefix.str, qprefix.len, qprefix.str, tmp.len, tmp.str,
               table_name.len, table_name.str, qprefix.len, qprefix.str,
               qprefix.len, qprefix.str, qprefix.len, qprefix.str,
               table_name.len, table_name.str, qprefix.len, qprefix.str,
               tmp.len, tmp.str, strings__Builder_str(&/* ? */ obj_gen).len,
               strings__Builder_str(&/* ? */ obj_gen).str, qprefix.len,
               qprefix.str, tmp.len, tmp.str, qprefix.len, qprefix.str, tmp.len,
               tmp.str, tmp.len, tmp.str, table_name.len, table_name.str));
      compiler__CGen_resetln(p->cgen, _STR("%.*sarr_%.*s", qprefix.len,
                                           qprefix.str, tmp.len, tmp.str));
    };
  };
  if (string_eq(n, tos3("count"))) {
    return tos3("int");
  } else if (query_one) {
    string opt_type = _STR("Option_%.*s", table_name.len, table_name.str);
    _PUSH(&p->cgen->typedefs,
          (/*typ = array_string   tmp_typ=string*/ _STR(
              "typedef Option %.*s;", opt_type.len, opt_type.str)),
          tmp16, string);
    compiler__Table_register_builtin(p->table, opt_type);
    return opt_type;
  } else {
    compiler__Parser_register_array(
        p, _STR("array_%.*s", table_name.len, table_name.str));
    return _STR("array_%.*s", table_name.len, table_name.str);
  };
}
void compiler__Parser_insert_query(compiler__Parser *p, int fn_ph) {
  compiler__Parser_check_name(p);
  compiler__Parser_check(p, compiler__compiler__TokenKind_lpar);
  string var_name = compiler__Parser_check_name(p);
  compiler__Parser_check(p, compiler__compiler__TokenKind_rpar);
  Option_compiler__Var tmp17 = compiler__Parser_find_var(&/* ? */ *p, var_name);
  compiler__Var var;
  if (!tmp17.ok) {
    string err = tmp17.error;
    int errcode = tmp17.ecode;

    return;
  }
  var = *(compiler__Var *)tmp17.data;
  ;
  compiler__Type typ = compiler__Table_find_type(&/* ? */ *p->table, var.typ);
  array_compiler__Var fields = new_array_from_c_array(
      0, 0, sizeof(compiler__Var),
      EMPTY_ARRAY_OF_ELEMS(compiler__Var, 0){TCCSKIP(0)});
  array_compiler__Var tmp18 = typ.fields;
  for (int i = 0; i < tmp18.len; i++) {
    compiler__Var field = ((compiler__Var *)tmp18.data)[i];

    if (string_ne(field.typ, tos3("string")) &&
        string_ne(field.typ, tos3("int"))) {
      continue;
    };
    _PUSH(&fields,
          (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ field), tmp19,
          compiler__Var);
  };
  if (fields.len == 0) {
    compiler__Parser_error(p, _STR("V orm: insert: empty fields in `%.*s`",
                                   var.typ.len, var.typ.str));
  };
  if (string_ne((*(compiler__Var *)array_get(fields, 0)).name, tos3("id"))) {
    compiler__Parser_error(
        p, _STR("V orm: `id int` must be the first field in `%.*s`",
                var.typ.len, var.typ.str));
  };
  string table_name = var.typ;
  string sfields = tos3("");
  string params = tos3("");
  string vals = tos3("");
  int nr_vals = 0;
  array_compiler__Var tmp22 = fields;
  for (int i = 0; i < tmp22.len; i++) {
    compiler__Var field = ((compiler__Var *)tmp22.data)[i];

    if (string_eq(field.name, tos3("id"))) {
      continue;
    };
    sfields = string_add(sfields, field.name);
    vals = string_add(vals, string_add(tos3("$"), int_str(i)));
    nr_vals++;
    params = string_add(params, _STR("params[%d] = ", i - 1));
    if (string_eq(field.typ, tos3("string"))) {
      params = string_add(params,
                          _STR("%.*s . %.*s .str;\n", var_name.len,
                               var_name.str, field.name.len, field.name.str));
    } else if (string_eq(field.typ, tos3("int"))) {
      params = string_add(params,
                          _STR("int_str(%.*s . %.*s).str;\n", var_name.len,
                               var_name.str, field.name.len, field.name.str));
    } else {
      compiler__Parser_error(p, _STR("V ORM: unsupported type `%.*s`",
                                     field.typ.len, field.typ.str));
    };
    if (i < fields.len - 1) {
      sfields = string_add(sfields, tos3(", "));
      vals = string_add(vals, tos3(", "));
    };
  };
  compiler__CGen_insert_before(
      p->cgen, string_add(_STR("char* params[%d];", nr_vals), params));
  compiler__CGen_set_placeholder(p->cgen, fn_ph, tos3("PQexecParams( "));
  compiler__Parser_genln(p, _STR(".conn, \"insert into %.*s (%.*s) values "
                                 "(%.*s)\", %d,\n0, params, 0, 0, 0)",
                                 table_name.len, table_name.str, sfields.len,
                                 sfields.str, vals.len, vals.str, nr_vals));
}
void compiler__Parser_update_query(compiler__Parser *p, int fn_ph) {
  println(tos3("update query"));
  compiler__Parser_check_name(p);
  ;
  string table_name = compiler__Parser_check_name(p);
  ;
  compiler__Type typ =
      compiler__Table_find_type(&/* ? */ *p->table, table_name);
  if (string_eq(typ.name, tos3(""))) {
    compiler__Parser_error(
        p, _STR("unknown type `%.*s`", table_name.len, table_name.str));
  };
  string set = compiler__Parser_check_name(p);
  ;
  if (string_ne(set, tos3("set"))) {
    compiler__Parser_error(p, tos3("expected `set`"));
  };
  if (typ.fields.len == 0) {
    compiler__Parser_error(p, _STR("V orm: update: empty fields in `%.*s`",
                                   typ.name.len, typ.name.str));
  };
  if (string_ne((*(compiler__Var *)array_get(typ.fields, 0)).name,
                tos3("id"))) {
    compiler__Parser_error(
        p, _STR("V orm: `id int` must be the first field in `%.*s`",
                typ.name.len, typ.name.str));
  };
  string field = compiler__Parser_check_name(p);
  ;
  compiler__Parser_check(p, compiler__compiler__TokenKind_assign);
  ;
  array_compiler__Var tmp25 = typ.fields;
  for (int tmp26 = 0; tmp26 < tmp25.len; tmp26++) {
    compiler__Var f = ((compiler__Var *)tmp25.data)[tmp26];

    if (!((string_eq(f.typ, tos3("string")) || string_eq(f.typ, tos3("int")) ||
           string_eq(f.typ, tos3("bool"))))) {
      printf("orm: skipping %.*s\n", f.name.len, f.name.str);
      continue;
    };
    compiler__Parser_register_var(p, (compiler__Var){
                                         .is_mut = 1,
                                         .is_used = 1,
                                         .is_changed = 1,
                                         .typ = f.typ,
                                         .name = f.name,
                                         .idx = f.idx,
                                         .is_arg = f.is_arg,
                                         .is_const = f.is_const,
                                         .args = f.args,
                                         .attr = f.attr,
                                         .is_alloc = f.is_alloc,
                                         .is_returned = f.is_returned,
                                         .ptr = f.ptr,
                                         .ref = f.ref,
                                         .parent_fn = f.parent_fn,
                                         .mod = f.mod,
                                         .access_mod = f.access_mod,
                                         .is_global = f.is_global,
                                         .scope_level = f.scope_level,
                                         .is_c = f.is_c,
                                         .is_moved = f.is_moved,
                                         .line_nr = f.line_nr,
                                         .token_idx = f.token_idx,
                                         .is_for_var = f.is_for_var,
                                         .is_public = f.is_public,
                                     });
  };
  string q = _STR("update %.*ss set %.*s=", typ.name.len, typ.name.str,
                  field.len, field.str);
  p->is_sql = 1;
  _V_MulRet_string_V_string _V_mret_1593_set_typ_expr =
      compiler__Parser_tmp_expr(p);
  string set_typ = _V_mret_1593_set_typ_expr.var_0;
  string expr = _V_mret_1593_set_typ_expr.var_1;
  p->is_sql = 0;
  if (string_eq(set_typ, tos3("bool"))) {
    if (string_eq(string_trim_space(expr), tos3("1"))) {
      q = string_add(q, tos3("true"));
    } else {
      q = string_add(q, tos3("false"));
    };
  } else {
    q = string_add(q, expr);
  };
  if (p->tok == compiler__compiler__TokenKind_name &&
      string_eq(p->lit, tos3("where"))) {
    compiler__Parser_next(p);
    ;
    p->is_sql = 1;
    _V_MulRet_string_V_string _V_mret_1667___wexpr =
        compiler__Parser_tmp_expr(p);
    string wexpr = _V_mret_1667___wexpr.var_1;
    p->is_sql = 0;
    q = string_add(q, string_add(tos3(" where "), wexpr));
  };
  int nr_vals = 0;
  compiler__CGen_insert_before(p->cgen, _STR("char* params[%d];", nr_vals));
  compiler__CGen_set_placeholder(p->cgen, fn_ph, tos3("PQexecParams( "));
  printf("update q=\"%.*s\"\n", q.len, q.str);
  compiler__Parser_genln(p, _STR(".conn, \"%.*s\", %d, 0, params, 0, 0, 0)",
                                 q.len, q.str, nr_vals));
}
compiler__Scanner *compiler__new_scanner_file(string file_path) {
  if (!os__exists(file_path)) {
    compiler__verror(_STR("%.*s doesn't exist", file_path.len, file_path.str));
  };
  Option_string tmp1 = os__read_file(file_path);
  string raw_text;
  if (!tmp1.ok) {
    string err = tmp1.error;
    int errcode = tmp1.ecode;
    compiler__verror(
        _STR("scanner: failed to open %.*s", file_path.len, file_path.str));
    return 0;
  }
  raw_text = *(string *)tmp1.data;
  ;
  if (raw_text.len >= 3) {
    byte *c_text = raw_text.str;
    if (c_text[/*ptr!*/ 0] /*rbyte 0*/ == 0xEF &&
        c_text[/*ptr!*/ 1] /*rbyte 0*/ == 0xBB &&
        c_text[/*ptr!*/ 2] /*rbyte 0*/ == 0xBF) {
      int offset_from_begin = 3;
      raw_text = tos(&/*114*/ c_text[/*ptr!*/ offset_from_begin] /*rbyte 0*/,
                     vstrlen(c_text) - offset_from_begin);
    };
  };
  compiler__Scanner *s = compiler__new_scanner(raw_text);
  ;
  s->file_path = file_path;
  return s;
}
compiler__Scanner *compiler__new_scanner(string text) {
  return (compiler__Scanner *)memdup(
      &(compiler__Scanner){.text = text,
                           .print_line_on_error = 1,
                           .print_colored_error = 1,
                           .print_rel_paths_on_error = 1,
                           .file_path = tos3(""),
                           .pos = 0,
                           .line_nr = 0,
                           .last_nl_pos = 0,
                           .inside_string = 0,
                           .inter_start = 0,
                           .inter_end = 0,
                           .debug = 0,
                           .line_comment = tos3(""),
                           .started = 0,
                           .fmt_lines = new_array(0, 1, sizeof(string)),
                           .fmt_indent = 0,
                           .fmt_line_empty = 0,
                           .fn_name = tos3(""),
                           .quote = 0,
                           .line_ends = new_array(0, 1, sizeof(int)),
                           .nlines = 0,
                           .is_vh = 0,
                           .is_fmt = 0},
      sizeof(compiler__Scanner));
}
compiler__ScanRes compiler__scan_res(compiler__TokenKind tok, string lit) {
  return (compiler__ScanRes){.tok = tok, .lit = lit};
}
string compiler__Scanner_ident_name(compiler__Scanner *s) {
  int start = s->pos;
  s->pos++;
  while (s->pos < s->text.len &&
         (compiler__is_name_char(string_at(s->text, s->pos)) ||
          byte_is_digit(string_at(s->text, s->pos)))) {

    s->pos++;
  };
  string name = string_substr2(s->text, start, s->pos, false);
  s->pos--;
  return name;
}
string compiler__filter_num_sep(byte *txt, int start, int end) {
  {
    byte *b = v_malloc(end - start + 1);
    int i = start;
    int i1 = 0;
    while (i < end) {

      if (txt[/*ptr!*/ i] /*rbyte 0*/ != compiler__num_sep &&
          txt[/*ptr!*/ i] /*rbyte 0*/ != 'o') {
        b[/*ptr!*/ i1] /*rbyte 1*/ = txt[/*ptr!*/ i] /*rbyte 0*/;
        i1++;
      };
      i++;
    };
    b[/*ptr!*/ i1] /*rbyte 1*/ = 0;
    return (string){.str = b, .len = i1};
  };
}
string compiler__Scanner_ident_bin_number(compiler__Scanner *s) {
  bool has_wrong_digit = 0;
  byte first_wrong_digit = '\0';
  int start_pos = s->pos;
  s->pos += 2;
  while (s->pos < s->text.len) {

    byte c = string_at(s->text, s->pos);
    if (!byte_is_bin_digit(c) && c != compiler__num_sep) {
      if ((!byte_is_digit(c) && !byte_is_letter(c)) || s->inside_string) {
        break;
      } else if (!has_wrong_digit) {
        has_wrong_digit = 1;
        first_wrong_digit = c;
      };
    };
    s->pos++;
  };
  if (start_pos + 2 == s->pos) {
    compiler__Scanner_error(&/* ? */ *s,
                            tos3("number part of this binary is not provided"));
  } else if (has_wrong_digit) {
    compiler__Scanner_error(
        &/* ? */ *s,
        _STR("this binary number has unsuitable digit `%.*s`",
             byte_str(first_wrong_digit).len, byte_str(first_wrong_digit).str));
  };
  string number = compiler__filter_num_sep(s->text.str, start_pos, s->pos);
  s->pos--;
  return number;
}
string compiler__Scanner_ident_hex_number(compiler__Scanner *s) {
  bool has_wrong_digit = 0;
  byte first_wrong_digit = '\0';
  int start_pos = s->pos;
  s->pos += 2;
  while (s->pos < s->text.len) {

    byte c = string_at(s->text, s->pos);
    if (!byte_is_hex_digit(c) && c != compiler__num_sep) {
      if (!byte_is_letter(c) || s->inside_string) {
        break;
      } else if (!has_wrong_digit) {
        has_wrong_digit = 1;
        first_wrong_digit = c;
      };
    };
    s->pos++;
  };
  if (start_pos + 2 == s->pos) {
    compiler__Scanner_error(
        &/* ? */ *s, tos3("number part of this hexadecimal is not provided"));
  } else if (has_wrong_digit) {
    compiler__Scanner_error(
        &/* ? */ *s,
        _STR("this hexadecimal number has unsuitable digit `%.*s`",
             byte_str(first_wrong_digit).len, byte_str(first_wrong_digit).str));
  };
  string number = compiler__filter_num_sep(s->text.str, start_pos, s->pos);
  s->pos--;
  return number;
}
string compiler__Scanner_ident_oct_number(compiler__Scanner *s) {
  bool has_wrong_digit = 0;
  byte first_wrong_digit = '\0';
  int start_pos = s->pos;
  s->pos += 2;
  while (s->pos < s->text.len) {

    byte c = string_at(s->text, s->pos);
    if (!byte_is_oct_digit(c) && c != compiler__num_sep) {
      if ((!byte_is_digit(c) && !byte_is_letter(c)) || s->inside_string) {
        break;
      } else if (!has_wrong_digit) {
        has_wrong_digit = 1;
        first_wrong_digit = c;
      };
    };
    s->pos++;
  };
  if (start_pos + 2 == s->pos) {
    compiler__Scanner_error(&/* ? */ *s,
                            tos3("number part of this octal is not provided"));
  } else if (has_wrong_digit) {
    compiler__Scanner_error(
        &/* ? */ *s,
        _STR("this octal number has unsuitable digit `%.*s`",
             byte_str(first_wrong_digit).len, byte_str(first_wrong_digit).str));
  };
  string number = compiler__filter_num_sep(s->text.str, start_pos, s->pos);
  s->pos--;
  return number;
}
string compiler__Scanner_ident_dec_number(compiler__Scanner *s) {
  bool has_wrong_digit = 0;
  byte first_wrong_digit = '\0';
  int start_pos = s->pos;
  while (s->pos < s->text.len) {

    byte c = string_at(s->text, s->pos);
    if (!byte_is_digit(c) && c != compiler__num_sep) {
      if (!byte_is_letter(c) || (c == 'e' || c == 'E') || s->inside_string) {
        break;
      } else if (!has_wrong_digit) {
        has_wrong_digit = 1;
        first_wrong_digit = c;
      };
    };
    s->pos++;
  };
  if (compiler__Scanner_expect(&/* ? */ *s, tos3(".."), s->pos)) {
    string number = compiler__filter_num_sep(s->text.str, start_pos, s->pos);
    s->pos--;
    return number;
  };
  if (s->pos < s->text.len && string_at(s->text, s->pos) == '.') {
    s->pos++;
    while (s->pos < s->text.len) {

      byte c = string_at(s->text, s->pos);
      if (!byte_is_digit(c)) {
        if (!byte_is_letter(c) || (c == 'e' || c == 'E') || s->inside_string) {
          break;
        } else if (!has_wrong_digit) {
          has_wrong_digit = 1;
          first_wrong_digit = c;
        };
      };
      s->pos++;
    };
  };
  bool has_exponential_part = 0;
  if (compiler__Scanner_expect(&/* ? */ *s, tos3("e"), s->pos) ||
      compiler__Scanner_expect(&/* ? */ *s, tos3("E"), s->pos)) {
    s->pos++;
    int exp_start_pos = s->pos;
    if (s->pos < s->text.len && (string_at(s->text, s->pos) == '-' ||
                                 string_at(s->text, s->pos) == '+')) {
      s->pos++;
    };
    while (s->pos < s->text.len) {

      byte c = string_at(s->text, s->pos);
      if (!byte_is_digit(c)) {
        if (!byte_is_letter(c) || s->inside_string) {
          break;
        } else if (!has_wrong_digit) {
          has_wrong_digit = 1;
          first_wrong_digit = c;
        };
      };
      s->pos++;
    };
    if (exp_start_pos == s->pos) {
      compiler__Scanner_error(&/* ? */ *s, tos3("exponent has no digits"));
    };
    has_exponential_part = 1;
  };
  if (s->pos < s->text.len && string_at(s->text, s->pos) == '.') {
    if (has_exponential_part) {
      compiler__Scanner_error(&/* ? */ *s,
                              tos3("exponential part should be integer"));
    } else {
      compiler__Scanner_error(&/* ? */ *s,
                              tos3("too many decimal points in number"));
    };
  };
  if (has_wrong_digit) {
    compiler__Scanner_error(&/* ? */ *s,
                            _STR("this number has unsuitable digit `%.*s`",
                                 byte_str(first_wrong_digit).len,
                                 byte_str(first_wrong_digit).str));
  };
  string number = compiler__filter_num_sep(s->text.str, start_pos, s->pos);
  s->pos--;
  return number;
}
string compiler__Scanner_ident_number(compiler__Scanner *s) {
  if (compiler__Scanner_expect(&/* ? */ *s, tos3("0b"), s->pos)) {
    return compiler__Scanner_ident_bin_number(s);
  } else if (compiler__Scanner_expect(&/* ? */ *s, tos3("0x"), s->pos)) {
    return compiler__Scanner_ident_hex_number(s);
  } else if (compiler__Scanner_expect(&/* ? */ *s, tos3("0o"), s->pos)) {
    return compiler__Scanner_ident_oct_number(s);
  } else {
    return compiler__Scanner_ident_dec_number(s);
  };
}
void compiler__Scanner_skip_whitespace(compiler__Scanner *s) {
  while (s->pos < s->text.len && byte_is_space(string_at(s->text, s->pos))) {

    if (compiler__is_nl(string_at(s->text, s->pos)) && s->is_vh) {

      return;
    };
    if (compiler__is_nl(string_at(s->text, s->pos)) &&
        !compiler__Scanner_expect(&/* ? */ *s, tos3("\r\n"), s->pos - 1)) {
      compiler__Scanner_inc_line_number(s);
    };
    s->pos++;
  };
}
compiler__ScanRes compiler__Scanner_end_of_file(compiler__Scanner *s) {
  s->pos = s->text.len;
  compiler__Scanner_inc_line_number(s);
  return compiler__scan_res(compiler__compiler__TokenKind_eof, tos3(""));
}
compiler__ScanRes compiler__Scanner_scan(compiler__Scanner *s) {
  if (s->started) {
    s->pos++;
  };
  s->started = 1;
  if (s->pos >= s->text.len) {
    return compiler__Scanner_end_of_file(s);
  };
  if (!s->inside_string) {
    compiler__Scanner_skip_whitespace(s);
  };
  if (s->inter_end) {
    if (string_at(s->text, s->pos) == s->quote) {
      s->inter_end = 0;
      return compiler__scan_res(compiler__compiler__TokenKind_string, tos3(""));
    };
    s->inter_end = 0;
    return compiler__scan_res(compiler__compiler__TokenKind_string,
                              compiler__Scanner_ident_string(s));
  };
  compiler__Scanner_skip_whitespace(s);
  if (s->pos >= s->text.len) {
    return compiler__Scanner_end_of_file(s);
  };
  byte c = string_at(s->text, s->pos);
  byte nextc = '\0';
  if (s->pos + 1 < s->text.len) {
    nextc = string_at(s->text, s->pos + 1);
  };
  if (compiler__is_name_char(c)) {
    string name = compiler__Scanner_ident_name(s);
    byte next_char =
        ((s->pos + 1 < s->text.len) ? (string_at(s->text, s->pos + 1))
                                    : ('\0'));
    if (compiler__is_key(name)) {
      return compiler__scan_res(compiler__key_to_token(name), tos3(""));
    };
    if (s->inside_string) {
      if (next_char == s->quote) {
        s->inter_end = 1;
        s->inter_start = 0;
        s->inside_string = 0;
      };
    };
    if (s->inter_start && next_char != '.' && next_char != '(') {
      s->inter_end = 1;
      s->inter_start = 0;
    };
    if (s->pos == 0 && next_char == ' ') {
      s->pos++;
    };
    return compiler__scan_res(compiler__compiler__TokenKind_name, name);
  } else if (byte_is_digit(c) || (c == '.' && byte_is_digit(nextc))) {
    if (!s->inside_string) {
      int start_pos = s->pos;
      while (start_pos < s->text.len && string_at(s->text, start_pos) == '0') {

        start_pos++;
      };
      int prefix_zero_num = start_pos - s->pos;
      if (start_pos == s->text.len ||
          (c == '0' && !byte_is_digit(string_at(s->text, start_pos)))) {
        prefix_zero_num--;
      };
      s->pos += prefix_zero_num;
    };
    string num = compiler__Scanner_ident_number(s);
    return compiler__scan_res(compiler__compiler__TokenKind_number, num);
  };
  if (c == ')' && s->inter_start) {
    s->inter_end = 1;
    s->inter_start = 0;
    byte next_char =
        ((s->pos + 1 < s->text.len) ? (string_at(s->text, s->pos + 1))
                                    : ('\0'));
    if (next_char == s->quote) {
      s->inside_string = 0;
    };
    return compiler__scan_res(compiler__compiler__TokenKind_rpar, tos3(""));
  };
  byte tmp46 = c;

  if (tmp46 == '+') {
    if (nextc == '+') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_inc, tos3(""));
    } else if (nextc == '=') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_plus_assign,
                                tos3(""));
    };
    return compiler__scan_res(compiler__compiler__TokenKind_plus, tos3(""));
  } else if (tmp46 == '-') {
    if (nextc == '-') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_dec, tos3(""));
    } else if (nextc == '=') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_minus_assign,
                                tos3(""));
    };
    return compiler__scan_res(compiler__compiler__TokenKind_minus, tos3(""));
  } else if (tmp46 == '*') {
    if (nextc == '=') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_mult_assign,
                                tos3(""));
    };
    return compiler__scan_res(compiler__compiler__TokenKind_mul, tos3(""));
  } else if (tmp46 == '^') {
    if (nextc == '=') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_xor_assign,
                                tos3(""));
    };
    return compiler__scan_res(compiler__compiler__TokenKind_xor, tos3(""));
  } else if (tmp46 == '%') {
    if (nextc == '=') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_mod_assign,
                                tos3(""));
    };
    return compiler__scan_res(compiler__compiler__TokenKind_mod, tos3(""));
  } else if (tmp46 == '?') {
    return compiler__scan_res(compiler__compiler__TokenKind_question, tos3(""));
  } else if ((tmp46 == compiler__single_quote) ||
             (tmp46 == compiler__double_quote)) {
    return compiler__scan_res(compiler__compiler__TokenKind_string,
                              compiler__Scanner_ident_string(s));
  } else if (tmp46 == '`') {
    return compiler__scan_res(compiler__compiler__TokenKind_chartoken,
                              compiler__Scanner_ident_char(s));
  } else if (tmp46 == '(') {
    return compiler__scan_res(compiler__compiler__TokenKind_lpar, tos3(""));
  } else if (tmp46 == ')') {
    return compiler__scan_res(compiler__compiler__TokenKind_rpar, tos3(""));
  } else if (tmp46 == '[') {
    return compiler__scan_res(compiler__compiler__TokenKind_lsbr, tos3(""));
  } else if (tmp46 == ']') {
    return compiler__scan_res(compiler__compiler__TokenKind_rsbr, tos3(""));
  } else if (tmp46 == '{') {
    if (s->inside_string) {
      return compiler__Scanner_scan(s);
    };
    return compiler__scan_res(compiler__compiler__TokenKind_lcbr, tos3(""));
  } else if (tmp46 == '$') {
    if (s->inside_string) {
      return compiler__scan_res(compiler__compiler__TokenKind_str_dollar,
                                tos3(""));
    } else {
      return compiler__scan_res(compiler__compiler__TokenKind_dollar, tos3(""));
    };
  } else if (tmp46 == '}') {
    if (s->inside_string) {
      s->pos++;
      if (string_at(s->text, s->pos) == s->quote) {
        s->inside_string = 0;
        return compiler__scan_res(compiler__compiler__TokenKind_string,
                                  tos3(""));
      };
      return compiler__scan_res(compiler__compiler__TokenKind_string,
                                compiler__Scanner_ident_string(s));
    } else {
      return compiler__scan_res(compiler__compiler__TokenKind_rcbr, tos3(""));
    };
  } else if (tmp46 == '&') {
    if (nextc == '=') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_and_assign,
                                tos3(""));
    };
    if (nextc == '&') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_and, tos3(""));
    };
    return compiler__scan_res(compiler__compiler__TokenKind_amp, tos3(""));
  } else if (tmp46 == '|') {
    if (nextc == '|') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_logical_or,
                                tos3(""));
    };
    if (nextc == '=') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_or_assign,
                                tos3(""));
    };
    return compiler__scan_res(compiler__compiler__TokenKind_pipe, tos3(""));
  } else if (tmp46 == ',') {
    return compiler__scan_res(compiler__compiler__TokenKind_comma, tos3(""));
  } else if (tmp46 == '@') {
    s->pos++;
    string name = compiler__Scanner_ident_name(s);
    if (string_eq(name, tos3("FN"))) {
      return compiler__scan_res(compiler__compiler__TokenKind_string,
                                s->fn_name);
    };
    if (string_eq(name, tos3("FILE"))) {
      return compiler__scan_res(
          compiler__compiler__TokenKind_string,
          compiler__cescaped_path(os__realpath(s->file_path)));
    };
    if (string_eq(name, tos3("LINE"))) {
      return compiler__scan_res(compiler__compiler__TokenKind_string,
                                int_str((s->line_nr + 1)));
    };
    if (string_eq(name, tos3("COLUMN"))) {
      return compiler__scan_res(
          compiler__compiler__TokenKind_string,
          int_str((compiler__Scanner_current_column(&/* ? */ *s))));
    };
    if (string_eq(name, tos3("VHASH"))) {
      return compiler__scan_res(compiler__compiler__TokenKind_string,
                                compiler__vhash());
    };
    if (!compiler__is_key(name)) {
      compiler__Scanner_error(
          &/* ? */ *s,
          tos3("@ must be used before keywords (e.g. `@type string`)"));
    };
    return compiler__scan_res(compiler__compiler__TokenKind_name, name);
  } else if (tmp46 == '.') {
    if (nextc == '.') {
      s->pos++;
      if (string_at(s->text, s->pos + 1) == '.') {
        s->pos++;
        return compiler__scan_res(compiler__compiler__TokenKind_ellipsis,
                                  tos3(""));
      };
      return compiler__scan_res(compiler__compiler__TokenKind_dotdot, tos3(""));
    };
    return compiler__scan_res(compiler__compiler__TokenKind_dot, tos3(""));
  } else if (tmp46 == '#') {
    int start = s->pos + 1;
    compiler__Scanner_ignore_line(s);
    if (nextc == '!') {
      s->line_comment =
          string_trim_space(string_substr2(s->text, start + 1, s->pos, false));
      return compiler__Scanner_scan(s);
    };
    string hash = string_substr2(s->text, start, s->pos, false);
    return compiler__scan_res(compiler__compiler__TokenKind_hash,
                              string_trim_space(hash));
  } else if (tmp46 == '>') {
    if (nextc == '=') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_ge, tos3(""));
    } else if (nextc == '>') {
      if (s->pos + 2 < s->text.len && string_at(s->text, s->pos + 2) == '=') {
        s->pos += 2;
        return compiler__scan_res(
            compiler__compiler__TokenKind_righ_shift_assign, tos3(""));
      };
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_righ_shift,
                                tos3(""));
    } else {
      return compiler__scan_res(compiler__compiler__TokenKind_gt, tos3(""));
    };
  } else if (tmp46 == 0xE2) {
    if (nextc == 0x89 && string_at(s->text, s->pos + 2) == 0xA0) {
      s->pos += 2;
      return compiler__scan_res(compiler__compiler__TokenKind_ne, tos3(""));
    } else if (nextc == 0x89 && string_at(s->text, s->pos + 2) == 0xBD) {
      s->pos += 2;
      return compiler__scan_res(compiler__compiler__TokenKind_le, tos3(""));
    } else if (nextc == 0xA9 && string_at(s->text, s->pos + 2) == 0xBE) {
      s->pos += 2;
      return compiler__scan_res(compiler__compiler__TokenKind_ge, tos3(""));
    };
  } else if (tmp46 == '<') {
    if (nextc == '=') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_le, tos3(""));
    } else if (nextc == '<') {
      if (s->pos + 2 < s->text.len && string_at(s->text, s->pos + 2) == '=') {
        s->pos += 2;
        return compiler__scan_res(
            compiler__compiler__TokenKind_left_shift_assign, tos3(""));
      };
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_left_shift,
                                tos3(""));
    } else if (nextc == '-') {
      s->pos++;
      println(tos3("GOT ARR"));
      return compiler__scan_res(compiler__compiler__TokenKind_left_arrow,
                                tos3(""));
    } else {
      return compiler__scan_res(compiler__compiler__TokenKind_lt, tos3(""));
    };
  } else if (tmp46 == '=') {
    if (nextc == '=') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_eq, tos3(""));
    } else if (nextc == '>') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_arrow, tos3(""));
    } else {
      return compiler__scan_res(compiler__compiler__TokenKind_assign, tos3(""));
    };
  } else if (tmp46 == ':') {
    if (nextc == '=') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_decl_assign,
                                tos3(""));
    } else {
      return compiler__scan_res(compiler__compiler__TokenKind_colon, tos3(""));
    };
  } else if (tmp46 == ';') {
    return compiler__scan_res(compiler__compiler__TokenKind_semicolon,
                              tos3(""));
  } else if (tmp46 == '!') {
    if (nextc == '=') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_ne, tos3(""));
    } else {
      return compiler__scan_res(compiler__compiler__TokenKind_not, tos3(""));
    };
  } else if (tmp46 == '~') {
    return compiler__scan_res(compiler__compiler__TokenKind_bit_not, tos3(""));
  } else if (tmp46 == '/') {
    if (nextc == '=') {
      s->pos++;
      return compiler__scan_res(compiler__compiler__TokenKind_div_assign,
                                tos3(""));
    };
    if (nextc == '/') {
      int start = s->pos + 1;
      compiler__Scanner_ignore_line(s);
      s->line_comment = string_substr2(s->text, start + 1, s->pos, false);
      s->line_comment = string_trim_space(s->line_comment);
      if (s->is_fmt) {
        s->pos--;
        s->line_nr--;
        return compiler__scan_res(compiler__compiler__TokenKind_line_comment,
                                  s->line_comment);
      };
      return compiler__Scanner_scan(s);
    };
    if (nextc == '*') {
      int start = s->pos;
      int nest_count = 1;
      while (nest_count > 0) {

        s->pos++;
        if (s->pos >= s->text.len) {
          s->line_nr--;
          compiler__Scanner_error(&/* ? */ *s, tos3("comment not terminated"));
        };
        if (string_at(s->text, s->pos) == '\n') {
          compiler__Scanner_inc_line_number(s);
          continue;
        };
        if (compiler__Scanner_expect(&/* ? */ *s, tos3("/*"), s->pos)) {
          nest_count++;
          continue;
        };
        if (compiler__Scanner_expect(&/* ? */ *s, tos3("*/"), s->pos)) {
          nest_count--;
        };
      };
      s->pos++;
      int end = s->pos + 1;
      string comment = string_substr2(s->text, start, end, false);
      if (s->is_fmt) {
        s->line_comment = comment;
        return compiler__scan_res(compiler__compiler__TokenKind_mline_comment,
                                  s->line_comment);
      };
      return compiler__Scanner_scan(s);
    };
    return compiler__scan_res(compiler__compiler__TokenKind_div, tos3(""));
  } else // default:
  {
  };
#ifdef _WIN32
  if (c == '\0') {
    return compiler__Scanner_end_of_file(s);
  };
#endif
  ;
  compiler__Scanner_error(&/* ? */ *s, _STR("invalid character `%.*s`",
                                            byte_str(c).len, byte_str(c).str));
  return compiler__Scanner_end_of_file(s);
}
int compiler__Scanner_current_column(compiler__Scanner *s) {
  return s->pos - s->last_nl_pos;
}
int compiler__Scanner_count_symbol_before(compiler__Scanner s, int p,
                                          byte sym) {
  int count = 0;
  for (int i = p; i >= 0; i--) {

    if (string_at(s.text, i) != sym) {
      break;
    };
    count++;
  };
  return count;
}
string compiler__Scanner_ident_string(compiler__Scanner *s) {
  byte q = string_at(s->text, s->pos);
  bool is_quote = q == compiler__single_quote || q == compiler__double_quote;
  bool is_raw = is_quote && string_at(s->text, s->pos - 1) == 'r';
  if (is_quote && !s->inside_string) {
    s->quote = q;
  };
  int start = s->pos;
  s->inside_string = 0;
  byte slash = '\\';
  while (1) {
    s->pos++;
    if (s->pos >= s->text.len) {
      break;
    };
    byte c = string_at(s->text, s->pos);
    byte prevc = string_at(s->text, s->pos - 1);
    if (c == s->quote &&
        (prevc != slash ||
         (prevc == slash && string_at(s->text, s->pos - 2) == slash))) {
      break;
    };
    if (c == '\n') {
      compiler__Scanner_inc_line_number(s);
    };
    if (c == '0' && s->pos > 2 && string_at(s->text, s->pos - 1) == slash) {
      if (s->pos < s->text.len - 1 &&
          byte_is_digit(string_at(s->text, s->pos + 1))) {
      } else {
        compiler__Scanner_error(&/* ? */ *s,
                                tos3("0 character in a string literal"));
      };
    };
    if (c == '0' && s->pos > 5 &&
        compiler__Scanner_expect(&/* ? */ *s, tos3("\\x0"), s->pos - 3)) {
      compiler__Scanner_error(&/* ? */ *s,
                              tos3("0 character in a string literal"));
    };
    if (c == '{' && prevc == '$' && !is_raw && !s->is_fmt &&
        compiler__Scanner_count_symbol_before(*s, s->pos - 2, slash) % 2 == 0) {
      s->inside_string = 1;
      s->pos -= 2;
      break;
    };
    if (compiler__is_name_char(c) && prevc == '$' && !s->is_fmt && !is_raw &&
        compiler__Scanner_count_symbol_before(*s, s->pos - 2, slash) % 2 == 0) {
      s->inside_string = 1;
      s->inter_start = 1;
      s->pos -= 2;
      break;
    };
  };
  string lit = tos3("");
  if (string_at(s->text, start) == s->quote) {
    start++;
  };
  int end = s->pos;
  if (s->inside_string) {
    end++;
  };
  if (start > s->pos) {
  } else {
    lit = string_substr2(s->text, start, end, false);
  };
  return lit;
}
string compiler__Scanner_ident_char(compiler__Scanner *s) {
  int start = s->pos;
  byte slash = '\\';
  int len = 0;
  while (1) {
    s->pos++;
    if (s->pos >= s->text.len) {
      break;
    };
    if (string_at(s->text, s->pos) != slash) {
      len++;
    };
    bool double_slash =
        compiler__Scanner_expect(&/* ? */ *s, tos3("\\\\"), s->pos - 2);
    if (string_at(s->text, s->pos) == '`' &&
        (string_at(s->text, s->pos - 1) != slash || double_slash)) {
      if (double_slash) {
        len++;
      };
      break;
    };
  };
  len--;
  string c = string_substr2(s->text, start + 1, s->pos, false);
  if (len != 1) {
    ustring u = string_ustring(c);
    if (u.len != 1) {
      compiler__Scanner_error(
          &/* ? */ *s,
          string_add(
              tos3("invalid character literal (more than one character)\n"),
              tos3("use quotes for strings, backticks for characters")));
    };
  };
  if (string_eq(c, tos3("\\`"))) {
    return tos3("`");
  };
  return ((string_eq(c, tos3("\'"))) ? (string_add(tos3("\\"), c)) : (c));
}
bool compiler__Scanner_expect(compiler__Scanner *s, string want,
                              int start_pos) {
  int end_pos = start_pos + want.len;
  if (start_pos < 0 || start_pos >= s->text.len) {
    return 0;
  };
  if (end_pos < 0 || end_pos > s->text.len) {
    return 0;
  };
  int tmp99 = start_pos;
  ;
  for (int tmp100 = tmp99; tmp100 < end_pos; tmp100++) {
    int pos = tmp100;

    if (string_at(s->text, pos) != string_at(want, pos - start_pos)) {
      return 0;
    };
  };
  return 1;
}
void compiler__Scanner_debug_tokens(compiler__Scanner *s) {
  s->pos = 0;
  s->started = 0;
  s->debug = 1;
  string fname = string_all_after(s->file_path, os__path_separator);
  printf("\n===DEBUG TOKENS %.*s===\n", fname.len, fname.str);
  while (1) {
    compiler__ScanRes res = compiler__Scanner_scan(s);
    compiler__TokenKind tok = res.tok;
    string lit = res.lit;
    print(compiler__TokenKind_str(tok));
    if (string_ne(lit, tos3(""))) {
      printf(" `%.*s`\n", lit.len, lit.str);
    } else {
      println(tos3(""));
    };
    if (tok == compiler__compiler__TokenKind_eof) {
      println(tos3("============ END OF DEBUG TOKENS =================="));
      break;
    };
  };
}
void compiler__Scanner_ignore_line(compiler__Scanner *s) {
  compiler__Scanner_eat_to_end_of_line(s);
  compiler__Scanner_inc_line_number(s);
}
void compiler__Scanner_eat_to_end_of_line(compiler__Scanner *s) {
  while (s->pos < s->text.len && string_at(s->text, s->pos) != '\n') {

    s->pos++;
  };
}
void compiler__Scanner_inc_line_number(compiler__Scanner *s) {
  s->last_nl_pos = s->pos;
  s->line_nr++;
  _PUSH(&s->line_ends, (/*typ = array_int   tmp_typ=int*/ s->pos), tmp107, int);
  if (s->line_nr > s->nlines) {
    s->nlines = s->line_nr;
  };
}
string compiler__Scanner_line(compiler__Scanner s, int n) {
  string res = tos3("");
  if (n >= 0 && n < s.line_ends.len) {
    int nline_start =
        ((n == 0) ? (0) : ((*(int *)array_get(s.line_ends, n - 1))));
    int nline_end = (*(int *)array_get(s.line_ends, n));
    if (nline_start <= nline_end) {
      res = string_substr2(s.text, nline_start, nline_end, false);
    };
  };
  return string_trim_left(string_trim_right(res, tos3("\r\n")), tos3("\r\n"));
}
bool compiler__is_name_char(byte c) {
  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
}
static inline bool compiler__is_nl(byte c) { return c == '\r' || c == '\n'; }
bool compiler__contains_capital(string s) {
  string tmp114 = s;
  ;
  for (int tmp115 = 0; tmp115 < tmp114.len; tmp115++) {
    byte c = tmp114.str[tmp115];

    if (c >= 'A' && c <= 'Z') {
      return 1;
    };
  };
  return 0;
}
bool compiler__good_type_name(string s) {
  if (s.len < 4) {
    return 1;
  };
  int tmp116 = 2;
  ;
  for (int tmp117 = tmp116; tmp117 < s.len; tmp117++) {
    int i = tmp117;

    if (byte_is_capital(string_at(s, i)) &&
        byte_is_capital(string_at(s, i - 1)) &&
        byte_is_capital(string_at(s, i - 2))) {
      return 0;
    };
  };
  return 1;
}
void compiler__Parser_string_expr(compiler__Parser *p) {
  bool is_raw = p->tok == compiler__compiler__TokenKind_name &&
                string_eq(p->lit, tos3("r"));
  bool is_cstr = p->tok == compiler__compiler__TokenKind_name &&
                 string_eq(p->lit, tos3("c"));
  if (is_raw || is_cstr) {
    compiler__Parser_next(p);
  };
  string str = p->lit;
  if (compiler__Parser_peek(&/* ? */ *p) !=
          compiler__compiler__TokenKind_str_dollar ||
      is_raw) {
    string f = ((is_raw) ? (string_replace(compiler__cescaped_path(str),
                                           tos3("\""), tos3("\\\"")))
                         : (compiler__format_str(str)));
    if ((p->calling_c && compiler__Parser_peek(&/* ? */ *p) !=
                             compiler__compiler__TokenKind_dot) ||
        is_cstr || (p->pref->translated && string_eq(p->mod, tos3("main")))) {
      if (p->os == v_dot_pref__v_dot_pref__OS_windows &&
          string_eq(p->mod, tos3("ui"))) {
        compiler__Parser_gen(p, _STR("L\"%.*s\"", f.len, f.str));
      } else {
        compiler__Parser_gen(p, _STR("\"%.*s\"", f.len, f.str));
      };
    } else if (p->is_sql) {
      compiler__Parser_gen(p, _STR("'%.*s'", str.len, str.str));
    } else if (p->is_js) {
      compiler__Parser_gen(p, _STR("tos(\"%.*s\")", f.len, f.str));
    } else {
      compiler__Parser_gen(p, _STR("tos3(\"%.*s\")", f.len, f.str));
    };
    compiler__Parser_next(p);
    if (p->scanner->is_fmt && p->tok == compiler__compiler__TokenKind_not) {
      ;
      compiler__Parser_check(p, compiler__compiler__TokenKind_not);
    };

    return;
  };
#ifdef _VJS
#endif
  ;
  p->is_alloc = 1;
  string args = tos3("\"");
  string format = tos3("\"");
  bool complex_inter = 0;
  while (p->tok == compiler__compiler__TokenKind_string) {

    p->lit = string_replace(p->lit, tos3("%"), tos3("%%"));
    format = string_add(format, compiler__format_str(p->lit));
    compiler__Parser_next(p);
    if (p->tok != compiler__compiler__TokenKind_str_dollar) {
      continue;
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_str_dollar);
    if (compiler__Parser_peek(&/* ? */ *p) !=
        compiler__compiler__TokenKind_string) {
      ;
      complex_inter = 1;
    };
    _V_MulRet_string_V_string _V_mret_345_typ_val_ =
        compiler__Parser_tmp_expr(p);
    string typ = _V_mret_345_typ_val_.var_0;
    string val_ = _V_mret_345_typ_val_.var_1;
    string val = string_trim_space(val_);
    args = string_add(args, _STR(", %.*s", val.len, val.str));
    if (string_eq(typ, tos3("string"))) {
      args = string_add(args, _STR(".len, %.*s.str", val.len, val.str));
    };
    if (string_eq(typ, tos3("ustring"))) {
      args = string_add(args, _STR(".len, %.*s.s.str", val.len, val.str));
    };
    if (string_eq(typ, tos3("bool"))) {
    };
    bool custom = p->tok == compiler__compiler__TokenKind_colon;
    if (custom) {
      string cformat = tos3("");
      compiler__Parser_next(p);
      if (p->tok == compiler__compiler__TokenKind_dot) {
        cformat = string_add(cformat, tos3("."));
        compiler__Parser_next(p);
      };
      if (p->tok == compiler__compiler__TokenKind_minus) {
        cformat = string_add(cformat, tos3("-"));
        compiler__Parser_next(p);
      };
      cformat = string_add(cformat, p->lit);
      compiler__Parser_next(p);
      string fspec = p->lit;
      cformat = string_add(cformat, fspec);
      if (string_eq(fspec, tos3("s"))) {
        if (string_ne(typ, tos3("string"))) {
          compiler__Parser_error(
              p, _STR("only V strings can be formatted with a :%.*s format, "
                      "but you have given \"%.*s\", which has type %.*s",
                      cformat.len, cformat.str, val.len, val.str, typ.len,
                      typ.str));
        };
        args = string_add(
            string_all_before_last(args, _STR("%.*s.len, %.*s.str", val.len,
                                              val.str, val.len, val.str)),
            _STR("%.*s.str", val.len, val.str));
      };
      format = string_add(format, _STR("%%%.*s", cformat.len, cformat.str));
      compiler__Parser_next(p);
    } else {
      string f = compiler__Parser_typ_to_fmt(p, typ, 0);
      if (string_eq(f, tos3(""))) {
        _V_MulRet_bool_V_string _V_mret_544_has_str_method_styp =
            compiler__Parser_gen_default_str_method_if_missing(p, typ);
        bool has_str_method = _V_mret_544_has_str_method_styp.var_0;
        string styp = _V_mret_544_has_str_method_styp.var_1;
        if (has_str_method) {
          string tmp_var = compiler__Parser_get_tmp(p);
          compiler__CGen_insert_before(
              p->cgen, _STR("string %.*s = %.*s_str(%.*s);", tmp_var.len,
                            tmp_var.str, styp.len, styp.str, val.len, val.str));
          args = string_add(string_all_before_last(args, val),
                            _STR("%.*s.len, %.*s.str", tmp_var.len, tmp_var.str,
                                 tmp_var.len, tmp_var.str));
          format = string_add(format, tos3("%.*s "));
        } else {
          compiler__Parser_error(
              p, _STR("unhandled sprintf format \"%.*s\" ", typ.len, typ.str));
        };
      };
      format = string_add(format, f);
    };
  };
  if (complex_inter) {
    ;
  };
  if (p->cgen->nogen) {

    return;
  };
#ifndef _WIN32
#endif
  ;
  if (p->tok == compiler__compiler__TokenKind_not) {
    ;
    compiler__Parser_check(p, compiler__compiler__TokenKind_not);
    compiler__Parser_gen(p, _STR("_STR_TMP(%.*s%.*s)", format.len, format.str,
                                 args.len, args.str));
  } else {
    compiler__Parser_gen(
        p, _STR("_STR(%.*s%.*s)", format.len, format.str, args.len, args.str));
  };
}
void compiler__Parser_struct_decl(compiler__Parser *p,
                                  array_string generic_param_types) {
  int decl_tok_idx = compiler__Parser_cur_tok_index(&/* ? */ *p);
  bool is_pub = p->tok == compiler__compiler__TokenKind_key_pub;
  if (is_pub) {
    compiler__Parser_next(p);
    ;
  };
  bool is_objc = string_starts_with(p->attr, tos3("objc_interface"));
  string objc_parent =
      ((is_objc) ? (string_substr2(p->attr, 15, -1, true)) : (tos3("")));
  bool is_interface = p->tok == compiler__compiler__TokenKind_key_interface;
  bool is_union = p->tok == compiler__compiler__TokenKind_key_union;
  bool is_struct = p->tok == compiler__compiler__TokenKind_key_struct;
  compiler__TypeCategory cat = compiler__key_to_type_cat(p->tok);
  if (is_objc) {
    cat = compiler__compiler__TypeCategory_objc_interface;
  };
  compiler__Parser_next(p);
  ;
  string name = compiler__Parser_check_name(p);
  if (string_contains(name, tos3("_")) && !p->pref->translated) {
    compiler__Parser_error(p, tos3("type names cannot contain `_`"));
  };
  if (!p->builtin_mod && !byte_is_capital(string_at(name, 0))) {
    compiler__Parser_error(
        p, _STR("mod=%.*s struct names must be capitalized: use `struct %.*s`",
                p->mod.len, p->mod.str, string_capitalize(name).len,
                string_capitalize(name).str));
  };
  if (is_interface && !string_ends_with(name, tos3("er")) &&
      string_at(name, 0) != 'I') {
    compiler__Parser_error(p, tos3("interface names temporarily have to end "
                                   "with `er` (e.g. `Speaker`, `Reader`)"));
  };
  map_string generic_types = new_map(1, sizeof(string));
  bool is_generic = 0;
  if (p->tok == compiler__compiler__TokenKind_lt) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_lt);
    for (int i = 0;; i++) {

      if (generic_param_types.len > 0 && i > generic_param_types.len - 1) {
        compiler__Parser_error(p, tos3("mismatched generic type params"));
      };
      string type_param = compiler__Parser_check_name(p);
      map_set(
          &generic_types, type_param,
          &(string[]){((generic_param_types.len > 0)
                           ? ((*(string *)array_get(generic_param_types, i)))
                           : (tos3("")))});
      if (p->tok != compiler__compiler__TokenKind_comma) {
        break;
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
    };
    compiler__Parser_check(p, compiler__compiler__TokenKind_gt);
    is_generic = 1;
  };
  bool is_generic_instance = is_generic && generic_param_types.len > 0;
  bool is_c =
      string_eq(name, tos3("C")) && p->tok == compiler__compiler__TokenKind_dot;
  if (is_c) {
    compiler__Parser_check(p, compiler__compiler__TokenKind_dot);
    name = compiler__Parser_check_name(p);
    cat = compiler__compiler__TypeCategory_c_struct;
    if (string_eq(p->attr, tos3("typedef"))) {
      cat = compiler__compiler__TypeCategory_c_typedef;
    };
  };
  if (name.len == 1 && !p->pref->building_v && !p->pref->is_repl) {
    compiler__Parser_warn(p, _STR("struct names must have more than one "
                                  "character (\"%.*s\", len=%d, %d)",
                                  name.len, name.str, name.len,
                                  p->pref->building_v));
  };
  if (!is_c && !compiler__good_type_name(name)) {
    compiler__Parser_error(p, tos3("bad struct name, e.g. use `HttpRequest` "
                                   "instead of `HTTPRequest`"));
  };
  if (!is_c && !p->builtin_mod && string_ne(p->mod, tos3("main"))) {
    name = compiler__Parser_prepend_mod(&/* ? */ *p, name);
  };
  compiler__Type typ = compiler__Table_find_type(&/* ? */ *p->table, name);
  if (p->pass == compiler__compiler__Pass_decl &&
      compiler__Table_known_type_fast(&/* ? */ *p->table, &/*114*/ typ)) {
    compiler__Parser_error(p,
                           _STR("type `%.*s` redeclared", name.len, name.str));
  };
  if (is_objc) {
    compiler__Parser_gen_typedef(p, _STR("@class %.*s;", name.len, name.str));
  } else if (!is_c) {
    string kind = ((is_union) ? (tos3("union")) : (tos3("struct")));
    compiler__Parser_gen_typedef(p, _STR("typedef %.*s %.*s %.*s;", kind.len,
                                         kind.str, name.len, name.str, name.len,
                                         name.str));
  };
  Option_int tmp9 =
      compiler__V_get_file_parser_index(&/* ? */ *p->v, p->file_path);
  int parser_idx;
  if (!tmp9.ok) {
    string err = tmp9.error;
    int errcode = tmp9.ecode;
  }
  if (tmp9.ok) {
    parser_idx = *(int *)tmp9.data;
  } else {
    parser_idx = 0;
  };
  bool is_ph = 0;
  if (typ.is_placeholder) {
    is_ph = 1;
    typ.name = name;
    typ.mod = p->mod;
    typ.is_c = is_c;
    typ.is_placeholder = 0;
    typ.cat = cat;
    typ.parent = objc_parent;
    typ.is_public = is_pub || p->is_vh;
    typ.is_generic = is_generic && !is_generic_instance;
    typ.decl_tok_idx = decl_tok_idx;
    typ.parser_idx = parser_idx;
    compiler__Table_rewrite_type(p->table, typ);
  } else {
    typ = (compiler__Type){.name = name,
                           .mod = p->mod,
                           .is_c = is_c,
                           .cat = cat,
                           .parent = objc_parent,
                           .is_public = is_pub || p->is_vh,
                           .is_generic = is_generic && !is_generic_instance,
                           .decl_tok_idx = decl_tok_idx,
                           .parser_idx = parser_idx,
                           .fields = new_array(0, 1, sizeof(compiler__Var)),
                           .methods = new_array(0, 1, sizeof(compiler__Fn)),
                           .enum_vals = new_array(0, 1, sizeof(string)),
                           .gen_types = new_array(0, 1, sizeof(string)),
                           .default_vals = new_array(0, 1, sizeof(string)),
                           .is_placeholder = 0,
                           .gen_str = 0,
                           .is_flag = 0,
                           .ctype_names = new_array(0, 1, sizeof(string))};
  };
  if (is_c && is_struct && p->tok != compiler__compiler__TokenKind_lcbr) {
    compiler__Table_register_type(p->table, typ);

    return;
  };
  if (is_generic) {
    if (!is_generic_instance) {
      compiler__Table_register_type(p->table, typ);
      map_set(&p->table->generic_struct_params, typ.name,
              &(array_string[]){map_keys(&/* ? */ generic_types)});
      compiler__Parser_skip_block(p, 0);

      return;
    } else {
      compiler__Type_rename_generic_struct(&/* ? */ typ, generic_types);
    };
  };
  ;
  compiler__Parser_check(p, compiler__compiler__TokenKind_lcbr);
  compiler__AccessMod access_mod = compiler__compiler__AccessMod_private;
  array_string names = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  int tmp10 = 0;
  bool tmp11 =
      map_get(/*struct.v : 169*/ p->table->max_field_len, name, &tmp10);

  int fmt_max_len = tmp10;
  if ((!is_ph && compiler__Parser_first_pass(&/* ? */ *p)) || is_generic) {
    compiler__Table_register_type(p->table, typ);
  };
  bool did_gen_something = 0;
  array_compiler__AccessMod used = new_array_from_c_array(
      0, 0, sizeof(compiler__AccessMod),
      EMPTY_ARRAY_OF_ELEMS(compiler__AccessMod, 0){TCCSKIP(0)});
  int i = -1;
  while (p->tok != compiler__compiler__TokenKind_rcbr) {

    i++;
    compiler__AccessMod new_access_mod = access_mod;
    if (p->tok == compiler__compiler__TokenKind_key_pub) {
      ;
      compiler__Parser_check(p, compiler__compiler__TokenKind_key_pub);
      if (p->tok == compiler__compiler__TokenKind_key_mut) {
        ;
        new_access_mod = compiler__compiler__AccessMod_public_mut;
        compiler__Parser_next(p);
      } else {
        new_access_mod = compiler__compiler__AccessMod_public;
      };
      if ((_IN(compiler__AccessMod, (new_access_mod), used))) {
        compiler__Parser_error(
            p, tos3("structs can only have one `pub:`/`pub mut:`, all public "
                    "fields have to be grouped"));
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_colon);
      ;
      ;
    } else if (p->tok == compiler__compiler__TokenKind_key_mut) {
      new_access_mod = compiler__compiler__AccessMod_private_mut;
      if ((_IN(compiler__AccessMod, (new_access_mod), used))) {
        compiler__Parser_error(
            p, tos3("structs can only have one `mut:`, all private mutable "
                    "fields have to be grouped"));
      };
      ;
      compiler__Parser_check(p, compiler__compiler__TokenKind_key_mut);
      compiler__Parser_check(p, compiler__compiler__TokenKind_colon);
      ;
      ;
    } else if (p->tok == compiler__compiler__TokenKind_key_global) {
      new_access_mod = compiler__compiler__AccessMod_global;
      if ((_IN(compiler__AccessMod, (new_access_mod), used))) {
        compiler__Parser_error(p, tos3("structs can only have one `__global:`, "
                                       "all global fields have to be grouped"));
      };
      ;
      compiler__Parser_check(p, compiler__compiler__TokenKind_key_global);
      compiler__Parser_check(p, compiler__compiler__TokenKind_colon);
      ;
      ;
    };
    if (new_access_mod != access_mod) {
      _PUSH(&used,
            (/*typ = array_compiler__AccessMod   tmp_typ=compiler__AccessMod*/
             new_access_mod),
            tmp12, compiler__AccessMod);
    };
    access_mod = new_access_mod;
    int field_name_token_idx = compiler__Parser_cur_tok_index(&/* ? */ *p);
    string field_name =
        ((string_ne(name, tos3("Option")) && !is_interface)
             ? (compiler__Table_var_cgen_name(&/* ? */ *p->table,
                                              compiler__Parser_check_name(p)))
             : (compiler__Parser_check_name(p)));
    if (p->pass == compiler__compiler__Pass_main) {
      ;
    };
    if ((_IN(string, (field_name), names))) {
      compiler__Parser_error(
          p, _STR("duplicate field `%.*s`", field_name.len, field_name.str));
    };
    if (p->scanner->is_fmt && p->pass == compiler__compiler__Pass_decl &&
        field_name.len > fmt_max_len) {
      fmt_max_len = field_name.len;
    };
    if (!is_c && string_ne(p->mod, tos3("os")) &&
        compiler__contains_capital(field_name)) {
      compiler__Parser_error(p, tos3("struct fields cannot contain uppercase "
                                     "letters, use snake_case instead"));
    };
    _PUSH(&names, (/*typ = array_string   tmp_typ=string*/ field_name), tmp13,
          string);
    if (is_interface) {
      compiler__Fn *f = compiler__Parser_interface_method(p, field_name, name);
      if (compiler__Parser_first_pass(&/* ? */ *p)) {
        compiler__Parser_add_method(p, typ.name, *f);
      };
      continue;
    };
    ;
    if (is_generic_instance) {
      p->generic_dispatch =
          (compiler__TypeInst){.inst = generic_types, .done = 0};
    };
    compiler__Type tt = compiler__Parser_get_type2(p);
    string field_type = tt.name;
    if (string_eq(field_type, name)) {
      compiler__Parser_error_with_token_index(
          p,
          _STR("cannot embed struct `%.*s` in itself (field `%.*s`)", name.len,
               name.str, field_name.len, field_name.str),
          field_name_token_idx);
    };
    if (string_starts_with(field_type, tos3("Option_"))) {
      compiler__Parser_gen_typedef(
          p, _STR("typedef Option %.*s;", field_type.len, field_type.str));
    };
    compiler__Parser_check_and_register_used_imported_type(p, field_type);
    bool is_atomic = p->tok == compiler__compiler__TokenKind_key_atomic;
    if (is_atomic) {
      compiler__Parser_next(p);
    };
    if (p->tok == compiler__compiler__TokenKind_assign) {
      compiler__Parser_next(p);
      _V_MulRet_string_V_string _V_mret_1341_def_val_type_expr =
          compiler__Parser_tmp_expr(p);
      string def_val_type = _V_mret_1341_def_val_type_expr.var_0;
      string expr = _V_mret_1341_def_val_type_expr.var_1;
      if (string_ne(def_val_type, field_type)) {
        compiler__Parser_error(p, _STR("expected `%.*s` but got `%.*s`",
                                       field_type.len, field_type.str,
                                       def_val_type.len, def_val_type.str));
      };
      if (!compiler__Parser_first_pass(&/* ? */ *p)) {
        compiler__Table_add_default_val(p->table, i, typ.name, expr);
      };
    };
    string attr = tos3("");
    if (p->tok == compiler__compiler__TokenKind_lsbr) {
      ;
      compiler__Parser_next(p);
      attr = compiler__Parser_check_name(p);
      if (p->tok == compiler__compiler__TokenKind_colon) {
        compiler__Parser_check(p, compiler__compiler__TokenKind_colon);
        string val = tos3("");
        compiler__TokenKind tmp14 = p->tok;

        if (tmp14 == compiler__compiler__TokenKind_name) {
          val = compiler__Parser_check_name(p);
        } else if (tmp14 == compiler__compiler__TokenKind_string) {
          val = compiler__Parser_check_string(p);
        } else // default:
        {
          compiler__Parser_error(
              p, tos3("attribute value should be either name or string"));
        };
        attr = string_add(attr, string_add(tos3(":"), val));
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_rsbr);
    };
    if (string_eq(attr, tos3("raw")) && string_ne(field_type, tos3("string"))) {
      compiler__Parser_error(p,
                             _STR("struct field with attribute \"raw\" should "
                                  "be of type \"string\" but got \"%.*s\"",
                                  field_type.len, field_type.str));
    };
    did_gen_something = 1;
    bool is_mut = (access_mod == compiler__compiler__AccessMod_private_mut ||
                   access_mod == compiler__compiler__AccessMod_public_mut ||
                   access_mod == compiler__compiler__AccessMod_global);
    if (compiler__Parser_first_pass(&/* ? */ *p) || is_generic) {
      compiler__Table_add_field(p->table, typ.name, field_name, field_type,
                                is_mut, attr, access_mod);
    };
    ;
    {
      if (is_generic_instance) {
        p->generic_dispatch =
            (compiler__TypeInst){.inst = new_map(1, sizeof(string)), .done = 0};
      };
    }
  };
  if (p->scanner->is_fmt && p->pass == compiler__compiler__Pass_decl) {
    map_set(&p->table->max_field_len, typ.name, &(int[]){fmt_max_len});
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
  if (!is_c && !did_gen_something && compiler__Parser_first_pass(&/* ? */ *p)) {
    compiler__Table_add_field(p->table, typ.name, tos3(""),
                              tos3("EMPTY_STRUCT_DECLARATION"), 0, tos3(""),
                              compiler__compiler__AccessMod_private);
  };
  ;
  ;
}
string compiler__Parser_struct_init(compiler__Parser *p, string typ_) {
  p->is_struct_init = 1;
  string typ = typ_;
  compiler__Type t = compiler__Table_find_type(&/* ? */ *p->table, typ);
  if (!t.is_public && string_ne(t.mod, p->mod)) {
    compiler__Parser_error(
        p, _STR("struct `%.*s` is private", t.name.len, t.name.str));
  };
  if (compiler__Parser_peek(&/* ? */ *p) == compiler__compiler__TokenKind_lt) {
    compiler__Parser_next(p);
    compiler__Parser_check(p, compiler__compiler__TokenKind_lt);
    array_string type_params = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    while (1) {
      string type_param = compiler__Parser_check_name(p);
      if ((_IN_MAP((type_param), p->generic_dispatch.inst))) {
        string tmp15 = tos3("");
        bool tmp16 = map_get(/*struct.v : 356*/ p->generic_dispatch.inst,
                             type_param, &tmp15);

        if (!tmp16)
          tmp15 = tos((byte *)"", 0);

        type_param = tmp15;
      };
      _PUSH(&type_params, (/*typ = array_string   tmp_typ=string*/ type_param),
            tmp17, string);
      if (p->tok != compiler__compiler__TokenKind_comma) {
        break;
      };
      compiler__Parser_check(p, compiler__compiler__TokenKind_comma);
    };
    compiler__Parser_dispatch_generic_struct(p, &/*114*/ t, type_params);
    t = compiler__Table_find_type(&/* ? */ *p->table, t.name);
    typ = t.name;
  };
  if (compiler__Parser_gen_struct_init(p, typ, &t)) {
    return typ;
  };
  bool ptr = string_contains(typ, tos3("*"));
  bool did_gen_something = 0;
  array_string inited_fields = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  compiler__TokenKind peek = compiler__Parser_peek(&/* ? */ *p);
  if (peek == compiler__compiler__TokenKind_colon ||
      p->tok == compiler__compiler__TokenKind_rcbr) {
    while (p->tok != compiler__compiler__TokenKind_rcbr) {

      string field =
          ((string_ne(typ, tos3("Option")))
               ? (compiler__Table_var_cgen_name(&/* ? */ *p->table,
                                                compiler__Parser_check_name(p)))
               : (compiler__Parser_check_name(p)));
      if (!compiler__Parser_first_pass(&/* ? */ *p) &&
          !compiler__Type_has_field(&/* ? */ t, field)) {
        compiler__Parser_error(p, _STR("`%.*s` has no field `%.*s`", t.name.len,
                                       t.name.str, field.len, field.str));
      };
      if ((_IN(string, (field), inited_fields))) {
        compiler__Parser_error(
            p, _STR("already initialized field `%.*s` in `%.*s`", field.len,
                    field.str, t.name.len, t.name.str));
      };
      Option_compiler__Var tmp18 = compiler__Type_find_field(&/* ? */ t, field);
      compiler__Var f;
      if (!tmp18.ok) {
        string err = tmp18.error;
        int errcode = tmp18.ecode;
        compiler__Parser_error(p, _STR("no such field: \"%.*s\" in type %.*s",
                                       field.len, field.str, typ.len, typ.str));
        break;
      }
      f = *(compiler__Var *)tmp18.data;
      ;
      compiler__Type tt = compiler__Table_find_type(&/* ? */ *p->table, f.typ);
      if (tt.is_flag) {
        compiler__Parser_error(p, compiler__err_modify_bitfield);
      };
      _PUSH(&inited_fields, (/*typ = array_string   tmp_typ=string*/ field),
            tmp19, string);
      compiler__Parser_gen_struct_field_init(p, field);
      compiler__Parser_check(p, compiler__compiler__TokenKind_colon);
      ;
      p->expected_type = f.typ;
      compiler__Parser_check_types(p, compiler__Parser_bool_expression(p),
                                   f.typ);
      if (p->tok == compiler__compiler__TokenKind_comma) {
        compiler__Parser_next(p);
        ;
      };
      if (p->tok != compiler__compiler__TokenKind_rcbr) {
        compiler__Parser_gen(p, tos3(","));
      };
      ;
      did_gen_something = 1;
      ;
    };
    if (t.fields.len != inited_fields.len && inited_fields.len > 0) {
      compiler__Parser_gen(p, tos3(","));
    };
    array_compiler__Var tmp20 = t.fields;
    for (int i = 0; i < tmp20.len; i++) {
      compiler__Var field = ((compiler__Var *)tmp20.data)[i];

      string sanitized_name =
          ((string_ne(typ, tos3("Option")))
               ? (compiler__Table_var_cgen_name(&/* ? */ *p->table, field.name))
               : (field.name));
      if ((_IN(string, (sanitized_name), inited_fields))) {
        continue;
      };
      string field_typ = field.typ;
      if (!p->builtin_mod && string_ends_with(field_typ, tos3("*")) &&
          !p->is_c_struct_init && string_ne(p->mod, tos3("os")) &&
          string_ne(p->mod, tos3("ui"))) {
        compiler__Parser_warn(
            p, _STR("reference field `%.*s.%.*s` must be initialized", typ.len,
                    typ.str, field.name.len, field.name.str));
      };
      if (string_starts_with(field_typ, tos3("map_"))) {
        compiler__Parser_gen_struct_field_init(p, sanitized_name);
        compiler__Parser_gen_empty_map(
            p, compiler__parse_pointer(string_substr2(field_typ, 4, -1, true)));
        _PUSH(&inited_fields,
              (/*typ = array_string   tmp_typ=string*/ sanitized_name), tmp23,
              string);
        if (i != t.fields.len - 1) {
          compiler__Parser_gen(p, tos3(","));
        };
        did_gen_something = 1;
        continue;
      };
      string def_val =
          ((t.default_vals.len > i &&
            string_ne((*(string *)array_get(t.default_vals, i)), tos3("")))
               ? ((*(string *)array_get(t.default_vals, i)))
               : (compiler__type_default(field_typ)));
      if (string_ne(def_val, tos3("")) && string_ne(def_val, tos3("{0}"))) {
        compiler__Parser_gen_struct_field_init(p, sanitized_name);
        compiler__Parser_gen(p, def_val);
        if (i != t.fields.len - 1) {
          compiler__Parser_gen(p, tos3(","));
        };
        did_gen_something = 1;
      };
    };
  } else {
    compiler__Type T = compiler__Table_find_type(&/* ? */ *p->table, typ);
    if (T.fields.len == 0 && string_ne(T.parent, tos3(""))) {
      T = compiler__Table_find_type(&/* ? */ *p->table, T.parent);
    };
    array_compiler__Var tmp28 = T.fields;
    for (int i = 0; i < tmp28.len; i++) {
      compiler__Var ffield = ((compiler__Var *)tmp28.data)[i];

      string expr_typ = compiler__Parser_bool_expression(p);
      if (!compiler__Parser_check_types_no_throw(p, expr_typ, ffield.typ)) {
        compiler__Parser_error(
            p, _STR("field value #%d `%.*s` has type `%.*s`, got `%.*s` ",
                    i + 1, ffield.name.len, ffield.name.str, ffield.typ.len,
                    ffield.typ.str, expr_typ.len, expr_typ.str));
      };
      compiler__Type tt =
          compiler__Table_find_type(&/* ? */ *p->table, ffield.typ);
      if (tt.is_flag) {
        compiler__Parser_error(p, compiler__err_modify_bitfield);
      };
      if (i < T.fields.len - 1) {
        if (p->tok != compiler__compiler__TokenKind_comma) {
          compiler__Parser_error(
              p, _STR("too few values in `%.*s` literal (%d instead of %d)",
                      typ.len, typ.str, i + 1, T.fields.len));
        };
        compiler__Parser_gen(p, tos3(","));
        compiler__Parser_next(p);
      };
    };
    if (p->tok == compiler__compiler__TokenKind_comma) {
      compiler__Parser_next(p);
    };
    if (p->tok != compiler__compiler__TokenKind_rcbr) {
      compiler__Parser_error(
          p, _STR("too many fields initialized: `%.*s` has %d field(s)",
                  typ.len, typ.str, T.fields.len));
    };
    did_gen_something = 1;
  };
  if (!did_gen_something) {
    compiler__Parser_gen(p, tos3("EMPTY_STRUCT_INITIALIZATION"));
  };
  compiler__Parser_gen(p, tos3("}"));
  if (ptr && !p->is_js) {
    compiler__Parser_gen(p, _STR(", sizeof(%.*s))", t.name.len, t.name.str));
  };
  compiler__Parser_check(p, compiler__compiler__TokenKind_rcbr);
  p->is_struct_init = 0;
  p->is_c_struct_init = 0;
  return typ;
}
void compiler__Type_rename_generic_struct(compiler__Type *t,
                                          map_string generic_types) {
  t->name = string_add(t->name, tos3("_T"));
  map_string tmp29 = generic_types;
  array_string keys_tmp29 = map_keys(&tmp29);
  for (int l = 0; l < keys_tmp29.len; l++) {
    string _ = ((string *)keys_tmp29.data)[l];
    string v = tos3("");
    map_get(tmp29, _, &v);

    t->name = string_add(string_add(t->name, tos3("_")),
                         compiler__type_to_safe_str(v));
  };
}
void compiler__Parser_dispatch_generic_struct(compiler__Parser *p,
                                              compiler__Type *t,
                                              array_string type_params) {
  map_string generic_types = new_map(1, sizeof(string));
  if ((_IN_MAP((t->name), p->table->generic_struct_params))) {
    int i = 0;
    array_string tmp31 = new_array(0, 1, sizeof(string));
    bool tmp32 = map_get(/*struct.v : 510*/ p->table->generic_struct_params,
                         t->name, &tmp31);

    array_string tmp30 = tmp31;
    for (int _ = 0; _ < tmp30.len; _++) {
      string v = ((string *)tmp30.data)[_];

      map_set(&generic_types, v,
              &(string[]){(*(string *)array_get(type_params, i))});
      i++;
    };
    compiler__Type_rename_generic_struct(t, generic_types);
    if (compiler__Table_known_type(&/* ? */ *p->table, t->name)) {

      return;
    };
    _PUSH(&p->cgen->typedefs,
          (/*typ = array_string   tmp_typ=string*/ _STR(
              "typedef struct %.*s %.*s;\n", t->name.len, t->name.str,
              t->name.len, t->name.str)),
          tmp35, string);
  };
  compiler__Parser gp =
      (*(compiler__Parser *)array_get(p->v->parsers, t->parser_idx));
  gp.is_vgen = 1;
  compiler__ParserState saved_state = compiler__Parser_save_state(&/* ? */ *p);
  compiler__Parser_clear_state(p, 0, 1);
  gp.token_idx = t->decl_tok_idx;
  if (gp.tokens.len == 0) {
    gp.scanner->pos = 0;
    compiler__Parser_scan_tokens(&/* ? */ gp);
  };
  compiler__Parser_next(&/* ? */ gp);
  compiler__Parser_struct_decl(&/* ? */ gp, type_params);
  _PUSH_MANY(&p->cgen->lines_extra,
             (/*typ = array_string   tmp_typ=string*/ p->cgen->lines), tmp38,
             array_string);
  compiler__Parser_restore_state(p, saved_state, 0, 1);
}
bool array_compiler__AccessMod_contains(array_compiler__AccessMod a,
                                        compiler__AccessMod b) {
  array_compiler__AccessMod tmp1 = a;
  for (int tmp2 = 0; tmp2 < tmp1.len; tmp2++) {
    compiler__AccessMod elm = ((compiler__AccessMod *)tmp1.data)[tmp2];

    if (elm == b) {
      return 1;
    };
  };
  return 0;
}
string compiler__Fn_str(compiler__Fn f) {
  compiler__Table t = (compiler__Table){
      .typesmap = new_map(1, sizeof(compiler__Type)),
      .consts = new_array(0, 1, sizeof(compiler__Var)),
      .fns = new_map(1, sizeof(compiler__Fn)),
      .obf_ids = new_map(1, sizeof(int)),
      .modules = new_array(0, 1, sizeof(string)),
      .imports = new_array(0, 1, sizeof(string)),
      .cflags = new_array(0, 1, sizeof(compiler__CFlag)),
      .fn_cnt = 0,
      .obfuscate = 0,
      .varg_access = new_array(0, 1, sizeof(compiler__VargAccess)),
      .max_field_len = new_map(1, sizeof(int)),
      .generic_struct_params = new_map(1, sizeof(array_string)),
      .tuple_variants = new_map(1, sizeof(array_string)),
      .sum_types = new_map(1, sizeof(array_string))};
  string str_args = compiler__Fn_str_args(&/* ? */ f, &/*114*/ t);
  return _STR("%.*s(%.*s) %.*s", f.name.len, f.name.str, str_args.len,
              str_args.str, f.typ.len, f.typ.str);
}
string compiler__Table_debug_fns(compiler__Table *t) {
  strings__Builder s = strings__new_builder(1000);
  map_compiler__Fn tmp3 = t->fns;
  array_string keys_tmp3 = map_keys(&tmp3);
  for (int l = 0; l < keys_tmp3.len; l++) {
    string _ = ((string *)keys_tmp3.data)[l];
    compiler__Fn f = {0};
    map_get(tmp3, _, &f);

    strings__Builder_writeln(&/* ? */ s, f.name);
  };
  return strings__Builder_str(&/* ? */ s);
}
bool compiler__is_number_type(string typ) {
  return (_IN(string, (typ), compiler__integer_types)) ||
         (_IN(string, (typ), compiler__float_types));
}
bool compiler__is_integer_type(string typ) {
  return (_IN(string, (typ), compiler__integer_types));
}
bool compiler__is_float_type(string typ) {
  return (_IN(string, (typ), compiler__float_types));
}
bool compiler__is_primitive_type(string typ) {
  return compiler__is_number_type(typ) || string_eq(typ, tos3("string"));
}
bool compiler__is_pointer_type(string typ) {
  return (_IN(string, (typ), compiler__pointer_types));
}
compiler__Table *compiler__new_table(bool obfuscate) {
  compiler__Table *t = (compiler__Table *)memdup(
      &(compiler__Table){
          .obfuscate = obfuscate,
          .typesmap = new_map(1, sizeof(compiler__Type)),
          .consts = new_array(0, 1, sizeof(compiler__Var)),
          .fns = new_map(1, sizeof(compiler__Fn)),
          .obf_ids = new_map(1, sizeof(int)),
          .modules = new_array(0, 1, sizeof(string)),
          .imports = new_array(0, 1, sizeof(string)),
          .cflags = new_array(0, 1, sizeof(compiler__CFlag)),
          .fn_cnt = 0,
          .varg_access = new_array(0, 1, sizeof(compiler__VargAccess)),
          .max_field_len = new_map(1, sizeof(int)),
          .generic_struct_params = new_map(1, sizeof(array_string)),
          .tuple_variants = new_map(1, sizeof(array_string)),
          .sum_types = new_map(1, sizeof(array_string))},
      sizeof(compiler__Table));
  compiler__Table_register_builtin(t, tos3("int"));
  compiler__Table_register_builtin(t, tos3("size_t"));
  compiler__Table_register_type_with_parent(t, tos3("i8"), tos3("int"));
  compiler__Table_register_type_with_parent(t, tos3("byte"), tos3("int"));
  compiler__Table_register_type_with_parent(t, tos3("char"), tos3("int"));
  compiler__Table_register_type_with_parent(t, tos3("i16"), tos3("int"));
  compiler__Table_register_type_with_parent(t, tos3("u16"), tos3("u32"));
  compiler__Table_register_type_with_parent(t, tos3("u32"), tos3("int"));
  compiler__Table_register_type_with_parent(t, tos3("i64"), tos3("int"));
  compiler__Table_register_type_with_parent(t, tos3("u64"), tos3("u32"));
  compiler__Table_register_builtin(t, tos3("byteptr"));
  compiler__Table_register_builtin(t, tos3("charptr"));
  compiler__Table_register_builtin(t, tos3("intptr"));
  compiler__Table_register_builtin(t, tos3("f32"));
  compiler__Table_register_builtin(t, tos3("f64"));
  compiler__Table_register_builtin(t, tos3("rune"));
  compiler__Table_register_builtin(t, tos3("bool"));
  compiler__Table_register_builtin(t, tos3("void"));
  compiler__Table_register_builtin(t, tos3("voidptr"));
  compiler__Table_register_builtin(t, tos3("va_list"));
  array_string tmp4 = compiler__reserved_type_param_names;
  for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
    string c = ((string *)tmp4.data)[tmp5];

    compiler__Table_register_builtin(t, c);
  };
  compiler__Table_register_const(t, tos3("stdin"), tos3("int"), tos3("main"),
                                 1);
  compiler__Table_register_const(t, tos3("stdout"), tos3("int"), tos3("main"),
                                 1);
  compiler__Table_register_const(t, tos3("stderr"), tos3("int"), tos3("main"),
                                 1);
  compiler__Table_register_const(t, tos3("errno"), tos3("int"), tos3("main"),
                                 1);
  compiler__Table_register_type_with_parent(t, tos3("map_string"), tos3("map"));
  compiler__Table_register_type_with_parent(t, tos3("map_int"), tos3("map"));
  return t;
}
string compiler__Table_var_cgen_name(compiler__Table *t, string name) {
  if ((_IN(string, (name), compiler__c_reserved))) {
    return _STR("v_%.*s", name.len, name.str);
  } else {
    return name;
  };
}
void compiler__Table_register_module(compiler__Table *t, string mod) {
  if ((_IN(string, (mod), t->modules))) {

    return;
  };
  _PUSH(&t->modules, (/*typ = array_string   tmp_typ=string*/ mod), tmp6,
        string);
}
void compiler__Parser_register_array(compiler__Parser *p, string typ) {
  if (string_contains(typ, tos3("*"))) {
    printf("bad arr %.*s\n", typ.len, typ.str);

    return;
  };
  if (!compiler__Table_known_type(&/* ? */ *p->table, typ)) {
    compiler__Parser_register_type_with_parent(p, typ, tos3("array"));
    _PUSH(&p->cgen->typedefs,
          (/*typ = array_string   tmp_typ=string*/ _STR("typedef array %.*s;",
                                                        typ.len, typ.str)),
          tmp7, string);
  };
}
void compiler__Parser_register_map(compiler__Parser *p, string typ) {
  if (string_contains(typ, tos3("*"))) {
    printf("bad map %.*s\n", typ.len, typ.str);

    return;
  };
  if (!compiler__Table_known_type(&/* ? */ *p->table, typ)) {
    compiler__Parser_register_type_with_parent(p, typ, tos3("map"));
    _PUSH(&p->cgen->typedefs,
          (/*typ = array_string   tmp_typ=string*/ _STR("typedef map %.*s;",
                                                        typ.len, typ.str)),
          tmp8, string);
  };
}
bool compiler__Table_known_mod(compiler__Table *table, string mod) {
  return (_IN(string, (mod), table->modules));
}
void compiler__Table_register_const(compiler__Table *t, string name, string typ,
                                    string mod, bool is_pub) {
  _PUSH(&t->consts,
        (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ (compiler__Var){
            .name = name,
            .typ = typ,
            .is_const = 1,
            .mod = mod,
            .idx = -1,
            .is_public = is_pub,
            .is_arg = 0,
            .args = new_array(0, 1, sizeof(compiler__Var)),
            .attr = tos3(""),
            .is_mut = 0,
            .is_alloc = 0,
            .is_returned = 0,
            .ptr = 0,
            .ref = 0,
            .parent_fn = tos3(""),
            .is_global = 0,
            .is_used = 0,
            .is_changed = 0,
            .scope_level = 0,
            .is_c = 0,
            .is_moved = 0,
            .line_nr = 0,
            .token_idx = 0,
            .is_for_var = 0,
        }),
        tmp9, compiler__Var);
}
void compiler__Parser_register_global(compiler__Parser *p, string name,
                                      string typ) {
  _PUSH(&p->table->consts,
        (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ (compiler__Var){
            .name = name,
            .typ = typ,
            .is_const = 1,
            .is_global = 1,
            .mod = p->mod,
            .is_mut = 1,
            .idx = -1,
            .is_arg = 0,
            .args = new_array(0, 1, sizeof(compiler__Var)),
            .attr = tos3(""),
            .is_alloc = 0,
            .is_returned = 0,
            .ptr = 0,
            .ref = 0,
            .parent_fn = tos3(""),
            .is_used = 0,
            .is_changed = 0,
            .scope_level = 0,
            .is_c = 0,
            .is_moved = 0,
            .line_nr = 0,
            .token_idx = 0,
            .is_for_var = 0,
            .is_public = 0}),
        tmp10, compiler__Var);
}
void compiler__Table_register_fn(compiler__Table *t, compiler__Fn new_fn) {
  map_set(&t->fns, new_fn.name, &(compiler__Fn[]){new_fn});
}
bool compiler__Table_known_type(compiler__Table *table, string typ_) {
  string typ = typ_;
  if (string_ends_with(typ, tos3("*")) && !string_contains(typ, tos3(" "))) {
    typ = string_replace(typ, tos3("*"), tos3(""));
  };
  compiler__Type tmp11 = {0};
  bool tmp12 = map_get(/*table.v : 346*/ table->typesmap, typ, &tmp11);

  compiler__Type t = tmp11;
  return t.name.len > 0 && !t.is_placeholder;
}
bool compiler__Table_known_type_fast(compiler__Table *table,
                                     compiler__Type *t) {
  return string_ne(t->name, tos3("")) && !t->is_placeholder;
}
Option_compiler__Fn compiler__Table_find_fn(compiler__Table *t, string name) {
  compiler__Fn tmp13 = {0};
  bool tmp14 = map_get(/*table.v : 355*/ t->fns, name, &tmp13);

  compiler__Fn f = tmp13;
  if (f.name.str != 0) {
    compiler__Fn tmp15 = OPTION_CAST(compiler__Fn)(f);
    return opt_ok(&tmp15, sizeof(compiler__Fn));
  };
  return opt_none();
}
Option_compiler__Fn compiler__Table_find_fn_is_script(compiler__Table *t,
                                                      string name,
                                                      bool is_script) {
  compiler__Fn tmp16 = {0};
  bool tmp17 = map_get(/*table.v : 364*/ t->fns, name, &tmp16);

  compiler__Fn f = tmp16;
  if (f.name.str != 0) {
    compiler__Fn tmp18 = OPTION_CAST(compiler__Fn)(f);
    return opt_ok(&tmp18, sizeof(compiler__Fn));
  };
  if (is_script) {
    printf("trying replace %.*s\n", name.len, name.str);
    compiler__Fn tmp19 = {0};
    bool tmp20 =
        map_get(/*table.v : 372*/ t->fns,
                string_replace(name, tos3("main__"), tos3("os__")), &tmp19);

    f = tmp19;
    if (f.name.str != 0) {
      compiler__Fn tmp21 = OPTION_CAST(compiler__Fn)(f);
      return opt_ok(&tmp21, sizeof(compiler__Fn));
    };
  };
  return opt_none();
}
bool compiler__Table_known_fn(compiler__Table *t, string name) {
  Option_compiler__Fn tmp22 = compiler__Table_find_fn(&/* ? */ *t, name);
  if (!tmp22.ok) {
    string err = tmp22.error;
    int errcode = tmp22.ecode;
    return 0;
  };
  return 1;
}
bool compiler__Table_known_const(compiler__Table *t, string name) {
  Option_compiler__Var tmp23 = compiler__Table_find_const(&/* ? */ *t, name);
  if (!tmp23.ok) {
    string err = tmp23.error;
    int errcode = tmp23.ecode;
    return 0;
  };
  return 1;
}
void compiler__Table_register_builtin(compiler__Table *t, string typ) {
  if (typ.len == 0) {

    return;
  };
  if ((_IN_MAP((typ), t->typesmap))) {

    return;
  };
  map_set(&t->typesmap, typ,
          &(compiler__Type[]){(compiler__Type){
              .name = typ,
              .is_public = 1,
              .mod = tos3(""),
              .fields = new_array(0, 1, sizeof(compiler__Var)),
              .methods = new_array(0, 1, sizeof(compiler__Fn)),
              .parent = tos3(""),
              .is_c = 0,
              .enum_vals = new_array(0, 1, sizeof(string)),
              .gen_types = new_array(0, 1, sizeof(string)),
              .default_vals = new_array(0, 1, sizeof(string)),
              .parser_idx = 0,
              .decl_tok_idx = 0,
              .is_placeholder = 0,
              .gen_str = 0,
              .is_flag = 0,
              .is_generic = 0,
              .ctype_names = new_array(0, 1, sizeof(string))}});
}
void compiler__Parser_register_type_with_parent(compiler__Parser *p,
                                                string strtyp, string parent) {
  compiler__Type typ =
      (compiler__Type){.name = strtyp,
                       .parent = parent,
                       .mod = p->mod,
                       .is_public = 1,
                       .fields = new_array(0, 1, sizeof(compiler__Var)),
                       .methods = new_array(0, 1, sizeof(compiler__Fn)),
                       .is_c = 0,
                       .enum_vals = new_array(0, 1, sizeof(string)),
                       .gen_types = new_array(0, 1, sizeof(string)),
                       .default_vals = new_array(0, 1, sizeof(string)),
                       .parser_idx = 0,
                       .decl_tok_idx = 0,
                       .is_placeholder = 0,
                       .gen_str = 0,
                       .is_flag = 0,
                       .is_generic = 0,
                       .ctype_names = new_array(0, 1, sizeof(string))};
  compiler__Table_register_type(p->table, typ);
}
void compiler__Table_register_type_with_parent(compiler__Table *t, string typ,
                                               string parent) {
  if (typ.len == 0) {

    return;
  };
  map_set(&t->typesmap, typ,
          &(compiler__Type[]){(compiler__Type){
              .name = typ,
              .parent = parent,
              .is_public = 1,
              .mod = tos3(""),
              .fields = new_array(0, 1, sizeof(compiler__Var)),
              .methods = new_array(0, 1, sizeof(compiler__Fn)),
              .is_c = 0,
              .enum_vals = new_array(0, 1, sizeof(string)),
              .gen_types = new_array(0, 1, sizeof(string)),
              .default_vals = new_array(0, 1, sizeof(string)),
              .parser_idx = 0,
              .decl_tok_idx = 0,
              .is_placeholder = 0,
              .gen_str = 0,
              .is_flag = 0,
              .is_generic = 0,
              .ctype_names = new_array(0, 1, sizeof(string))}});
}
void compiler__Table_register_type(compiler__Table *t, compiler__Type typ) {
  if (typ.name.len == 0) {

    return;
  };
  map_set(&t->typesmap, typ.name, &(compiler__Type[]){typ});
}
void compiler__Table_rewrite_type(compiler__Table *t, compiler__Type typ) {
  if (typ.name.len == 0) {

    return;
  };
  map_set(&t->typesmap, typ.name, &(compiler__Type[]){typ});
}
void compiler__Table_add_field(compiler__Table *table, string type_name,
                               string field_name, string field_type,
                               bool is_mut, string attr,
                               compiler__AccessMod access_mod) {
  if (string_eq(type_name, tos3(""))) {
    print_backtrace();
    compiler__verror(tos3("add_field: empty type"));
  };
  compiler__Type tmp24 = {0};
  bool tmp25 = map_get(/*table.v : 449*/ table->typesmap, type_name, &tmp24);

  compiler__Type t = tmp24;
  _PUSH(&t.fields,
        (/*typ = array_compiler__Var   tmp_typ=compiler__Var*/ (compiler__Var){
            .name = field_name,
            .typ = field_type,
            .is_mut = is_mut,
            .attr = attr,
            .parent_fn = type_name,
            .access_mod = access_mod,
            .idx = 0,
            .is_arg = 0,
            .is_const = 0,
            .args = new_array(0, 1, sizeof(compiler__Var)),
            .is_alloc = 0,
            .is_returned = 0,
            .ptr = 0,
            .ref = 0,
            .mod = tos3(""),
            .is_global = 0,
            .is_used = 0,
            .is_changed = 0,
            .scope_level = 0,
            .is_c = 0,
            .is_moved = 0,
            .line_nr = 0,
            .token_idx = 0,
            .is_for_var = 0,
            .is_public = 0}),
        tmp26, compiler__Var);
  map_set(&table->typesmap, type_name, &(compiler__Type[]){t});
}
void compiler__Table_add_default_val(compiler__Table *table, int idx,
                                     string type_name, string val_expr) {
  compiler__Type tmp27 = {0};
  bool tmp28 = map_get(/*table.v : 463*/ table->typesmap, type_name, &tmp27);

  compiler__Type t = tmp27;
  if (t.default_vals.len == 0) {
    t.default_vals = array_repeat(
        new_array_from_c_array(1, 1, sizeof(string),
                               EMPTY_ARRAY_OF_ELEMS(string, 1){tos3("")}),
        t.fields.len);
  };
  array_set(&/*q*/ t.default_vals, idx, &(string[]){val_expr});
  map_set(&table->typesmap, type_name, &(compiler__Type[]){t});
}
bool compiler__Type_has_field(compiler__Type *t, string name) {
  Option_compiler__Var tmp29 = compiler__Type_find_field(&/* ? */ *t, name);
  if (!tmp29.ok) {
    string err = tmp29.error;
    int errcode = tmp29.ecode;
    return 0;
  };
  return 1;
}
bool compiler__Type_has_enum_val(compiler__Type *t, string name) {
  return (_IN(string, (name), t->enum_vals));
}
Option_compiler__Var compiler__Type_find_field(compiler__Type *t, string name) {
  array_compiler__Var tmp30 = t->fields;
  for (int tmp31 = 0; tmp31 < tmp30.len; tmp31++) {
    compiler__Var field = ((compiler__Var *)tmp30.data)[tmp31];

    if (string_eq(field.name, name)) {
      compiler__Var tmp32 = OPTION_CAST(compiler__Var)(field);
      return opt_ok(&tmp32, sizeof(compiler__Var));
    };
  };
  return opt_none();
}
bool compiler__Table_type_has_field(compiler__Table *table, compiler__Type *typ,
                                    string name) {
  Option_compiler__Var tmp33 =
      compiler__Table_find_field(&/* ? */ *table, typ, name);
  if (!tmp33.ok) {
    string err = tmp33.error;
    int errcode = tmp33.ecode;
    return 0;
  };
  return 1;
}
Option_compiler__Var compiler__Table_find_field(compiler__Table *table,
                                                compiler__Type *typ,
                                                string name) {
  array_compiler__Var tmp34 = typ->fields;
  for (int tmp35 = 0; tmp35 < tmp34.len; tmp35++) {
    compiler__Var field = ((compiler__Var *)tmp34.data)[tmp35];

    if (string_eq(field.name, name)) {
      compiler__Var tmp36 = OPTION_CAST(compiler__Var)(field);
      return opt_ok(&tmp36, sizeof(compiler__Var));
    };
  };
  if (string_ne(typ->parent, tos3(""))) {
    compiler__Type parent =
        compiler__Table_find_type(&/* ? */ *table, typ->parent);
    array_compiler__Var tmp37 = parent.fields;
    for (int tmp38 = 0; tmp38 < tmp37.len; tmp38++) {
      compiler__Var field = ((compiler__Var *)tmp37.data)[tmp38];

      if (string_eq(field.name, name)) {
        compiler__Var tmp39 = OPTION_CAST(compiler__Var)(field);
        return opt_ok(&tmp39, sizeof(compiler__Var));
      };
    };
  };
  return opt_none();
}
void compiler__Parser_add_method(compiler__Parser *p, string type_name,
                                 compiler__Fn f) {
  if (!compiler__Parser_first_pass(&/* ? */ *p) &&
      string_ne(f.name, tos3("str"))) {

    return;
  };
  if (string_eq(type_name, tos3(""))) {
    print_backtrace();
    compiler__verror(tos3("add_method: empty type"));
  };
  compiler__Type tmp40 = {0};
  bool tmp41 = map_get(/*table.v : 524*/ p->table->typesmap, type_name, &tmp40);

  compiler__Type t = tmp40;
  if (string_ne(f.name, tos3("str")) && (_IN(compiler__Fn, (f), t.methods))) {
    compiler__Parser_error(p, _STR("redefinition of method `%.*s.%.*s`",
                                   type_name.len, type_name.str, f.name.len,
                                   f.name.str));
  };
  _PUSH(&t.methods, (/*typ = array_compiler__Fn   tmp_typ=compiler__Fn*/ f),
        tmp42, compiler__Fn);
  map_set(&p->table->typesmap, type_name, &(compiler__Type[]){t});
}
bool compiler__Type_has_method(compiler__Type *t, string name) {
  Option_compiler__Fn tmp43 = compiler__Type_find_method(&/* ? */ *t, name);
  if (!tmp43.ok) {
    string err = tmp43.error;
    int errcode = tmp43.ecode;
    return 0;
  };
  return 1;
}
bool compiler__Table_type_has_method(compiler__Table *table,
                                     compiler__Type *typ, string name) {
  Option_compiler__Fn tmp44 =
      compiler__Table_find_method(&/* ? */ *table, typ, name);
  if (!tmp44.ok) {
    string err = tmp44.error;
    int errcode = tmp44.ecode;
    return 0;
  };
  return 1;
}
Option_compiler__Fn compiler__Table_find_method(compiler__Table *table,
                                                compiler__Type *typ,
                                                string name) {
  compiler__Type tmp45 = {0};
  bool tmp46 = map_get(/*table.v : 547*/ table->typesmap, typ->name, &tmp45);

  compiler__Type t = tmp45;
  array_compiler__Fn tmp47 = t.methods;
  for (int tmp48 = 0; tmp48 < tmp47.len; tmp48++) {
    compiler__Fn method = ((compiler__Fn *)tmp47.data)[tmp48];

    if (string_eq(method.name, name)) {
      compiler__Fn tmp49 = OPTION_CAST(compiler__Fn)(method);
      return opt_ok(&tmp49, sizeof(compiler__Fn));
    };
  };
  if (string_ne(typ->parent, tos3(""))) {
    compiler__Type parent =
        compiler__Table_find_type(&/* ? */ *table, typ->parent);
    array_compiler__Fn tmp50 = parent.methods;
    for (int tmp51 = 0; tmp51 < tmp50.len; tmp51++) {
      compiler__Fn method = ((compiler__Fn *)tmp50.data)[tmp51];

      if (string_eq(method.name, name)) {
        compiler__Fn tmp52 = OPTION_CAST(compiler__Fn)(method);
        return opt_ok(&tmp52, sizeof(compiler__Fn));
      };
    };
    return opt_none();
  };
  return opt_none();
}
Option_compiler__Fn compiler__Type_find_method(compiler__Type *t, string name) {
  array_compiler__Fn tmp53 = t->methods;
  for (int tmp54 = 0; tmp54 < tmp53.len; tmp54++) {
    compiler__Fn method = ((compiler__Fn *)tmp53.data)[tmp54];

    if (string_eq(method.name, name)) {
      compiler__Fn tmp55 = OPTION_CAST(compiler__Fn)(method);
      return opt_ok(&tmp55, sizeof(compiler__Fn));
    };
  };
  return opt_none();
}
void compiler__Table_add_gen_type(compiler__Table *table, string type_name,
                                  string gen_type) {
  compiler__Type tmp56 = {0};
  bool tmp57 = map_get(/*table.v : 577*/ table->typesmap, type_name, &tmp56);

  compiler__Type t = tmp56;
  if ((_IN(string, (gen_type), t.gen_types))) {

    return;
  };
  _PUSH(&t.gen_types, (/*typ = array_string   tmp_typ=string*/ gen_type), tmp58,
        string);
  map_set(&table->typesmap, type_name, &(compiler__Type[]){t});
}
compiler__Type compiler__Parser_find_type(compiler__Parser *p, string name) {
  compiler__Type typ = compiler__Table_find_type(&/* ? */ *p->table, name);
  if (string_eq(typ.name, tos3(""))) {
    return compiler__Table_find_type(
        &/* ? */ *p->table, compiler__Parser_prepend_mod(&/* ? */ *p, name));
  };
  return typ;
}
compiler__Type compiler__Table_find_type(compiler__Table *t, string name_) {
  string name = name_;
  if (string_ends_with(name, tos3("*")) && !string_contains(name, tos3(" "))) {
    name = string_replace(name, tos3("*"), tos3(""));
  };
  if (!((_IN_MAP((name), t->typesmap)))) {
    return (compiler__Type){.mod = tos3(""),
                            .name = tos3(""),
                            .is_public = 0,
                            .fields = new_array(0, 1, sizeof(compiler__Var)),
                            .methods = new_array(0, 1, sizeof(compiler__Fn)),
                            .parent = tos3(""),
                            .is_c = 0,
                            .enum_vals = new_array(0, 1, sizeof(string)),
                            .gen_types = new_array(0, 1, sizeof(string)),
                            .default_vals = new_array(0, 1, sizeof(string)),
                            .parser_idx = 0,
                            .decl_tok_idx = 0,
                            .is_placeholder = 0,
                            .gen_str = 0,
                            .is_flag = 0,
                            .is_generic = 0,
                            .ctype_names = new_array(0, 1, sizeof(string))};
  };
  compiler__Type tmp59 = {0};
  bool tmp60 = map_get(/*table.v : 603*/ t->typesmap, name, &tmp59);

  return tmp59;
}
bool compiler__Parser_check_types2(compiler__Parser *p, string got_,
                                   string expected_, bool throw) {
  string got = got_;
  string expected = expected_;
  if (p->pref->translated) {
    return 1;
  };
  if (string_eq(got, expected)) {
    return 1;
  };
  if (string_eq(expected, tos3("_ANYTYPE_"))) {
    p->cur_fn.typ = got;
    return 1;
  };
  if (throw &&string_eq(compiler__Parser_base_type(p, got),
                        compiler__Parser_base_type(p, expected))) {
    return 1;
  };
  if (string_starts_with(expected, tos3("varg_"))) {
    expected = string_substr2(expected, 5, -1, true);
  };
  if (string_starts_with(got, tos3("varg_"))) {
    got = string_substr2(got, 5, -1, true);
  };
  if (string_eq(got, tos3("int")) && string_ends_with(expected, tos3("Fn"))) {
    return 1;
  };
  if (string_eq(got, tos3("int")) && string_eq(expected, tos3("f32"))) {
    return 1;
  };
  if (string_eq(got, tos3("int")) && string_eq(expected, tos3("f64"))) {
    return 1;
  };
  if (string_eq(got, tos3("f64")) && string_eq(expected, tos3("f32"))) {
    return 1;
  };
  if (string_eq(got, tos3("f32")) && string_eq(expected, tos3("f64"))) {
    return 1;
  };
  if (string_eq(got, tos3("int")) && string_eq(expected, tos3("i64"))) {
    return 1;
  };
  if (string_eq(got, tos3("void*")) &&
      string_starts_with(expected, tos3("fn "))) {
    return 1;
  };
  if (string_starts_with(got, tos3("[")) &&
      string_eq(expected, tos3("byte*"))) {
    return 1;
  };
  if (string_eq(got, tos3("void*")) || string_eq(expected, tos3("void*"))) {
    return 1;
  };
  if (string_eq(got, tos3("int")) && string_eq(expected, tos3("byte"))) {
    return 1;
  };
  if (string_eq(got, tos3("byteptr")) && string_eq(expected, tos3("byte*"))) {
    return 1;
  };
  if (string_eq(got, tos3("byte*")) && string_eq(expected, tos3("byteptr"))) {
    return 1;
  };
  if (string_eq(got, tos3("charptr")) && string_eq(expected, tos3("char*"))) {
    return 1;
  };
  if (string_eq(got, tos3("char*")) && string_eq(expected, tos3("charptr"))) {
    return 1;
  };
  if (string_eq(got, tos3("int")) && string_eq(expected, tos3("byte*"))) {
    return 1;
  };
  if (string_eq(got, tos3("int")) && (string_eq(expected, tos3("byteptr")) ||
                                      string_eq(expected, tos3("charptr")))) {
    return 1;
  };
  if (string_eq(got, tos3("Option")) &&
      string_starts_with(expected, tos3("Option_"))) {
    return 1;
  };
  if (string_eq(got, tos3("array")) &&
      string_starts_with(expected, tos3("array_"))) {
    return 1;
  };
  if (string_starts_with(expected, tos3("Option_")) &&
      string_ends_with(expected, compiler__stringify_pointer(got))) {
    return 1;
  };
  if (string_ends_with(expected, tos3("*")) && string_eq(got, tos3("int"))) {
    return 1;
  };
  if (string_starts_with(got, tos3("fn ")) &&
      (string_ends_with(expected, tos3("fn")) ||
       string_ends_with(expected, tos3("Fn")))) {
    return 1;
  };
  if (string_starts_with(got, tos3("fn ")) &&
      string_starts_with(expected, tos3("fn ")) &&
      string_eq(p->mod, tos3("gg2"))) {
    return 1;
  };
  if (string_eq(expected, tos3("void*")) && string_eq(got, tos3("int"))) {
    return 1;
  };
  if (compiler__is_integer_type(got) && compiler__is_number_type(expected) &&
      p->is_const_literal) {
    return 1;
  };
  if (string_eq(expected, tos3("integer"))) {
    if (compiler__is_integer_type(got)) {
      return 1;
    } else {
      compiler__Parser_error(p, _STR("expected type `%.*s`, but got `%.*s`",
                                     expected.len, expected.str, got.len,
                                     got.str));
    };
  };
  expected = string_replace(expected, tos3("*"), tos3(""));
  got = string_replace(string_replace(got, tos3("*"), tos3("")), tos3("ptr"),
                       tos3(""));
  if (string_ne(got, expected)) {
    if (string_ends_with(expected, tos3("er")) ||
        string_at(expected, 0) == 'I') {
      if (compiler__Parser_satisfies_interface(p, expected, got, throw)) {
        return 1;
      };
    };
    if ((_IN_MAP((expected), p->table->sum_types))) {
      array_string tmp67 = new_array(0, 1, sizeof(string));
      bool tmp68 =
          map_get(/*table.v : 751*/ p->table->sum_types, expected, &tmp67);

      if ((_IN(string, (got), tmp67))) {
        return 1;
      };
    };
    if (!throw) {
      return 0;
    } else {
      compiler__Parser_error(p, _STR("cannot convert `%.*s` to `%.*s`", got.len,
                                     got.str, expected.len, expected.str));
    };
  };
  return 1;
}
string compiler__Parser_base_type(compiler__Parser *p, string name) {
  compiler__Type typ = compiler__Parser_find_type(&/* ? */ *p, name);
  if (string_ne(typ.parent, tos3(""))) {
    return compiler__Parser_base_type(p, typ.parent);
  };
  return name;
}
bool compiler__Parser_check_types(compiler__Parser *p, string got,
                                  string expected) {
  if (compiler__Parser_first_pass(&/* ? */ *p)) {
    return 1;
  };
  return compiler__Parser_check_types2(p, got, expected, 1);
}
bool compiler__Parser_check_types_no_throw(compiler__Parser *p, string got,
                                           string expected) {
  return compiler__Parser_check_types2(p, got, expected, 0);
}
void compiler__Parser_check_types_with_token_index(compiler__Parser *p,
                                                   string got, string expected,
                                                   int var_token_idx) {
  if (!compiler__Parser_check_types2(p, got, expected, 0)) {
    compiler__Parser_error_with_token_index(
        p,
        _STR("expected type `%.*s`, but got `%.*s`", expected.len, expected.str,
             got.len, got.str),
        var_token_idx);
  };
}
bool compiler__Parser_satisfies_interface(compiler__Parser *p,
                                          string interface_name, string _typ,
                                          bool throw) {
  compiler__Type int_typ =
      compiler__Table_find_type(&/* ? */ *p->table, interface_name);
  compiler__Type typ = compiler__Table_find_type(&/* ? */ *p->table, _typ);
  array_compiler__Fn tmp69 = int_typ.methods;
  for (int tmp70 = 0; tmp70 < tmp69.len; tmp70++) {
    compiler__Fn method = ((compiler__Fn *)tmp69.data)[tmp70];

    if (!compiler__Type_has_method(&/* ? */ typ, method.name)) {
      compiler__Parser_error(
          p, string_add(_STR("type `%.*s` doesn\'t satisfy interface ",
                             _typ.len, _typ.str),
                        _STR("`%.*s` (method `%.*s` is not implemented)",
                             interface_name.len, interface_name.str,
                             method.name.len, method.name.str)));
      return 0;
    };
  };
  return 1;
}
bool compiler__Table_is_interface(compiler__Table *table, string name) {
  if (!((_IN_MAP((name), table->typesmap)))) {
    return 0;
  };
  compiler__Type tmp71 = {0};
  bool tmp72 = map_get(/*table.v : 811*/ table->typesmap, name, &tmp71);

  compiler__Type t = tmp71;
  return t.cat == compiler__compiler__TypeCategory_interface_;
}
bool compiler__Table_main_exists(compiler__Table *t) {
  map_compiler__Fn tmp73 = t->fns;
  array_string keys_tmp73 = map_keys(&tmp73);
  for (int l = 0; l < keys_tmp73.len; l++) {
    string _ = ((string *)keys_tmp73.data)[l];
    compiler__Fn f = {0};
    map_get(tmp73, _, &f);

    if (string_eq(f.name, tos3("main__main"))) {
      return 1;
    };
  };
  return 0;
}
array_string compiler__Table_all_test_function_names(compiler__Table *t) {
  string fn_begin_test_name = tos3("");
  string fn_end_test_name = tos3("");
  array_string fn_test_names = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  map_compiler__Fn tmp74 = t->fns;
  array_string keys_tmp74 = map_keys(&tmp74);
  for (int l = 0; l < keys_tmp74.len; l++) {
    string _ = ((string *)keys_tmp74.data)[l];
    compiler__Fn f = {0};
    map_get(tmp74, _, &f);

    if (string_contains(f.name, tos3("__test_"))) {
      _PUSH(&fn_test_names, (/*typ = array_string   tmp_typ=string*/ f.name),
            tmp75, string);
    } else if (string_contains(f.name, tos3("__testsuite_begin"))) {
      fn_begin_test_name = f.name;
    } else if (string_contains(f.name, tos3("__testsuite_end"))) {
      fn_end_test_name = f.name;
    };
  };
  if (fn_begin_test_name.len == 0) {
    if (fn_end_test_name.len > 0) {
      _PUSH(&fn_test_names,
            (/*typ = array_string   tmp_typ=string*/ fn_end_test_name), tmp76,
            string);
    };
    return fn_test_names;
  } else {
    array_string res = new_array_from_c_array(
        0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
    _PUSH(&res, (/*typ = array_string   tmp_typ=string*/ fn_begin_test_name),
          tmp77, string);
    _PUSH_MANY(&res, (/*typ = array_string   tmp_typ=string*/ fn_test_names),
               tmp78, array_string);
    if (fn_end_test_name.len > 0) {
      _PUSH(&res, (/*typ = array_string   tmp_typ=string*/ fn_end_test_name),
            tmp79, string);
    };
    return res;
  };
}
Option_compiler__Var compiler__Table_find_const(compiler__Table *t,
                                                string name) {
  array_compiler__Var tmp80 = t->consts;
  for (int tmp81 = 0; tmp81 < tmp80.len; tmp81++) {
    compiler__Var c = ((compiler__Var *)tmp80.data)[tmp81];

    if (string_eq(c.name, name)) {
      compiler__Var tmp82 = OPTION_CAST(compiler__Var)(c);
      return opt_ok(&tmp82, sizeof(compiler__Var));
    };
  };
  return opt_none();
}
string compiler__Table_cgen_name_type_pair(compiler__Table *table, string name,
                                           string typ) {
  if (typ.len > 0 && string_at(typ, 0) == '[') {
    string tmp = string_all_after(typ, tos3("]"));
    string size = string_all_before(typ, tos3("]"));
    return _STR("%.*s %.*s  %.*s ]", tmp.len, tmp.str, name.len, name.str,
                size.len, size.str);
  } else if (string_starts_with(typ, tos3("fn ("))) {
    compiler__Type T = compiler__Table_find_type(&/* ? */ *table, typ);
    if (string_eq(T.name, tos3(""))) {
      eprintln(_STR("function type `%.*s` not found", typ.len, typ.str));
      v_exit(1);
    };
    string str_args = compiler__Fn_str_args(&/* ? */ T.func, table);
    return _STR("%.*s (*%.*s)( %.*s /*FFF*/ )", T.func.typ.len, T.func.typ.str,
                name.len, name.str, str_args.len, str_args.str);
  } else if (string_eq(typ, tos3("tm"))) {
    return _STR("struct /*TM*/ tm %.*s", name.len, name.str);
  };
  return _STR("%.*s %.*s", typ.len, typ.str, name.len, name.str);
}
bool compiler__is_valid_int_const(string val, string typ) {
  int x = v_string_int(val);
  string tmp85 = typ;

  return ((string_eq(tmp85, tos3("char")))
              ? (0 <= x && x <= 255)
              : ((string_eq(tmp85, tos3("byte")))
                     ? (0 <= x && x <= 255)
                     : ((string_eq(tmp85, tos3("u16")))
                            ? (0 <= x && x <= 65535)
                            : ((string_eq(tmp85, tos3("i8")))
                                   ? (-128 <= x && x <= 127)
                                   : (1)))));
}
string compiler__Parser_typ_to_fmt(compiler__Parser *p, string typ, int level) {
  compiler__Type t = compiler__Table_find_type(&/* ? */ *p->table, typ);
  if (t.cat == compiler__compiler__TypeCategory_enum_) {
    return tos3("%d");
  };
  string tmp86 = typ;

  if (string_eq(tmp86, tos3("string"))) {
    return tos3("%.*s");
  } else if (string_eq(tmp86, tos3("ustring"))) {
    return tos3("%.*s");
  } else if ((string_eq(tmp86, tos3("byte"))) ||
             (string_eq(tmp86, tos3("bool"))) ||
             (string_eq(tmp86, tos3("int"))) ||
             (string_eq(tmp86, tos3("char"))) ||
             (string_eq(tmp86, tos3("i16"))) ||
             (string_eq(tmp86, tos3("i8")))) {
    return tos3("%d");
  } else if ((string_eq(tmp86, tos3("u16"))) ||
             (string_eq(tmp86, tos3("u32")))) {
    return tos3("%u");
  } else if ((string_eq(tmp86, tos3("f64"))) ||
             (string_eq(tmp86, tos3("f32")))) {
    return tos3("%f");
  } else if (string_eq(tmp86, tos3("i64"))) {
    return tos3("%lld");
  } else if (string_eq(tmp86, tos3("u64"))) {
    return tos3("%llu");
  } else if ((string_eq(tmp86, tos3("byte*"))) ||
             (string_eq(tmp86, tos3("byteptr")))) {
    return tos3("%s");
  } else if (string_eq(tmp86, tos3("void"))) {
    compiler__Parser_error(p, tos3("cannot interpolate this value"));
  } else // default:
  {
    if (string_ends_with(typ, tos3("*"))) {
      return tos3("%p");
    };
  };
  if (string_ne(t.parent, tos3("")) && level == 0) {
    return compiler__Parser_typ_to_fmt(p, t.parent, level + 1);
  };
  return tos3("");
}
string compiler__type_to_safe_str(string typ) {
  string r =
      string_replace(string_replace(string_replace(typ, tos3(" "), tos3("")),
                                    tos3("("), tos3("_")),
                     tos3(")"), tos3("_"));
  return r;
}
bool compiler__is_compile_time_const(string s_) {
  string s = string_trim_space(s_);
  if (string_eq(s, tos3(""))) {
    return 0;
  };
  if (string_contains(s, tos3("\'"))) {
    return 1;
  };
  string tmp87 = s;
  ;
  for (int tmp88 = 0; tmp88 < tmp87.len; tmp88++) {
    byte c = tmp87.str[tmp88];

    if (!((c >= '0' && c <= '9') || c == '.')) {
      return 0;
    };
  };
  return 1;
}
bool compiler__Type_contains_field_type(compiler__Type *t, string typ) {
  if (!byte_is_capital(string_at(t->name, 0))) {
    return 0;
  };
  array_compiler__Var tmp91 = t->fields;
  for (int tmp92 = 0; tmp92 < tmp91.len; tmp92++) {
    compiler__Var field = ((compiler__Var *)tmp91.data)[tmp92];

    if (string_eq(field.typ, typ)) {
      return 1;
    };
  };
  return 0;
}
string compiler__Parser_identify_typo(compiler__Parser *p, string name) {
  if (name.len < 2) {
    return tos3("");
  };
  string name_dotted =
      compiler__mod_gen_name_rev(string_replace(name, tos3("__"), tos3(".")));
  f32 min_match = 0.50;
  string output = tos3("");
  string n = compiler__Table_find_misspelled_imported_mod(
      &/* ? */ *p->table, name_dotted, p, min_match);
  if (n.len > 0) {
    output = string_add(output, _STR("\n  * module: `%.*s`", n.len, n.str));
  };
  n = compiler__Table_find_misspelled_const(&/* ? */ *p->table, name, p,
                                            min_match);
  if (string_ne(n, tos3(""))) {
    output = string_add(output, _STR("\n  * const: `%.*s`", n.len, n.str));
  };
  _V_MulRet_string_V_string _V_mret_4118_typ_type_cat =
      compiler__Table_find_misspelled_type(&/* ? */ *p->table, name, p,
                                           min_match);
  string typ = _V_mret_4118_typ_type_cat.var_0;
  string type_cat = _V_mret_4118_typ_type_cat.var_1;
  if (typ.len > 0) {
    output = string_add(output, _STR("\n  * %.*s: `%.*s`", type_cat.len,
                                     type_cat.str, typ.len, typ.str));
  };
  n = compiler__Table_find_misspelled_fn(&/* ? */ *p->table, name, p,
                                         min_match);
  if (n.len > 0) {
    output = string_add(output, _STR("\n  * function: `%.*s`", n.len, n.str));
  };
  n = compiler__Parser_find_misspelled_local_var(&/* ? */ *p, name_dotted,
                                                 min_match);
  if (n.len > 0) {
    output = string_add(output, _STR("\n  * variable: `%.*s`", n.len, n.str));
  };
  return output;
}
f32 compiler__typo_compare_name_mod(string a, string b, string b_mod) {
  if (a.len - b.len > 2 || b.len - a.len > 2) {
    return 0;
  };
  Option_int tmp93 = string_index(a, tos3("__"));
  int auidx;
  if (!tmp93.ok) {
    string err = tmp93.error;
    int errcode = tmp93.ecode;
    return 0;
  }
  auidx = *(int *)tmp93.data;
  ;
  Option_int tmp94 = string_index(b, tos3("__"));
  int buidx;
  if (!tmp94.ok) {
    string err = tmp94.error;
    int errcode = tmp94.ecode;
    return 0;
  }
  buidx = *(int *)tmp94.data;
  ;
  string a_mod =
      ((auidx != -1)
           ? (compiler__mod_gen_name_rev(string_substr2(a, 0, auidx, false)))
           : (tos3("")));
  string a_name =
      ((auidx != -1) ? (string_substr2(a, auidx + 2, -1, true)) : (a));
  string b_name =
      ((buidx != -1) ? (string_substr2(b, buidx + 2, -1, true)) : (b));
  if (a_mod.len > 0 && b_mod.len > 0 && string_ne(a_mod, b_mod)) {
    return 0;
  };
  return strings__dice_coefficient(a_name, b_name);
}
string compiler__Table_find_misspelled_fn(compiler__Table *table, string name,
                                          compiler__Parser *p, f32 min_match) {
  f32 closest = ((f32)(0));
  string closest_fn = tos3("");
  map_compiler__Fn tmp101 = table->fns;
  array_string keys_tmp101 = map_keys(&tmp101);
  for (int l = 0; l < keys_tmp101.len; l++) {
    string _ = ((string *)keys_tmp101.data)[l];
    compiler__Fn f = {0};
    map_get(tmp101, _, &f);

    if (string_contains(f.name, tos3("__")) &&
        !compiler__Parser_is_mod_in_scope(&/* ? */ *p, f.mod)) {
      continue;
    };
    f32 c = compiler__typo_compare_name_mod(name, f.name, f.mod);
    if (macro_f32_gt(c, closest)) {
      closest = c;
      closest_fn = compiler__mod_gen_name_rev(
          string_replace(f.name, tos3("__"), tos3(".")));
    };
  };
  return ((macro_f32_ge(closest, min_match)) ? (closest_fn) : (tos3("")));
}
string compiler__Table_find_misspelled_imported_mod(compiler__Table *table,
                                                    string name,
                                                    compiler__Parser *p,
                                                    f32 min_match) {
  f32 closest = ((f32)(0));
  string closest_mod = tos3("");
  string n1 = ((string_starts_with(name, tos3("main.")))
                   ? (string_substr2(name, 5, -1, true))
                   : (name));
  map_string tmp104 = p->import_table.imports;
  array_string keys_tmp104 = map_keys(&tmp104);
  for (int l = 0; l < keys_tmp104.len; l++) {
    string alias = ((string *)keys_tmp104.data)[l];
    string mod = tos3("");
    map_get(tmp104, alias, &mod);

    f32 c = compiler__typo_compare_name_mod(n1, alias, tos3(""));
    if (macro_f32_gt(c, closest)) {
      closest = c;
      closest_mod =
          ((string_eq(alias, mod))
               ? (alias)
               : (_STR("%.*s (%.*s)", alias.len, alias.str, mod.len, mod.str)));
    };
  };
  return ((macro_f32_ge(closest, min_match)) ? (closest_mod) : (tos3("")));
}
string compiler__Table_find_misspelled_const(compiler__Table *table,
                                             string name, compiler__Parser *p,
                                             f32 min_match) {
  f32 closest = ((f32)(0));
  string closest_const = tos3("");
  array_compiler__Var tmp105 = table->consts;
  for (int tmp106 = 0; tmp106 < tmp105.len; tmp106++) {
    compiler__Var cnst = ((compiler__Var *)tmp105.data)[tmp106];

    if (string_contains(cnst.name, tos3("__")) &&
        !compiler__Parser_is_mod_in_scope(&/* ? */ *p, cnst.mod)) {
      continue;
    };
    f32 c = compiler__typo_compare_name_mod(name, cnst.name, cnst.mod);
    if (macro_f32_gt(c, closest)) {
      closest = c;
      closest_const = compiler__mod_gen_name_rev(
          string_replace(cnst.name, tos3("__"), tos3(".")));
    };
  };
  return ((macro_f32_ge(closest, min_match)) ? (closest_const) : (tos3("")));
}
_V_MulRet_string_V_string
compiler__Table_find_misspelled_type(compiler__Table *table, string name,
                                     compiler__Parser *p, f32 min_match) {
  f32 closest = ((f32)(0));
  string closest_type = tos3("");
  string type_cat = tos3("");
  map_compiler__Type tmp107 = table->typesmap;
  array_string keys_tmp107 = map_keys(&tmp107);
  for (int l = 0; l < keys_tmp107.len; l++) {
    string _ = ((string *)keys_tmp107.data)[l];
    compiler__Type typ = {0};
    map_get(tmp107, _, &typ);

    if (string_contains(typ.name, tos3("__")) &&
        !compiler__Parser_is_mod_in_scope(&/* ? */ *p, typ.mod)) {
      continue;
    };
    f32 c = compiler__typo_compare_name_mod(name, typ.name, typ.mod);
    if (macro_f32_gt(c, closest)) {
      closest = c;
      closest_type = compiler__mod_gen_name_rev(
          string_replace(typ.name, tos3("__"), tos3(".")));
      type_cat = compiler__type_cat_str(typ.cat);
    };
  };
  if (macro_f32_ge(closest, min_match)) {
    return (_V_MulRet_string_V_string){.var_0 = closest_type,
                                       .var_1 = type_cat};
  };
  return (_V_MulRet_string_V_string){.var_0 = tos3(""), .var_1 = tos3("")};
}
string compiler__type_cat_str(compiler__TypeCategory tc) {
  compiler__TypeCategory tmp108 = tc;

  string tc_str =
      ((tmp108 == compiler__compiler__TypeCategory_builtin)
           ? (tos3("builtin"))
           : ((tmp108 == compiler__compiler__TypeCategory_struct_)
                  ? (tos3("struct"))
                  : ((tmp108 == compiler__compiler__TypeCategory_func)
                         ? (tos3("function"))
                         : ((tmp108 ==
                             compiler__compiler__TypeCategory_interface_)
                                ? (tos3("interface"))
                                : ((tmp108 ==
                                    compiler__compiler__TypeCategory_enum_)
                                       ? (tos3("enum"))
                                       : ((tmp108 ==
                                           compiler__compiler__TypeCategory_union_)
                                              ? (tos3("union"))
                                              : ((tmp108 ==
                                                  compiler__compiler__TypeCategory_c_struct)
                                                     ? (tos3("C struct"))
                                                     : ((tmp108 ==
                                                         compiler__compiler__TypeCategory_c_typedef)
                                                            ? (tos3(
                                                                  "C typedef"))
                                                            : ((tmp108 ==
                                                                compiler__compiler__TypeCategory_objc_interface)
                                                                   ? (tos3(
                                                                         "obj "
                                                                         "C "
                                                                         "inter"
                                                                         "fac"
                                                                         "e"))
                                                                   : ((tmp108 ==
                                                                       compiler__compiler__TypeCategory_array)
                                                                          ? (tos3(
                                                                                "array"))
                                                                          : ((tmp108 ==
                                                                              compiler__compiler__TypeCategory_alias)
                                                                                 ? (tos3(
                                                                                       "type alias"))
                                                                                 : (tos3(
                                                                                       "unknown")))))))))))));
  return tc_str;
}
map_int compiler__build_keys() {
  map_int res = new_map(1, sizeof(int));
  for (int t = ((int)(compiler__compiler__TokenKind_keyword_beg)) + 1;
       t < ((int)(compiler__compiler__TokenKind_keyword_end)); t++) {

    string key = (*(string *)array_get(compiler__TokenStr, t));
    map_set(&res, key, &(int[]){t});
  };
  return res;
}
array_string compiler__build_token_str() {
  array_string s = array_repeat(
      new_array_from_c_array(1, 1, sizeof(string),
                             EMPTY_ARRAY_OF_ELEMS(string, 1){tos3("")}),
      compiler__NrTokens);
  array_set(&/*q*/ s, compiler__compiler__TokenKind_keyword_beg,
            &(string[]){tos3("")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_keyword_end,
            &(string[]){tos3("")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_eof,
            &(string[]){tos3("eof")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_name,
            &(string[]){tos3("name")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_number,
            &(string[]){tos3("number")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_string,
            &(string[]){tos3("STR")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_chartoken,
            &(string[]){tos3("char")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_plus,
            &(string[]){tos3("+")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_minus,
            &(string[]){tos3("-")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_mul,
            &(string[]){tos3("*")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_div,
            &(string[]){tos3("/")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_mod,
            &(string[]){tos3("%")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_xor,
            &(string[]){tos3("^")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_bit_not,
            &(string[]){tos3("~")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_pipe,
            &(string[]){tos3("|")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_hash,
            &(string[]){tos3("#")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_amp,
            &(string[]){tos3("&")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_inc,
            &(string[]){tos3("++")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_dec,
            &(string[]){tos3("--")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_and,
            &(string[]){tos3("&&")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_logical_or,
            &(string[]){tos3("||")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_not,
            &(string[]){tos3("!")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_dot,
            &(string[]){tos3(".")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_dotdot,
            &(string[]){tos3("..")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_ellipsis,
            &(string[]){tos3("...")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_comma,
            &(string[]){tos3(",")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_semicolon,
            &(string[]){tos3(";")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_colon,
            &(string[]){tos3(":")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_arrow,
            &(string[]){tos3("=>")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_assign,
            &(string[]){tos3("=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_decl_assign,
            &(string[]){tos3(":=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_plus_assign,
            &(string[]){tos3("+=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_minus_assign,
            &(string[]){tos3("-=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_mult_assign,
            &(string[]){tos3("*=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_div_assign,
            &(string[]){tos3("/=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_xor_assign,
            &(string[]){tos3("^=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_mod_assign,
            &(string[]){tos3("%=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_or_assign,
            &(string[]){tos3("|=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_and_assign,
            &(string[]){tos3("&=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_righ_shift_assign,
            &(string[]){tos3(">>=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_left_shift_assign,
            &(string[]){tos3("<<=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_lcbr,
            &(string[]){tos3("{")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_rcbr,
            &(string[]){tos3("}")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_lpar,
            &(string[]){tos3("(")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_rpar,
            &(string[]){tos3(")")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_lsbr,
            &(string[]){tos3("[")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_rsbr,
            &(string[]){tos3("]")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_eq,
            &(string[]){tos3("==")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_ne,
            &(string[]){tos3("!=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_gt, &(string[]){tos3(">")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_lt, &(string[]){tos3("<")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_ge,
            &(string[]){tos3(">=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_le,
            &(string[]){tos3("<=")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_question,
            &(string[]){tos3("?")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_left_shift,
            &(string[]){tos3("<<")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_righ_shift,
            &(string[]){tos3(">>")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_line_comment,
            &(string[]){tos3("// line comment")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_mline_comment,
            &(string[]){tos3("/* mline comment */")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_nl,
            &(string[]){tos3("NLL")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_dollar,
            &(string[]){tos3("$")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_str_dollar,
            &(string[]){tos3("$2")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_assert,
            &(string[]){tos3("assert")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_struct,
            &(string[]){tos3("struct")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_if,
            &(string[]){tos3("if")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_else,
            &(string[]){tos3("else")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_asm,
            &(string[]){tos3("asm")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_return,
            &(string[]){tos3("return")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_module,
            &(string[]){tos3("module")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_sizeof,
            &(string[]){tos3("sizeof")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_go,
            &(string[]){tos3("go")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_goto,
            &(string[]){tos3("goto")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_const,
            &(string[]){tos3("const")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_mut,
            &(string[]){tos3("mut")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_type,
            &(string[]){tos3("type")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_for,
            &(string[]){tos3("for")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_switch,
            &(string[]){tos3("switch")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_fn,
            &(string[]){tos3("fn")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_true,
            &(string[]){tos3("true")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_false,
            &(string[]){tos3("false")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_continue,
            &(string[]){tos3("continue")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_break,
            &(string[]){tos3("break")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_import,
            &(string[]){tos3("import")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_embed,
            &(string[]){tos3("embed")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_unsafe,
            &(string[]){tos3("unsafe")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_typeof,
            &(string[]){tos3("typeof")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_enum,
            &(string[]){tos3("enum")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_interface,
            &(string[]){tos3("interface")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_pub,
            &(string[]){tos3("pub")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_import_const,
            &(string[]){tos3("import_const")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_in,
            &(string[]){tos3("in")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_atomic,
            &(string[]){tos3("atomic")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_orelse,
            &(string[]){tos3("or")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_global,
            &(string[]){tos3("__global")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_union,
            &(string[]){tos3("union")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_static,
            &(string[]){tos3("static")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_as,
            &(string[]){tos3("as")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_defer,
            &(string[]){tos3("defer")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_match,
            &(string[]){tos3("match")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_select,
            &(string[]){tos3("select")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_none,
            &(string[]){tos3("none")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_offsetof,
            &(string[]){tos3("__offsetof")});
  array_set(&/*q*/ s, compiler__compiler__TokenKind_key_nameof,
            &(string[]){tos3("nameof")});
  return s;
}
compiler__TokenKind compiler__key_to_token(string key) {
  int tmp3 = 0;
  bool tmp4 = map_get(/*token.v : 254*/ compiler__KEYWORDS, key, &tmp3);

  compiler__TokenKind a = ((compiler__TokenKind)(tmp3));
  return a;
}
bool compiler__is_key(string key) {
  return ((int)(compiler__key_to_token(key))) > 0;
}
string compiler__TokenKind_str(compiler__TokenKind t) {
  return (*(string *)array_get(compiler__TokenStr, ((int)(t))));
}
bool compiler__TokenKind_is_decl(compiler__TokenKind t) {
  return (t == compiler__compiler__TokenKind_key_enum ||
          t == compiler__compiler__TokenKind_key_interface ||
          t == compiler__compiler__TokenKind_key_fn ||
          t == compiler__compiler__TokenKind_key_struct ||
          t == compiler__compiler__TokenKind_key_type ||
          t == compiler__compiler__TokenKind_key_const ||
          t == compiler__compiler__TokenKind_key_import_const ||
          t == compiler__compiler__TokenKind_key_pub ||
          t == compiler__compiler__TokenKind_eof);
}
bool compiler__TokenKind_is_assign(compiler__TokenKind t) {
  return (_IN(compiler__TokenKind, (t), compiler__AssignTokens));
}
bool array_compiler__TokenKind_contains(array_compiler__TokenKind t,
                                        compiler__TokenKind val) {
  array_compiler__TokenKind tmp7 = t;
  for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
    compiler__TokenKind tt = ((compiler__TokenKind *)tmp7.data)[tmp8];

    if (tt == val) {
      return 1;
    };
  };
  return 0;
}
string compiler__Token_str(compiler__Token t) {
  if (t.tok == compiler__compiler__TokenKind_number) {
    return t.lit;
  };
  if (t.tok == compiler__compiler__TokenKind_chartoken) {
    return _STR("`%.*s`", t.lit.len, t.lit.str);
  };
  if (t.tok == compiler__compiler__TokenKind_string) {
    return _STR("'%.*s'", t.lit.len, t.lit.str);
  };
  if (t.tok == compiler__compiler__TokenKind_eof) {
    return tos3(".EOF");
  };
  if (t.tok < compiler__compiler__TokenKind_plus) {
    return t.lit;
  };
  return compiler__TokenKind_str(t.tok);
}
string compiler__Token_detailed_str(compiler__Token t) {
  string tmp9 = compiler__Token_str(t);

  return _STR("Token{ .line:%4d, .pos:%5d, .tok: %3d } = %.*s  ", t.line_nr,
              t.pos, t.tok, tmp9.len, tmp9.str);
}
compiler__ModFileCacher *compiler__new_mod_file_cacher() {
  return (compiler__ModFileCacher *)memdup(
      &(compiler__ModFileCacher){
          .cache = new_map(1, sizeof(compiler__ModFileAndFolder)),
          .folder_files = new_map(1, sizeof(array_string))},
      sizeof(compiler__ModFileCacher));
}
void compiler__ModFileCacher_dump(compiler__ModFileCacher *mcache) {
#ifdef VDEBUG
  eprintln(tos3("ModFileCacher DUMP:"));
  eprintln(tos3("	 ModFileCacher.cache:"));
  map_compiler__ModFileAndFolder tmp1 = mcache->cache;
  array_string keys_tmp1 = map_keys(&tmp1);
  for (int l = 0; l < keys_tmp1.len; l++) {
    string k = ((string *)keys_tmp1.data)[l];
    compiler__ModFileAndFolder v = {0};
    map_get(tmp1, k, &v);

    eprintln(_STR("	 K: %-32s | V: \"%32s\" | \"%32s\" ", k.str,
                  v.vmod_file.str, v.vmod_folder.str));
  };
  eprintln(tos3("	 ModFileCacher.folder_files:"));
  map_array_string tmp2 = mcache->folder_files;
  array_string keys_tmp2 = map_keys(&tmp2);
  for (int l = 0; l < keys_tmp2.len; l++) {
    string k = ((string *)keys_tmp2.data)[l];
    array_string v = new_array(0, 1, sizeof(string));
    map_get(tmp2, k, &v);

    eprintln(_STR("	 K: %-32s | V: %.*s", k.str, array_string_str(v).len,
                  array_string_str(v).str));
  };
#endif
  ;
}
compiler__ModFileAndFolder
compiler__ModFileCacher_get(compiler__ModFileCacher *mcache, string mfolder) {
  if ((_IN_MAP((mfolder), mcache->cache))) {
    compiler__ModFileAndFolder tmp3 = {0};
    bool tmp4 = map_get(/*v_mod_cache.v : 63*/ mcache->cache, mfolder, &tmp3);

    return tmp3;
  };
  _V_MulRet_array_string_V_compiler__ModFileAndFolder
      _V_mret_171_traversed_folders_res =
          compiler__ModFileCacher_traverse(mcache, mfolder);
  array_string traversed_folders = _V_mret_171_traversed_folders_res.var_0;
  compiler__ModFileAndFolder res = _V_mret_171_traversed_folders_res.var_1;
  array_string tmp5 = traversed_folders;
  for (int tmp6 = 0; tmp6 < tmp5.len; tmp6++) {
    string tfolder = ((string *)tmp5.data)[tmp6];

    compiler__ModFileCacher_add(mcache, tfolder, res);
  };
  return res;
}
void compiler__ModFileCacher_add(compiler__ModFileCacher *cacher, string path,
                                 compiler__ModFileAndFolder result) {
  map_set(&cacher->cache, path, &(compiler__ModFileAndFolder[]){result});
}
_V_MulRet_array_string_V_compiler__ModFileAndFolder
compiler__ModFileCacher_traverse(compiler__ModFileCacher *mcache,
                                 string mfolder) {
  string cfolder = mfolder;
  array_string folders_so_far = new_array_from_c_array(
      1, 1, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 1){cfolder});
  int levels = 0;
  while (1) {
    if (levels > 255) {
      break;
    };
    if (string_eq(cfolder, tos3("/")) || string_eq(cfolder, tos3(""))) {
      break;
    };
    if ((_IN_MAP((cfolder), mcache->cache))) {
      compiler__ModFileAndFolder tmp7 = {0};
      bool tmp8 = map_get(/*v_mod_cache.v : 88*/ mcache->cache, cfolder, &tmp7);

      compiler__ModFileAndFolder res = tmp7;
      if (res.vmod_file.len == 0) {
        compiler__ModFileCacher_mark_folders_as_vmod_free(mcache,
                                                          folders_so_far);
      } else {
        compiler__ModFileCacher_mark_folders_with_vmod(mcache, folders_so_far,
                                                       res);
      };
      return (_V_MulRet_array_string_V_compiler__ModFileAndFolder){
          .var_0 = new_array_from_c_array(
              0, 0, sizeof(string),
              EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)}),
          .var_1 = res};
    };
    array_string files = compiler__ModFileCacher_get_files(mcache, cfolder);
    if ((_IN(string, (tos3("v.mod")), files))) {
      compiler__ModFileAndFolder res = (compiler__ModFileAndFolder){
          .vmod_file = os__join_path(
              cfolder, &(varg_string){.len = 1, .args = {tos3("v.mod")}}),
          .vmod_folder = cfolder};
      return (_V_MulRet_array_string_V_compiler__ModFileAndFolder){
          .var_0 = folders_so_far, .var_1 = res};
    };
    if (compiler__ModFileCacher_check_for_stop(&/* ? */ *mcache, cfolder,
                                               files)) {
      break;
    };
    cfolder = os__base_dir(cfolder);
    _PUSH(&folders_so_far, (/*typ = array_string   tmp_typ=string*/ cfolder),
          tmp9, string);
    levels++;
  };
  compiler__ModFileCacher_mark_folders_as_vmod_free(mcache, folders_so_far);
  return (_V_MulRet_array_string_V_compiler__ModFileAndFolder){
      .var_0 = new_array_from_c_array(1, 1, sizeof(string),
                                      EMPTY_ARRAY_OF_ELEMS(string, 1){mfolder}),
      .var_1 = (compiler__ModFileAndFolder){.vmod_file = tos3(""),
                                            .vmod_folder = mfolder}};
}
void compiler__ModFileCacher_mark_folders_with_vmod(
    compiler__ModFileCacher *mcache, array_string folders_so_far,
    compiler__ModFileAndFolder vmod) {
  array_string tmp10 = folders_so_far;
  for (int tmp11 = 0; tmp11 < tmp10.len; tmp11++) {
    string f = ((string *)tmp10.data)[tmp11];

    compiler__ModFileCacher_add(mcache, f, vmod);
  };
}
void compiler__ModFileCacher_mark_folders_as_vmod_free(
    compiler__ModFileCacher *mcache, array_string folders_so_far) {
  array_string tmp12 = folders_so_far;
  for (int tmp13 = 0; tmp13 < tmp12.len; tmp13++) {
    string f = ((string *)tmp12.data)[tmp13];

    compiler__ModFileCacher_add(
        mcache, f,
        (compiler__ModFileAndFolder){.vmod_file = tos3(""), .vmod_folder = f});
  };
}
bool compiler__ModFileCacher_check_for_stop(compiler__ModFileCacher *mcache,
                                            string cfolder,
                                            array_string files) {
  array_string tmp14 = compiler__MOD_FILE_STOP_PATHS;
  for (int tmp15 = 0; tmp15 < tmp14.len; tmp15++) {
    string i = ((string *)tmp14.data)[tmp15];

    if ((_IN(string, (i), files))) {
      return 1;
    };
  };
  return 0;
}
array_string compiler__ModFileCacher_get_files(compiler__ModFileCacher *mcache,
                                               string cfolder) {
  if ((_IN_MAP((cfolder), mcache->folder_files))) {
    array_string tmp16 = new_array(0, 1, sizeof(string));
    bool tmp17 =
        map_get(/*v_mod_cache.v : 140*/ mcache->folder_files, cfolder, &tmp16);

    return tmp16;
  };
  Option_array_string tmp18 = os__ls(cfolder);
  array_string files;
  if (!tmp18.ok) {
    string err = tmp18.error;
    int errcode = tmp18.ecode;
    return new_array_from_c_array(0, 0, sizeof(string),
                                  EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  }
  files = *(array_string *)tmp18.data;
  ;
  map_set(&mcache->folder_files, cfolder, &(array_string[]){files});
  return files;
}
void compiler__Scanner_fgen(compiler__Scanner *scanner, string s_) {
  string s = s_;
  if (string_ne(s, tos3(" "))) {
  };
  if (scanner->fmt_line_empty) {
    s = string_add(strings__repeat('\t', scanner->fmt_indent),
                   string_trim_left(s, tos3(" ")));
  };
  _PUSH(&scanner->fmt_lines, (/*typ = array_string   tmp_typ=string*/ s), tmp1,
        string);
  scanner->fmt_line_empty = 0;
}
void compiler__Scanner_fgenln(compiler__Scanner *scanner, string s_) {
  string s = string_trim_right(s_, tos3(" "));
  if (scanner->fmt_line_empty && scanner->fmt_indent > 0) {
    s = string_add(strings__repeat('\t', scanner->fmt_indent), s);
  };
  _PUSH(&scanner->fmt_lines, (/*typ = array_string   tmp_typ=string*/ s), tmp2,
        string);
  _PUSH(&scanner->fmt_lines,
        (/*typ = array_string   tmp_typ=string*/ tos3("\n")), tmp3, string);
  scanner->fmt_line_empty = 1;
}
void compiler__Parser_fgen(compiler__Parser *p, string s) {
  if (p->pass != compiler__compiler__Pass_main) {

    return;
  };
  ;
}
void compiler__Parser_fspace(compiler__Parser *p) {
  if (compiler__Parser_first_pass(&/* ? */ *p)) {

    return;
  };
  ;
}
void compiler__Parser_fspace_or_newline(compiler__Parser *p) {
  if (compiler__Parser_first_pass(&/* ? */ *p)) {

    return;
  };
  if (p->token_idx >= 2 &&
      (*(compiler__Token *)array_get(p->tokens, p->token_idx - 1)).line_nr !=
          (*(compiler__Token *)array_get(p->tokens, p->token_idx - 2))
              .line_nr) {
    ;
  } else {
    ;
  };
}
void compiler__Parser_fgenln(compiler__Parser *p, string s) {
  if (p->pass != compiler__compiler__Pass_main) {

    return;
  };
  ;
}
void compiler__Parser_fgen_nl(compiler__Parser *p) {
  if (p->pass != compiler__compiler__Pass_main) {

    return;
  };
  if (p->scanner->fmt_lines.len > 0 &&
      string_eq(*(string *)array_last(p->scanner->fmt_lines), tos3("\n")) &&
      p->token_idx > 2 &&
      (*(compiler__Token *)array_get(p->tokens, p->token_idx - 2)).tok ==
          compiler__compiler__TokenKind_line_comment) {

    return;
  };
  ;
}
void compiler__Scanner_fgen_nl(compiler__Scanner *scanner) {
  _PUSH(&scanner->fmt_lines,
        (/*typ = array_string   tmp_typ=string*/ tos3("\n")), tmp10, string);
  scanner->fmt_line_empty = 1;
}
void compiler__Parser_fmt_inc(compiler__Parser *p) {
  if (p->pass != compiler__compiler__Pass_main) {

    return;
  };
  p->scanner->fmt_indent++;
}
void compiler__Parser_fmt_dec(compiler__Parser *p) {
  if (p->pass != compiler__compiler__Pass_main) {

    return;
  };
  p->scanner->fmt_indent--;
}
void compiler__Scanner_init_fmt(compiler__Scanner *s) { s->is_fmt = 1; }
void compiler__Parser_fnext(compiler__Parser *p) {
  if (p->tok == compiler__compiler__TokenKind_rcbr && !p->inside_if_expr &&
      p->prev_tok != compiler__compiler__TokenKind_lcbr) {
    ;
  };
  string s = compiler__Parser_strtok(&/* ? */ *p);
  if (p->tok != compiler__compiler__TokenKind_eof) {
    ;
  };
  bool inc_indent = 0;
  if (p->tok == compiler__compiler__TokenKind_lcbr && !p->inside_if_expr &&
      compiler__Parser_peek(&/* ? */ *p) !=
          compiler__compiler__TokenKind_rcbr) {
    ;
    ;
  };
  if (p->token_idx >= p->tokens.len) {

    return;
  };
  if (((*(compiler__Token *)array_get(p->tokens, p->token_idx)).tok ==
           compiler__compiler__TokenKind_line_comment ||
       (*(compiler__Token *)array_get(p->tokens, p->token_idx)).tok ==
           compiler__compiler__TokenKind_mline_comment)) {
    if (p->inside_const) {
    };
    while (p->token_idx < p->tokens.len - 1) {

      int i = p->token_idx;
      compiler__TokenKind tok =
          (*(compiler__Token *)array_get(p->tokens, p->token_idx)).tok;
      if (tok != compiler__compiler__TokenKind_line_comment &&
          tok != compiler__compiler__TokenKind_mline_comment) {
        break;
      };
      compiler__Token comment_token =
          (*(compiler__Token *)array_get(p->tokens, i));
      compiler__Token next = (*(compiler__Token *)array_get(p->tokens, i + 1));
      bool comment_on_new_line =
          i == 0 ||
          comment_token.line_nr >
              (*(compiler__Token *)array_get(p->tokens, i - 1)).line_nr;
      string comment = comment_token.lit;
      if (i > 0 &&
          (((*(compiler__Token *)array_get(p->tokens, i - 1)).tok !=
                compiler__compiler__TokenKind_line_comment &&
            (*(compiler__Token *)array_get(p->tokens, i - 1)).tok !=
                compiler__compiler__TokenKind_lcbr &&
            comment_token.line_nr >
                (*(compiler__Token *)array_get(p->tokens, i - 1)).line_nr) ||
           (*(compiler__Token *)array_get(p->tokens, i - 1)).tok ==
               compiler__compiler__TokenKind_hash)) {
        ;
      };
      if (i > 0 &&
          (*(compiler__Token *)array_get(p->tokens, i - 1)).tok ==
              compiler__compiler__TokenKind_rcbr &&
          p->scanner->fmt_indent == 0) {
        ;
      };
      if (tok == compiler__compiler__TokenKind_line_comment) {
        if (!comment_on_new_line) {
          ;
        };
        ;
      } else {
        ;
      };
      if (comment_token.line_nr < next.line_nr) {
        ;
      };
      p->token_idx++;
    };
    if (inc_indent) {
      ;
    };
  };
}
void compiler__Parser_fremove_last(compiler__Parser *p) {
  if (p->scanner->fmt_lines.len > 0) {
    array_set(&/*q*/ p->scanner->fmt_lines, p->scanner->fmt_lines.len - 1,
              &(string[]){tos3("")});
  };
}
void compiler__Parser_gen_fmt(compiler__Parser *p) {
  if (p->pass != compiler__compiler__Pass_main) {

    return;
  };
  if (string_eq(p->file_name, tos3(""))) {

    return;
  };
  bool is_all = p->v->v_fmt_all;
  string vfmt_file = p->v->v_fmt_file;
  if (string_ne(p->file_path, vfmt_file) && !is_all) {

    return;
  };
  string s = array_string_join(p->scanner->fmt_lines, tos3(""));
  s = string_replace(s, tos3(" \n"), tos3("\n"));
  s = string_replace(s, tos3(")  or {"), tos3(") or {"));
  s = string_replace(s, tos3(") or{"), tos3(") or {"));
  s = string_replace(s, tos3(")or{"), tos3(") or {"));
  s = string_replace(s, tos3("or{"), tos3("or {"));
  s = string_replace(s, tos3("}}\n"), tos3("}\n\t}\n"));
  if (string_eq(s, tos3(""))) {

    return;
  };
  if (string_contains(p->file_path, tos3("compiler/vfmt.v"))) {

    return;
  };
  if (is_all) {
    if (p->file_path.len > 0) {
      string path = compiler__write_formatted_source(p->file_name, s);
      Option_bool tmp31 = os__cp(path, p->file_path);
      if (!tmp31.ok) {
        string err = tmp31.error;
        int errcode = tmp31.ecode;
        v_panic(err);
      };
      eprintln(_STR("Written fmt file to: %.*s", p->file_path.len,
                    p->file_path.str));
    };
  };
  if (string_eq(p->file_path, vfmt_file)) {
    string res_path = compiler__write_formatted_source(p->file_name, s);
    compiler__V *vv = p->v;
    vv->v_fmt_file_result = res_path;
  };
}
string compiler__write_formatted_source(string file_name, string s) {
  string path = string_add(string_add(os__temp_dir(), tos3("/")), file_name);
  Option_os__File tmp32 = os__create(path);
  os__File out;
  if (!tmp32.ok) {
    string err = tmp32.error;
    int errcode = tmp32.ecode;
    compiler__verror(_STR("failed to create file %.*s", path.len, path.str));
    return tos3("");
  }
  out = *(os__File *)tmp32.data;
  ;
  os__File_writeln(&/* ? */ out, string_trim_space(s));
  os__File_close(&/* ? */ out);
  return path;
}
string compiler__get_vtmp_folder() {
  string vtmp = os__join_path(os__temp_dir(),
                              &(varg_string){.len = 1, .args = {tos3("v")}});
  if (!os__is_dir(vtmp)) {
    Option_bool tmp1 = os__mkdir(vtmp);
    if (!tmp1.ok) {
      string err = tmp1.error;
      int errcode = tmp1.ecode;
      v_panic(err);
    };
  };
  return vtmp;
}
string compiler__get_vtmp_filename(string base_file_name, string postfix) {
  string vtmp = compiler__get_vtmp_folder();
  return os__realpath(os__join_path(
      vtmp, &(varg_string){
                .len = 1,
                .args = {string_add(os__filename(os__realpath(base_file_name)),
                                    postfix)}}));
}
void internal_dot_compile__check_for_common_mistake(
    array_string args, v_dot_pref__Preferences *p) {
  if (string_ends_with(p->out_name, tos3(".c")) &&
      p->backend == v_dot_pref__v_dot_pref__Backend_c) {
  };
  if (string_ends_with(p->out_name, tos3(".js")) &&
      p->backend != v_dot_pref__v_dot_pref__Backend_js) {
    printf("HINT: `-o %.*s` implies `-backend js` currently.\n",
           p->out_name.len, p->out_name.str);
  };
  if (string_eq(p->path, tos3("vlib/compiler")) ||
      string_eq(p->path, tos3("v.v"))) {
    println(tos3("HINT: The V compiler is now located in `cmd/v`."));
    printf("      `%.*s` is no longer the correct path to compile if you are "
           "intending to do so.\n",
           p->path.len, p->path.str);
  };
  if (!string_ends_with(p->path, tos3(".v")) && !os__is_dir(p->path) &&
      os__is_dir(string_add(p->path, os__path_separator))) {
    printf("HINT: `%.*s` is not a directory nor a file suffixed with `.v`.\n",
           p->path.len, p->path.str);
    println(tos3("      Did you perhaps accidentally reference the compiled "
                 "executable?"));
    println(tos3("      To make sure V detects the directory correctly, add "
                 "the path separator to the end of the path like so:"));
    printf("      `v %.*s%.*s`\n", p->path.len, p->path.str,
           os__path_separator.len, os__path_separator.str);
  };
}
void internal_dot_compile__compile(string command, array_string args) {
  internal_dot_compile__parse_and_output_new_format(args);
  _V_MulRet_v_dot_pref__Preferences_V_array_string _V_mret_30_prefs_remaining =
      internal_dot_compile__parse_arguments(args);
  v_dot_pref__Preferences prefs = _V_mret_30_prefs_remaining.var_0;
  array_string remaining = _V_mret_30_prefs_remaining.var_1;
  internal_dot_compile__check_for_common_mistake(args, &prefs);
  compiler__V *v = compiler__new_v(&/*114*/ prefs);
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
    println(array_string_str(args));
  };
  benchmark__Benchmark tmark = benchmark__new_benchmark();
  if (v->pref->backend == v_dot_pref__v_dot_pref__Backend_x64) {
    compiler__V_compile_x64(v);
  } else if (v->pref->backend == v_dot_pref__v_dot_pref__Backend_experimental) {
    compiler__V_compile2(v);
  } else {
    compiler__V_compile(v);
  };
  if (v->pref->is_stats) {
    benchmark__Benchmark_stop(&/* ? */ tmark);
    println(string_add(string_add(tos3("compilation took: "),
                                  i64_str(benchmark__Benchmark_total_duration(
                                      &/* ? */ tmark))),
                       tos3("ms")));
  };
  if (v->pref->is_test || v->pref->is_run) {
    internal_dot_compile__run_compiled_executable_and_exit(v, remaining);
  };
  compiler__V_finalize_compilation(&/* ? */ *v);
}
void internal_dot_compile__run_compiled_executable_and_exit(
    compiler__V *v, array_string remaining_args) {
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
    printf("============ running %.*s ============\n", v->pref->out_name.len,
           v->pref->out_name.str);
  };
  string cmd = _STR("\"%.*s\"", v->pref->out_name.len, v->pref->out_name.str);
  if (remaining_args.len > 1) {
    cmd = string_add(
        cmd,
        string_add(tos3(" "),
                   array_string_join(array_slice2(remaining_args, 1, -1, true),
                                     tos3(" "))));
  };
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          v->pref->verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
    printf("command to run executable: %.*s\n", cmd.len, cmd.str);
  };
  if (v->pref->is_test) {
    int ret = os__system(cmd);
    if (ret != 0) {
      v_exit(1);
    };
  };
  if (v->pref->is_run) {
    int ret = os__system(cmd);
    v_exit(ret);
  };
  v_exit(0);
}
static inline void
internal_dot_compile__parse_c_options(string flag,
                                      internal_dot_flag__Instance *f,
                                      v_dot_pref__Preferences *prefs) {
  string tmp1 = flag;

  if ((string_eq(tmp1, tos3("cc"))) || (string_eq(tmp1, tos3("compiler")))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               2, 2, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 2){tos3("cc"), tos3("compiler")}));
    Option_string tmp2 = internal_dot_flag__Instance_string(f);
    string tmp;
    if (!tmp2.ok) {
      string err = tmp2.error;
      int errcode = tmp2.ecode;
      printf("V error: Expected argument after `-%.*s`.\n", flag.len, flag.str);
      v_exit(1);
    }
    tmp = *(string *)tmp2.data;
    ;
    prefs->ccompiler = tmp;
  } else if ((string_eq(tmp1, tos3("cg"))) ||
             (string_eq(tmp1, tos3("cdebug")))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               4, 4, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 4){tos3("cg"), tos3("cdebug"),
                                               tos3("g"), tos3("debug")}));
    if (internal_dot_flag__Instance_bool(f)) {
      prefs->is_debug = 1;
      prefs->is_vlines = 0;
    };
  } else if (string_eq(tmp1, tos3("live"))) {
    prefs->is_live = internal_dot_flag__Instance_bool(f);
  } else if (string_eq(tmp1, tos3("csource"))) {
    Option_string tmp3 = internal_dot_flag__Instance_string(f);
    string operation;
    if (!tmp3.ok) {
      string err = tmp3.error;
      int errcode = tmp3.ecode;
      println(tos3("V error: Expected argument after `-csource`."));
      v_exit(1);
    }
    operation = *(string *)tmp3.data;
    ;
    string tmp4 = operation;

    if (string_eq(tmp4, tos3("keep"))) {
      prefs->is_keep_c = 1;
    } else if (string_eq(tmp4, tos3("prettify"))) {
      prefs->is_keep_c = 1;
      prefs->is_pretty_c = 1;
    } else if (string_eq(tmp4, tos3("drop"))) {
    } else // default:
    {
      printf("V error: Unknown argument for `-csource` (`%.*s`).\n",
             operation.len, operation.str);
      println(tos3("Allowed options: `keep`, `prettify` and `drop`."));
      v_exit(1);
    };
  } else if (string_eq(tmp1, tos3("sanitize"))) {
    prefs->sanitize = internal_dot_flag__Instance_bool(f);
  } else if ((string_eq(tmp1, tos3("cf"))) ||
             (string_eq(tmp1, tos3("cflags")))) {
    internal_dot_flag__Instance_allow_duplicate(f);
    Option_string tmp5 = internal_dot_flag__Instance_string(f);
    string cflag;
    if (!tmp5.ok) {
      string err = tmp5.error;
      int errcode = tmp5.ecode;
      printf("V error: Expected argument after `-%.*s`.\n", flag.len, flag.str);
      v_exit(1);
    }
    cflag = *(string *)tmp5.data;
    ;
    prefs->cflags =
        string_add(prefs->cflags, _STR(" %.*s", cflag.len, cflag.str));
  } else if (string_eq(tmp1, tos3("repl"))) {
    prefs->is_repl = internal_dot_flag__Instance_bool(f);
  } else if (string_eq(tmp1, tos3("solive"))) {
    prefs->is_solive = internal_dot_flag__Instance_bool(f);
    prefs->is_so = prefs->is_solive;
  } else // default:
  {
    internal_dot_compile__parse_executable_options(flag, f, prefs);
  };
}
static inline void internal_dot_compile__parse_js_options(
    string flag, internal_dot_flag__Instance f, v_dot_pref__Preferences prefs) {
  printf("V error: Unknown flag `-%.*s` provided.\n", flag.len, flag.str);
  println(tos3("Use `--` to terminate flag list if necessary."));
  v_exit(1);
}
_V_MulRet_v_dot_pref__Preferences_V_array_string
internal_dot_compile__parse_arguments(array_string args) {
  v_dot_pref__Preferences p = (v_dot_pref__Preferences){
      .enable_globals = 1,
      .is_test = 0,
      .is_script = 0,
      .is_live = 0,
      .is_solive = 0,
      .is_so = 0,
      .is_prof = 0,
      .translated = 0,
      .is_prod = 0,
      .obfuscate = 0,
      .is_repl = 0,
      .is_run = 0,
      .sanitize = 0,
      .is_debug = 0,
      .is_vlines = 0,
      .is_keep_c = 0,
      .is_pretty_c = 0,
      .is_cache = 0,
      .is_stats = 0,
      .no_auto_free = 0,
      .cflags = tos3(""),
      .ccompiler = tos3(""),
      .third_party_option = tos3(""),
      .building_v = 0,
      .autofree = 0,
      .compress = 0,
      .fast = 0,
      .is_bare = 0,
      .lookup_path = new_array(0, 1, sizeof(string)),
      .output_cross_c = 0,
      .prealloc = 0,
      .vroot = tos3(""),
      .out_name = tos3(""),
      .path = tos3(""),
      .compile_defines = new_array(0, 1, sizeof(string)),
      .compile_defines_all = new_array(0, 1, sizeof(string)),
      .mod = tos3("")};
  array_string backend = os_dot_cmdline__options(args, tos3("-b"));
  _PUSH_MANY(&backend,
             (/*typ = array_string   tmp_typ=string*/ os_dot_cmdline__options(
                 args, tos3("-backend"))),
             tmp1, array_string);
  if (backend.len > 1) {
    println(tos3("V error: Only one backend may be enabled at once. (Multiple "
                 "`-b`/`-backend` flags provided)"));
    v_exit(1);
  };
  if (backend.len == 1) {
    Option_v_dot_pref__Backend tmp4 =
        v_dot_pref__backend_from_string((*(string *)array_get(backend, 0)));
    if (!tmp4.ok) {
      string err = tmp4.error;
      int errcode = tmp4.ecode;
      printf("V error: Unknown backend %.*s provided.\n",
             (*(string *)array_get(backend, 0)).len,
             (*(string *)array_get(backend, 0)).str);
      v_exit(1);
    }
    p.backend = *(v_dot_pref__Backend *)tmp4.data;
    ;
  } else {
    p.backend = v_dot_pref__v_dot_pref__Backend_c;
  };
  Option_array_string tmp7 = internal_dot_flag__parse_pref(
      args, internal_dot_compile__parse_options, &p);
  array_string remaining;
  if (!tmp7.ok) {
    string err = tmp7.error;
    int errcode = tmp7.ecode;
    println(tos3("V error: Error while parsing flags."));
    println(err);
    v_exit(1);
  }
  remaining = *(array_string *)tmp7.data;
  ;
  string tmp10 = (*(string *)array_get(remaining, 0));

  if (string_eq(tmp10, tos3("run"))) {
    p.is_run = 1;
    remaining = array_slice2(remaining, 1, -1, true);
  } else if (string_eq(tmp10, tos3("build"))) {
    remaining = array_slice2(remaining, 1, -1, true);
    if (remaining.len > 0 &&
        string_eq((*(string *)array_get(remaining, 0)), tos3("module"))) {
      remaining = array_slice2(remaining, 1, -1, true);
      println(tos3("V error: Module compilation is not ready yet."));
      v_exit(1);
    };
  } else // default:
  {
  };
  if (remaining.len == 0) {
    println(tos3("V error: Expected file/directory to compile."));
    v_exit(1);
  };
  if (!p.is_run && remaining.len > 1) {
    println(tos3("V error: Expected only one file/directory to compile."));
    println(tos3("Did you perhaps put flags after the file/directory?"));
    v_exit(1);
  };
  p.path = (*(string *)array_get(remaining, 0));
  v_dot_pref__Preferences_fill_with_defaults(&/* ? */ p);
  return (_V_MulRet_v_dot_pref__Preferences_V_array_string){.var_0 = p,
                                                            .var_1 = remaining};
}
void internal_dot_compile__parse_options(string flag,
                                         internal_dot_flag__Instance *f,
                                         v_dot_pref__Preferences *prefs) {
  string tmp21 = flag;

  if (string_eq(tmp21, tos3("path"))) {
    Option_string tmp22 = internal_dot_flag__Instance_string(f);
    string path_str;
    if (!tmp22.ok) {
      string err = tmp22.error;
      int errcode = tmp22.ecode;
      println(tos3("V error: Expected argument for `-path`."));
      v_exit(1);
    }
    path_str = *(string *)tmp22.data;
    ;
    prefs->lookup_path = string_split(path_str, tos3("|"));
  } else if ((string_eq(tmp21, tos3("o"))) ||
             (string_eq(tmp21, tos3("output")))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               2, 2, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 2){tos3("o"), tos3("output")}));
    Option_string tmp23 = internal_dot_flag__Instance_string(f);
    string tmp;
    if (!tmp23.ok) {
      string err = tmp23.error;
      int errcode = tmp23.ecode;
      printf("V error: Expected argument for `-%.*s`.\n", flag.len, flag.str);
      v_exit(1);
    }
    tmp = *(string *)tmp23.data;
    ;
    prefs->out_name = tmp;
  } else if ((string_eq(tmp21, tos3("d"))) ||
             (string_eq(tmp21, tos3("define")))) {
    internal_dot_flag__Instance_allow_duplicate(f);
    Option_string tmp24 = internal_dot_flag__Instance_string(f);
    string define;
    if (!tmp24.ok) {
      string err = tmp24.error;
      int errcode = tmp24.ecode;
      printf("V error: Expected argument for `-%.*s`.\n", flag.len, flag.str);
      v_exit(1);
    }
    define = *(string *)tmp24.data;
    ;
    internal_dot_compile__parse_define(prefs, define);
  } else if ((string_eq(tmp21, tos3("g"))) ||
             (string_eq(tmp21, tos3("debug")))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               4, 4, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 4){tos3("g"), tos3("debug"),
                                               tos3("cg"), tos3("cdebug")}));
    if (internal_dot_flag__Instance_bool(f)) {
      prefs->is_debug = 1;
      prefs->is_vlines = 1;
    };
  } else if ((string_eq(tmp21, tos3("e"))) ||
             (string_eq(tmp21, tos3("experiments")))) {
    internal_dot_flag__Instance_allow_duplicate(f);
    Option_string tmp25 = internal_dot_flag__Instance_string(f);
    string to_enable;
    if (!tmp25.ok) {
      string err = tmp25.error;
      int errcode = tmp25.ecode;
      printf("V error: Expected argument for `-%.*s`.\n", flag.len, flag.str);
      v_exit(1);
    }
    to_enable = *(string *)tmp25.data;
    ;
    string tmp26 = to_enable;

    if (string_eq(tmp26, tos3("prealloc"))) {
      prefs->prealloc = 1;
    } else // default:
    {
      printf("V error: Unknown experiment `%.*s`.\n", to_enable.len,
             to_enable.str);
      v_exit(1);
    };
  } else if (string_eq(tmp21, tos3("prod"))) {
    prefs->is_prod = 1;
  } else if (string_eq(tmp21, tos3("v"))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               4, 4, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 4){tos3("v"), tos3("vv"),
                                               tos3("vvv"), tos3("verbose")}));
    prefs->verbosity = v_dot_pref__v_dot_pref__VerboseLevel_level_one;
  } else if (string_eq(tmp21, tos3("vv"))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               4, 4, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 4){tos3("v"), tos3("vv"),
                                               tos3("vvv"), tos3("verbose")}));
    prefs->verbosity = v_dot_pref__v_dot_pref__VerboseLevel_level_two;
  } else if (string_eq(tmp21, tos3("vvv"))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               4, 4, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 4){tos3("v"), tos3("vv"),
                                               tos3("vvv"), tos3("verbose")}));
    prefs->verbosity = v_dot_pref__v_dot_pref__VerboseLevel_level_three;
  } else if (string_eq(tmp21, tos3("verbose"))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               4, 4, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 4){tos3("v"), tos3("vv"),
                                               tos3("vvv"), tos3("verbose")}));
    Option_int tmp27 = internal_dot_flag__Instance_int(f);
    int level;
    if (!tmp27.ok) {
      string err = tmp27.error;
      int errcode = tmp27.ecode;
      println(tos3("V error: Expected `0`, `1`, `2` or `3` as argument to "
                   "`-verbose` to specify verbosity level."));
      v_exit(1);
    }
    level = *(int *)tmp27.data;
    ;
    int tmp28 = level;

    if (tmp28 == 0) {
    } else if (tmp28 == 1) {
      prefs->verbosity = v_dot_pref__v_dot_pref__VerboseLevel_level_one;
    } else if (tmp28 == 2) {
      prefs->verbosity = v_dot_pref__v_dot_pref__VerboseLevel_level_two;
    } else if (tmp28 == 3) {
      prefs->verbosity = v_dot_pref__v_dot_pref__VerboseLevel_level_three;
    } else // default:
    {
      println(tos3("V error: Expected `0`, `1`, `2` or `3` as argument to "
                   "`-verbose` to specify verbosity level."));
      v_exit(1);
    };
  } else if (string_eq(tmp21, tos3("full-rebuild"))) {
    prefs->is_cache = !internal_dot_flag__Instance_bool(f);
  } else if (string_eq(tmp21, tos3("stats"))) {
    prefs->is_stats = internal_dot_flag__Instance_bool(f);
  } else if ((string_eq(tmp21, tos3("obf"))) ||
             (string_eq(tmp21, tos3("obfuscate")))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(2, 2, sizeof(string),
                                  EMPTY_ARRAY_OF_ELEMS(string, 2){
                                      tos3("-obf"), tos3("-obfuscate")}));
    prefs->obfuscate = internal_dot_flag__Instance_bool(f);
  } else if ((string_eq(tmp21, tos3("prof"))) ||
             (string_eq(tmp21, tos3("profile")))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(2, 2, sizeof(string),
                                  EMPTY_ARRAY_OF_ELEMS(string, 2){
                                      tos3("-prof"), tos3("-profile")}));
    prefs->is_prof = internal_dot_flag__Instance_bool(f);
  } else if (string_eq(tmp21, tos3("translated"))) {
    prefs->translated = internal_dot_flag__Instance_bool(f);
  } else if ((string_eq(tmp21, tos3("b"))) ||
             (string_eq(tmp21, tos3("backend")))) {
    Option_string tmp29 = internal_dot_flag__Instance_string(f);
    if (!tmp29.ok) {
      string err = tmp29.error;
      int errcode = tmp29.ecode;

      return;
    };
  } else // default:
  {
    v_dot_pref__Backend tmp30 = prefs->backend;

    if ((tmp30 == v_dot_pref__v_dot_pref__Backend_c) ||
        (tmp30 == v_dot_pref__v_dot_pref__Backend_experimental)) {
      internal_dot_compile__parse_c_options(flag, f, prefs);
    } else if (tmp30 == v_dot_pref__v_dot_pref__Backend_x64) {
      internal_dot_compile__parse_x64_options(flag, f, prefs);
    } else if (tmp30 == v_dot_pref__v_dot_pref__Backend_js) {
      internal_dot_compile__parse_js_options(flag, *f, *prefs);
    } else // default:
    {
      v_panic(_STR("unexpected backend type: %d", prefs->backend));
    };
  };
}
static inline void
internal_dot_compile__parse_define(v_dot_pref__Preferences *prefs,
                                   string define) {
  array_string define_parts = string_split(define, tos3("="));
  if (define_parts.len == 1) {
    _PUSH(&prefs->compile_defines,
          (/*typ = array_string   tmp_typ=string*/ define), tmp31, string);
    _PUSH(&prefs->compile_defines_all,
          (/*typ = array_string   tmp_typ=string*/ define), tmp32, string);

    return;
  };
  if (define_parts.len == 2) {
    _PUSH(&prefs->compile_defines_all,
          (/*typ = array_string   tmp_typ=string*/ (
              *(string *)array_get(define_parts, 0))),
          tmp33, string);
    string tmp38 = (*(string *)array_get(define_parts, 1));

    if (string_eq(tmp38, tos3("0"))) {
    } else if (string_eq(tmp38, tos3("1"))) {
      _PUSH(&prefs->compile_defines,
            (/*typ = array_string   tmp_typ=string*/ (
                *(string *)array_get(define_parts, 0))),
            tmp39, string);
    } else // default:
    {
      println(string_add(
          _STR("V error: Unknown define argument value `%.*s` for %.*s.",
               (*(string *)array_get(define_parts, 1)).len,
               (*(string *)array_get(define_parts, 1)).str,
               (*(string *)array_get(define_parts, 0)).len,
               (*(string *)array_get(define_parts, 0)).str),
          tos3("Expected `0` or `1`.")));
      v_exit(1);
    };

    return;
  };
  printf("V error: Unknown define argument: %.*s. Expected at most one `=`.\n",
         define.len, define.str);
  v_exit(1);
}
static inline void
internal_dot_compile__parse_x64_options(string flag,
                                        internal_dot_flag__Instance *f,
                                        v_dot_pref__Preferences *prefs) {
  if (string_eq(flag, tos3("arch"))) {
    println(
        tos3("V error: The `-arch` flag is not supported on the x64 backend."));
    v_exit(1);
  };
  internal_dot_compile__parse_executable_options(flag, f, prefs);
}
static inline void
internal_dot_compile__parse_executable_options(string flag,
                                               internal_dot_flag__Instance *f,
                                               v_dot_pref__Preferences *prefs) {
  string tmp1 = flag;

  if ((string_eq(tmp1, tos3("os"))) || (string_eq(tmp1, tos3("target-os")))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               2, 2, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 2){tos3("os"), tos3("target-os")}));
    Option_string tmp2 = internal_dot_flag__Instance_string(f);
    string target_os;
    if (!tmp2.ok) {
      string err = tmp2.error;
      int errcode = tmp2.ecode;
      printf("V error: Expected argument after `-%.*s`.\n", flag.len, flag.str);
      v_exit(1);
    }
    target_os = *(string *)tmp2.data;
    ;
    if (string_eq(target_os, tos3("cross"))) {
      prefs->output_cross_c = 1;

      return;
    };
    Option_v_dot_pref__OS tmp3 = v_dot_pref__os_from_string(target_os);
    v_dot_pref__OS tmp;
    if (!tmp3.ok) {
      string err = tmp3.error;
      int errcode = tmp3.ecode;
      printf("V error: Unknown operating system target `%.*s`.\n",
             target_os.len, target_os.str);
      v_exit(1);
    }
    tmp = *(v_dot_pref__OS *)tmp3.data;
    ;
    prefs->os = tmp;
  } else if (string_eq(tmp1, tos3("arch"))) {
    Option_string tmp4 = internal_dot_flag__Instance_string(f);
    string target_arch;
    if (!tmp4.ok) {
      string err = tmp4.error;
      int errcode = tmp4.ecode;
      println(tos3("V error: Expected argument after `-arch`."));
      v_exit(1);
    }
    target_arch = *(string *)tmp4.data;
    ;
    string tmp5 = target_arch;

    if (string_eq(tmp5, tos3("x86"))) {
      prefs->cflags = string_add(prefs->cflags, tos3(" -m32"));
    } else if (string_eq(tmp5, tos3("x64"))) {
    } else // default:
    {
      println(tos3("V error: Unknown architecture type. Only x86 and x64 are "
                   "supported currently."));
      v_exit(1);
    };
  } else if (string_eq(tmp1, tos3("freestanding"))) {
    prefs->is_bare = internal_dot_flag__Instance_bool(f);
  } else if (string_eq(tmp1, tos3("shared"))) {
    prefs->is_so = internal_dot_flag__Instance_bool(f);
  } else if (string_eq(tmp1, tos3("live"))) {
    prefs->is_solive = internal_dot_flag__Instance_bool(f);
  } else if (string_eq(tmp1, tos3("manual-free"))) {
    prefs->autofree = !internal_dot_flag__Instance_bool(f);
  } else if (string_eq(tmp1, tos3("compress"))) {
    prefs->compress = internal_dot_flag__Instance_bool(f);
  } else // default:
  {
    printf("V error: Unknown flag `-%.*s` provided.\n", flag.len, flag.str);
    println(tos3("Use `--` to terminate flag list if necessary."));
    v_exit(1);
  };
}
void internal_dot_compile__parse_and_output_new_format(array_string args) {
  array_internal_dot_compile__Deprecated list = new_array_from_c_array(
      0, 0, sizeof(internal_dot_compile__Deprecated),
      EMPTY_ARRAY_OF_ELEMS(internal_dot_compile__Deprecated, 0){TCCSKIP(0)});
  array_string obsolete = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  string os = os_dot_cmdline__option(args, tos3("-os"), tos3(""));
  if (string_eq(os, tos3("msvc"))) {
    _PUSH(&list,
          (/*typ = array_internal_dot_compile__Deprecated
              tmp_typ=internal_dot_compile__Deprecated*/
           (internal_dot_compile__Deprecated){.old = tos3("-os msvc"),
                                              .new = tos3("-cc msvc"),
                                              .not_exactly = 0}),
          tmp1, internal_dot_compile__Deprecated);
  };
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("-cache"), tos3("-full-rebuild=false"))),
             tmp2, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("translated"), tos3("-translated"))),
             tmp3, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("-x64"), tos3("-backend x64"))),
             tmp4, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("-v2"), tos3("-backend experimental"))),
             tmp5, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("-keep_c"), tos3("-csource keep"))),
             tmp6, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("-pretty_c"), tos3("-csource prettify"))),
             tmp7, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("-show_c_cmd"), tos3("-v"))),
             tmp8, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("-autofree"), tos3("-manual-free=false"))),
             tmp9, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(args, tos3("-fast"),
                                                            tos3("-cc tcc"))),
             tmp10, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("-output-cross-platform-c"), tos3("-os cross"))),
             tmp11, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(args, tos3("-m32"),
                                                            tos3("-arch x86"))),
             tmp12, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("-bare"), tos3("-freestanding"))),
             tmp13, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&obsolete,
             (/*typ = array_string   tmp_typ=string*/
              internal_dot_compile__add_if_found_string(
                  args, tos3("--enable-globals"))),
             tmp14, array_string);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("-prealloc"), tos3("-e prealloc"))),
             tmp15, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("-user_mod_path"), tos3("-path*"))),
             tmp16, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("-vlib-path"), tos3("-path*"))),
             tmp17, array_internal_dot_compile__Deprecated);
  _PUSH_MANY(&list,
             (/*typ = array_internal_dot_compile__Deprecated
                 tmp_typ=internal_dot_compile__Deprecated*/
              internal_dot_compile__add_if_found_deprecated(
                  args, tos3("-vpath"), tos3("-path*"))),
             tmp18, array_internal_dot_compile__Deprecated);
  if (list.len == 0 && obsolete.len == 0) {

    return;
  };
  println(tos3("V has encountered deprecated/obsolete options. Please edit "
               "your command.\n"));
  if (list.len > 0) {
    println(tos3("Deprecated options that have been replaced:"));
    array_internal_dot_compile__Deprecated tmp19 = list;
    for (int tmp20 = 0; tmp20 < tmp19.len; tmp20++) {
      internal_dot_compile__Deprecated deprecation =
          ((internal_dot_compile__Deprecated *)tmp19.data)[tmp20];

      if (deprecation.not_exactly) {
        printf("   `%.*s` has been superseded by `%.*s` (see help for more "
               "details)\n",
               deprecation.old.len, deprecation.old.str, deprecation.new.len,
               deprecation.new.str);
      } else {
        printf("   use `%.*s` instead of `%.*s`\n", deprecation.new.len,
               deprecation.new.str, deprecation.old.len, deprecation.old.str);
      };
    };
    println(tos3(""));
  };
  if (obsolete.len > 0) {
    println(tos3("Obsolete options that are no longer supported:"));
    array_string tmp21 = obsolete;
    for (int tmp22 = 0; tmp22 < tmp21.len; tmp22++) {
      string obsoleted = ((string *)tmp21.data)[tmp22];

      printf("   `%.*s` has been removed\n", obsoleted.len, obsoleted.str);
    };
    println(tos3(""));
  };
  println(tos3("For more details, please use the command `v help build` for a "
               "list of options."));
  v_exit(1);
}
static inline array_internal_dot_compile__Deprecated
internal_dot_compile__add_if_found_deprecated(array_string args,
                                              string deprecated, string alt) {
  if ((_IN(string, (deprecated), args))) {
    internal_dot_compile__Deprecated new =
        ((string_ends_with(alt, tos3("*")))
             ? ((internal_dot_compile__Deprecated){
                   .old = deprecated,
                   .new = string_substr2(alt, 0, alt.len - 1, false),
                   .not_exactly = 1})
             : ((internal_dot_compile__Deprecated){
                   .old = deprecated, .new = alt, .not_exactly = 0}));
    return new_array_from_c_array(
        1, 1, sizeof(internal_dot_compile__Deprecated),
        EMPTY_ARRAY_OF_ELEMS(internal_dot_compile__Deprecated, 1){new});
  };
  return new_array_from_c_array(
      0, 0, sizeof(internal_dot_compile__Deprecated),
      EMPTY_ARRAY_OF_ELEMS(internal_dot_compile__Deprecated, 0){TCCSKIP(0)});
}
static inline array_string
internal_dot_compile__add_if_found_string(array_string args,
                                          string deprecated) {
  if ((_IN(string, (deprecated), args))) {
    return new_array_from_c_array(1, 1, sizeof(string),
                                  EMPTY_ARRAY_OF_ELEMS(string, 1){deprecated});
  };
  return new_array_from_c_array(0, 0, sizeof(string),
                                EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
}
array_string main__join_flags_and_argument() {
  string vosargs = os__getenv(tos3("VOSARGS"));
  if (string_ne(vosargs, tos3(""))) {
    return string_split(vosargs, tos3(" "));
  };
  array_string args = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  string vflags = os__getenv(tos3("VFLAGS"));
  if (string_ne(vflags, tos3(""))) {
    _PUSH(&args,
          (/*typ = array_string   tmp_typ=string*/ (
              *(string *)array_get(os__args, 0))),
          tmp1, string);
    _PUSH_MANY(&args,
               (/*typ = array_string   tmp_typ=string*/ string_split(
                   vflags, tos3(" "))),
               tmp4, array_string);
    if (os__args.len > 1) {
      _PUSH_MANY(&args,
                 (/*typ = array_string   tmp_typ=string*/ array_slice2(
                     os__args, 1, -1, true)),
                 tmp5, array_string);
    };
    return args;
  };
  return os__args;
}
void main__parse_flags(string flag, internal_dot_flag__Instance *f,
                       internal_dot_flag__MainCmdPreferences *prefs) {
  string tmp8 = flag;

  if (string_eq(tmp8, tos3("v"))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               4, 4, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 4){tos3("v"), tos3("vv"),
                                               tos3("vvv"), tos3("verbose")}));
    prefs->verbosity = v_dot_pref__v_dot_pref__VerboseLevel_level_one;
  } else if (string_eq(tmp8, tos3("vv"))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               4, 4, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 4){tos3("v"), tos3("vv"),
                                               tos3("vvv"), tos3("verbose")}));
    prefs->verbosity = v_dot_pref__v_dot_pref__VerboseLevel_level_two;
  } else if (string_eq(tmp8, tos3("vvv"))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               4, 4, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 4){tos3("v"), tos3("vv"),
                                               tos3("vvv"), tos3("verbose")}));
    prefs->verbosity = v_dot_pref__v_dot_pref__VerboseLevel_level_three;
  } else if (string_eq(tmp8, tos3("verbose"))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               4, 4, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 4){tos3("v"), tos3("vv"),
                                               tos3("vvv"), tos3("verbose")}));
    Option_int tmp9 = internal_dot_flag__Instance_int(f);
    int level;
    if (!tmp9.ok) {
      string err = tmp9.error;
      int errcode = tmp9.ecode;
      println(tos3("V error: Expected `0`, `1`, `2` or `3` as argument to "
                   "`-verbose` to specify verbosity level."));
      v_exit(1);
    }
    level = *(int *)tmp9.data;
    ;
    int tmp10 = level;

    if (tmp10 == 0) {
    } else if (tmp10 == 1) {
      prefs->verbosity = v_dot_pref__v_dot_pref__VerboseLevel_level_one;
    } else if (tmp10 == 2) {
      prefs->verbosity = v_dot_pref__v_dot_pref__VerboseLevel_level_two;
    } else if (tmp10 == 3) {
      prefs->verbosity = v_dot_pref__v_dot_pref__VerboseLevel_level_three;
    } else // default:
    {
      println(tos3("V error: Expected `0`, `1`, `2` or `3` as argument to "
                   "`-verbose` to specify verbosity level."));
      v_exit(1);
    };
  } else if ((string_eq(tmp8, tos3("h"))) || (string_eq(tmp8, tos3("help")))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               2, 2, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 2){tos3("h"), tos3("help")}));
    prefs->action = internal_dot_flag__internal_dot_flag__MainCmdAction_help;
  } else if ((string_eq(tmp8, tos3("v"))) ||
             (string_eq(tmp8, tos3("version")))) {
    internal_dot_flag__Instance_is_equivalent_to(
        f, new_array_from_c_array(
               2, 2, sizeof(string),
               EMPTY_ARRAY_OF_ELEMS(string, 2){tos3("v"), tos3("version")}));
    prefs->action = internal_dot_flag__internal_dot_flag__MainCmdAction_version;
  } else if ((string_eq(tmp8, tos3("-version"))) ||
             (string_eq(tmp8, tos3("-help")))) {
    printf("V error: `-%.*s` has been deprecated. Use `%.*s` instead.\n",
           flag.len, flag.str, flag.len, flag.str);
    v_exit(1);
  } else // default:
  {
    prefs->unknown_flag = _STR("-%.*s", flag.len, flag.str);
    if (!((_IN(string, (flag), main__list_of_flags)))) {

      return;
    };
    Option_string tmp11 = internal_dot_flag__Instance_string(f);
    if (!tmp11.ok) {
      string err = tmp11.error;
      int errcode = tmp11.ecode;
      printf("V error: Error parsing flag. Expected value for `-%.*s`.\n",
             flag.len, flag.str);
      v_exit(1);
    };
  };
}
void main__launch_tool(v_dot_pref__VerboseLevel verbosity, string tool_name) {
  string vexe = v_dot_pref__vexe_path();
  string vroot = os__dir(vexe);
  compiler__set_vroot_folder(vroot);
  string tool_args =
      array_string_join(array_slice2(os__args, 1, -1, true), tos3(" "));
  string tool_exe = main__path_of_executable(
      os__realpath(_STR("%.*s/cmd/tools/%.*s", vroot.len, vroot.str,
                        tool_name.len, tool_name.str)));
  string tool_source =
      os__realpath(_STR("%.*s/cmd/tools/%.*s.v", vroot.len, vroot.str,
                        tool_name.len, tool_name.str));
  string tool_command = _STR("\"%.*s\" %.*s", tool_exe.len, tool_exe.str,
                             tool_args.len, tool_args.str);
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
    eprintln(_STR("launch_tool vexe        : %.*s", vroot.len, vroot.str));
    eprintln(_STR("launch_tool vroot       : %.*s", vroot.len, vroot.str));
    eprintln(
        _STR("launch_tool tool_args   : %.*s", tool_args.len, tool_args.str));
    eprintln(_STR("launch_tool tool_command: %.*s", tool_command.len,
                  tool_command.str));
  };
  bool should_compile = 0;
  if (!os__exists(tool_exe)) {
    should_compile = 1;
  } else {
    if (os__file_last_mod_unix(tool_exe) <= os__file_last_mod_unix(vexe)) {
      should_compile = 1;
      if (string_eq(tool_name, tos3("vself")) ||
          string_eq(tool_name, tos3("vup"))) {
        should_compile = 0;
      };
    };
    if (os__file_last_mod_unix(tool_exe) <=
        os__file_last_mod_unix(tool_source)) {
      should_compile = 1;
    };
  };
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
    eprintln(_STR("launch_tool should_compile: %d", should_compile));
  };
  if (should_compile) {
    string compilation_command = _STR("\"%.*s\" ", vexe.len, vexe.str);
    if (string_eq(tool_name, tos3("vfmt"))) {
      compilation_command = string_add(compilation_command, tos3("-d vfmt "));
    };
    compilation_command =
        string_add(compilation_command,
                   _STR("\"%.*s\"", tool_source.len, tool_source.str));
    if (v_dot_pref__VerboseLevel_is_higher_or_equal(
            verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
      eprintln(_STR("Compiling %.*s with: \"%.*s\"", tool_name.len,
                    tool_name.str, compilation_command.len,
                    compilation_command.str));
    };
    Option_os__Result tmp3 = os__exec(compilation_command);
    os__Result tool_compilation;
    if (!tmp3.ok) {
      string err = tmp3.error;
      int errcode = tmp3.ecode;
      v_panic(err);
    }
    tool_compilation = *(os__Result *)tmp3.data;
    ;
    if (tool_compilation.exit_code != 0) {
      v_panic(string_add(_STR("V tool \"%.*s\" could not be compiled\n",
                              tool_source.len, tool_source.str),
                         tool_compilation.output));
    };
  };
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
    eprintln(_STR("launch_tool running tool command: %.*s ...",
                  tool_command.len, tool_command.str));
  };
  v_exit(os__system(tool_command));
}
string main__path_of_executable(string path) {
#ifdef _WIN32
  return string_add(path, tos3(".exe"));
#endif
  ;
  return path;
}
void main__create_symlink() {
#ifdef _WIN32

  return;
#endif
  ;
  string vexe = v_dot_pref__vexe_path();
  string link_path = tos3("/usr/local/bin/v");
  Option_os__Result tmp1 = os__exec(_STR("ln -sf %.*s %.*s", vexe.len, vexe.str,
                                         link_path.len, link_path.str));
  os__Result ret;
  if (!tmp1.ok) {
    string err = tmp1.error;
    int errcode = tmp1.ecode;
    v_panic(err);
  }
  ret = *(os__Result *)tmp1.data;
  ;
  if (ret.exit_code == 0) {
    printf("Symlink \"%.*s\" has been created\n", link_path.len, link_path.str);
  } else if (os__system(tos3("uname -o | grep -q \'[A/a]ndroid\'")) == 0) {
    printf("Failed to create symlink \"%.*s\". Trying again with Termux path "
           "for Android.\n",
           link_path.len, link_path.str);
    link_path = tos3("/data/data/com.termux/files/usr/bin/v");
    Option_os__Result tmp2 = os__exec(_STR(
        "ln -sf %.*s %.*s", vexe.len, vexe.str, link_path.len, link_path.str));
    os__Result ret;
    if (!tmp2.ok) {
      string err = tmp2.error;
      int errcode = tmp2.ecode;
      v_panic(err);
    }
    ret = *(os__Result *)tmp2.data;
    ;
    if (ret.exit_code == 0) {
      printf("Symlink \"%.*s\" has been created\n", link_path.len,
             link_path.str);
    } else {
      printf("Failed to create symlink \"%.*s\". Try again with sudo.\n",
             link_path.len, link_path.str);
    };
  } else {
    printf("Failed to create symlink \"%.*s\". Try again with sudo.\n",
           link_path.len, link_path.str);
  };
}
void main__main() {
  internal_dot_flag__MainCmdPreferences prefs =
      (internal_dot_flag__MainCmdPreferences){.unknown_flag = tos3("")};
  Option_array_string tmp1 =
      internal_dot_flag__parse_main_cmd(os__args, main__parse_flags, &prefs);
  array_string values;
  if (!tmp1.ok) {
    string err = tmp1.error;
    int errcode = tmp1.ecode;
    println(tos3("V Error: An error has occurred while parsing flags: "));
    println(err);
    v_exit(1);
  }
  values = *(array_string *)tmp1.data;
  ;
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          prefs.verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_two)) {
    printf("V %.*s %.*s\n", compiler__Version.len, compiler__Version.str,
           compiler__vhash().len, compiler__vhash().str);
  };
  if (v_dot_pref__VerboseLevel_is_higher_or_equal(
          prefs.verbosity, v_dot_pref__v_dot_pref__VerboseLevel_level_three)) {
    println(tos3("Parsed preferences: "));
    println(internal_dot_flag__MainCmdPreferences_str(prefs));
    string tmp2 = array_string_str(values);

    printf("Remaining: %.*s \n", tmp2.len, tmp2.str);
  };
  if (prefs.verbosity == v_dot_pref__v_dot_pref__VerboseLevel_level_one &&
      values.len == 0) {
    println(tos3("`v -v` now runs V with verbose mode set to level one which "
                 "doesn't do anything."));
    println(tos3("Did you mean `v -version` instead?"));
    v_exit(1);
  };
  if (prefs.action ==
      internal_dot_flag__internal_dot_flag__MainCmdAction_version) {
    main__disallow_unknown_flags(prefs);
    main__print_version_and_exit();
  };
  if (values.len == 0 &&
      prefs.action ==
          internal_dot_flag__internal_dot_flag__MainCmdAction_help) {
    main__invoke_help_and_exit(values);
  };
  if (values.len == 0 ||
      string_eq((*(string *)array_get(values, 0)), tos3("-")) ||
      string_eq((*(string *)array_get(values, 0)), tos3("repl"))) {
    if (values.len == 0) {
      println(tos3("Running REPL as no arguments are provided."));
      println(tos3(
          "For usage information, quit V REPL using `exit` and use `v help`."));
    };
    main__launch_tool(prefs.verbosity, tos3("vrepl"));
  };
  string command = (*(string *)array_get(values, 0));
  if ((_IN(string, (command), main__simple_cmd))) {
    main__launch_tool(prefs.verbosity, string_add(tos3("v"), command));

    return;
  };
  string tmp9 = command;

  if ((string_eq(tmp9, tos3("create"))) || (string_eq(tmp9, tos3("init")))) {
    main__launch_tool(prefs.verbosity, tos3("vcreate"));

    return;
  } else if (string_eq(tmp9, tos3("translate"))) {
    println(tos3("Translating C to V will be available in V 0.3"));

    return;
  } else if ((string_eq(tmp9, tos3("search"))) ||
             (string_eq(tmp9, tos3("install"))) ||
             (string_eq(tmp9, tos3("update"))) ||
             (string_eq(tmp9, tos3("remove")))) {
    main__launch_tool(prefs.verbosity, tos3("vpm"));

    return;
  } else if (string_eq(tmp9, tos3("get"))) {
    println(
        tos3("V Error: Use `v install` to install modules from vpm.vlang.io"));
    v_exit(1);
  } else if (string_eq(tmp9, tos3("symlink"))) {
    main__disallow_unknown_flags(prefs);
    main__create_symlink();

    return;
  } else if (string_eq(tmp9, tos3("doc"))) {
    main__disallow_unknown_flags(prefs);
    if (values.len == 1) {
      println(tos3("V Error: Expected argument: Module name to output "
                   "documentations for"));
      v_exit(1);
    };
    v_dot_table__Table *table = v_dot_table__new_table();
    println(v_dot_doc__doc((*(string *)array_get(values, 1)), table));

    return;
  } else if (string_eq(tmp9, tos3("help"))) {
    main__disallow_unknown_flags(prefs);
    main__invoke_help_and_exit(values);

    return;
  } else if (string_eq(tmp9, tos3("version"))) {
    main__disallow_unknown_flags(prefs);
    main__print_version_and_exit();

    return;
  } else // default:
  {
  };
  if (string_eq(command, tos3("run")) || string_eq(command, tos3("build")) ||
      string_ends_with(command, tos3(".v")) || os__exists(command)) {
    array_string arg = main__join_flags_and_argument();
    internal_dot_compile__compile(command, arg);

    return;
  };
  eprintln(_STR("v %.*s: unknown command\nRun \"v help\" for usage.",
                command.len, command.str));
  v_exit(1);
}
void main__print_version_and_exit() {
  string version_hash = compiler__vhash();
  printf("V %.*s %.*s\n", compiler__Version.len, compiler__Version.str,
         version_hash.len, version_hash.str);
  v_exit(0);
}
void main__invoke_help_and_exit(array_string remaining) {
  int tmp12 = remaining.len;

  if ((tmp12 == 0) || (tmp12 == 1)) {
    internal_dot_help__print_and_exit(tos3("default"));
  } else if (tmp12 == 2) {
    internal_dot_help__print_and_exit((*(string *)array_get(remaining, 1)));
  } else // default:
  {
  };
  println(tos3("V Error: Expected only one help topic to be provided."));
  println(tos3("For usage information, use `v help`."));
  v_exit(1);
}
static inline void
main__disallow_unknown_flags(internal_dot_flag__MainCmdPreferences prefs) {
  if (string_eq(prefs.unknown_flag, tos3(""))) {

    return;
  };
  printf("V Error: Unexpected flag found: %.*s\n", prefs.unknown_flag.len,
         prefs.unknown_flag.str);
  v_exit(1);
}
string array_v_dot_table__Type_str(array_v_dot_table__Type a) {
  strings__Builder sb = strings__new_builder(a.len * 3);
  strings__Builder_write(&/* ? */ sb, tos3("["));
  array_v_dot_table__Type tmp1 = a;
  for (int i = 0; i < tmp1.len; i++) {
    v_dot_table__Type elm = ((v_dot_table__Type *)tmp1.data)[i];

    strings__Builder_write(&/* ? */ sb, int_str(elm));
    if (i < a.len - 1) {
      strings__Builder_write(&/* ? */ sb, tos3(", "));
    };
  };
  strings__Builder_write(&/* ? */ sb, tos3("]"));
  return strings__Builder_str(&/* ? */ sb);
}
string internal_dot_flag__MainCmdPreferences_str(
    internal_dot_flag__MainCmdPreferences a) {
  return _STR("MainCmdPreferences {\n	verbosity: %d\n	action: %d\n	"
              "unknown_flag: %.*s\n}",
              a.verbosity, a.action, a.unknown_flag.len, a.unknown_flag.str);
}
void init() {
#if VPREALLOC
  g_m2_buf = malloc(50 * 1000 * 1000);
  g_m2_ptr = g_m2_buf;
  puts("allocated 50 mb");
#endif

  builtin__SYMOPT_UNDNAME = 0x00000002;
  builtin__SYMOPT_DEFERRED_LOADS = 0x00000004;
  builtin__SYMOPT_NO_CPP = 0x00000008;
  builtin__SYMOPT_LOAD_LINES = 0x00000010;
  builtin__SYMOPT_INCLUDE_32BIT_MODULES = 0x00002000;
  builtin__SYMOPT_ALLOW_ZERO_ADDRESS = 0x01000000;
  builtin__SYMOPT_DEBUG = 0x80000000;
  builtin__digit_pairs = tos3(
      "001020304050607080900111213141516171819102122232425262728292031323334353"
      "637383930414243444546474849405152535455565758595061626364656667686960717"
      "27374757677787970818283848586878889809192939495969798999");
  builtin__init_capicity = 1 << builtin__init_log_capicity;
  builtin__init_cap = builtin__init_capicity - 2;
  builtin__hash_mask = ((u32)(0x00FFFFFF));
  builtin__probe_inc = ((u32)(0x01000000));
  builtin__max_probe = ((u32)(0xFF000000));
  builtin__mid_index = builtin__degree - 1;
  builtin__max_size = 2 * builtin__degree - 1;
  builtin__children_bytes = sizeof(void *) * (builtin__max_size + 1);
  hash_dot_wyhash__wyp0 = 0xa0761d6478bd642f;
  hash_dot_wyhash__wyp1 = 0xe7037ed1a0b428db;
  hash_dot_wyhash__wyp2 = 0x8ebc6af09c88c6e3;
  hash_dot_wyhash__wyp3 = 0x589965cc75374cc3;
  hash_dot_wyhash__wyp4 = 0x1d8e4e27c47d124f;
  strconv__DOUBLE_PLUS_ZERO = ((u64)(0x0000000000000000));
  strconv__DOUBLE_MINUS_ZERO = 0x8000000000000000;
  strconv__DOUBLE_PLUS_INFINITY = 0x7FF0000000000000;
  strconv__DOUBLE_MINUS_INFINITY = 0xFFF0000000000000;
  strconv__TEN = ((u32)(10));
  strconv__max_u64 = ((u64)(UINT64_MAX));
  math__uvnan = 0x7FF8000000000001;
  math__uvinf = 0x7FF0000000000000;
  math__uvneginf = 0xFFF0000000000000;
  math__uvone = 0x3FF0000000000000;
  math__mask = 0x7FF;
  math__shift = 64 - 11 - 1;
  math__sign_mask = (((u64)(1)) << 63);
  math__frac_mask = ((((u64)(1)) << ((u64)(math__shift))) - ((u64)(1)));
  math__log2_e = 1.0 / math__ln2;
  math__log10_e = 1.0 / math__ln10;
  math__max_f32 = 3.40282346638528859811704183484516925440e+38;
  math__smallest_non_zero_f32 = 1.401298464324817070923729583289916131280e-45;
  math__max_f64 = 1.797693134862315708145274237317043567981e+308;
  math__smallest_non_zero_f64 = 4.940656458412465441765687928682213723651e-324;
  math__min_i8 = -128;
  math__min_i16 = -32768;
  math__min_i32 = -2147483648;
  math__min_i64 = -9223372036854775807 - 1;
  math_dot_bits__de_bruijn32 = ((u32)(0x077CB531));
  math_dot_bits__de_bruijn32tab = new_array_from_c_array(
      32, 32, sizeof(byte),
      EMPTY_ARRAY_OF_ELEMS(byte, 32){
          ((byte)(0)), 1,  28, 2,  29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4,  8,
          31,          27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6,  11, 5,  10, 9,
      });
  math_dot_bits__de_bruijn64 = (0x03f79d71b4ca8b09);
  math_dot_bits__de_bruijn64tab = new_array_from_c_array(
      64, 64, sizeof(byte),
      EMPTY_ARRAY_OF_ELEMS(byte, 64){
          ((byte)(0)), 1,  56, 2,  57, 49, 28, 3,  61, 58, 42, 50, 38,
          29,          17, 4,  62, 47, 59, 36, 45, 43, 51, 22, 53, 39,
          33,          30, 24, 18, 12, 5,  63, 55, 48, 27, 60, 41, 37,
          16,          46, 35, 44, 21, 52, 32, 23, 11, 54, 26, 40, 15,
          34,          20, 31, 10, 25, 14, 19, 9,  13, 8,  7,  6,
      });
  math_dot_bits__m0 = 0x5555555555555555;
  math_dot_bits__m1 = 0x3333333333333333;
  math_dot_bits__m2 = 0x0f0f0f0f0f0f0f0f;
  math_dot_bits__m3 = 0x00ff00ff00ff00ff;
  math_dot_bits__m4 = 0x0000ffff0000ffff;
  math_dot_bits__two32 = 0x100000000;
  math_dot_bits__mask32 = math_dot_bits__two32 - 1;
  math_dot_bits__overflow_error = tos3("Overflow Error");
  math_dot_bits__divide_error = tos3("Divide Error");
  math_dot_bits__ntz_8_tab = new_array_from_c_array(
      256, 256, sizeof(byte),
      EMPTY_ARRAY_OF_ELEMS(byte, 256){
          ((byte)(0x08)), 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00,
          0x01,           0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00,
          0x02,           0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00,
          0x01,           0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
          0x03,           0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00,
          0x01,           0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00,
          0x02,           0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x00,
          0x01,           0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
          0x04,           0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00,
          0x01,           0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00,
          0x02,           0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00,
          0x01,           0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
          0x03,           0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x07, 0x00,
          0x01,           0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00,
          0x02,           0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00,
          0x01,           0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
          0x05,           0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00,
          0x01,           0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00,
          0x02,           0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00,
          0x01,           0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
          0x03,           0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00,
          0x01,           0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00,
          0x02,           0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00,
          0x01,           0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
          0x04,           0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00,
          0x01,           0x00, 0x02, 0x00, 0x01, 0x00,
      });
  math_dot_bits__pop_8_tab = new_array_from_c_array(
      256, 256, sizeof(byte),
      EMPTY_ARRAY_OF_ELEMS(byte, 256){
          ((byte)(0x00)), 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02,
          0x02,           0x03, 0x02, 0x03, 0x03, 0x04, 0x01, 0x02, 0x02, 0x03,
          0x02,           0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04,
          0x04,           0x05, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04,
          0x02,           0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03,
          0x03,           0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05,
          0x04,           0x05, 0x05, 0x06, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03,
          0x03,           0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
          0x02,           0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04,
          0x04,           0x05, 0x04, 0x05, 0x05, 0x06, 0x02, 0x03, 0x03, 0x04,
          0x03,           0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05,
          0x05,           0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
          0x04,           0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x01, 0x02,
          0x02,           0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04,
          0x03,           0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04,
          0x04,           0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
          0x02,           0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04,
          0x04,           0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05,
          0x04,           0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06,
          0x06,           0x07, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
          0x03,           0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04,
          0x04,           0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06,
          0x05,           0x06, 0x06, 0x07, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05,
          0x05,           0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
          0x04,           0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06,
          0x06,           0x07, 0x06, 0x07, 0x07, 0x08,
      });
  math_dot_bits__rev_8_tab = new_array_from_c_array(
      256, 256, sizeof(byte),
      EMPTY_ARRAY_OF_ELEMS(byte, 256){
          ((byte)(0x00)), 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90,
          0x50,           0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8,
          0x28,           0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8,
          0x78,           0xf8, 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
          0x14,           0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c,
          0x4c,           0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc,
          0x3c,           0xbc, 0x7c, 0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2,
          0x62,           0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
          0x0a,           0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a,
          0x5a,           0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46, 0xc6,
          0x26,           0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6,
          0x76,           0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
          0x1e,           0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01, 0x81,
          0x41,           0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1,
          0x31,           0xb1, 0x71, 0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9,
          0x69,           0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
          0x05,           0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95,
          0x55,           0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d, 0x8d, 0x4d, 0xcd,
          0x2d,           0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd,
          0x7d,           0xfd, 0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
          0x13,           0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b, 0x8b,
          0x4b,           0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb,
          0x3b,           0xbb, 0x7b, 0xfb, 0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7,
          0x67,           0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
          0x0f,           0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f,
          0x5f,           0xdf, 0x3f, 0xbf, 0x7f, 0xff,
      });
  math_dot_bits__len_8_tab = new_array_from_c_array(
      256, 256, sizeof(byte),
      EMPTY_ARRAY_OF_ELEMS(byte, 256){
          ((byte)(0x00)), 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04,
          0x04,           0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,
          0x05,           0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
          0x05,           0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
          0x06,           0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
          0x06,           0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
          0x06,           0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
          0x07,           0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
          0x07,           0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
          0x07,           0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
          0x07,           0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
          0x07,           0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
          0x07,           0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08,
          0x08,           0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08,           0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08,           0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08,           0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08,           0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08,           0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08,           0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08,           0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08,           0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08,           0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08,           0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08,           0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08,           0x08, 0x08, 0x08, 0x08, 0x08,
      });
  time__days_string = tos3("MonTueWedThuFriSatSun");
  time__month_days = new_array_from_c_array(
      12, 12, sizeof(int),
      EMPTY_ARRAY_OF_ELEMS(int, 12){31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30,
                                    31});
  time__months_string = tos3("JanFebMarAprMayJunJulAugSepOctNovDec");
  time__absolute_zero_year = ((i64)(-292277022399));
  time__seconds_per_hour = 60 * time__seconds_per_minute;
  time__seconds_per_day = 24 * time__seconds_per_hour;
  time__seconds_per_week = 7 * time__seconds_per_day;
  time__days_per_400_years = 365 * 400 + 97;
  time__days_per_100_years = 365 * 100 + 24;
  time__days_per_4_years = 365 * 4 + 1;
  time__days_before = new_array_from_c_array(
      13, 13, sizeof(int),
      EMPTY_ARRAY_OF_ELEMS(int, 13){
          0,
          31,
          31 + 28,
          31 + 28 + 31,
          31 + 28 + 31 + 30,
          31 + 28 + 31 + 30 + 31,
          31 + 28 + 31 + 30 + 31 + 30,
          31 + 28 + 31 + 30 + 31 + 30 + 31,
          31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,
          31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,
          31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,
          31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30,
          31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31,
      });
  v_dot_token__assign_tokens = new_array_from_c_array(
      11, 11, sizeof(v_dot_token__Kind),
      EMPTY_ARRAY_OF_ELEMS(v_dot_token__Kind, 11){
          v_dot_token__v_dot_token__Kind_assign,
          v_dot_token__v_dot_token__Kind_plus_assign,
          v_dot_token__v_dot_token__Kind_minus_assign,
          v_dot_token__v_dot_token__Kind_mult_assign,
          v_dot_token__v_dot_token__Kind_div_assign,
          v_dot_token__v_dot_token__Kind_xor_assign,
          v_dot_token__v_dot_token__Kind_mod_assign,
          v_dot_token__v_dot_token__Kind_or_assign,
          v_dot_token__v_dot_token__Kind_and_assign,
          v_dot_token__v_dot_token__Kind_right_shift_assign,
          v_dot_token__v_dot_token__Kind_left_shift_assign});
  v_dot_token__token_str = v_dot_token__build_token_str();
  v_dot_token__keywords = v_dot_token__build_keys();
  v_dot_token__precedences = v_dot_token__build_precedences();
  strconv_dot_ftoa__mantbits32 = ((u32)(23));
  strconv_dot_ftoa__expbits32 = ((u32)(8));
  strconv_dot_ftoa__bias32 = ((u32)(127));
  strconv_dot_ftoa__mantbits64 = ((u32)(52));
  strconv_dot_ftoa__expbits64 = ((u32)(11));
  strconv_dot_ftoa__bias64 = ((u32)(1023));
  strconv_dot_ftoa__powers_of_10 = new_array_from_c_array(
      18, 18, sizeof(u64),
      EMPTY_ARRAY_OF_ELEMS(u64, 18){
          ((u64)(1e0)), ((u64)(1e1)), ((u64)(1e2)), ((u64)(1e3)), ((u64)(1e4)),
          ((u64)(1e5)), ((u64)(1e6)), ((u64)(1e7)), ((u64)(1e8)), ((u64)(1e9)),
          ((u64)(1e10)), ((u64)(1e11)), ((u64)(1e12)), ((u64)(1e13)),
          ((u64)(1e14)), ((u64)(1e15)), ((u64)(1e16)), ((u64)(1e17))});
  strconv_dot_ftoa__pow5_split_32 = new_array_from_c_array(
      47, 47, sizeof(u64),
      EMPTY_ARRAY_OF_ELEMS(u64, 47){
          1152921504606846976, 1441151880758558720, 1801439850948198400,
          2251799813685248000, 1407374883553280000, 1759218604441600000,
          2199023255552000000, 1374389534720000000, 1717986918400000000,
          2147483648000000000, 1342177280000000000, 1677721600000000000,
          2097152000000000000, 1310720000000000000, 1638400000000000000,
          2048000000000000000, 1280000000000000000, 1600000000000000000,
          2000000000000000000, 1250000000000000000, 1562500000000000000,
          1953125000000000000, 1220703125000000000, 1525878906250000000,
          1907348632812500000, 1192092895507812500, 1490116119384765625,
          1862645149230957031, 1164153218269348144, 1455191522836685180,
          1818989403545856475, 2273736754432320594, 1421085471520200371,
          1776356839400250464, 2220446049250313080, 1387778780781445675,
          1734723475976807094, 2168404344971008868, 1355252715606880542,
          1694065894508600678, 2117582368135750847, 1323488980084844279,
          1654361225106055349, 2067951531382569187, 1292469707114105741,
          1615587133892632177, 2019483917365790221});
  strconv_dot_ftoa__pow5_inv_split_32 = new_array_from_c_array(
      31, 31, sizeof(u64),
      EMPTY_ARRAY_OF_ELEMS(u64, 31){
          576460752303423489, 461168601842738791, 368934881474191033,
          295147905179352826, 472236648286964522, 377789318629571618,
          302231454903657294, 483570327845851670, 386856262276681336,
          309485009821345069, 495176015714152110, 396140812571321688,
          316912650057057351, 507060240091291761, 405648192073033409,
          324518553658426727, 519229685853482763, 415383748682786211,
          332306998946228969, 531691198313966350, 425352958651173080,
          340282366920938464, 544451787073501542, 435561429658801234,
          348449143727040987, 557518629963265579, 446014903970612463,
          356811923176489971, 570899077082383953, 456719261665907162,
          365375409332725730});
  strconv_dot_ftoa__pow5_split_64 = new_array_from_c_array(
      326, 326, sizeof(strconv_dot_ftoa__Uint128),
      EMPTY_ARRAY_OF_ELEMS(strconv_dot_ftoa__Uint128, 326){
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x0100000000000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x0140000000000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x0190000000000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x01f4000000000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x0138800000000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x0186a00000000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x01e8480000000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x01312d0000000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x017d784000000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x01dcd65000000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x012a05f200000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x0174876e80000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x01d1a94a20000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x012309ce54000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x016bcc41e9000000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x01c6bf5263400000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x011c37937e080000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x016345785d8a0000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x01bc16d674ec8000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x01158e460913d000},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x015af1d78b58c400},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x01b1ae4d6e2ef500},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x010f0cf064dd5920},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x0152d02c7e14af68},
          (strconv_dot_ftoa__Uint128){0x0000000000000000, 0x01a784379d99db42},
          (strconv_dot_ftoa__Uint128){0x4000000000000000, 0x0108b2a2c2802909},
          (strconv_dot_ftoa__Uint128){0x9000000000000000, 0x014adf4b7320334b},
          (strconv_dot_ftoa__Uint128){0x7400000000000000, 0x019d971e4fe8401e},
          (strconv_dot_ftoa__Uint128){0x0880000000000000, 0x01027e72f1f12813},
          (strconv_dot_ftoa__Uint128){0xcaa0000000000000, 0x01431e0fae6d7217},
          (strconv_dot_ftoa__Uint128){0xbd48000000000000, 0x0193e5939a08ce9d},
          (strconv_dot_ftoa__Uint128){0x2c9a000000000000, 0x01f8def8808b0245},
          (strconv_dot_ftoa__Uint128){0x3be0400000000000, 0x013b8b5b5056e16b},
          (strconv_dot_ftoa__Uint128){0x0ad8500000000000, 0x018a6e32246c99c6},
          (strconv_dot_ftoa__Uint128){0x8d8e640000000000, 0x01ed09bead87c037},
          (strconv_dot_ftoa__Uint128){0xb878fe8000000000, 0x013426172c74d822},
          (strconv_dot_ftoa__Uint128){0x66973e2000000000, 0x01812f9cf7920e2b},
          (strconv_dot_ftoa__Uint128){0x403d0da800000000, 0x01e17b84357691b6},
          (strconv_dot_ftoa__Uint128){0xe826288900000000, 0x012ced32a16a1b11},
          (strconv_dot_ftoa__Uint128){0x622fb2ab40000000, 0x0178287f49c4a1d6},
          (strconv_dot_ftoa__Uint128){0xfabb9f5610000000, 0x01d6329f1c35ca4b},
          (strconv_dot_ftoa__Uint128){0x7cb54395ca000000, 0x0125dfa371a19e6f},
          (strconv_dot_ftoa__Uint128){0x5be2947b3c800000, 0x016f578c4e0a060b},
          (strconv_dot_ftoa__Uint128){0x32db399a0ba00000, 0x01cb2d6f618c878e},
          (strconv_dot_ftoa__Uint128){0xdfc9040047440000, 0x011efc659cf7d4b8},
          (strconv_dot_ftoa__Uint128){0x17bb450059150000, 0x0166bb7f0435c9e7},
          (strconv_dot_ftoa__Uint128){0xddaa16406f5a4000, 0x01c06a5ec5433c60},
          (strconv_dot_ftoa__Uint128){0x8a8a4de845986800, 0x0118427b3b4a05bc},
          (strconv_dot_ftoa__Uint128){0xad2ce16256fe8200, 0x015e531a0a1c872b},
          (strconv_dot_ftoa__Uint128){0x987819baecbe2280, 0x01b5e7e08ca3a8f6},
          (strconv_dot_ftoa__Uint128){0x1f4b1014d3f6d590, 0x0111b0ec57e6499a},
          (strconv_dot_ftoa__Uint128){0xa71dd41a08f48af4, 0x01561d276ddfdc00},
          (strconv_dot_ftoa__Uint128){0xd0e549208b31adb1, 0x01aba4714957d300},
          (strconv_dot_ftoa__Uint128){0x828f4db456ff0c8e, 0x010b46c6cdd6e3e0},
          (strconv_dot_ftoa__Uint128){0xa33321216cbecfb2, 0x014e1878814c9cd8},
          (strconv_dot_ftoa__Uint128){0xcbffe969c7ee839e, 0x01a19e96a19fc40e},
          (strconv_dot_ftoa__Uint128){0x3f7ff1e21cf51243, 0x0105031e2503da89},
          (strconv_dot_ftoa__Uint128){0x8f5fee5aa43256d4, 0x014643e5ae44d12b},
          (strconv_dot_ftoa__Uint128){0x7337e9f14d3eec89, 0x0197d4df19d60576},
          (strconv_dot_ftoa__Uint128){0x1005e46da08ea7ab, 0x01fdca16e04b86d4},
          (strconv_dot_ftoa__Uint128){0x8a03aec4845928cb, 0x013e9e4e4c2f3444},
          (strconv_dot_ftoa__Uint128){0xac849a75a56f72fd, 0x018e45e1df3b0155},
          (strconv_dot_ftoa__Uint128){0x17a5c1130ecb4fbd, 0x01f1d75a5709c1ab},
          (strconv_dot_ftoa__Uint128){0xeec798abe93f11d6, 0x013726987666190a},
          (strconv_dot_ftoa__Uint128){0xaa797ed6e38ed64b, 0x0184f03e93ff9f4d},
          (strconv_dot_ftoa__Uint128){0x1517de8c9c728bde, 0x01e62c4e38ff8721},
          (strconv_dot_ftoa__Uint128){0xad2eeb17e1c7976b, 0x012fdbb0e39fb474},
          (strconv_dot_ftoa__Uint128){0xd87aa5ddda397d46, 0x017bd29d1c87a191},
          (strconv_dot_ftoa__Uint128){0x4e994f5550c7dc97, 0x01dac74463a989f6},
          (strconv_dot_ftoa__Uint128){0xf11fd195527ce9de, 0x0128bc8abe49f639},
          (strconv_dot_ftoa__Uint128){0x6d67c5faa71c2456, 0x0172ebad6ddc73c8},
          (strconv_dot_ftoa__Uint128){0x88c1b77950e32d6c, 0x01cfa698c95390ba},
          (strconv_dot_ftoa__Uint128){0x957912abd28dfc63, 0x0121c81f7dd43a74},
          (strconv_dot_ftoa__Uint128){0xbad75756c7317b7c, 0x016a3a275d494911},
          (strconv_dot_ftoa__Uint128){0x298d2d2c78fdda5b, 0x01c4c8b1349b9b56},
          (strconv_dot_ftoa__Uint128){0xd9f83c3bcb9ea879, 0x011afd6ec0e14115},
          (strconv_dot_ftoa__Uint128){0x50764b4abe865297, 0x0161bcca7119915b},
          (strconv_dot_ftoa__Uint128){0x2493de1d6e27e73d, 0x01ba2bfd0d5ff5b2},
          (strconv_dot_ftoa__Uint128){0x56dc6ad264d8f086, 0x01145b7e285bf98f},
          (strconv_dot_ftoa__Uint128){0x2c938586fe0f2ca8, 0x0159725db272f7f3},
          (strconv_dot_ftoa__Uint128){0xf7b866e8bd92f7d2, 0x01afcef51f0fb5ef},
          (strconv_dot_ftoa__Uint128){0xfad34051767bdae3, 0x010de1593369d1b5},
          (strconv_dot_ftoa__Uint128){0x79881065d41ad19c, 0x015159af80444623},
          (strconv_dot_ftoa__Uint128){0x57ea147f49218603, 0x01a5b01b605557ac},
          (strconv_dot_ftoa__Uint128){0xb6f24ccf8db4f3c1, 0x01078e111c3556cb},
          (strconv_dot_ftoa__Uint128){0xa4aee003712230b2, 0x014971956342ac7e},
          (strconv_dot_ftoa__Uint128){0x4dda98044d6abcdf, 0x019bcdfabc13579e},
          (strconv_dot_ftoa__Uint128){0xf0a89f02b062b60b, 0x010160bcb58c16c2},
          (strconv_dot_ftoa__Uint128){0xacd2c6c35c7b638e, 0x0141b8ebe2ef1c73},
          (strconv_dot_ftoa__Uint128){0x98077874339a3c71, 0x01922726dbaae390},
          (strconv_dot_ftoa__Uint128){0xbe0956914080cb8e, 0x01f6b0f092959c74},
          (strconv_dot_ftoa__Uint128){0xf6c5d61ac8507f38, 0x013a2e965b9d81c8},
          (strconv_dot_ftoa__Uint128){0x34774ba17a649f07, 0x0188ba3bf284e23b},
          (strconv_dot_ftoa__Uint128){0x01951e89d8fdc6c8, 0x01eae8caef261aca},
          (strconv_dot_ftoa__Uint128){0x40fd3316279e9c3d, 0x0132d17ed577d0be},
          (strconv_dot_ftoa__Uint128){0xd13c7fdbb186434c, 0x017f85de8ad5c4ed},
          (strconv_dot_ftoa__Uint128){0x458b9fd29de7d420, 0x01df67562d8b3629},
          (strconv_dot_ftoa__Uint128){0xcb7743e3a2b0e494, 0x012ba095dc7701d9},
          (strconv_dot_ftoa__Uint128){0x3e5514dc8b5d1db9, 0x017688bb5394c250},
          (strconv_dot_ftoa__Uint128){0x4dea5a13ae346527, 0x01d42aea2879f2e4},
          (strconv_dot_ftoa__Uint128){0xb0b2784c4ce0bf38, 0x01249ad2594c37ce},
          (strconv_dot_ftoa__Uint128){0x5cdf165f6018ef06, 0x016dc186ef9f45c2},
          (strconv_dot_ftoa__Uint128){0xf416dbf7381f2ac8, 0x01c931e8ab871732},
          (strconv_dot_ftoa__Uint128){0xd88e497a83137abd, 0x011dbf316b346e7f},
          (strconv_dot_ftoa__Uint128){0xceb1dbd923d8596c, 0x01652efdc6018a1f},
          (strconv_dot_ftoa__Uint128){0xc25e52cf6cce6fc7, 0x01be7abd3781eca7},
          (strconv_dot_ftoa__Uint128){0xd97af3c1a40105dc, 0x01170cb642b133e8},
          (strconv_dot_ftoa__Uint128){0x0fd9b0b20d014754, 0x015ccfe3d35d80e3},
          (strconv_dot_ftoa__Uint128){0xd3d01cde90419929, 0x01b403dcc834e11b},
          (strconv_dot_ftoa__Uint128){0x6462120b1a28ffb9, 0x01108269fd210cb1},
          (strconv_dot_ftoa__Uint128){0xbd7a968de0b33fa8, 0x0154a3047c694fdd},
          (strconv_dot_ftoa__Uint128){0x2cd93c3158e00f92, 0x01a9cbc59b83a3d5},
          (strconv_dot_ftoa__Uint128){0x3c07c59ed78c09bb, 0x010a1f5b81324665},
          (strconv_dot_ftoa__Uint128){0x8b09b7068d6f0c2a, 0x014ca732617ed7fe},
          (strconv_dot_ftoa__Uint128){0x2dcc24c830cacf34, 0x019fd0fef9de8dfe},
          (strconv_dot_ftoa__Uint128){0xdc9f96fd1e7ec180, 0x0103e29f5c2b18be},
          (strconv_dot_ftoa__Uint128){0x93c77cbc661e71e1, 0x0144db473335deee},
          (strconv_dot_ftoa__Uint128){0x38b95beb7fa60e59, 0x01961219000356aa},
          (strconv_dot_ftoa__Uint128){0xc6e7b2e65f8f91ef, 0x01fb969f40042c54},
          (strconv_dot_ftoa__Uint128){0xfc50cfcffbb9bb35, 0x013d3e2388029bb4},
          (strconv_dot_ftoa__Uint128){0x3b6503c3faa82a03, 0x018c8dac6a0342a2},
          (strconv_dot_ftoa__Uint128){0xca3e44b4f9523484, 0x01efb1178484134a},
          (strconv_dot_ftoa__Uint128){0xbe66eaf11bd360d2, 0x0135ceaeb2d28c0e},
          (strconv_dot_ftoa__Uint128){0x6e00a5ad62c83907, 0x0183425a5f872f12},
          (strconv_dot_ftoa__Uint128){0x0980cf18bb7a4749, 0x01e412f0f768fad7},
          (strconv_dot_ftoa__Uint128){0x65f0816f752c6c8d, 0x012e8bd69aa19cc6},
          (strconv_dot_ftoa__Uint128){0xff6ca1cb527787b1, 0x017a2ecc414a03f7},
          (strconv_dot_ftoa__Uint128){0xff47ca3e2715699d, 0x01d8ba7f519c84f5},
          (strconv_dot_ftoa__Uint128){0xbf8cde66d86d6202, 0x0127748f9301d319},
          (strconv_dot_ftoa__Uint128){0x2f7016008e88ba83, 0x017151b377c247e0},
          (strconv_dot_ftoa__Uint128){0x3b4c1b80b22ae923, 0x01cda62055b2d9d8},
          (strconv_dot_ftoa__Uint128){0x250f91306f5ad1b6, 0x012087d4358fc827},
          (strconv_dot_ftoa__Uint128){0xee53757c8b318623, 0x0168a9c942f3ba30},
          (strconv_dot_ftoa__Uint128){0x29e852dbadfde7ac, 0x01c2d43b93b0a8bd},
          (strconv_dot_ftoa__Uint128){0x3a3133c94cbeb0cc, 0x0119c4a53c4e6976},
          (strconv_dot_ftoa__Uint128){0xc8bd80bb9fee5cff, 0x016035ce8b6203d3},
          (strconv_dot_ftoa__Uint128){0xbaece0ea87e9f43e, 0x01b843422e3a84c8},
          (strconv_dot_ftoa__Uint128){0x74d40c9294f238a7, 0x01132a095ce492fd},
          (strconv_dot_ftoa__Uint128){0xd2090fb73a2ec6d1, 0x0157f48bb41db7bc},
          (strconv_dot_ftoa__Uint128){0x068b53a508ba7885, 0x01adf1aea12525ac},
          (strconv_dot_ftoa__Uint128){0x8417144725748b53, 0x010cb70d24b7378b},
          (strconv_dot_ftoa__Uint128){0x651cd958eed1ae28, 0x014fe4d06de5056e},
          (strconv_dot_ftoa__Uint128){0xfe640faf2a8619b2, 0x01a3de04895e46c9},
          (strconv_dot_ftoa__Uint128){0x3efe89cd7a93d00f, 0x01066ac2d5daec3e},
          (strconv_dot_ftoa__Uint128){0xcebe2c40d938c413, 0x014805738b51a74d},
          (strconv_dot_ftoa__Uint128){0x426db7510f86f518, 0x019a06d06e261121},
          (strconv_dot_ftoa__Uint128){0xc9849292a9b4592f, 0x0100444244d7cab4},
          (strconv_dot_ftoa__Uint128){0xfbe5b73754216f7a, 0x01405552d60dbd61},
          (strconv_dot_ftoa__Uint128){0x7adf25052929cb59, 0x01906aa78b912cba},
          (strconv_dot_ftoa__Uint128){0x1996ee4673743e2f, 0x01f485516e7577e9},
          (strconv_dot_ftoa__Uint128){0xaffe54ec0828a6dd, 0x0138d352e5096af1},
          (strconv_dot_ftoa__Uint128){0x1bfdea270a32d095, 0x018708279e4bc5ae},
          (strconv_dot_ftoa__Uint128){0xa2fd64b0ccbf84ba, 0x01e8ca3185deb719},
          (strconv_dot_ftoa__Uint128){0x05de5eee7ff7b2f4, 0x01317e5ef3ab3270},
          (strconv_dot_ftoa__Uint128){0x0755f6aa1ff59fb1, 0x017dddf6b095ff0c},
          (strconv_dot_ftoa__Uint128){0x092b7454a7f3079e, 0x01dd55745cbb7ecf},
          (strconv_dot_ftoa__Uint128){0x65bb28b4e8f7e4c3, 0x012a5568b9f52f41},
          (strconv_dot_ftoa__Uint128){0xbf29f2e22335ddf3, 0x0174eac2e8727b11},
          (strconv_dot_ftoa__Uint128){0x2ef46f9aac035570, 0x01d22573a28f19d6},
          (strconv_dot_ftoa__Uint128){0xdd58c5c0ab821566, 0x0123576845997025},
          (strconv_dot_ftoa__Uint128){0x54aef730d6629ac0, 0x016c2d4256ffcc2f},
          (strconv_dot_ftoa__Uint128){0x29dab4fd0bfb4170, 0x01c73892ecbfbf3b},
          (strconv_dot_ftoa__Uint128){0xfa28b11e277d08e6, 0x011c835bd3f7d784},
          (strconv_dot_ftoa__Uint128){0x38b2dd65b15c4b1f, 0x0163a432c8f5cd66},
          (strconv_dot_ftoa__Uint128){0xc6df94bf1db35de7, 0x01bc8d3f7b3340bf},
          (strconv_dot_ftoa__Uint128){0xdc4bbcf772901ab0, 0x0115d847ad000877},
          (strconv_dot_ftoa__Uint128){0xd35eac354f34215c, 0x015b4e5998400a95},
          (strconv_dot_ftoa__Uint128){0x48365742a30129b4, 0x01b221effe500d3b},
          (strconv_dot_ftoa__Uint128){0x0d21f689a5e0ba10, 0x010f5535fef20845},
          (strconv_dot_ftoa__Uint128){0x506a742c0f58e894, 0x01532a837eae8a56},
          (strconv_dot_ftoa__Uint128){0xe4851137132f22b9, 0x01a7f5245e5a2ceb},
          (strconv_dot_ftoa__Uint128){0x6ed32ac26bfd75b4, 0x0108f936baf85c13},
          (strconv_dot_ftoa__Uint128){0x4a87f57306fcd321, 0x014b378469b67318},
          (strconv_dot_ftoa__Uint128){0x5d29f2cfc8bc07e9, 0x019e056584240fde},
          (strconv_dot_ftoa__Uint128){0xfa3a37c1dd7584f1, 0x0102c35f729689ea},
          (strconv_dot_ftoa__Uint128){0xb8c8c5b254d2e62e, 0x014374374f3c2c65},
          (strconv_dot_ftoa__Uint128){0x26faf71eea079fb9, 0x01945145230b377f},
          (strconv_dot_ftoa__Uint128){0xf0b9b4e6a48987a8, 0x01f965966bce055e},
          (strconv_dot_ftoa__Uint128){0x5674111026d5f4c9, 0x013bdf7e0360c35b},
          (strconv_dot_ftoa__Uint128){0x2c111554308b71fb, 0x018ad75d8438f432},
          (strconv_dot_ftoa__Uint128){0xb7155aa93cae4e7a, 0x01ed8d34e547313e},
          (strconv_dot_ftoa__Uint128){0x326d58a9c5ecf10c, 0x013478410f4c7ec7},
          (strconv_dot_ftoa__Uint128){0xff08aed437682d4f, 0x01819651531f9e78},
          (strconv_dot_ftoa__Uint128){0x3ecada89454238a3, 0x01e1fbe5a7e78617},
          (strconv_dot_ftoa__Uint128){0x873ec895cb496366, 0x012d3d6f88f0b3ce},
          (strconv_dot_ftoa__Uint128){0x290e7abb3e1bbc3f, 0x01788ccb6b2ce0c2},
          (strconv_dot_ftoa__Uint128){0xb352196a0da2ab4f, 0x01d6affe45f818f2},
          (strconv_dot_ftoa__Uint128){0xb0134fe24885ab11, 0x01262dfeebbb0f97},
          (strconv_dot_ftoa__Uint128){0x9c1823dadaa715d6, 0x016fb97ea6a9d37d},
          (strconv_dot_ftoa__Uint128){0x031e2cd19150db4b, 0x01cba7de5054485d},
          (strconv_dot_ftoa__Uint128){0x21f2dc02fad2890f, 0x011f48eaf234ad3a},
          (strconv_dot_ftoa__Uint128){0xaa6f9303b9872b53, 0x01671b25aec1d888},
          (strconv_dot_ftoa__Uint128){0xd50b77c4a7e8f628, 0x01c0e1ef1a724eaa},
          (strconv_dot_ftoa__Uint128){0xc5272adae8f199d9, 0x01188d357087712a},
          (strconv_dot_ftoa__Uint128){0x7670f591a32e004f, 0x015eb082cca94d75},
          (strconv_dot_ftoa__Uint128){0xd40d32f60bf98063, 0x01b65ca37fd3a0d2},
          (strconv_dot_ftoa__Uint128){0xc4883fd9c77bf03e, 0x0111f9e62fe44483},
          (strconv_dot_ftoa__Uint128){0xb5aa4fd0395aec4d, 0x0156785fbbdd55a4},
          (strconv_dot_ftoa__Uint128){0xe314e3c447b1a760, 0x01ac1677aad4ab0d},
          (strconv_dot_ftoa__Uint128){0xaded0e5aaccf089c, 0x010b8e0acac4eae8},
          (strconv_dot_ftoa__Uint128){0xd96851f15802cac3, 0x014e718d7d7625a2},
          (strconv_dot_ftoa__Uint128){0x8fc2666dae037d74, 0x01a20df0dcd3af0b},
          (strconv_dot_ftoa__Uint128){0x39d980048cc22e68, 0x010548b68a044d67},
          (strconv_dot_ftoa__Uint128){0x084fe005aff2ba03, 0x01469ae42c8560c1},
          (strconv_dot_ftoa__Uint128){0x4a63d8071bef6883, 0x0198419d37a6b8f1},
          (strconv_dot_ftoa__Uint128){0x9cfcce08e2eb42a4, 0x01fe52048590672d},
          (strconv_dot_ftoa__Uint128){0x821e00c58dd309a7, 0x013ef342d37a407c},
          (strconv_dot_ftoa__Uint128){0xa2a580f6f147cc10, 0x018eb0138858d09b},
          (strconv_dot_ftoa__Uint128){0x8b4ee134ad99bf15, 0x01f25c186a6f04c2},
          (strconv_dot_ftoa__Uint128){0x97114cc0ec80176d, 0x0137798f428562f9},
          (strconv_dot_ftoa__Uint128){0xfcd59ff127a01d48, 0x018557f31326bbb7},
          (strconv_dot_ftoa__Uint128){0xfc0b07ed7188249a, 0x01e6adefd7f06aa5},
          (strconv_dot_ftoa__Uint128){0xbd86e4f466f516e0, 0x01302cb5e6f642a7},
          (strconv_dot_ftoa__Uint128){0xace89e3180b25c98, 0x017c37e360b3d351},
          (strconv_dot_ftoa__Uint128){0x1822c5bde0def3be, 0x01db45dc38e0c826},
          (strconv_dot_ftoa__Uint128){0xcf15bb96ac8b5857, 0x01290ba9a38c7d17},
          (strconv_dot_ftoa__Uint128){0xc2db2a7c57ae2e6d, 0x01734e940c6f9c5d},
          (strconv_dot_ftoa__Uint128){0x3391f51b6d99ba08, 0x01d022390f8b8375},
          (strconv_dot_ftoa__Uint128){0x403b393124801445, 0x01221563a9b73229},
          (strconv_dot_ftoa__Uint128){0x904a077d6da01956, 0x016a9abc9424feb3},
          (strconv_dot_ftoa__Uint128){0x745c895cc9081fac, 0x01c5416bb92e3e60},
          (strconv_dot_ftoa__Uint128){0x48b9d5d9fda513cb, 0x011b48e353bce6fc},
          (strconv_dot_ftoa__Uint128){0x5ae84b507d0e58be, 0x01621b1c28ac20bb},
          (strconv_dot_ftoa__Uint128){0x31a25e249c51eeee, 0x01baa1e332d728ea},
          (strconv_dot_ftoa__Uint128){0x5f057ad6e1b33554, 0x0114a52dffc67992},
          (strconv_dot_ftoa__Uint128){0xf6c6d98c9a2002aa, 0x0159ce797fb817f6},
          (strconv_dot_ftoa__Uint128){0xb4788fefc0a80354, 0x01b04217dfa61df4},
          (strconv_dot_ftoa__Uint128){0xf0cb59f5d8690214, 0x010e294eebc7d2b8},
          (strconv_dot_ftoa__Uint128){0x2cfe30734e83429a, 0x0151b3a2a6b9c767},
          (strconv_dot_ftoa__Uint128){0xf83dbc9022241340, 0x01a6208b50683940},
          (strconv_dot_ftoa__Uint128){0x9b2695da15568c08, 0x0107d457124123c8},
          (strconv_dot_ftoa__Uint128){0xc1f03b509aac2f0a, 0x0149c96cd6d16cba},
          (strconv_dot_ftoa__Uint128){0x726c4a24c1573acd, 0x019c3bc80c85c7e9},
          (strconv_dot_ftoa__Uint128){0xe783ae56f8d684c0, 0x0101a55d07d39cf1},
          (strconv_dot_ftoa__Uint128){0x616499ecb70c25f0, 0x01420eb449c8842e},
          (strconv_dot_ftoa__Uint128){0xf9bdc067e4cf2f6c, 0x019292615c3aa539},
          (strconv_dot_ftoa__Uint128){0x782d3081de02fb47, 0x01f736f9b3494e88},
          (strconv_dot_ftoa__Uint128){0x4b1c3e512ac1dd0c, 0x013a825c100dd115},
          (strconv_dot_ftoa__Uint128){0x9de34de57572544f, 0x018922f31411455a},
          (strconv_dot_ftoa__Uint128){0x455c215ed2cee963, 0x01eb6bafd91596b1},
          (strconv_dot_ftoa__Uint128){0xcb5994db43c151de, 0x0133234de7ad7e2e},
          (strconv_dot_ftoa__Uint128){0x7e2ffa1214b1a655, 0x017fec216198ddba},
          (strconv_dot_ftoa__Uint128){0x1dbbf89699de0feb, 0x01dfe729b9ff1529},
          (strconv_dot_ftoa__Uint128){0xb2957b5e202ac9f3, 0x012bf07a143f6d39},
          (strconv_dot_ftoa__Uint128){0x1f3ada35a8357c6f, 0x0176ec98994f4888},
          (strconv_dot_ftoa__Uint128){0x270990c31242db8b, 0x01d4a7bebfa31aaa},
          (strconv_dot_ftoa__Uint128){0x5865fa79eb69c937, 0x0124e8d737c5f0aa},
          (strconv_dot_ftoa__Uint128){0xee7f791866443b85, 0x016e230d05b76cd4},
          (strconv_dot_ftoa__Uint128){0x2a1f575e7fd54a66, 0x01c9abd04725480a},
          (strconv_dot_ftoa__Uint128){0x5a53969b0fe54e80, 0x011e0b622c774d06},
          (strconv_dot_ftoa__Uint128){0xf0e87c41d3dea220, 0x01658e3ab7952047},
          (strconv_dot_ftoa__Uint128){0xed229b5248d64aa8, 0x01bef1c9657a6859},
          (strconv_dot_ftoa__Uint128){0x3435a1136d85eea9, 0x0117571ddf6c8138},
          (strconv_dot_ftoa__Uint128){0x4143095848e76a53, 0x015d2ce55747a186},
          (strconv_dot_ftoa__Uint128){0xd193cbae5b2144e8, 0x01b4781ead1989e7},
          (strconv_dot_ftoa__Uint128){0xe2fc5f4cf8f4cb11, 0x0110cb132c2ff630},
          (strconv_dot_ftoa__Uint128){0x1bbb77203731fdd5, 0x0154fdd7f73bf3bd},
          (strconv_dot_ftoa__Uint128){0x62aa54e844fe7d4a, 0x01aa3d4df50af0ac},
          (strconv_dot_ftoa__Uint128){0xbdaa75112b1f0e4e, 0x010a6650b926d66b},
          (strconv_dot_ftoa__Uint128){0xad15125575e6d1e2, 0x014cffe4e7708c06},
          (strconv_dot_ftoa__Uint128){0x585a56ead360865b, 0x01a03fde214caf08},
          (strconv_dot_ftoa__Uint128){0x37387652c41c53f8, 0x010427ead4cfed65},
          (strconv_dot_ftoa__Uint128){0x850693e7752368f7, 0x014531e58a03e8be},
          (strconv_dot_ftoa__Uint128){0x264838e1526c4334, 0x01967e5eec84e2ee},
          (strconv_dot_ftoa__Uint128){0xafda4719a7075402, 0x01fc1df6a7a61ba9},
          (strconv_dot_ftoa__Uint128){0x0de86c7008649481, 0x013d92ba28c7d14a},
          (strconv_dot_ftoa__Uint128){0x9162878c0a7db9a1, 0x018cf768b2f9c59c},
          (strconv_dot_ftoa__Uint128){0xb5bb296f0d1d280a, 0x01f03542dfb83703},
          (strconv_dot_ftoa__Uint128){0x5194f9e568323906, 0x01362149cbd32262},
          (strconv_dot_ftoa__Uint128){0xe5fa385ec23ec747, 0x0183a99c3ec7eafa},
          (strconv_dot_ftoa__Uint128){0x9f78c67672ce7919, 0x01e494034e79e5b9},
          (strconv_dot_ftoa__Uint128){0x03ab7c0a07c10bb0, 0x012edc82110c2f94},
          (strconv_dot_ftoa__Uint128){0x04965b0c89b14e9c, 0x017a93a2954f3b79},
          (strconv_dot_ftoa__Uint128){0x45bbf1cfac1da243, 0x01d9388b3aa30a57},
          (strconv_dot_ftoa__Uint128){0x8b957721cb92856a, 0x0127c35704a5e676},
          (strconv_dot_ftoa__Uint128){0x2e7ad4ea3e7726c4, 0x0171b42cc5cf6014},
          (strconv_dot_ftoa__Uint128){0x3a198a24ce14f075, 0x01ce2137f7433819},
          (strconv_dot_ftoa__Uint128){0xc44ff65700cd1649, 0x0120d4c2fa8a030f},
          (strconv_dot_ftoa__Uint128){0xb563f3ecc1005bdb, 0x016909f3b92c83d3},
          (strconv_dot_ftoa__Uint128){0xa2bcf0e7f14072d2, 0x01c34c70a777a4c8},
          (strconv_dot_ftoa__Uint128){0x65b61690f6c847c3, 0x011a0fc668aac6fd},
          (strconv_dot_ftoa__Uint128){0xbf239c35347a59b4, 0x016093b802d578bc},
          (strconv_dot_ftoa__Uint128){0xeeec83428198f021, 0x01b8b8a6038ad6eb},
          (strconv_dot_ftoa__Uint128){0x7553d20990ff9615, 0x01137367c236c653},
          (strconv_dot_ftoa__Uint128){0x52a8c68bf53f7b9a, 0x01585041b2c477e8},
          (strconv_dot_ftoa__Uint128){0x6752f82ef28f5a81, 0x01ae64521f7595e2},
          (strconv_dot_ftoa__Uint128){0x8093db1d57999890, 0x010cfeb353a97dad},
          (strconv_dot_ftoa__Uint128){0xe0b8d1e4ad7ffeb4, 0x01503e602893dd18},
          (strconv_dot_ftoa__Uint128){0x18e7065dd8dffe62, 0x01a44df832b8d45f},
          (strconv_dot_ftoa__Uint128){0x6f9063faa78bfefd, 0x0106b0bb1fb384bb},
          (strconv_dot_ftoa__Uint128){0x4b747cf9516efebc, 0x01485ce9e7a065ea},
          (strconv_dot_ftoa__Uint128){0xde519c37a5cabe6b, 0x019a742461887f64},
          (strconv_dot_ftoa__Uint128){0x0af301a2c79eb703, 0x01008896bcf54f9f},
          (strconv_dot_ftoa__Uint128){0xcdafc20b798664c4, 0x0140aabc6c32a386},
          (strconv_dot_ftoa__Uint128){0x811bb28e57e7fdf5, 0x0190d56b873f4c68},
          (strconv_dot_ftoa__Uint128){0xa1629f31ede1fd72, 0x01f50ac6690f1f82},
          (strconv_dot_ftoa__Uint128){0xa4dda37f34ad3e67, 0x013926bc01a973b1},
          (strconv_dot_ftoa__Uint128){0x0e150c5f01d88e01, 0x0187706b0213d09e},
          (strconv_dot_ftoa__Uint128){0x919a4f76c24eb181, 0x01e94c85c298c4c5},
          (strconv_dot_ftoa__Uint128){0x7b0071aa39712ef1, 0x0131cfd3999f7afb},
          (strconv_dot_ftoa__Uint128){0x59c08e14c7cd7aad, 0x017e43c8800759ba},
          (strconv_dot_ftoa__Uint128){0xf030b199f9c0d958, 0x01ddd4baa0093028},
          (strconv_dot_ftoa__Uint128){0x961e6f003c1887d7, 0x012aa4f4a405be19},
          (strconv_dot_ftoa__Uint128){0xfba60ac04b1ea9cd, 0x01754e31cd072d9f},
          (strconv_dot_ftoa__Uint128){0xfa8f8d705de65440, 0x01d2a1be4048f907},
          (strconv_dot_ftoa__Uint128){0xfc99b8663aaff4a8, 0x0123a516e82d9ba4},
          (strconv_dot_ftoa__Uint128){0x3bc0267fc95bf1d2, 0x016c8e5ca239028e},
          (strconv_dot_ftoa__Uint128){0xcab0301fbbb2ee47, 0x01c7b1f3cac74331},
          (strconv_dot_ftoa__Uint128){0x1eae1e13d54fd4ec, 0x011ccf385ebc89ff},
          (strconv_dot_ftoa__Uint128){0xe659a598caa3ca27, 0x01640306766bac7e},
          (strconv_dot_ftoa__Uint128){0x9ff00efefd4cbcb1, 0x01bd03c81406979e},
          (strconv_dot_ftoa__Uint128){0x23f6095f5e4ff5ef, 0x0116225d0c841ec3},
          (strconv_dot_ftoa__Uint128){0xecf38bb735e3f36a, 0x015baaf44fa52673},
          (strconv_dot_ftoa__Uint128){0xe8306ea5035cf045, 0x01b295b1638e7010},
          (strconv_dot_ftoa__Uint128){0x911e4527221a162b, 0x010f9d8ede39060a},
          (strconv_dot_ftoa__Uint128){0x3565d670eaa09bb6, 0x015384f295c7478d},
          (strconv_dot_ftoa__Uint128){0x82bf4c0d2548c2a3, 0x01a8662f3b391970},
          (strconv_dot_ftoa__Uint128){0x51b78f88374d79a6, 0x01093fdd8503afe6},
          (strconv_dot_ftoa__Uint128){0xe625736a4520d810, 0x014b8fd4e6449bdf},
          (strconv_dot_ftoa__Uint128){0xdfaed044d6690e14, 0x019e73ca1fd5c2d7},
          (strconv_dot_ftoa__Uint128){0xebcd422b0601a8cc, 0x0103085e53e599c6},
          (strconv_dot_ftoa__Uint128){0xa6c092b5c78212ff, 0x0143ca75e8df0038},
          (strconv_dot_ftoa__Uint128){0xd070b763396297bf, 0x0194bd136316c046},
          (strconv_dot_ftoa__Uint128){0x848ce53c07bb3daf, 0x01f9ec583bdc7058},
          (strconv_dot_ftoa__Uint128){0x52d80f4584d5068d, 0x013c33b72569c637},
          (strconv_dot_ftoa__Uint128){0x278e1316e60a4831, 0x018b40a4eec437c5}});
  strconv_dot_ftoa__pow5_inv_split_64 = new_array_from_c_array(
      292, 292, sizeof(strconv_dot_ftoa__Uint128),
      EMPTY_ARRAY_OF_ELEMS(strconv_dot_ftoa__Uint128, 292){
          (strconv_dot_ftoa__Uint128){0x0000000000000001, 0x0400000000000000},
          (strconv_dot_ftoa__Uint128){0x3333333333333334, 0x0333333333333333},
          (strconv_dot_ftoa__Uint128){0x28f5c28f5c28f5c3, 0x028f5c28f5c28f5c},
          (strconv_dot_ftoa__Uint128){0xed916872b020c49c, 0x020c49ba5e353f7c},
          (strconv_dot_ftoa__Uint128){0xaf4f0d844d013a93, 0x0346dc5d63886594},
          (strconv_dot_ftoa__Uint128){0x8c3f3e0370cdc876, 0x029f16b11c6d1e10},
          (strconv_dot_ftoa__Uint128){0xd698fe69270b06c5, 0x0218def416bdb1a6},
          (strconv_dot_ftoa__Uint128){0xf0f4ca41d811a46e, 0x035afe535795e90a},
          (strconv_dot_ftoa__Uint128){0xf3f70834acdae9f1, 0x02af31dc4611873b},
          (strconv_dot_ftoa__Uint128){0x5cc5a02a23e254c1, 0x0225c17d04dad296},
          (strconv_dot_ftoa__Uint128){0xfad5cd10396a2135, 0x036f9bfb3af7b756},
          (strconv_dot_ftoa__Uint128){0xfbde3da69454e75e, 0x02bfaffc2f2c92ab},
          (strconv_dot_ftoa__Uint128){0x2fe4fe1edd10b918, 0x0232f33025bd4223},
          (strconv_dot_ftoa__Uint128){0x4ca19697c81ac1bf, 0x0384b84d092ed038},
          (strconv_dot_ftoa__Uint128){0x3d4e1213067bce33, 0x02d09370d4257360},
          (strconv_dot_ftoa__Uint128){0x643e74dc052fd829, 0x024075f3dceac2b3},
          (strconv_dot_ftoa__Uint128){0x6d30baf9a1e626a7, 0x039a5652fb113785},
          (strconv_dot_ftoa__Uint128){0x2426fbfae7eb5220, 0x02e1dea8c8da92d1},
          (strconv_dot_ftoa__Uint128){0x1cebfcc8b9890e80, 0x024e4bba3a487574},
          (strconv_dot_ftoa__Uint128){0x94acc7a78f41b0cc, 0x03b07929f6da5586},
          (strconv_dot_ftoa__Uint128){0xaa23d2ec729af3d7, 0x02f394219248446b},
          (strconv_dot_ftoa__Uint128){0xbb4fdbf05baf2979, 0x025c768141d369ef},
          (strconv_dot_ftoa__Uint128){0xc54c931a2c4b758d, 0x03c7240202ebdcb2},
          (strconv_dot_ftoa__Uint128){0x9dd6dc14f03c5e0b, 0x0305b66802564a28},
          (strconv_dot_ftoa__Uint128){0x4b1249aa59c9e4d6, 0x026af8533511d4ed},
          (strconv_dot_ftoa__Uint128){0x44ea0f76f60fd489, 0x03de5a1ebb4fbb15},
          (strconv_dot_ftoa__Uint128){0x6a54d92bf80caa07, 0x0318481895d96277},
          (strconv_dot_ftoa__Uint128){0x21dd7a89933d54d2, 0x0279d346de4781f9},
          (strconv_dot_ftoa__Uint128){0x362f2a75b8622150, 0x03f61ed7ca0c0328},
          (strconv_dot_ftoa__Uint128){0xf825bb91604e810d, 0x032b4bdfd4d668ec},
          (strconv_dot_ftoa__Uint128){0xc684960de6a5340b, 0x0289097fdd7853f0},
          (strconv_dot_ftoa__Uint128){0xd203ab3e521dc33c, 0x02073accb12d0ff3},
          (strconv_dot_ftoa__Uint128){0xe99f7863b696052c, 0x033ec47ab514e652},
          (strconv_dot_ftoa__Uint128){0x87b2c6b62bab3757, 0x02989d2ef743eb75},
          (strconv_dot_ftoa__Uint128){0xd2f56bc4efbc2c45, 0x0213b0f25f69892a},
          (strconv_dot_ftoa__Uint128){0x1e55793b192d13a2, 0x0352b4b6ff0f41de},
          (strconv_dot_ftoa__Uint128){0x4b77942f475742e8, 0x02a8909265a5ce4b},
          (strconv_dot_ftoa__Uint128){0xd5f9435905df68ba, 0x022073a8515171d5},
          (strconv_dot_ftoa__Uint128){0x565b9ef4d6324129, 0x03671f73b54f1c89},
          (strconv_dot_ftoa__Uint128){0xdeafb25d78283421, 0x02b8e5f62aa5b06d},
          (strconv_dot_ftoa__Uint128){0x188c8eb12cecf681, 0x022d84c4eeeaf38b},
          (strconv_dot_ftoa__Uint128){0x8dadb11b7b14bd9b, 0x037c07a17e44b8de},
          (strconv_dot_ftoa__Uint128){0x7157c0e2c8dd647c, 0x02c99fb46503c718},
          (strconv_dot_ftoa__Uint128){0x8ddfcd823a4ab6ca, 0x023ae629ea696c13},
          (strconv_dot_ftoa__Uint128){0x1632e269f6ddf142, 0x0391704310a8acec},
          (strconv_dot_ftoa__Uint128){0x44f581ee5f17f435, 0x02dac035a6ed5723},
          (strconv_dot_ftoa__Uint128){0x372ace584c1329c4, 0x024899c4858aac1c},
          (strconv_dot_ftoa__Uint128){0xbeaae3c079b842d3, 0x03a75c6da27779c6},
          (strconv_dot_ftoa__Uint128){0x6555830061603576, 0x02ec49f14ec5fb05},
          (strconv_dot_ftoa__Uint128){0xb7779c004de6912b, 0x0256a18dd89e626a},
          (strconv_dot_ftoa__Uint128){0xf258f99a163db512, 0x03bdcf495a9703dd},
          (strconv_dot_ftoa__Uint128){0x5b7a614811caf741, 0x02fe3f6de212697e},
          (strconv_dot_ftoa__Uint128){0xaf951aa00e3bf901, 0x0264ff8b1b41edfe},
          (strconv_dot_ftoa__Uint128){0x7f54f7667d2cc19b, 0x03d4cc11c5364997},
          (strconv_dot_ftoa__Uint128){0x32aa5f8530f09ae3, 0x0310a3416a91d479},
          (strconv_dot_ftoa__Uint128){0xf55519375a5a1582, 0x0273b5cdeedb1060},
          (strconv_dot_ftoa__Uint128){0xbbbb5b8bc3c3559d, 0x03ec56164af81a34},
          (strconv_dot_ftoa__Uint128){0x2fc916096969114a, 0x03237811d593482a},
          (strconv_dot_ftoa__Uint128){0x596dab3ababa743c, 0x0282c674aadc39bb},
          (strconv_dot_ftoa__Uint128){0x478aef622efb9030, 0x0202385d557cfafc},
          (strconv_dot_ftoa__Uint128){0xd8de4bd04b2c19e6, 0x0336c0955594c4c6},
          (strconv_dot_ftoa__Uint128){0xad7ea30d08f014b8, 0x029233aaaadd6a38},
          (strconv_dot_ftoa__Uint128){0x24654f3da0c01093, 0x020e8fbbbbe454fa},
          (strconv_dot_ftoa__Uint128){0x3a3bb1fc346680eb, 0x034a7f92c63a2190},
          (strconv_dot_ftoa__Uint128){0x94fc8e635d1ecd89, 0x02a1ffa89e94e7a6},
          (strconv_dot_ftoa__Uint128){0xaa63a51c4a7f0ad4, 0x021b32ed4baa52eb},
          (strconv_dot_ftoa__Uint128){0xdd6c3b607731aaed, 0x035eb7e212aa1e45},
          (strconv_dot_ftoa__Uint128){0x1789c919f8f488bd, 0x02b22cb4dbbb4b6b},
          (strconv_dot_ftoa__Uint128){0xac6e3a7b2d906d64, 0x022823c3e2fc3c55},
          (strconv_dot_ftoa__Uint128){0x13e390c515b3e23a, 0x03736c6c9e606089},
          (strconv_dot_ftoa__Uint128){0xdcb60d6a77c31b62, 0x02c2bd23b1e6b3a0},
          (strconv_dot_ftoa__Uint128){0x7d5e7121f968e2b5, 0x0235641c8e52294d},
          (strconv_dot_ftoa__Uint128){0xc8971b698f0e3787, 0x0388a02db0837548},
          (strconv_dot_ftoa__Uint128){0xa078e2bad8d82c6c, 0x02d3b357c0692aa0},
          (strconv_dot_ftoa__Uint128){0xe6c71bc8ad79bd24, 0x0242f5dfcd20eee6},
          (strconv_dot_ftoa__Uint128){0x0ad82c7448c2c839, 0x039e5632e1ce4b0b},
          (strconv_dot_ftoa__Uint128){0x3be023903a356cfa, 0x02e511c24e3ea26f},
          (strconv_dot_ftoa__Uint128){0x2fe682d9c82abd95, 0x0250db01d8321b8c},
          (strconv_dot_ftoa__Uint128){0x4ca4048fa6aac8ee, 0x03b4919c8d1cf8e0},
          (strconv_dot_ftoa__Uint128){0x3d5003a61eef0725, 0x02f6dae3a4172d80},
          (strconv_dot_ftoa__Uint128){0x9773361e7f259f51, 0x025f1582e9ac2466},
          (strconv_dot_ftoa__Uint128){0x8beb89ca6508fee8, 0x03cb559e42ad070a},
          (strconv_dot_ftoa__Uint128){0x6fefa16eb73a6586, 0x0309114b688a6c08},
          (strconv_dot_ftoa__Uint128){0xf3261abef8fb846b, 0x026da76f86d52339},
          (strconv_dot_ftoa__Uint128){0x51d691318e5f3a45, 0x03e2a57f3e21d1f6},
          (strconv_dot_ftoa__Uint128){0x0e4540f471e5c837, 0x031bb798fe8174c5},
          (strconv_dot_ftoa__Uint128){0xd8376729f4b7d360, 0x027c92e0cb9ac3d0},
          (strconv_dot_ftoa__Uint128){0xf38bd84321261eff, 0x03fa849adf5e061a},
          (strconv_dot_ftoa__Uint128){0x293cad0280eb4bff, 0x032ed07be5e4d1af},
          (strconv_dot_ftoa__Uint128){0xedca240200bc3ccc, 0x028bd9fcb7ea4158},
          (strconv_dot_ftoa__Uint128){0xbe3b50019a3030a4, 0x02097b309321cde0},
          (strconv_dot_ftoa__Uint128){0xc9f88002904d1a9f, 0x03425eb41e9c7c9a},
          (strconv_dot_ftoa__Uint128){0x3b2d3335403daee6, 0x029b7ef67ee396e2},
          (strconv_dot_ftoa__Uint128){0x95bdc291003158b8, 0x0215ff2b98b6124e},
          (strconv_dot_ftoa__Uint128){0x892f9db4cd1bc126, 0x035665128df01d4a},
          (strconv_dot_ftoa__Uint128){0x07594af70a7c9a85, 0x02ab840ed7f34aa2},
          (strconv_dot_ftoa__Uint128){0x6c476f2c0863aed1, 0x0222d00bdff5d54e},
          (strconv_dot_ftoa__Uint128){0x13a57eacda3917b4, 0x036ae67966562217},
          (strconv_dot_ftoa__Uint128){0x0fb7988a482dac90, 0x02bbeb9451de81ac},
          (strconv_dot_ftoa__Uint128){0xd95fad3b6cf156da, 0x022fefa9db1867bc},
          (strconv_dot_ftoa__Uint128){0xf565e1f8ae4ef15c, 0x037fe5dc91c0a5fa},
          (strconv_dot_ftoa__Uint128){0x911e4e608b725ab0, 0x02ccb7e3a7cd5195},
          (strconv_dot_ftoa__Uint128){0xda7ea51a0928488d, 0x023d5fe9530aa7aa},
          (strconv_dot_ftoa__Uint128){0xf7310829a8407415, 0x039566421e7772aa},
          (strconv_dot_ftoa__Uint128){0x2c2739baed005cde, 0x02ddeb68185f8eef},
          (strconv_dot_ftoa__Uint128){0xbcec2e2f24004a4b, 0x024b22b9ad193f25},
          (strconv_dot_ftoa__Uint128){0x94ad16b1d333aa11, 0x03ab6ac2ae8ecb6f},
          (strconv_dot_ftoa__Uint128){0xaa241227dc2954db, 0x02ef889bbed8a2bf},
          (strconv_dot_ftoa__Uint128){0x54e9a81fe35443e2, 0x02593a163246e899},
          (strconv_dot_ftoa__Uint128){0x2175d9cc9eed396a, 0x03c1f689ea0b0dc2},
          (strconv_dot_ftoa__Uint128){0xe7917b0a18bdc788, 0x03019207ee6f3e34},
          (strconv_dot_ftoa__Uint128){0xb9412f3b46fe393a, 0x0267a8065858fe90},
          (strconv_dot_ftoa__Uint128){0xf535185ed7fd285c, 0x03d90cd6f3c1974d},
          (strconv_dot_ftoa__Uint128){0xc42a79e57997537d, 0x03140a458fce12a4},
          (strconv_dot_ftoa__Uint128){0x03552e512e12a931, 0x02766e9e0ca4dbb7},
          (strconv_dot_ftoa__Uint128){0x9eeeb081e3510eb4, 0x03f0b0fce107c5f1},
          (strconv_dot_ftoa__Uint128){0x4bf226ce4f740bc3, 0x0326f3fd80d304c1},
          (strconv_dot_ftoa__Uint128){0xa3281f0b72c33c9c, 0x02858ffe00a8d09a},
          (strconv_dot_ftoa__Uint128){0x1c2018d5f568fd4a, 0x020473319a20a6e2},
          (strconv_dot_ftoa__Uint128){0xf9ccf48988a7fba9, 0x033a51e8f69aa49c},
          (strconv_dot_ftoa__Uint128){0xfb0a5d3ad3b99621, 0x02950e53f87bb6e3},
          (strconv_dot_ftoa__Uint128){0x2f3b7dc8a96144e7, 0x0210d8432d2fc583},
          (strconv_dot_ftoa__Uint128){0xe52bfc7442353b0c, 0x034e26d1e1e608d1},
          (strconv_dot_ftoa__Uint128){0xb756639034f76270, 0x02a4ebdb1b1e6d74},
          (strconv_dot_ftoa__Uint128){0x2c451c735d92b526, 0x021d897c15b1f12a},
          (strconv_dot_ftoa__Uint128){0x13a1c71efc1deea3, 0x0362759355e981dd},
          (strconv_dot_ftoa__Uint128){0x761b05b2634b2550, 0x02b52adc44bace4a},
          (strconv_dot_ftoa__Uint128){0x91af37c1e908eaa6, 0x022a88b036fbd83b},
          (strconv_dot_ftoa__Uint128){0x82b1f2cfdb417770, 0x03774119f192f392},
          (strconv_dot_ftoa__Uint128){0xcef4c23fe29ac5f3, 0x02c5cdae5adbf60e},
          (strconv_dot_ftoa__Uint128){0x3f2a34ffe87bd190, 0x0237d7beaf165e72},
          (strconv_dot_ftoa__Uint128){0x984387ffda5fb5b2, 0x038c8c644b56fd83},
          (strconv_dot_ftoa__Uint128){0xe0360666484c915b, 0x02d6d6b6a2abfe02},
          (strconv_dot_ftoa__Uint128){0x802b3851d3707449, 0x024578921bbccb35},
          (strconv_dot_ftoa__Uint128){0x99dec082ebe72075, 0x03a25a835f947855},
          (strconv_dot_ftoa__Uint128){0xae4bcd358985b391, 0x02e8486919439377},
          (strconv_dot_ftoa__Uint128){0xbea30a913ad15c74, 0x02536d20e102dc5f},
          (strconv_dot_ftoa__Uint128){0xfdd1aa81f7b560b9, 0x03b8ae9b019e2d65},
          (strconv_dot_ftoa__Uint128){0x97daeece5fc44d61, 0x02fa2548ce182451},
          (strconv_dot_ftoa__Uint128){0xdfe258a51969d781, 0x0261b76d71ace9da},
          (strconv_dot_ftoa__Uint128){0x996a276e8f0fbf34, 0x03cf8be24f7b0fc4},
          (strconv_dot_ftoa__Uint128){0xe121b9253f3fcc2a, 0x030c6fe83f95a636},
          (strconv_dot_ftoa__Uint128){0xb41afa8432997022, 0x02705986994484f8},
          (strconv_dot_ftoa__Uint128){0xecf7f739ea8f19cf, 0x03e6f5a4286da18d},
          (strconv_dot_ftoa__Uint128){0x23f99294bba5ae40, 0x031f2ae9b9f14e0b},
          (strconv_dot_ftoa__Uint128){0x4ffadbaa2fb7be99, 0x027f5587c7f43e6f},
          (strconv_dot_ftoa__Uint128){0x7ff7c5dd1925fdc2, 0x03feef3fa6539718},
          (strconv_dot_ftoa__Uint128){0xccc637e4141e649b, 0x033258ffb842df46},
          (strconv_dot_ftoa__Uint128){0xd704f983434b83af, 0x028ead9960357f6b},
          (strconv_dot_ftoa__Uint128){0x126a6135cf6f9c8c, 0x020bbe144cf79923},
          (strconv_dot_ftoa__Uint128){0x83dd685618b29414, 0x0345fced47f28e9e},
          (strconv_dot_ftoa__Uint128){0x9cb12044e08edcdd, 0x029e63f1065ba54b},
          (strconv_dot_ftoa__Uint128){0x16f419d0b3a57d7d, 0x02184ff405161dd6},
          (strconv_dot_ftoa__Uint128){0x8b20294dec3bfbfb, 0x035a19866e89c956},
          (strconv_dot_ftoa__Uint128){0x3c19baa4bcfcc996, 0x02ae7ad1f207d445},
          (strconv_dot_ftoa__Uint128){0xc9ae2eea30ca3adf, 0x02252f0e5b39769d},
          (strconv_dot_ftoa__Uint128){0x0f7d17dd1add2afd, 0x036eb1b091f58a96},
          (strconv_dot_ftoa__Uint128){0x3f97464a7be42264, 0x02bef48d41913bab},
          (strconv_dot_ftoa__Uint128){0xcc790508631ce850, 0x02325d3dce0dc955},
          (strconv_dot_ftoa__Uint128){0xe0c1a1a704fb0d4d, 0x0383c862e3494222},
          (strconv_dot_ftoa__Uint128){0x4d67b4859d95a43e, 0x02cfd3824f6dce82},
          (strconv_dot_ftoa__Uint128){0x711fc39e17aae9cb, 0x023fdc683f8b0b9b},
          (strconv_dot_ftoa__Uint128){0xe832d2968c44a945, 0x039960a6cc11ac2b},
          (strconv_dot_ftoa__Uint128){0xecf575453d03ba9e, 0x02e11a1f09a7bcef},
          (strconv_dot_ftoa__Uint128){0x572ac4376402fbb1, 0x024dae7f3aec9726},
          (strconv_dot_ftoa__Uint128){0x58446d256cd192b5, 0x03af7d985e47583d},
          (strconv_dot_ftoa__Uint128){0x79d0575123dadbc4, 0x02f2cae04b6c4697},
          (strconv_dot_ftoa__Uint128){0x94a6ac40e97be303, 0x025bd5803c569edf},
          (strconv_dot_ftoa__Uint128){0x8771139b0f2c9e6c, 0x03c62266c6f0fe32},
          (strconv_dot_ftoa__Uint128){0x9f8da948d8f07ebd, 0x0304e85238c0cb5b},
          (strconv_dot_ftoa__Uint128){0xe60aedd3e0c06564, 0x026a5374fa33d5e2},
          (strconv_dot_ftoa__Uint128){0xa344afb9679a3bd2, 0x03dd5254c3862304},
          (strconv_dot_ftoa__Uint128){0xe903bfc78614fca8, 0x031775109c6b4f36},
          (strconv_dot_ftoa__Uint128){0xba6966393810ca20, 0x02792a73b055d8f8},
          (strconv_dot_ftoa__Uint128){0x2a423d2859b4769a, 0x03f510b91a22f4c1},
          (strconv_dot_ftoa__Uint128){0xee9b642047c39215, 0x032a73c7481bf700},
          (strconv_dot_ftoa__Uint128){0xbee2b680396941aa, 0x02885c9f6ce32c00},
          (strconv_dot_ftoa__Uint128){0xff1bc53361210155, 0x0206b07f8a4f5666},
          (strconv_dot_ftoa__Uint128){0x31c6085235019bbb, 0x033de73276e5570b},
          (strconv_dot_ftoa__Uint128){0x27d1a041c4014963, 0x0297ec285f1ddf3c},
          (strconv_dot_ftoa__Uint128){0xeca7b367d0010782, 0x021323537f4b18fc},
          (strconv_dot_ftoa__Uint128){0xadd91f0c8001a59d, 0x0351d21f3211c194},
          (strconv_dot_ftoa__Uint128){0xf17a7f3d3334847e, 0x02a7db4c280e3476},
          (strconv_dot_ftoa__Uint128){0x279532975c2a0398, 0x021fe2a3533e905f},
          (strconv_dot_ftoa__Uint128){0xd8eeb75893766c26, 0x0366376bb8641a31},
          (strconv_dot_ftoa__Uint128){0x7a5892ad42c52352, 0x02b82c562d1ce1c1},
          (strconv_dot_ftoa__Uint128){0xfb7a0ef102374f75, 0x022cf044f0e3e7cd},
          (strconv_dot_ftoa__Uint128){0xc59017e8038bb254, 0x037b1a07e7d30c7c},
          (strconv_dot_ftoa__Uint128){0x37a67986693c8eaa, 0x02c8e19feca8d6ca},
          (strconv_dot_ftoa__Uint128){0xf951fad1edca0bbb, 0x023a4e198a20abd4},
          (strconv_dot_ftoa__Uint128){0x28832ae97c76792b, 0x03907cf5a9cddfbb},
          (strconv_dot_ftoa__Uint128){0x2068ef21305ec756, 0x02d9fd9154a4b2fc},
          (strconv_dot_ftoa__Uint128){0x19ed8c1a8d189f78, 0x0247fe0ddd508f30},
          (strconv_dot_ftoa__Uint128){0x5caf4690e1c0ff26, 0x03a66349621a7eb3},
          (strconv_dot_ftoa__Uint128){0x4a25d20d81673285, 0x02eb82a11b48655c},
          (strconv_dot_ftoa__Uint128){0x3b5174d79ab8f537, 0x0256021a7c39eab0},
          (strconv_dot_ftoa__Uint128){0x921bee25c45b21f1, 0x03bcd02a605caab3},
          (strconv_dot_ftoa__Uint128){0xdb498b5169e2818e, 0x02fd735519e3bbc2},
          (strconv_dot_ftoa__Uint128){0x15d46f7454b53472, 0x02645c4414b62fcf},
          (strconv_dot_ftoa__Uint128){0xefba4bed545520b6, 0x03d3c6d35456b2e4},
          (strconv_dot_ftoa__Uint128){0xf2fb6ff110441a2b, 0x030fd242a9def583},
          (strconv_dot_ftoa__Uint128){0x8f2f8cc0d9d014ef, 0x02730e9bbb18c469},
          (strconv_dot_ftoa__Uint128){0xb1e5ae015c80217f, 0x03eb4a92c4f46d75},
          (strconv_dot_ftoa__Uint128){0xc1848b344a001acc, 0x0322a20f03f6bdf7},
          (strconv_dot_ftoa__Uint128){0xce03a2903b3348a3, 0x02821b3f365efe5f},
          (strconv_dot_ftoa__Uint128){0xd802e873628f6d4f, 0x0201af65c518cb7f},
          (strconv_dot_ftoa__Uint128){0x599e40b89db2487f, 0x0335e56fa1c14599},
          (strconv_dot_ftoa__Uint128){0xe14b66fa17c1d399, 0x029184594e3437ad},
          (strconv_dot_ftoa__Uint128){0x81091f2e7967dc7a, 0x020e037aa4f692f1},
          (strconv_dot_ftoa__Uint128){0x9b41cb7d8f0c93f6, 0x03499f2aa18a84b5},
          (strconv_dot_ftoa__Uint128){0xaf67d5fe0c0a0ff8, 0x02a14c221ad536f7},
          (strconv_dot_ftoa__Uint128){0xf2b977fe70080cc7, 0x021aa34e7bddc592},
          (strconv_dot_ftoa__Uint128){0x1df58cca4cd9ae0b, 0x035dd2172c9608eb},
          (strconv_dot_ftoa__Uint128){0xe4c470a1d7148b3c, 0x02b174df56de6d88},
          (strconv_dot_ftoa__Uint128){0x83d05a1b1276d5ca, 0x022790b2abe5246d},
          (strconv_dot_ftoa__Uint128){0x9fb3c35e83f1560f, 0x0372811ddfd50715},
          (strconv_dot_ftoa__Uint128){0xb2f635e5365aab3f, 0x02c200e4b310d277},
          (strconv_dot_ftoa__Uint128){0xf591c4b75eaeef66, 0x0234cd83c273db92},
          (strconv_dot_ftoa__Uint128){0xef4fa125644b18a3, 0x0387af39371fc5b7},
          (strconv_dot_ftoa__Uint128){0x8c3fb41de9d5ad4f, 0x02d2f2942c196af9},
          (strconv_dot_ftoa__Uint128){0x3cffc34b2177bdd9, 0x02425ba9bce12261},
          (strconv_dot_ftoa__Uint128){0x94cc6bab68bf9628, 0x039d5f75fb01d09b},
          (strconv_dot_ftoa__Uint128){0x10a38955ed6611b9, 0x02e44c5e6267da16},
          (strconv_dot_ftoa__Uint128){0xda1c6dde5784dafb, 0x02503d184eb97b44},
          (strconv_dot_ftoa__Uint128){0xf693e2fd58d49191, 0x03b394f3b128c53a},
          (strconv_dot_ftoa__Uint128){0xc5431bfde0aa0e0e, 0x02f610c2f4209dc8},
          (strconv_dot_ftoa__Uint128){0x6a9c1664b3bb3e72, 0x025e73cf29b3b16d},
          (strconv_dot_ftoa__Uint128){0x10f9bd6dec5eca4f, 0x03ca52e50f85e8af},
          (strconv_dot_ftoa__Uint128){0xda616457f04bd50c, 0x03084250d937ed58},
          (strconv_dot_ftoa__Uint128){0xe1e783798d09773d, 0x026d01da475ff113},
          (strconv_dot_ftoa__Uint128){0x030c058f480f252e, 0x03e19c9072331b53},
          (strconv_dot_ftoa__Uint128){0x68d66ad906728425, 0x031ae3a6c1c27c42},
          (strconv_dot_ftoa__Uint128){0x8711ef14052869b7, 0x027be952349b969b},
          (strconv_dot_ftoa__Uint128){0x0b4fe4ecd50d75f2, 0x03f97550542c242c},
          (strconv_dot_ftoa__Uint128){0xa2a650bd773df7f5, 0x032df7737689b689},
          (strconv_dot_ftoa__Uint128){0xb551da312c31932a, 0x028b2c5c5ed49207},
          (strconv_dot_ftoa__Uint128){0x5ddb14f4235adc22, 0x0208f049e576db39},
          (strconv_dot_ftoa__Uint128){0x2fc4ee536bc49369, 0x034180763bf15ec2},
          (strconv_dot_ftoa__Uint128){0xbfd0bea92303a921, 0x029acd2b63277f01},
          (strconv_dot_ftoa__Uint128){0x9973cbba8269541a, 0x021570ef8285ff34},
          (strconv_dot_ftoa__Uint128){0x5bec792a6a42202a, 0x0355817f373ccb87},
          (strconv_dot_ftoa__Uint128){0xe3239421ee9b4cef, 0x02aacdff5f63d605},
          (strconv_dot_ftoa__Uint128){0xb5b6101b25490a59, 0x02223e65e5e97804},
          (strconv_dot_ftoa__Uint128){0x22bce691d541aa27, 0x0369fd6fd64259a1},
          (strconv_dot_ftoa__Uint128){0xb563eba7ddce21b9, 0x02bb31264501e14d},
          (strconv_dot_ftoa__Uint128){0xf78322ecb171b494, 0x022f5a850401810a},
          (strconv_dot_ftoa__Uint128){0x259e9e47824f8753, 0x037ef73b399c01ab},
          (strconv_dot_ftoa__Uint128){0x1e187e9f9b72d2a9, 0x02cbf8fc2e1667bc},
          (strconv_dot_ftoa__Uint128){0x4b46cbb2e2c24221, 0x023cc73024deb963},
          (strconv_dot_ftoa__Uint128){0x120adf849e039d01, 0x039471e6a1645bd2},
          (strconv_dot_ftoa__Uint128){0xdb3be603b19c7d9a, 0x02dd27ebb4504974},
          (strconv_dot_ftoa__Uint128){0x7c2feb3627b0647c, 0x024a865629d9d45d},
          (strconv_dot_ftoa__Uint128){0x2d197856a5e7072c, 0x03aa7089dc8fba2f},
          (strconv_dot_ftoa__Uint128){0x8a7ac6abb7ec05bd, 0x02eec06e4a0c94f2},
          (strconv_dot_ftoa__Uint128){0xd52f05562cbcd164, 0x025899f1d4d6dd8e},
          (strconv_dot_ftoa__Uint128){0x21e4d556adfae8a0, 0x03c0f64fbaf1627e},
          (strconv_dot_ftoa__Uint128){0xe7ea444557fbed4d, 0x0300c50c958de864},
          (strconv_dot_ftoa__Uint128){0xecbb69d1132ff10a, 0x0267040a113e5383},
          (strconv_dot_ftoa__Uint128){0xadf8a94e851981aa, 0x03d8067681fd526c},
          (strconv_dot_ftoa__Uint128){0x8b2d543ed0e13488, 0x0313385ece6441f0},
          (strconv_dot_ftoa__Uint128){0xd5bddcff0d80f6d3, 0x0275c6b23eb69b26},
          (strconv_dot_ftoa__Uint128){0x892fc7fe7c018aeb, 0x03efa45064575ea4},
          (strconv_dot_ftoa__Uint128){0x3a8c9ffec99ad589, 0x03261d0d1d12b21d},
          (strconv_dot_ftoa__Uint128){0xc8707fff07af113b, 0x0284e40a7da88e7d},
          (strconv_dot_ftoa__Uint128){0x39f39998d2f2742f, 0x0203e9a1fe2071fe},
          (strconv_dot_ftoa__Uint128){0x8fec28f484b7204b, 0x033975cffd00b663},
          (strconv_dot_ftoa__Uint128){0xd989ba5d36f8e6a2, 0x02945e3ffd9a2b82},
          (strconv_dot_ftoa__Uint128){0x47a161e42bfa521c, 0x02104b66647b5602},
          (strconv_dot_ftoa__Uint128){0x0c35696d132a1cf9, 0x034d4570a0c5566a},
          (strconv_dot_ftoa__Uint128){0x09c454574288172d, 0x02a4378d4d6aab88},
          (strconv_dot_ftoa__Uint128){0xa169dd129ba0128b, 0x021cf93dd7888939},
          (strconv_dot_ftoa__Uint128){0x0242fb50f9001dab, 0x03618ec958da7529},
          (strconv_dot_ftoa__Uint128){0x9b68c90d940017bc, 0x02b4723aad7b90ed},
          (strconv_dot_ftoa__Uint128){0x4920a0d7a999ac96, 0x0229f4fbbdfc73f1},
          (strconv_dot_ftoa__Uint128){0x750101590f5c4757, 0x037654c5fcc71fe8},
          (strconv_dot_ftoa__Uint128){0x2a6734473f7d05df, 0x02c5109e63d27fed},
          (strconv_dot_ftoa__Uint128){0xeeb8f69f65fd9e4c, 0x0237407eb641fff0},
          (strconv_dot_ftoa__Uint128){0xe45b24323cc8fd46, 0x038b9a6456cfffe7},
          (strconv_dot_ftoa__Uint128){0xb6af502830a0ca9f, 0x02d6151d123fffec},
          (strconv_dot_ftoa__Uint128){0xf88c402026e7087f, 0x0244ddb0db666656},
          (strconv_dot_ftoa__Uint128){0x2746cd003e3e73fe, 0x03a162b4923d708b},
          (strconv_dot_ftoa__Uint128){0x1f6bd73364fec332, 0x02e7822a0e978d3c},
          (strconv_dot_ftoa__Uint128){0xe5efdf5c50cbcf5b, 0x0252ce880bac70fc},
          (strconv_dot_ftoa__Uint128){0x3cb2fefa1adfb22b, 0x03b7b0d9ac471b2e},
          (strconv_dot_ftoa__Uint128){0x308f3261af195b56, 0x02f95a47bd05af58},
          (strconv_dot_ftoa__Uint128){0x5a0c284e25ade2ab, 0x0261150630d15913},
          (strconv_dot_ftoa__Uint128){0x29ad0d49d5e30445, 0x03ce8809e7b55b52},
          (strconv_dot_ftoa__Uint128){0x548a7107de4f369d, 0x030ba007ec9115db},
          (strconv_dot_ftoa__Uint128){0xdd3b8d9fe50c2bb1, 0x026fb3398a0dab15},
          (strconv_dot_ftoa__Uint128){0x952c15cca1ad12b5, 0x03e5eb8f434911bc},
          (strconv_dot_ftoa__Uint128){0x775677d6e7bda891, 0x031e560c35d40e30},
          (strconv_dot_ftoa__Uint128){0xc5dec645863153a7, 0x027eab3cf7dcd826}});
  os__S_IFMT = 0xF000;
  os__S_IFDIR = 0x4000;
  os__S_IFLNK = 0xa000;
  os__STD_INPUT_HANDLE = -10;
  os__STD_OUTPUT_HANDLE = -11;
  os__STD_ERROR_HANDLE = -12;
  os__FILE_ATTR_READONLY = 0x1;
  os__FILE_ATTR_HIDDEN = 0x2;
  os__FILE_ATTR_SYSTEM = 0x4;
  os__FILE_ATTR_DIRECTORY = 0x10;
  os__FILE_ATTR_ARCHIVE = 0x20;
  os__FILE_ATTR_DEVICE = 0x40;
  os__FILE_ATTR_NORMAL = 0x80;
  os__FILE_ATTR_TEMPORARY = 0x100;
  os__FILE_ATTR_SPARSE_FILE = 0x200;
  os__FILE_ATTR_REPARSE_POINT = 0x400;
  os__FILE_ATTR_COMPRESSED = 0x800;
  os__FILE_ATTR_OFFLINE = 0x1000;
  os__FILE_ATTR_NOT_CONTENT_INDEXED = 0x2000;
  os__FILE_ATTR_ENCRYPTED = 0x4000;
  os__FILE_ATTR_INTEGRITY_STREAM = 0x8000;
  os__FILE_ATTR_VIRTUAL = 0x10000;
  os__FILE_ATTR_NO_SCRUB_DATA = 0x20000;
  os__FILE_TYPE_DISK = 0x1;
  os__FILE_TYPE_CHAR = 0x2;
  os__FILE_TYPE_PIPE = 0x3;
  os__FILE_TYPE_UNKNOWN = 0x0;
  os__FILE_INVALID_FILE_ID = (-1);
  os__INVALID_HANDLE_VALUE = ((voidptr)(-1));
  os__ENABLE_ECHO_INPUT = 0x0004;
  os__ENABLE_EXTENDED_FLAGS = 0x0080;
  os__ENABLE_INSERT_MODE = 0x0020;
  os__ENABLE_LINE_INPUT = 0x0002;
  os__ENABLE_MOUSE_INPUT = 0x0010;
  os__ENABLE_PROCESSED_INPUT = 0x0001;
  os__ENABLE_QUICK_EDIT_MODE = 0x0040;
  os__ENABLE_WINDOW_INPUT = 0x0008;
  os__ENABLE_VIRTUAL_TERMINAL_INPUT = 0x0200;
  os__ENABLE_PROCESSED_OUTPUT = 0x0001;
  os__ENABLE_WRAP_AT_EOL_OUTPUT = 0x0002;
  os__ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004;
  os__DISABLE_NEWLINE_AUTO_RETURN = 0x0008;
  os__ENABLE_LVB_GRID_WORLDWIDE = 0x0010;
  os__O_APPEND = 0x0008;
  os__O_CREATE = 0x0100;
  os__O_TRUNC = 0x0200;
  os__O_EXCL = 0x0400;
  os__args = new_array_from_c_array(
      0, 0, sizeof(string), EMPTY_ARRAY_OF_ELEMS(string, 0){TCCSKIP(0)});
  os__wd_at_startup = os__getwd();
  os__path_separator = tos3("\\");
  os__FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100;
  os__FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000;
  os__FORMAT_MESSAGE_FROM_HMODULE = 0x00000800;
  os__FORMAT_MESSAGE_FROM_STRING = 0x00000400;
  os__FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000;
  os__FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200;
  os__SUBLANG_NEUTRAL = 0x00;
  os__SUBLANG_DEFAULT = 0x01;
  os__LANG_NEUTRAL = (os__SUBLANG_NEUTRAL);
  v_dot_pref__default_module_path =
      string_add(os__home_dir(), tos3(".vmodules"));
  v_dot_table__number_idxs = new_array_from_c_array(
      7, 7, sizeof(int),
      EMPTY_ARRAY_OF_ELEMS(int, 7){
          v_dot_table__int_type_idx, v_dot_table__byte_type_idx,
          v_dot_table__u16_type_idx, v_dot_table__i16_type_idx,
          v_dot_table__i64_type_idx, v_dot_table__u32_type_idx,
          v_dot_table__u64_type_idx});
  v_dot_table__void_type = v_dot_table__new_type(v_dot_table__void_type_idx);
  v_dot_table__voidptr_type =
      v_dot_table__new_type(v_dot_table__voidptr_type_idx);
  v_dot_table__byteptr_type =
      v_dot_table__new_type(v_dot_table__byteptr_type_idx);
  v_dot_table__charptr_type =
      v_dot_table__new_type(v_dot_table__charptr_type_idx);
  v_dot_table__i8_type = v_dot_table__new_type(v_dot_table__i8_type_idx);
  v_dot_table__int_type = v_dot_table__new_type(v_dot_table__int_type_idx);
  v_dot_table__i16_type = v_dot_table__new_type(v_dot_table__i16_type_idx);
  v_dot_table__i64_type = v_dot_table__new_type(v_dot_table__i64_type_idx);
  v_dot_table__byte_type = v_dot_table__new_type(v_dot_table__byte_type_idx);
  v_dot_table__u16_type = v_dot_table__new_type(v_dot_table__u16_type_idx);
  v_dot_table__u32_type = v_dot_table__new_type(v_dot_table__u32_type_idx);
  v_dot_table__u64_type = v_dot_table__new_type(v_dot_table__u64_type_idx);
  v_dot_table__f32_type = v_dot_table__new_type(v_dot_table__f32_type_idx);
  v_dot_table__f64_type = v_dot_table__new_type(v_dot_table__f64_type_idx);
  v_dot_table__char_type = v_dot_table__new_type(v_dot_table__char_type_idx);
  v_dot_table__bool_type = v_dot_table__new_type(v_dot_table__bool_type_idx);
  v_dot_table__none_type = v_dot_table__new_type(v_dot_table__none_type_idx);
  v_dot_table__string_type =
      v_dot_table__new_type(v_dot_table__string_type_idx);
  v_dot_table__array_type = v_dot_table__new_type(v_dot_table__array_type_idx);
  v_dot_table__map_type = v_dot_table__new_type(v_dot_table__map_type_idx);
  v_dot_table__builtin_type_names = new_array_from_c_array(
      24, 24, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 24){
          tos3("void"), tos3("voidptr"), tos3("charptr"), tos3("byteptr"),
          tos3("i8"),   tos3("i16"),     tos3("int"),     tos3("i64"),
          tos3("u16"),  tos3("u32"),     tos3("u64"),     tos3("f32"),
          tos3("f64"),  tos3("string"),  tos3("char"),    tos3("byte"),
          tos3("bool"), tos3("none"),    tos3("array"),   tos3("array_fixed"),
          tos3("map"),  tos3("struct"),  tos3("mapnode"), tos3("ustring")});
  v_dot_scanner__is_fmt =
      string_contains(os__getenv(tos3("VEXE")), tos3("vfmt"));
  internal_dot_flag__truthy =
      new_array_from_c_array(6, 6, sizeof(string),
                             EMPTY_ARRAY_OF_ELEMS(string, 6){
                                 tos3("1"), tos3("t"), tos3("T"), tos3("true"),
                                 tos3("TRUE"), tos3("True")});
  internal_dot_flag__falsey =
      new_array_from_c_array(6, 6, sizeof(string),
                             EMPTY_ARRAY_OF_ELEMS(string, 6){
                                 tos3("0"), tos3("f"), tos3("F"), tos3("false"),
                                 tos3("FALSE"), tos3("False")});
  internal_dot_help__unknown_topic =
      tos3("V Error: Unknown help topic provided. Use `v help` for usage "
           "information.");
  benchmark__BOK = term__ok_message(tos3("OK"));
  benchmark__BFAIL = term__fail_message(tos3("FAIL"));
  benchmark__BSPENT = term__ok_message(tos3("SPENT"));
  sync__no_result = ((voidptr)(0));
  sync__INFINITE = 0xffffffff;
  sync__WAIT_ABANDONED = 0x00000080;
  sync__WAIT_IO_COMPLETION = 0x000000C0;
  sync__WAIT_OBJECT_0 = 0x00000000;
  sync__WAIT_TIMEOUT = 0x00000102;
  sync__WAIT_FAILED = 0xFFFFFFFF;
  v_dot_parser__colored_output = term__can_show_color_on_stderr();
  v_dot_gen__builtins = new_array_from_c_array(
      6, 6, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 6){tos3("string"), tos3("array"),
                                      tos3("KeyValue"), tos3("DenseArray"),
                                      tos3("map"), tos3("Option")});
  v_dot_gen__c_common_macros = tos3(
      "\n\n#define EMPTY_STRUCT_DECLARATION\n#define "
      "EMPTY_STRUCT_INITIALIZATION 0\n// Due to a tcc bug, the length of an "
      "array needs to be specified, but GCC crashes if it is...\n#define "
      "EMPTY_ARRAY_OF_ELEMS(x,n) (x[])\n#define TCCSKIP(x) x\n\n#ifdef "
      "__TINYC__\n#undef EMPTY_STRUCT_DECLARATION\n#undef "
      "EMPTY_STRUCT_INITIALIZATION\n#define EMPTY_STRUCT_DECLARATION char "
      "_dummy\n#define EMPTY_STRUCT_INITIALIZATION 0\n#undef "
      "EMPTY_ARRAY_OF_ELEMS\n#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])\n#undef "
      "TCCSKIP\n#define TCCSKIP(x)\n#endif\n\n// for __offset_of\n#ifndef "
      "__offsetof\n#define __offsetof(s,memb) \\\n    ((size_t)((char *)&((s "
      "*)0)->memb - (char *)0))\n#endif\n\n#define OPTION_CAST(x) "
      "(x)\n\n#ifndef V64_PRINTFORMAT\n#ifdef PRIx64\n#define V64_PRINTFORMAT "
      "\"0x%\"PRIx64\n#elif defined(__WIN32__)\n#define V64_PRINTFORMAT "
      "\"0x%I64x\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define "
      "V64_PRINTFORMAT \"0x%lx\"\n#else\n#define V64_PRINTFORMAT "
      "\"0x%llx\"\n#endif\n#endif\n\n");
  v_dot_gen__c_headers = _STR(
      "\n\n// c_headers\n#include <stdio.h>  // TODO remove all these "
      "includes, define all function signatures and types manually\n#include "
      "<stdlib.h>\n#include <float.h>\n\n//#include \"fns.h\"\n#include "
      "<signal.h>\n#include <stdarg.h> // for va_list\n#include <string.h> // "
      "memcpy\n\n#if INTPTR_MAX == INT32_MAX\n    #define TARGET_IS_32BIT "
      "1\n#elif INTPTR_MAX == INT64_MAX\n    #define TARGET_IS_64BIT "
      "1\n#else\n    #error \"The environment is not 32 or "
      "64-bit.\"\n#endif\n\n#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == "
      "__ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == "
      "__BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || "
      "defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || "
      "defined(__MIBSEB) || defined(__MIBSEB__)\n    #define "
      "TARGET_ORDER_IS_BIG\n#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == "
      "__ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == "
      "__LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || "
      "defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || "
      "defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || "
      "defined(_M_X64) || defined(_M_IX86)\n    #define "
      "TARGET_ORDER_IS_LITTLE\n#else\n    #error \"Unknown architecture "
      "endianness\"\n#endif\n\n#ifndef _WIN32\n#include <ctype.h>\n#include "
      "<locale.h> // tolower\n#include <sys/time.h>\n#include <unistd.h> // "
      "sleep\nextern char **environ;\n#endif\n\n#if defined(__CYGWIN__) && "
      "!defined(_WIN32)\n#error Cygwin is not supported, please use MinGW or "
      "Visual Studio.\n#endif\n\n\n#ifdef __linux__\n#include "
      "<sys/types.h>\n#include <sys/wait.h> // os__wait uses wait on "
      "nix\n#endif\n\n#ifdef __FreeBSD__\n#include <sys/types.h>\n#include "
      "<sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef "
      "__DragonFly__\n#include <sys/types.h>\n#include <sys/wait.h> // "
      "os__wait uses wait on nix\n#endif\n\n#ifdef __OpenBSD__\n#include "
      "<sys/types.h>\n#include <sys/resource.h>\n#include <sys/wait.h> // "
      "os__wait uses wait on nix\n#endif\n\n#ifdef __NetBSD__\n#include "
      "<sys/wait.h> // os__wait uses wait on nix\n#endif\n\n%.*s\n\n#ifdef "
      "_WIN32\n#define WINVER 0x0600\n#ifdef _WIN32_WINNT\n#undef "
      "_WIN32_WINNT\n#endif\n#define _WIN32_WINNT 0x0600\n#define "
      "WIN32_LEAN_AND_MEAN\n#define _UNICODE\n#define UNICODE\n#include "
      "<windows.h>\n\n#include <io.h> // _waccess\n#include <direct.h> // "
      "_wgetcwd\n//#include <WinSock2.h>\n#ifdef _MSC_VER\n\n// On MSVC these "
      "are the same (as long as /volatile:ms is passed)\n#define _Atomic "
      "volatile\n\n// MSVC cannot parse some things properly\n#undef "
      "EMPTY_STRUCT_DECLARATION\n#undef OPTION_CAST\n\n#define "
      "EMPTY_STRUCT_DECLARATION int ____dummy_variable\n#define "
      "OPTION_CAST(x)\n\n#include <dbghelp.h>\n#pragma comment(lib, "
      "\"Dbghelp.lib\")\n\nextern wchar_t "
      "**_wenviron;\n\n#endif\n\n#else\n#include "
      "<pthread.h>\n#endif\n\n\n//============================== HELPER C "
      "MACROS =============================*/\n#define _PUSH(arr, val, tmp, "
      "tmp_typ) {tmp_typ tmp = (val); array_push(arr, &tmp);}\n#define "
      "_PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); "
      "array_push_many(arr, tmp.data, tmp.len);}\n#define _IN(typ, val, arr) "
      "array_##typ##_contains(arr, val)\n#define _IN_MAP(val, m) map_exists(m, "
      "val)\n#define DEFAULT_EQUAL(a, b) (a == b)\n#define "
      "DEFAULT_NOT_EQUAL(a, b) (a != b)\n#define DEFAULT_LT(a, b) (a < "
      "b)\n#define DEFAULT_LE(a, b) (a <= b)\n#define DEFAULT_GT(a, b) (a > "
      "b)\n#define DEFAULT_GE(a, b) (a >= b)\n\n// NB: macro_fXX_eq and "
      "macro_fXX_ne are NOT used\n// in the generated C code. They are here "
      "just for\n// completeness/testing.\n\n#define macro_f64_eq(a, b) (a == "
      "b)\n#define macro_f64_ne(a, b) (a != b)\n#define macro_f64_lt(a, b) (a "
      "<  b)\n#define macro_f64_le(a, b) (a <= b)\n#define macro_f64_gt(a, b) "
      "(a >  b)\n#define macro_f64_ge(a, b) (a >= b)\n\n#define "
      "macro_f32_eq(a, b) (a == b)\n#define macro_f32_ne(a, b) (a != "
      "b)\n#define macro_f32_lt(a, b) (a <  b)\n#define macro_f32_le(a, b) (a "
      "<= b)\n#define macro_f32_gt(a, b) (a >  b)\n#define macro_f32_ge(a, b) "
      "(a >= b)\n\n//================================== GLOBALS "
      "=================================*/\nbyte g_str_buf[1024];\nint "
      "load_so(byteptr);\nvoid reload_so();\n\n// ============== wyhash "
      "==============\n//	Author: Wang Yi "
      "<godspeed_china@yeah.net>\n#ifndef wyhash_version_4\n#define "
      "wyhash_version_4\n#include	<stdint.h>\n#include	"
      "<string.h>\n#if defined(_MSC_VER) && defined(_M_X64)\n#include "
      "<intrin.h>\n#pragma	intrinsic(_umul128)\n#endif\nconst	"
      "uint64_t	_wyp0=0xa0761d6478bd642full,	"
      "_wyp1=0xe7037ed1a0b428dbull,	_wyp2=0x8ebc6af09c88c6e3ull,	"
      "_wyp3=0x589965cc75374cc3ull,	"
      "_wyp4=0x1d8e4e27c47d124full;\nstatic	inline	uint64_t	"
      "_wyrotr(uint64_t v, unsigned k) {	return	"
      "(v>>k)|(v<<(64-k));	}\nstatic	inline	uint64_t	"
      "_wymum(uint64_t	A,	uint64_t	B) {\n#ifdef	"
      "WYHASH32\n	uint64_t    hh=(A>>32)*(B>>32), "
      "hl=(A>>32)*(unsigned)B, lh=(unsigned)A*(B>>32), "
      "ll=(uint64_t)(unsigned)A*(unsigned)B;\n	return  "
      "_wyrotr(hl,32)^_wyrotr(lh,32)^hh^ll;\n#else\n	#ifdef "
      "__SIZEOF_INT128__\n		__uint128_t	r=A;	r*=B;	"
      "return	(r>>64)^r;\n	#elif	defined(_MSC_VER) && "
      "defined(_M_X64)\n		A=_umul128(A, B, &B);	return	"
      "A^B;\n	#else\n		uint64_t	ha=A>>32,	"
      "hb=B>>32,	la=(uint32_t)A,	lb=(uint32_t)B,	hi, lo;\n	"
      "	uint64_t	rh=ha*hb,	rm0=ha*lb,	rm1=hb*la,	"
      "rl=la*lb,	t=rl+(rm0<<32),	c=t<rl;\n		"
      "lo=t+(rm1<<32);	c+=lo<t;hi=rh+(rm0>>32)+(rm1>>32)+c;	return "
      "hi^lo;\n	#endif\n#endif\n}\n#ifndef WYHASH_LITTLE_ENDIAN\n	"
      "#if	defined(_WIN32) || defined(__LITTLE_ENDIAN__) || "
      "(defined(__BYTE_ORDER__) && __BYTE_ORDER__ == "
      "__ORDER_LITTLE_ENDIAN__)\n		#define WYHASH_LITTLE_ENDIAN "
      "1\n	#elif	defined(__BIG_ENDIAN__) || (defined(__BYTE_ORDER__) && "
      "__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n		#define "
      "WYHASH_LITTLE_ENDIAN 0\n	#endif\n#endif\n#if(WYHASH_LITTLE_ENDIAN) || "
      "defined(__TINYC__)\nstatic	inline	uint64_t	"
      "_wyr8(const	uint8_t	*p)	{	uint64_t	v;	"
      "memcpy(&v,  p,  8);	return  v;	}\nstatic	inline	"
      "uint64_t	_wyr4(const	uint8_t	*p)	{	unsigned	"
      "v;	memcpy(&v,  p,  4);	return  v;	}\n#else\n	#if "
      "defined(__GNUC__) || defined(__INTEL_COMPILER)\nstatic	inline	"
      "uint64_t	_wyr8(const	uint8_t	*p)	{	uint64_t	"
      "v;	memcpy(&v,  p,  8);	return   __builtin_bswap64(v);	"
      "}\nstatic	inline	uint64_t	_wyr4(const	uint8_t	"
      "*p)	{	unsigned	v;	memcpy(&v,  p,  4);	return "
      "  __builtin_bswap32(v);	}\n	#elif	"
      "defined(_MSC_VER)\nstatic	inline	uint64_t	"
      "_wyr8(const	uint8_t	*p)	{	uint64_t	v;	"
      "memcpy(&v,  p,  8);	return  _byteswap_uint64(v);}\nstatic	"
      "inline	uint64_t	_wyr4(const	uint8_t	*p)	{	"
      "unsigned	v;	memcpy(&v,  p,  4);	return  "
      "_byteswap_ulong(v);	}\n	#endif\n#endif\nstatic	inline	"
      "uint64_t	_wyr3(const	uint8_t	*p,	unsigned	k) {	"
      "return	(((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];	"
      "}\nstatic	inline	uint64_t	wyhash(const void* key,	"
      "uint64_t	len,	uint64_t	seed) {\n	const	uint8_t	"
      "*p=(const	uint8_t*)key;	uint64_t	i=len&63;\n	#if "
      "defined(__GNUC__) || defined(__INTEL_COMPILER)\n		#define	"
      "_like_(x)	__builtin_expect(x,1)\n		#define	"
      "_unlike_(x)	__builtin_expect(x,0)\n	#else\n		#define "
      "_like_(x)  (x)\n		#define _unlike_(x)  (x)\n	"
      "#endif\n	if(_unlike_(!i)) {	}\n	else	"
      "if(_unlike_(i<4))	"
      "seed=_wymum(_wyr3(p,i)^seed^_wyp0,seed^_wyp1);\n	else	"
      "if(_like_(i<=8))	"
      "seed=_wymum(_wyr4(p)^seed^_wyp0,_wyr4(p+i-4)^seed^_wyp1);\n	"
      "else	if(_like_(i<=16))	"
      "seed=_wymum(_wyr8(p)^seed^_wyp0,_wyr8(p+i-8)^seed^_wyp1);\n	"
      "else	if(_like_(i<=24))	"
      "seed=_wymum(_wyr8(p)^seed^_wyp0,_wyr8(p+8)^seed^_wyp1)^_wymum(_wyr8(p+i-"
      "8)^seed^_wyp2,seed^_wyp3);\n	else	if(_like_(i<=32))	"
      "seed=_wymum(_wyr8(p)^seed^_wyp0,_wyr8(p+8)^seed^_wyp1)^_wymum(_wyr8(p+"
      "16)^seed^_wyp2,_wyr8(p+i-8)^seed^_wyp3);\n	else{	"
      "seed=_wymum(_wyr8(p)^seed^_wyp0,_wyr8(p+8)^seed^_wyp1)^_wymum(_wyr8(p+"
      "16)^seed^_wyp2,_wyr8(p+24)^seed^_wyp3)^_wymum(_wyr8(p+i-32)^seed^_wyp1,_"
      "wyr8(p+i-24)^seed^_wyp2)^_wymum(_wyr8(p+i-16)^seed^_wyp3,_wyr8(p+i-8)^"
      "seed^_wyp0);	}\n	if(_like_(i==len))	return	"
      "_wymum(seed,len^_wyp4);\n	uint64_t	see1=seed,	"
      "see2=seed,	see3=seed;\n	for(p+=i,i=len-i;	_like_(i>=64); "
      "i-=64,p+=64) {\n		"
      "seed=_wymum(_wyr8(p)^seed^_wyp0,_wyr8(p+8)^seed^_wyp1);		"
      "see1=_wymum(_wyr8(p+16)^see1^_wyp2,_wyr8(p+24)^see1^_wyp3);\n	"
      "	see2=_wymum(_wyr8(p+32)^see2^_wyp1,_wyr8(p+40)^see2^_wyp2);	"
      "see3=_wymum(_wyr8(p+48)^see3^_wyp3,_wyr8(p+56)^see3^_wyp0);\n	"
      "}\n	return	"
      "_wymum(seed^see1^see2,see3^len^_wyp4);\n}\nstatic	inline	"
      "uint64_t	wyhash64(uint64_t	A, uint64_t	B) {	return	"
      "_wymum(_wymum(A^_wyp0,	B^_wyp1),	_wyp2);	}\nstatic	"
      "inline	uint64_t	wyrand(uint64_t	*seed) {	"
      "*seed+=_wyp0;	return	_wymum(*seed^_wyp1,*seed);	"
      "}\nstatic	inline	double	wy2u01(uint64_t	r) {	const	"
      "double	_wynorm=1.0/(1ull<<52);	return	(r>>11)*_wynorm;	"
      "}\nstatic	inline	double	wy2gau(uint64_t	r) {	const	"
      "double	_wynorm=1.0/(1ull<<20);	return	"
      "((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;"
      "	}\nstatic inline uint64_t fastest_hash(const void *key, size_t len, "
      "uint64_t seed) {\n  const uint8_t *p = (const uint8_t *)key;\n  return "
      "_like_(len >= 4) ? (_wyr4(p) + _wyr4(p + len - 4)) * (_wyr4(p + (len >> "
      "1) - 2) ^ seed) : (_like_(len) ? _wyr3(p, len) * (_wyp0 ^ seed) : "
      "seed);\n}\n#endif\n\n",
      v_dot_gen__c_common_macros.len, v_dot_gen__c_common_macros.str);
  v_dot_gen__c_builtin_types = tos3(
      "\n\n//================================== builtin types "
      "================================*/\n\ntypedef int64_t i64;\ntypedef "
      "int16_t i16;\ntypedef int8_t i8;\ntypedef uint64_t u64;\ntypedef "
      "uint32_t u32;\ntypedef uint16_t u16;\ntypedef uint8_t byte;\ntypedef "
      "uint32_t rune;\ntypedef float f32;\ntypedef double f64;\ntypedef "
      "unsigned char* byteptr;\ntypedef int* intptr;\ntypedef void* "
      "voidptr;\ntypedef char* charptr;\ntypedef struct array array;\ntypedef "
      "struct map map;\ntypedef array array_string;\ntypedef array "
      "array_int;\ntypedef array array_byte;\ntypedef array "
      "array_f32;\ntypedef array array_f64;\ntypedef array array_u16;\ntypedef "
      "array array_u32;\ntypedef array array_u64;\ntypedef map "
      "map_int;\ntypedef map map_string;\ntypedef byte array_fixed_byte_300 "
      "[300];\n#ifndef bool\n	typedef int bool;\n	#define true "
      "1\n	#define false 0\n#endif\n");
  v_dot_gen__bare_c_headers =
      _STR("\n\n%.*s\n\n#ifndef exit\n#define exit(rc) sys_exit(rc)\nvoid "
           "sys_exit (int);\n#endif\n\n",
           v_dot_gen__c_common_macros.len, v_dot_gen__c_common_macros.str);
  v_dot_gen_dot_x64__mag0 = 0x7f;
  v_dot_gen_dot_x64__e_machine = 0x3e;
  v_dot_gen_dot_x64__shn_xindex = 0xffff;
  v_dot_gen_dot_x64__segment_start = 0x400000;
  compiler__reserved_types = new_map_init(16, sizeof(bool),
                                          (string[16]){
                                              tos3("i8"),
                                              tos3("i16"),
                                              tos3("int"),
                                              tos3("i64"),
                                              tos3("i128"),
                                              tos3("byte"),
                                              tos3("char"),
                                              tos3("u16"),
                                              tos3("u32"),
                                              tos3("u64"),
                                              tos3("u128"),
                                              tos3("f32"),
                                              tos3("f64"),
                                              tos3("rune"),
                                              tos3("byteptr"),
                                              tos3("voidptr"),
                                          },
                                          (bool[16]){
                                              1,
                                              1,
                                              1,
                                              1,
                                              1,
                                              1,
                                              1,
                                              1,
                                              1,
                                              1,
                                              1,
                                              1,
                                              1,
                                              1,
                                              1,
                                              1,
                                          });
  compiler__c_common_macros = tos3(
      "\n\n#define EMPTY_STRUCT_DECLARATION\n#define "
      "EMPTY_STRUCT_INITIALIZATION 0\n// Due to a tcc bug, the length of an "
      "array needs to be specified, but GCC crashes if it is...\n#define "
      "EMPTY_ARRAY_OF_ELEMS(x,n) (x[])\n#define TCCSKIP(x) x\n\n#ifdef "
      "__TINYC__\n#undef EMPTY_STRUCT_DECLARATION\n#undef "
      "EMPTY_STRUCT_INITIALIZATION\n#define EMPTY_STRUCT_DECLARATION char "
      "_dummy\n#define EMPTY_STRUCT_INITIALIZATION 0\n#undef "
      "EMPTY_ARRAY_OF_ELEMS\n#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])\n#undef "
      "TCCSKIP\n#define TCCSKIP(x)\n#endif\n\n// for __offset_of\n#ifndef "
      "__offsetof\n#define __offsetof(s,memb) \\\n    ((size_t)((char *)&((s "
      "*)0)->memb - (char *)0))\n#endif\n\n#define OPTION_CAST(x) "
      "(x)\n\n#ifndef V64_PRINTFORMAT\n#ifdef PRIx64\n#define V64_PRINTFORMAT "
      "\"0x%\"PRIx64\n#elif defined(__WIN32__)\n#define V64_PRINTFORMAT "
      "\"0x%I64x\"\n#elif defined(__LINUX__) && defined(__LP64__)\n#define "
      "V64_PRINTFORMAT \"0x%lx\"\n#else\n#define V64_PRINTFORMAT "
      "\"0x%llx\"\n#endif\n#endif\n\n");
  compiler__c_headers = _STR(
      "\n\n//#include <inttypes.h>  // int64_t etc\n#include <stdio.h>  // "
      "TODO remove all these includes, define all function signatures and "
      "types manually\n#include <stdlib.h>\n\n//#include \"fns.h\"\n#include "
      "<signal.h>\n#include <stdarg.h> // for va_list\n#include <string.h> // "
      "memcpy\n\n#if INTPTR_MAX == INT32_MAX\n    #define TARGET_IS_32BIT "
      "1\n#elif INTPTR_MAX == INT64_MAX\n    #define TARGET_IS_64BIT "
      "1\n#else\n    #error \"The environment is not 32 or "
      "64-bit.\"\n#endif\n\n#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == "
      "__ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == "
      "__BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || "
      "defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || "
      "defined(__MIBSEB) || defined(__MIBSEB__)\n    #define "
      "TARGET_ORDER_IS_BIG\n#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == "
      "__ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == "
      "__LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || "
      "defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || "
      "defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || "
      "defined(_M_X64) || defined(_M_IX86)\n    #define "
      "TARGET_ORDER_IS_LITTLE\n#else\n    #error \"Unknown architecture "
      "endianness\"\n#endif\n\n#ifndef _WIN32\n#include <ctype.h>\n#include "
      "<locale.h> // tolower\n#include <sys/time.h>\n#include <unistd.h> // "
      "sleep\nextern char **environ;\n#endif\n\n#if defined(__CYGWIN__) && "
      "!defined(_WIN32)\n#error Cygwin is not supported, please use MinGW or "
      "Visual Studio.\n#endif\n\n\n#ifdef __linux__\n#include "
      "<sys/types.h>\n#include <sys/wait.h> // os__wait uses wait on "
      "nix\n#endif\n\n#ifdef __FreeBSD__\n#include <sys/types.h>\n#include "
      "<sys/wait.h> // os__wait uses wait on nix\n#endif\n\n#ifdef "
      "__DragonFly__\n#include <sys/types.h>\n#include <sys/wait.h> // "
      "os__wait uses wait on nix\n#endif\n\n#ifdef __OpenBSD__\n#include "
      "<sys/types.h>\n#include <sys/resource.h>\n#include <sys/wait.h> // "
      "os__wait uses wait on nix\n#endif\n\n#ifdef __NetBSD__\n#include "
      "<sys/wait.h> // os__wait uses wait on nix\n#endif\n\n%.*s\n\n#ifdef "
      "_WIN32\n#define WINVER 0x0600\n#ifdef _WIN32_WINNT\n#undef "
      "_WIN32_WINNT\n#endif\n#define _WIN32_WINNT 0x0600\n#define "
      "WIN32_LEAN_AND_MEAN\n#define _UNICODE\n#define UNICODE\n#include "
      "<windows.h>\n\n#include <io.h> // _waccess\n#include <direct.h> // "
      "_wgetcwd\n//#include <WinSock2.h>\n#ifdef _MSC_VER\n\n// On MSVC these "
      "are the same (as long as /volatile:ms is passed)\n#define _Atomic "
      "volatile\n\n// MSVC cannot parse some things properly\n#undef "
      "EMPTY_STRUCT_DECLARATION\n#undef OPTION_CAST\n\n#define "
      "EMPTY_STRUCT_DECLARATION int ____dummy_variable\n#define "
      "OPTION_CAST(x)\n\n#include <dbghelp.h>\n#pragma comment(lib, "
      "\"Dbghelp.lib\")\n\nextern wchar_t "
      "**_wenviron;\n\n#endif\n\n#else\n#include "
      "<pthread.h>\n#endif\n\n\n//============================== HELPER C "
      "MACROS =============================*/\n#define _PUSH(arr, val, tmp, "
      "tmp_typ) {tmp_typ tmp = (val); array_push(arr, &tmp);}\n#define "
      "_PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); "
      "array_push_many(arr, tmp.data, tmp.len);}\n#define _IN(typ, val, arr) "
      "array_##typ##_contains(arr, val)\n#define _IN_MAP(val, m) map_exists(m, "
      "val)\n#define DEFAULT_EQUAL(a, b) (a == b)\n#define "
      "DEFAULT_NOT_EQUAL(a, b) (a != b)\n#define DEFAULT_LT(a, b) (a < "
      "b)\n#define DEFAULT_LE(a, b) (a <= b)\n#define DEFAULT_GT(a, b) (a > "
      "b)\n#define DEFAULT_GE(a, b) (a >= b)\n\n// NB: macro_fXX_eq and "
      "macro_fXX_ne are NOT used\n// in the generated C code. They are here "
      "just for\n// completeness/testing.\n\n#define macro_f64_eq(a, b) (a == "
      "b)\n#define macro_f64_ne(a, b) (a != b)\n#define macro_f64_lt(a, b) (a "
      "<  b)\n#define macro_f64_le(a, b) (a <= b)\n#define macro_f64_gt(a, b) "
      "(a >  b)\n#define macro_f64_ge(a, b) (a >= b)\n\n#define "
      "macro_f32_eq(a, b) (a == b)\n#define macro_f32_ne(a, b) (a != "
      "b)\n#define macro_f32_lt(a, b) (a <  b)\n#define macro_f32_le(a, b) (a "
      "<= b)\n#define macro_f32_gt(a, b) (a >  b)\n#define macro_f32_ge(a, b) "
      "(a >= b)\n\n//================================== GLOBALS "
      "=================================*/\nbyte g_str_buf[1024];\nint "
      "load_so(byteptr);\nvoid reload_so();\n\n// ============== wyhash "
      "==============\n//	Author: Wang Yi "
      "<godspeed_china@yeah.net>\n#ifndef wyhash_version_4\n#define "
      "wyhash_version_4\n#include	<stdint.h>\n#include	"
      "<string.h>\n#if defined(_MSC_VER) && defined(_M_X64)\n#include "
      "<intrin.h>\n#pragma	intrinsic(_umul128)\n#endif\nconst	"
      "uint64_t	_wyp0=0xa0761d6478bd642full,	"
      "_wyp1=0xe7037ed1a0b428dbull,	_wyp2=0x8ebc6af09c88c6e3ull,	"
      "_wyp3=0x589965cc75374cc3ull,	"
      "_wyp4=0x1d8e4e27c47d124full;\nstatic	inline	uint64_t	"
      "_wyrotr(uint64_t v, unsigned k) {	return	"
      "(v>>k)|(v<<(64-k));	}\nstatic	inline	uint64_t	"
      "_wymum(uint64_t	A,	uint64_t	B) {\n#ifdef	"
      "WYHASH32\n	uint64_t    hh=(A>>32)*(B>>32), "
      "hl=(A>>32)*(unsigned)B, lh=(unsigned)A*(B>>32), "
      "ll=(uint64_t)(unsigned)A*(unsigned)B;\n	return  "
      "_wyrotr(hl,32)^_wyrotr(lh,32)^hh^ll;\n#else\n	#ifdef "
      "__SIZEOF_INT128__\n		__uint128_t	r=A;	r*=B;	"
      "return	(r>>64)^r;\n	#elif	defined(_MSC_VER) && "
      "defined(_M_X64)\n		A=_umul128(A, B, &B);	return	"
      "A^B;\n	#else\n		uint64_t	ha=A>>32,	"
      "hb=B>>32,	la=(uint32_t)A,	lb=(uint32_t)B,	hi, lo;\n	"
      "	uint64_t	rh=ha*hb,	rm0=ha*lb,	rm1=hb*la,	"
      "rl=la*lb,	t=rl+(rm0<<32),	c=t<rl;\n		"
      "lo=t+(rm1<<32);	c+=lo<t;hi=rh+(rm0>>32)+(rm1>>32)+c;	return "
      "hi^lo;\n	#endif\n#endif\n}\n#ifndef WYHASH_LITTLE_ENDIAN\n	"
      "#if	defined(_WIN32) || defined(__LITTLE_ENDIAN__) || "
      "(defined(__BYTE_ORDER__) && __BYTE_ORDER__ == "
      "__ORDER_LITTLE_ENDIAN__)\n		#define WYHASH_LITTLE_ENDIAN "
      "1\n	#elif	defined(__BIG_ENDIAN__) || (defined(__BYTE_ORDER__) && "
      "__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n		#define "
      "WYHASH_LITTLE_ENDIAN 0\n	#endif\n#endif\n#if(WYHASH_LITTLE_ENDIAN) || "
      "defined(__TINYC__)\nstatic	inline	uint64_t	"
      "_wyr8(const	uint8_t	*p)	{	uint64_t	v;	"
      "memcpy(&v,  p,  8);	return  v;	}\nstatic	inline	"
      "uint64_t	_wyr4(const	uint8_t	*p)	{	unsigned	"
      "v;	memcpy(&v,  p,  4);	return  v;	}\n#else\n	#if "
      "defined(__GNUC__) || defined(__INTEL_COMPILER)\nstatic	inline	"
      "uint64_t	_wyr8(const	uint8_t	*p)	{	uint64_t	"
      "v;	memcpy(&v,  p,  8);	return   __builtin_bswap64(v);	"
      "}\nstatic	inline	uint64_t	_wyr4(const	uint8_t	"
      "*p)	{	unsigned	v;	memcpy(&v,  p,  4);	return "
      "  __builtin_bswap32(v);	}\n	#elif	"
      "defined(_MSC_VER)\nstatic	inline	uint64_t	"
      "_wyr8(const	uint8_t	*p)	{	uint64_t	v;	"
      "memcpy(&v,  p,  8);	return  _byteswap_uint64(v);}\nstatic	"
      "inline	uint64_t	_wyr4(const	uint8_t	*p)	{	"
      "unsigned	v;	memcpy(&v,  p,  4);	return  "
      "_byteswap_ulong(v);	}\n	#endif\n#endif\nstatic	inline	"
      "uint64_t	_wyr3(const	uint8_t	*p,	unsigned	k) {	"
      "return	(((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];	"
      "}\nstatic	inline	uint64_t	wyhash(const void* key,	"
      "uint64_t	len,	uint64_t	seed) {\n	const	uint8_t	"
      "*p=(const	uint8_t*)key;	uint64_t	i=len&63;\n	#if "
      "defined(__GNUC__) || defined(__INTEL_COMPILER)\n		#define	"
      "_like_(x)	__builtin_expect(x,1)\n		#define	"
      "_unlike_(x)	__builtin_expect(x,0)\n	#else\n		#define "
      "_like_(x)  (x)\n		#define _unlike_(x)  (x)\n	"
      "#endif\n	if(_unlike_(!i)) {	}\n	else	"
      "if(_unlike_(i<4))	"
      "seed=_wymum(_wyr3(p,i)^seed^_wyp0,seed^_wyp1);\n	else	"
      "if(_like_(i<=8))	"
      "seed=_wymum(_wyr4(p)^seed^_wyp0,_wyr4(p+i-4)^seed^_wyp1);\n	"
      "else	if(_like_(i<=16))	"
      "seed=_wymum(_wyr8(p)^seed^_wyp0,_wyr8(p+i-8)^seed^_wyp1);\n	"
      "else	if(_like_(i<=24))	"
      "seed=_wymum(_wyr8(p)^seed^_wyp0,_wyr8(p+8)^seed^_wyp1)^_wymum(_wyr8(p+i-"
      "8)^seed^_wyp2,seed^_wyp3);\n	else	if(_like_(i<=32))	"
      "seed=_wymum(_wyr8(p)^seed^_wyp0,_wyr8(p+8)^seed^_wyp1)^_wymum(_wyr8(p+"
      "16)^seed^_wyp2,_wyr8(p+i-8)^seed^_wyp3);\n	else{	"
      "seed=_wymum(_wyr8(p)^seed^_wyp0,_wyr8(p+8)^seed^_wyp1)^_wymum(_wyr8(p+"
      "16)^seed^_wyp2,_wyr8(p+24)^seed^_wyp3)^_wymum(_wyr8(p+i-32)^seed^_wyp1,_"
      "wyr8(p+i-24)^seed^_wyp2)^_wymum(_wyr8(p+i-16)^seed^_wyp3,_wyr8(p+i-8)^"
      "seed^_wyp0);	}\n	if(_like_(i==len))	return	"
      "_wymum(seed,len^_wyp4);\n	uint64_t	see1=seed,	"
      "see2=seed,	see3=seed;\n	for(p+=i,i=len-i;	_like_(i>=64); "
      "i-=64,p+=64) {\n		"
      "seed=_wymum(_wyr8(p)^seed^_wyp0,_wyr8(p+8)^seed^_wyp1);		"
      "see1=_wymum(_wyr8(p+16)^see1^_wyp2,_wyr8(p+24)^see1^_wyp3);\n	"
      "	see2=_wymum(_wyr8(p+32)^see2^_wyp1,_wyr8(p+40)^see2^_wyp2);	"
      "see3=_wymum(_wyr8(p+48)^see3^_wyp3,_wyr8(p+56)^see3^_wyp0);\n	"
      "}\n	return	"
      "_wymum(seed^see1^see2,see3^len^_wyp4);\n}\nstatic	inline	"
      "uint64_t	wyhash64(uint64_t	A, uint64_t	B) {	return	"
      "_wymum(_wymum(A^_wyp0,	B^_wyp1),	_wyp2);	}\nstatic	"
      "inline	uint64_t	wyrand(uint64_t	*seed) {	"
      "*seed+=_wyp0;	return	_wymum(*seed^_wyp1,*seed);	"
      "}\nstatic	inline	double	wy2u01(uint64_t	r) {	const	"
      "double	_wynorm=1.0/(1ull<<52);	return	(r>>11)*_wynorm;	"
      "}\nstatic	inline	double	wy2gau(uint64_t	r) {	const	"
      "double	_wynorm=1.0/(1ull<<20);	return	"
      "((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;"
      "	}\nstatic inline uint64_t fastest_hash(const void *key, size_t len, "
      "uint64_t seed) {\n  const uint8_t *p = (const uint8_t *)key;\n  return "
      "_like_(len >= 4) ? (_wyr4(p) + _wyr4(p + len - 4)) * (_wyr4(p + (len >> "
      "1) - 2) ^ seed) : (_like_(len) ? _wyr3(p, len) * (_wyp0 ^ seed) : "
      "seed);\n}\n#endif\n\n",
      compiler__c_common_macros.len, compiler__c_common_macros.str);
  compiler__js_headers = tos3(
      "\n\nvar array_string = function() {}\nvar array_byte = function() "
      "{}\nvar array_int = function() {}\nvar byte = function() {}\nvar double "
      "= function() {}\nvar int = function() {}\nvar f64 = function() {}\nvar "
      "f32 = function() {}\nvar i64 = function() {}\nvar i32 = function() "
      "{}\nvar i16 = function() {}\nvar u64 = function() {}\nvar u32 = "
      "function() {}\nvar u16 = function() {}\nvar i8 = function() {}\nvar "
      "bool = function() {}\nvar rune = function() {}\nvar map_string = "
      "function() {}\nvar map_int = function() {}\n\n");
  compiler__c_builtin_types = tos3(
      "\n\n//#include <inttypes.h>  // int64_t etc\n//#include <stdint.h>  // "
      "int64_t etc\n\n//================================== 1TYPEDEFS "
      "================================*/\n\ntypedef int64_t i64;\ntypedef "
      "int16_t i16;\ntypedef int8_t i8;\ntypedef uint64_t u64;\ntypedef "
      "uint32_t u32;\ntypedef uint16_t u16;\ntypedef uint8_t byte;\ntypedef "
      "uint32_t rune;\ntypedef float f32;\ntypedef double f64;\ntypedef "
      "unsigned char* byteptr;\ntypedef int* intptr;\ntypedef void* "
      "voidptr;\ntypedef char* charptr;\ntypedef struct array array;\ntypedef "
      "struct map map;\ntypedef array array_string;\ntypedef array "
      "array_int;\ntypedef array array_byte;\ntypedef array "
      "array_f32;\ntypedef array array_f64;\ntypedef array array_u16;\ntypedef "
      "array array_u32;\ntypedef array array_u64;\ntypedef map "
      "map_int;\ntypedef map map_string;\n#ifndef bool\n	typedef int "
      "bool;\n	#define true 1\n	#define false 0\n#endif\n");
  compiler__bare_c_headers =
      _STR("\n\n%.*s\n\n#ifndef exit\n#define exit(rc) sys_exit(rc)\nvoid "
           "sys_exit (int);\n#endif\n\n",
           compiler__c_common_macros.len, compiler__c_common_macros.str);
  compiler__warn_match_arrow =
      string_add(tos3("=> is no longer needed in match statements, use\n"),
                 tos3("match foo {\n	1 { bar }\n	2 { baz }\n	else { "
                      "... }\n}"));
  compiler__err_used_as_value = tos3("used as value");
  compiler__and_or_error =
      string_add(tos3("use `()` to make the boolean expression clear\n"),
                 tos3("for example: `(a && b) || c` instead of `a && b || c`"));
  compiler__err_modify_bitfield =
      tos3("to modify a bitfield flag use the methods: set, clear, toggle. and "
           "to check for flag use: has");
  compiler__EmptyFn =
      (compiler__Fn){.name = tos3(""),
                     .mod = tos3(""),
                     .args = new_array(0, 1, sizeof(compiler__Var)),
                     .is_interface = 0,
                     .scope_level = 0,
                     .typ = tos3(""),
                     .receiver_typ = tos3(""),
                     .is_c = 0,
                     .is_public = 0,
                     .is_method = 0,
                     .is_decl = 0,
                     .is_unsafe = 0,
                     .is_deprecated = 0,
                     .is_variadic = 0,
                     .is_generic = 0,
                     .returns_error = 0,
                     .defer_text = new_array(0, 1, sizeof(string)),
                     .type_pars = new_array(0, 1, sizeof(string)),
                     .type_inst = new_array(0, 1, sizeof(compiler__TypeInst)),
                     .generic_fn_idx = 0,
                     .parser_idx = 0,
                     .fn_name_token_idx = 0,
                     .comptime_define = tos3(""),
                     .is_used = 0};
  compiler__MainFn =
      (compiler__Fn){.name = tos3("main"),
                     .mod = tos3(""),
                     .args = new_array(0, 1, sizeof(compiler__Var)),
                     .is_interface = 0,
                     .scope_level = 0,
                     .typ = tos3(""),
                     .receiver_typ = tos3(""),
                     .is_c = 0,
                     .is_public = 0,
                     .is_method = 0,
                     .is_decl = 0,
                     .is_unsafe = 0,
                     .is_deprecated = 0,
                     .is_variadic = 0,
                     .is_generic = 0,
                     .returns_error = 0,
                     .defer_text = new_array(0, 1, sizeof(string)),
                     .type_pars = new_array(0, 1, sizeof(string)),
                     .type_inst = new_array(0, 1, sizeof(compiler__TypeInst)),
                     .generic_fn_idx = 0,
                     .parser_idx = 0,
                     .fn_name_token_idx = 0,
                     .comptime_define = tos3(""),
                     .is_used = 0};
  compiler__dot_ptr = tos3("->");
  compiler__Version = tos3("0.1.25");
  compiler__supported_platforms = new_array_from_c_array(
      13, 13, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 13){
          tos3("windows"), tos3("mac"), tos3("macos"), tos3("linux"),
          tos3("freebsd"), tos3("openbsd"), tos3("netbsd"), tos3("dragonfly"),
          tos3("android"), tos3("js"), tos3("solaris"), tos3("haiku"),
          tos3("linux_or_macos")});
  compiler__v_modules_path = v_dot_pref__default_module_path;
  compiler__HKEY_LOCAL_MACHINE = ((compiler__RegKey)(0x80000002));
  compiler__KEY_QUERY_VALUE = (0x0001);
  compiler__KEY_WOW64_32KEY = (0x0200);
  compiler__KEY_ENUMERATE_SUB_KEYS = (0x0008);
  compiler__c_reserved = new_array_from_c_array(
      30, 30, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 30){
          tos3("delete"),   tos3("exit"),     tos3("unix"),     tos3("error"),
          tos3("malloc"),   tos3("free"),     tos3("panic"),    tos3("auto"),
          tos3("char"),     tos3("default"),  tos3("do"),       tos3("double"),
          tos3("extern"),   tos3("float"),    tos3("inline"),   tos3("int"),
          tos3("long"),     tos3("register"), tos3("restrict"), tos3("short"),
          tos3("signed"),   tos3("sizeof"),   tos3("static"),   tos3("switch"),
          tos3("typedef"),  tos3("union"),    tos3("unsigned"), tos3("void"),
          tos3("volatile"), tos3("while"),
      });
  compiler__integer_types = new_array_from_c_array(
      9, 9, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 9){tos3("int"), tos3("i8"), tos3("char"),
                                      tos3("byte"), tos3("i16"), tos3("u16"),
                                      tos3("u32"), tos3("i64"), tos3("u64")});
  compiler__float_types = new_array_from_c_array(
      2, 2, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 2){tos3("f32"), tos3("f64")});
  compiler__reserved_type_param_names = new_array_from_c_array(
      5, 5, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 5){tos3("R"), tos3("S"), tos3("T"),
                                      tos3("U"), tos3("W")});
  compiler__pointer_types = new_array_from_c_array(
      8, 8, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 8){
          tos3("byte*"), tos3("byteptr"), tos3("char*"), tos3("charptr"),
          tos3("void*"), tos3("voidptr"), tos3("voidptr*"), tos3("intptr")});
  compiler__builtin_types = new_array_from_c_array(
      17, 17, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 17){
          tos3("int"), tos3("i8"), tos3("char"), tos3("byte"), tos3("i16"),
          tos3("u16"), tos3("u32"), tos3("i64"), tos3("u64"), tos3("f64"),
          tos3("f32"), tos3("byteptr"), tos3("charptr"), tos3("voidptr"),
          tos3("intptr"), tos3("string"), tos3("ustring")});
  compiler__TokenStr = compiler__build_token_str();
  compiler__KEYWORDS = compiler__build_keys();
  compiler__AssignTokens = new_array_from_c_array(
      11, 11, sizeof(compiler__TokenKind),
      EMPTY_ARRAY_OF_ELEMS(compiler__TokenKind, 11){
          compiler__compiler__TokenKind_assign,
          compiler__compiler__TokenKind_plus_assign,
          compiler__compiler__TokenKind_minus_assign,
          compiler__compiler__TokenKind_mult_assign,
          compiler__compiler__TokenKind_div_assign,
          compiler__compiler__TokenKind_xor_assign,
          compiler__compiler__TokenKind_mod_assign,
          compiler__compiler__TokenKind_or_assign,
          compiler__compiler__TokenKind_and_assign,
          compiler__compiler__TokenKind_righ_shift_assign,
          compiler__compiler__TokenKind_left_shift_assign});
  compiler__MOD_FILE_STOP_PATHS = new_array_from_c_array(
      4, 4, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 4){tos3(".git"), tos3(".hg"), tos3(".svn"),
                                      tos3(".v.mod.stop")});
  main__list_of_flags = new_array_from_c_array(
      14, 14, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 14){
          tos3("o"), tos3("output"), tos3("d"), tos3("define"), tos3("b"),
          tos3("backend"), tos3("cc"), tos3("os"), tos3("target-os"),
          tos3("arch"), tos3("csource"), tos3("cf"), tos3("cflags"),
          tos3("path")});
  main__simple_cmd = new_array_from_c_array(
      12, 12, sizeof(string),
      EMPTY_ARRAY_OF_ELEMS(string, 12){
          tos3("fmt"), tos3("up"), tos3("self"), tos3("test"), tos3("test-fmt"),
          tos3("test-compiler"), tos3("bin2v"), tos3("repl"),
          tos3("build-tools"), tos3("build-examples"), tos3("build-vbinaries"),
          tos3("setup-freetype")});
  builtin__init();
}

string _STR(const char *fmt, ...) {
  va_list argptr;
  va_start(argptr, fmt);
  size_t len = vsnprintf(0, 0, fmt, argptr) + 1;
  va_end(argptr);
  byte *buf = malloc(len);
  va_start(argptr, fmt);
  vsprintf((char *)buf, fmt, argptr);
  va_end(argptr);
#ifdef DEBUG_ALLOC
  puts("_STR:");
  puts(buf);
#endif
  return tos2(buf);
}

string _STR_TMP(const char *fmt, ...) {
  va_list argptr;
  va_start(argptr, fmt);
  // size_t len = vsnprintf(0, 0, fmt, argptr) + 1;
  va_end(argptr);
  va_start(argptr, fmt);
  vsprintf((char *)g_str_buf, fmt, argptr);
  va_end(argptr);
#ifdef DEBUG_ALLOC
  // puts("_STR_TMP:");
  // puts(g_str_buf);
#endif
  return tos2(g_str_buf);
}

int wmain(int argc, wchar_t *argv[], wchar_t *envp[]) {
  init();
  os__args = os__init_os_args_wide(argc, argv);

  main__main();
#if VPREALLOC
  free(g_m2_buf);
  puts("freed mem buf");
#endif

  return 0;
}
