// Generated by V

#include <inttypes.h> // int64_t etc
#include <signal.h>
#include <stdarg.h> // for va_list
#include <stdio.h> // TODO remove all these includes, define all function signatures and types manually
#include <stdlib.h>

#ifdef __linux__
#include <pthread.h>
#endif

#ifdef __APPLE__

#endif

#ifdef _WIN32
#include <windows.h>
//#include <WinSock2.h>
#endif

//================================== TYPEDEFS ================================*/

typedef unsigned char byte;
typedef unsigned int uint;
typedef int64_t i64;
typedef int32_t i32;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t u8;
typedef uint32_t rune;
typedef float f32;
typedef double f64;
typedef unsigned char *byteptr;
typedef int *intptr;
typedef void *voidptr;
typedef struct array array;
typedef struct map map;
typedef array array_string;
typedef array array_int;
typedef array array_byte;
typedef array array_uint;
typedef array array_float;
typedef map map_int;
typedef map map_string;
#ifndef bool
typedef int bool;
#define true 1
#define false 0
#endif

//============================== HELPER C MACROS =============================*/

#define _PUSH(arr, val, tmp, tmp_typ)                                          \
  {                                                                            \
    tmp_typ tmp = (val);                                                       \
    array__push(arr, &tmp);                                                    \
  }
#define _IN(typ, val, arr) array_##typ##_contains(arr, val)
#define ALLOC_INIT(type, ...)                                                  \
  (type *)memdup((type[]){__VA_ARGS__}, sizeof(type))
#define UTF8_CHAR_LEN(byte) ((0xE5000000 >> ((byte >> 3) & 0x1e)) & 3) + 1

//================================== GLOBALS =================================*/
// int V_ZERO = 0;
byteptr g_str_buf;
int load_so(byteptr);
void reload_so();
void init_consts();
int g_test_ok = 1;
/*================================== FNS =================================*/
#include <dirent.h>
#include <errno.h>
#include <signal.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>
typedef struct array array;
typedef array array_int;
typedef array array_string;
typedef struct string string;
typedef struct ustring ustring;
typedef array array_byte;
typedef struct map map;
typedef array array_Entry;
typedef struct Entry Entry;
typedef struct Option Option;
typedef struct StringBuilder StringBuilder;
typedef struct os__FILE os__FILE;
typedef struct os__File os__File;
typedef struct os__FileInfo os__FileInfo;
typedef Option Option_string;
typedef array array_ustring;
typedef struct time__Time time__Time;
typedef struct CGen CGen;
typedef struct Fn Fn;
typedef array array_Var;
typedef int BuildMode;

typedef int Os;

typedef int Pass;

typedef struct V V;
typedef struct Var Var;
typedef struct Parser Parser;
typedef struct Scanner Scanner;
typedef struct ScanRes ScanRes;
typedef struct Table Table;
typedef array array_Type;
typedef array array_Fn;
typedef int AccessMod;

typedef int TypeCategory;

typedef struct Type Type;
typedef int Token;

typedef array array_Token;
typedef Option Option_string;
typedef int BuildMode;

typedef int Os;

typedef int Pass;

typedef int AccessMod;

typedef int TypeCategory;

typedef int Token;

struct /*kind*/ array {
  void *data;
  int len;
  int cap;
  int element_size;
};
struct /*kind*/ string {
  byte *str;
  int len;
};
struct /*kind*/ ustring {
  string s;
  array_int runes;
  int len;
};
struct /*kind*/ map {
  int element_size;
  array_Entry entries;
  bool is_sorted;
};
struct /*kind*/ Entry {
  string key;
  void *val;
};
struct /*kind*/ Option {
  void *data;
  string error;
  bool ok;
};
struct /*kind*/ StringBuilder {
  array_byte buf;
  int len;
};
struct /*kind*/ os__FILE {};
struct /*kind*/ os__File {
  os__FILE *cfile;
};
struct /*kind*/ os__FileInfo {
  string name;
  int size;
};
struct /*kind*/ time__Time {
  int year;
  int month;
  int day;
  int hour;
  int minute;
  int second;
  int uni;
};
struct /*kind*/ CGen {
  os__File out;
  string out_path;
  array_string typedefs;
  array_string type_aliases;
  array_string includes;
  array_string types;
  array_string thread_args;
  array_string thread_fns;
  array_string consts;
  array_string fns;
  array_string so_fns;
  array_string consts_init;
  array_string lines;
  bool is_user;
  Pass run;
  bool nogen;
  string tmp_line;
  string cur_line;
  string prev_line;
  bool is_tmp;
  string fn_main;
  string stash;
};
struct /*kind*/ Fn {
  string pkg;
  array_Var local_vars;
  int var_idx;
  array_Var args;
  bool is_interface;
  int scope_level;
  string typ;
  string name;
  bool is_c;
  string receiver_typ;
  bool is_public;
  bool is_method;
  bool returns_error;
  bool is_decl;
  string defer;
};
struct /*kind*/ V {
  BuildMode build_mode;
  Os os;
  bool nofmt;
  string out_name_c;
  array_string files;
  string dir;
  Table *table;
  CGen *cgen;
  bool is_test;
  bool is_script;
  bool is_so;
  bool is_live;
  bool is_prof;
  bool translated;
  bool obfuscate;
  string lang_dir;
  bool is_verbose;
  bool is_run;
  bool is_play;
  bool show_c_cmd;
  bool sanitize;
  string out_name;
  bool is_prod;
  bool is_repl;
  string vroot;
};
struct /*kind*/ Var {
  string typ;
  string name;
  bool is_arg;
  bool is_const;
  bool is_import_const;
  array_Var args;
  string attr;
  bool is_mut;
  bool ptr;
  bool ref;
  string parent_fn;
  string pkg;
  int line_nr;
  AccessMod access_mod;
  bool is_global;
  bool is_used;
  int scope_level;
};
struct /*kind*/ Parser {
  string file_path;
  string file_name;
  Scanner *scanner;
  int token_idx;
  Token tok;
  Token prev_tok;
  Token prev_tok2;
  string lit;
  CGen *cgen;
  Table *table;
  Pass run;
  Os os;
  string pkg;
  bool inside_const;
  Var expr_var;
  string assigned_type;
  int tmp_cnt;
  bool is_test;
  bool is_script;
  bool is_live;
  bool is_so;
  bool is_prof;
  bool translated;
  bool is_prod;
  bool is_verbose;
  bool obfuscate;
  bool is_play;
  bool is_repl;
  bool builtin_pkg;
  BuildMode build_mode;
  array_string vh_lines;
  bool inside_if_expr;
  bool is_struct_init;
  int if_expr_cnt;
  int for_expr_cnt;
  bool ptr_cast;
  bool calling_c;
  Fn *cur_fn;
  bool returns;
  string vroot;
  bool is_c_struct_init;
  bool can_chash;
};
struct /*kind*/ Scanner {
  string file_path;
  string text;
  int pos;
  int line_nr;
  bool inside_string;
  bool dollar_start;
  bool dollar_end;
  bool debug;
  string line_comment;
  bool started;
  bool is_fmt;
  StringBuilder fmt_out;
  int fmt_indent;
  bool fmt_line_empty;
};
struct /*kind*/ ScanRes {
  Token tok;
  string lit;
};
struct /*kind*/ Table {
  array_Type types;
  array_Var consts;
  array_Fn fns;
  map_int obf_ids;
  array_string packages;
  array_string imports;
  array_string flags;
  _Atomic int fn_cnt;
  bool obfuscate;
};
struct /*kind*/ Type {
  string pkg;
  string name;
  array_Var fields;
  array_Fn methods;
  string parent;
  TypeCategory cat;
  array_string gen_types;
  Fn func;
  bool is_c;
  bool is_interface;
  bool is_enum;
  bool is_placeholder;
};

string _STR(const char *, ...);

string _STR_TMP(const char *, ...);

array new_array(int mylen, int cap, int elm_size);
array new_array_from_c_array(int len, int cap, int elm_size, void *c_array);
array new_array_from_c_array_no_alloc(int len, int cap, int elm_size,
                                      void *c_array);
array array_repeat(void *val, int nr_repeats, int elm_size);
void array_append_array(array *a, array b);
void array_sort_with_compare(array *a, void *compare);
void array_insert(array *a, int i, void *val);
void array_prepend(array *a, void *val);
void array_delete(array *a, int idx);
void *array__get(array a, int i);
void *array_first(array a);
void *array_last(array a);
array array_left(array s, int n);
array array_right(array s, int n);
array array_slice(array s, int start, int _end);
void array_set(array *a, int idx, void *val);
void array__push(array *arr, void *val);
void array__push_many(array *arr, void *val, int size);
string array_int_str(array_int a);
void v_array_int_free(array_int a);
string array_string_str(array_string a);
void v_free(void *a);
string tos(byte *s, int len);
string tos_clone(byte *s);
string tos2(byte *s);
string string_clone(string a);
byte *string_cstr(string s);
string string_replace(string s, string rep, string with);
int string_int(string s);
f32 string_f32(string s);
bool string_eq(string s, string a);
bool string_ne(string s, string a);
bool string_lt(string s, string a);
bool string_le(string s, string a);
bool string_gt(string s, string a);
bool string_ge(string s, string a);
string string_add(string s, string a);
array_string string_split(string s, string delim);
array_string string_split_single(string s, byte delim);
array_string string_split_into_lines(string s);
string string_left(string s, int n);
string string_right(string s, int n);
string string_substr(string s, int start, int end);
int string_index(string s, string p);
int string_last_index(string s, string p);
int string_index_after(string s, string p, int start);
bool string_contains(string s, string p);
bool string_starts_with(string s, string p);
bool string_ends_with(string s, string p);
string string_to_lower(string s);
string string_to_upper(string s);
string string_find_between(string s, string start, string end);
bool array_string_contains(array_string ar, string val);
bool array_int_contains(array_int ar, int val);
bool is_space(byte c);
bool byte_is_space(byte c);
string string_trim_space(string s);
string string_trim(string s, byte c);
string string_trim_left(string s, string cutset);
string string_trim_right(string s, string cutset);
int compare_strings(string *a, string *b);
int compare_strings_by_len(string *a, string *b);
int compare_lower_strings(string *a, string *b);
void array_string_sort(array_string *s);
void array_string_sort_ignore_case(array_string *s);
void array_string_sort_by_len(array_string *s);
ustring string_ustring(string s);
ustring string_ustring_tmp(string s);
string ustring_substr(ustring u, int start, int end);
string ustring_left(ustring u, int pos);
string ustring_right(ustring u, int pos);
byte string_at(string s, int idx);
string ustring_at(ustring u, int idx);
void v_ustring_free(ustring u);
int abs(int a);
bool byte_is_digit(byte c);
bool byte_is_letter(byte c);
void v_string_free(string s);
void v_array_string_free(array_string arr);
string string_all_before(string s, string dot);
string string_all_before_last(string s, string dot);
string string_all_after(string s, string dot);
string array_string_join(array_string a, string del);
string array_string_join_lines(array_string s);
string string_reverse(string s);
string string_limit(string s, int max);
bool byte_is_white(byte c);
string repeat_char(byte c, int n);
int string_hash(string s);
void v_exit(int code);
bool isnil(void *v);
void on_panic(int (*f)(int /*FFF*/));
void print_backtrace();
void v_panic(string s);
void println(string s);
void eprintln(string s);
void v_print(string s);
byte *v_malloc(int n);
byte *v_calloc(int n);
int _strlen(byte *s);
Option opt_ok(void *data);
void *memdup(void *src, int sz);
Option v_error(string s);
string double_str(double d);
string f64_str(f64 d);
string f32_str(f32 d);
string ptr_str(void *ptr);
string int_str(int nn);
string u8_str(u8 nn);
string i64_str(i64 nn);
string bool_str(bool b);
string int_hex(int n);
string i64_hex(i64 n);
bool array_byte_contains(array_byte a, byte val);
string byte_str(byte c);
int utf8_char_len(byte b);
string utf32_to_str(u32 code);
string utf32_to_str_no_malloc(u32 code, void *buf);
int string_utf32_code(string _rune);
map new_map(int cap, int elm_size);
Entry map_new_entry(map *m, string key, void *val);
void map__set(map *m, string key, void *val);
int volt_abs(int n);
void map_bs(map m, string query, int start, int end, void *out);
int compare_map(Entry *a, Entry *b);
void map_sort(map *m);
array_string map_keys(map m);
bool map_get(map m, string key, void *out);
bool map_exists(map m, string key);
void v_map_print(map m);
void v_map_free(map m);
string map_string_str(map_string m);
StringBuilder new_string_builder(int initial_size);
void StringBuilder_write(StringBuilder *b, string s);
void StringBuilder_writeln(StringBuilder *b, string s);
string StringBuilder_str(StringBuilder b);
void StringBuilder_cut(StringBuilder b, int n);
void v_StringBuilder_free(StringBuilder *b);
void os__todo_remove();
array_string os__init_os_args(int argc, byteptr *argv);
array_string os__parse_windows_cmd_line(byte *cmd);
Option_string os__read_file(string path);
int os__file_size(string path);
void os__mv(string old, string new);
array_string os__read_lines(string path);
array_ustring os__read_ulines(string path);
os__File os__open(string path);
os__File os__open_file(string file);
os__File os__create(string path);
os__File os__open_append(string path);
os__File os__create_file(string file);
os__File os__create_file_a(string file);
os__File os__open_file_a(string file);
os__File os__create_file2(string file, string mode);
void os__File_append(os__File f, string s);
void os__File_write_bytes(os__File f, void *data, int size);
void os__File_write_bytes_at(os__File f, void *data, int size, int pos);
void os__File_appendln(os__File f, string s);
void os__File_close(os__File f);
void os__close_file(os__FILE *fp);
int os__system(string cmd);
os__FILE *os__popen(string path);
string os__exec(string cmd);
string os__getenv(string key);
int os__setenv(string name, string value, bool overwrite);
int os__unsetenv(string name);
bool os__file_exists(string path);
bool os__dir_exists(string path);
void os__mkdir(string path);
void os__rm(string path);
void os__print_c_errno();
string os__ext(string path);
string os__path_sans_ext(string path);
string os__basedir(string path);
string os__filename(string path);
string os__get_line();
string os__get_raw_line();
string os__user_os();
string os__home_dir();
void os__write_file(string path, string text);
void os__clear();
void os__on_segfault(void *f);
string os__getexepath();
void os__log(string s);
bool os__is_dir(string path);
void os__chdir(string path);
string os__getwd();
array_string os__ls(string path);
void os__print_backtrace();
time__Time time__now();
time__Time time__random();
time__Time time__unix(int u);
time__Time time__convert_ctime(struct /*TM*/ tm t);
string time__Time_format_ss(time__Time t);
string time__Time_format(time__Time t);
string time__Time_smonth(time__Time t);
string time__Time_hhmm(time__Time t);
string time__Time_hhmm12(time__Time t);
string time__Time_hhmmss(time__Time t);
string time__Time_ymmdd(time__Time t);
string time__Time_md(time__Time t);
string time__Time_clean(time__Time t);
string time__Time_clean12(time__Time t);
time__Time time__parse(string s);
time__Time time__new_time(time__Time t);
int time__Time_calc_unix(time__Time *t);
time__Time time__Time_add_seconds(time__Time t, int seconds);
int time__since(time__Time t);
string time__Time_relative(time__Time t);
int time__day_of_week(int y, int m, int d);
int time__Time_day_of_week(time__Time t);
string time__Time_weekday_str(time__Time t);
f64 time__ticks();
void time__sleep(int seconds);
void time__usleep(int n);
void time__sleep_ms(int n);
void rand__seed();
int rand__next(int max);
CGen *new_cgen(string out_name_c);
void CGen_genln(CGen *g, string s);
void CGen_gen(CGen *g, string s);
void CGen_save(CGen *g);
void CGen_start_tmp(CGen *g);
string CGen_end_tmp(CGen *g);
int CGen_add_placeholder(CGen *g);
void CGen_set_placeholder(CGen *g, int pos, string val);
int CGen_add_placeholder2(CGen *g);
void CGen_set_placeholder2(CGen *g, int pos, string val);
void CGen_insert_before(CGen *g, string val);
void CGen_register_thread_fn(CGen *g, string wrapper_name, string wrapper_text,
                             string struct_text);
string V_prof_counters(V *c);
string Parser_print_prof_counters(Parser *p);
void Parser_gen_type(Parser *p, string s);
void Parser_gen_typedef(Parser *p, string s);
void Parser_gen_type_alias(Parser *p, string s);
void CGen_add_to_main(CGen *g, string s);
Var Fn_find_var(Fn *f, string name);
void Fn_open_scope(Fn *f);
void Fn_close_scope(Fn *f);
void Fn_mark_var_used(Fn *f, Var v);
bool Fn_known_var(Fn *f, string name);
void Fn_register_var(Fn *f, Var v);
void Fn_clear_vars(Fn *f);
bool Parser_is_sig(Parser *p);
Fn *new_fn(string pkg, bool is_public);
void Parser_fn_decl(Parser *p);
void Parser_check_unused_variables(Parser *p);
void Parser_async_fn_call(Parser *p, Fn f, int method_ph, string receiver_var,
                          string receiver_type);
void Parser_fn_call(Parser *p, Fn f, int method_ph, string receiver_var,
                    string receiver_type);
void Parser_fn_args(Parser *p, Fn *f);
Fn *Parser_fn_call_args(Parser *p, Fn *f);
bool contains_capital(string s);
string Fn_typ_str(Fn f);
string Fn_str_args(Fn *f, Table *table);
void Parser_gen_json_for_type(Parser *p, Type typ);
bool is_js_prim(string typ);
string Parser_decode_array(Parser *p, string typ);
string js_enc_name(string typ);
string js_dec_name(string typ);
string Parser_encode_array(Parser *p, string typ);
string vtmp_path();
void V_compile(V *c);
void V_cc(V *c);
array_string V_v_files_from_dir(V *c, string dir);
void V_add_user_v_files(V *c);
string get_arg(string joined_args, string arg, string def);
void V_log(V *c, string s);
V *new_v(array_string args);
array_string run_repl();
Parser V_new_parser(V *c, string path, Pass run);
void Parser_next(Parser *p);
void Parser_log(Parser *p, string s);
void Parser_parse(Parser *p);
void Parser_import_statement(Parser *p);
void Parser_const_decl(Parser *p);
void Parser_type_decl(Parser *p);
void Parser_struct_decl(Parser *p);
void Parser_enum_decl(Parser *p, string _enum_name);
string Parser_check_name(Parser *p);
string Parser_check_string(Parser *p);
string Parser_strtok(Parser *p);
void Parser_check_space(Parser *p, Token expected);
void Parser_check(Parser *p, Token expected);
void Parser_error(Parser *p, string s);
bool Parser_first_run(Parser *p);
string Parser_get_type(Parser *p);
void Parser_print_tok(Parser *p);
string Parser_statements(Parser *p);
string Parser_statements_no_curly_end(Parser *p);
void Parser_genln(Parser *p, string s);
void Parser_gen(Parser *p, string s);
void Parser_vh_genln(Parser *p, string s);
void Parser_fmt_inc(Parser *p);
void Parser_fmt_dec(Parser *p);
string Parser_statement(Parser *p, bool add_semi);
void Parser_assign_statement(Parser *p, Var v, int ph, bool is_map);
void Parser_var_decl(Parser *p);
string Parser_bool_expression(Parser *p);
string Parser_bterm(Parser *p);
string Parser_name_expr(Parser *p);
string Parser_var_expr(Parser *p, Var v);
bool Parser_fileis(Parser *p, string s);
string Parser_dot(Parser *p, string str_typ, int method_ph);
string Parser_index_expr(Parser *p, string typ, int fn_ph);
string Parser_expression(Parser *p);
string Parser_term(Parser *p);
string Parser_unary(Parser *p);
string Parser_factor(Parser *p);
string Parser_assoc(Parser *p);
void Parser_char_expr(Parser *p);
string format_str(string str);
string Parser_typ_to_fmt(Parser *p, string typ);
void Parser_string_expr(Parser *p);
string Parser_map_init(Parser *p);
string Parser_array_init(Parser *p);
void Parser_register_array(Parser *p, string typ);
string Parser_struct_init(Parser *p, bool is_c_struct_init);
string Parser_cast(Parser *p, string typ);
string Parser_get_tmp(Parser *p);
int Parser_get_tmp_counter(Parser *p);
string os_name_to_ifdef(string name);
void Parser_comp_time(Parser *p);
void Parser_chash(Parser *p);
string Parser_if_st(Parser *p, bool is_expr);
void Parser_for_st(Parser *p);
void Parser_switch_statement(Parser *p);
void Parser_assert_statement(Parser *p);
void Parser_return_st(Parser *p);
string prepend_pkg(string pkg, string name);
string Parser_prepend_pkg(Parser *p, string name);
void Parser_go_statement(Parser *p);
void Parser_register_var(Parser *p, Var v);
string Parser_js_decode(Parser *p);
bool is_compile_time_const(string s);
bool Parser_building_v(Parser *p);
void Scanner_fgen(Scanner *scanner, string s);
void Scanner_fgenln(Scanner *scanner, string s);
void Parser_fgen(Parser *p, string s);
void Parser_fspace(Parser *p);
void Parser_fgenln(Parser *p, string s);
Scanner *new_scanner(string file_path);
ScanRes scan_res(Token tok, string lit);
bool is_white(byte c);
bool is_nl(byte c);
string Scanner_ident_name(Scanner *s);
string Scanner_ident_number(Scanner *s);
void Scanner_skip_whitespace(Scanner *s);
string Scanner_get_var_name(Scanner *s, int pos);
void Scanner_cao_change(Scanner *s, string operator);
ScanRes Scanner_scan(Scanner *s);
void Scanner_error(Scanner *s, string msg);
string Scanner_ident_string(Scanner *s);
string Scanner_ident_char(Scanner *s);
Token Parser_peek(Parser *p);
Token Scanner_peek(Scanner *s);
void Scanner_debug_tokens(Scanner *s);
bool is_name_char(byte c);
int Scanner_get_opening_bracket(Scanner *s);
void Scanner_create_type_string(Scanner *s, Type T, string name);
void Parser_create_type_string(Parser *p, Type T, string name);
bool is_mutable_type(string typ);
string Type_str(Type t);
string Fn_str(Fn f);
bool is_number_type(string typ);
bool is_float_type(string typ);
Table *new_table(bool obfuscate);
string Table_var_cgen_name(Table *t, string name);
void Table_register_package(Table *t, string pkg);
bool Table_known_pkg(Table *table, string pkg);
void Table_register_const(Table *t, string name, string typ, string pkg,
                          bool is_imported);
void Parser_register_global(Parser *p, string name, string typ);
void Table_register_fn(Table *t, Fn f);
bool Table_known_type(Table *table, string typ);
Fn Table_find_fn(Table *t, string name);
bool Table_known_fn(Table *t, string name);
bool Table_known_const(Table *t, string name);
void Table_register_type(Table *t, string typ);
void Parser_register_type_with_parent(Parser *p, string strtyp, string parent);
void Table_register_type_with_parent(Table *t, string typ, string parent);
void Table_register_type2(Table *t, Type typ);
void Type_add_field(Type *t, string name, string typ, bool is_mut, string attr,
                    AccessMod access_mod);
bool Type_has_field(Type *t, string name);
Var Type_find_field(Type *t, string name);
bool Table_type_has_field(Table *table, Type *typ, string name);
Var Table_find_field(Table *table, Type *typ, string name);
void Type_add_method(Type *t, Fn f);
bool Type_has_method(Type *t, string name);
bool Table_type_has_method(Table *table, Type *typ, string name);
Fn Table_find_method(Table *table, Type *typ, string name);
Fn Type_find_method(Type *t, string name);
void Type_add_gen_type(Type *t, string type_name);
Type *Parser_find_type(Parser *p, string name);
Type *Table_find_type(Table *t, string name);
bool Parser__check_types(Parser *p, string got, string expected, bool throw);
bool Parser_check_types(Parser *p, string got, string expected);
bool Parser_check_types_no_throw(Parser *p, string got, string expected);
bool Parser_satisfies_interface(Parser *p, string interface_name, string _typ,
                                bool throw);
string type_default(string typ);
bool Table_is_interface(Table *t, string name);
bool Table_main_exists(Table *t);
Var Table_find_const(Table *t, string name);
string Table_cgen_name(Table *table, Fn *f);
string Table_cgen_name_type_pair(Table *table, string name, string typ);
map_int build_keys();
array_string build_token_str();
Token key_to_token(string key);
bool is_key(string key);
string Token_str(Token t);
bool Token_is_decl(Token t);
bool Token_is_assign(Token t);
bool array_Token_contains(array_Token t, Token val);
array_int g_ustring_runes; // global
i64 total_m = 0;           // global
array_string os__args;
#define os__MAX_PATH 4096
string time__Months;
string time__Days;
#define main__MaxLocalVars 50
string main__Version;
#define DEFAULT_MODE 0

#define EMBED_VLIB 1

#define BUILD 2

array_string main__SupportedPlatforms;
string main__TmpPath;
#define MAC 0

#define LINUX 1

#define WINDOWS 2

#define RUN_IMPORTS 0

#define RUN_DECLS 1

#define RUN_MAIN 2

string main__HelpText;
Fn *main__EmptyFn;
Fn *main__MainFn;
#define main__SINGLE_QUOTE '\''
#define main__QUOTE '"'
#define PRIVATE 0

#define PRIVET_MUT 1

#define PUBLIC 2

#define PUBLIC_MUT 3

#define PUBLIC_MUT_MUT 4

#define TYPE_STRUCT 0

#define T_CAT_FN 1

array_string main__CReserved;
array_string main__NUMBER_TYPES;
array_string main__FLOAT_TYPES;
#define EOF 0

#define NAME 1

#define INT 2

#define STRING 3

#define CHAR 4

#define PLUS 5

#define MINUS 6

#define MUL 7

#define DIV 8

#define MOD 9

#define XOR 10

#define PIPE 11

#define INC 12

#define DEC 13

#define AND 14

#define OR 15

#define NOT 16

#define BIT_NOT 17

#define QUESTION 18

#define COMMA 19

#define SEMICOLON 20

#define COLON 21

#define AMP 22

#define HASH 23

#define DOLLAR 24

#define LEFT_SHIFT 25

#define RIGHT_SHIFT 26

#define ASSIGN 27

#define DECL_ASSIGN 28

#define PLUS_ASSIGN 29

#define MINUS_ASSIGN 30

#define DIV_ASSIGN 31

#define MULT_ASSIGN 32

#define XOR_ASSIGN 33

#define MOD_ASSIGN 34

#define OR_ASSIGN 35

#define AND_ASSIGN 36

#define RIGHT_SHIFT_ASSIGN 37

#define LEFT_SHIFT_ASSIGN 38

#define LCBR 39

#define RCBR 40

#define LPAR 41

#define RPAR 42

#define LSBR 43

#define RSBR 44

#define EQ 45

#define NE 46

#define GT 47

#define LT 48

#define GE 49

#define LE 50

#define LINE_COM 51

#define MLINE_COM 52

#define NL 53

#define DOT 54

#define DOTDOT 55

#define keyword_beg 56

#define PACKAGE 57

#define STRUCT 58

#define IF 59

#define ELSE 60

#define RETURN 61

#define GO 62

#define CONST 63

#define IMPORT_CONST 64

#define MUT 65

#define TIP 66

#define ENUM 67

#define FOR 68

#define SWITCH 69

#define MATCH 70

#define CASE 71

#define FUNC 72

#define TRUE 73

#define FALSE 74

#define CONTINUE 75

#define BREAK 76

#define EMBED 77

#define IMPORT 78

#define TYPEOF 79

#define DEFAULT 80

#define ENDIF 81

#define ASSERT 82

#define SIZEOF 83

#define IN 84

#define ATOMIC 85

#define INTERFACE 86

#define OR_ELSE 87

#define GLOBAL 88

#define UNION 89

#define PUB 90

#define GOTO 91

#define STATIC 92

#define keyword_end 93

array_string main__TOKENSTR;
map_int main__KEYWORDS;
array_Token main__AssignTokens;

array new_array(int mylen, int cap, int elm_size) {

  array arr = (array){.len = mylen,
                      .cap = cap,
                      .element_size = elm_size,
                      .data = v_malloc(cap * elm_size)};

  return arr;
}
array new_array_from_c_array(int len, int cap, int elm_size, void *c_array) {

  array arr = (array){.len = len,
                      .cap = cap,
                      .element_size = elm_size,
                      .data = v_malloc(cap * elm_size)};

  memcpy(arr.data, c_array, len * elm_size);

  return arr;
}
array new_array_from_c_array_no_alloc(int len, int cap, int elm_size,
                                      void *c_array) {

  array arr = (array){
      .len = len, .cap = cap, .element_size = elm_size, .data = c_array};

  return arr;
}
array array_repeat(void *val, int nr_repeats, int elm_size) {

  array arr = (array){.len = nr_repeats,
                      .cap = nr_repeats,
                      .element_size = elm_size,
                      .data = v_malloc(nr_repeats * elm_size)};

  for (int i = 0; i < nr_repeats; i++) {

    memcpy(arr.data + i * elm_size, val, elm_size);
  };

  return arr;
}
void array_append_array(array *a, array b) {

  for (int i = 0; i < b.len; i++) {

    void *val = (*(void **)array__get(b, i));

    array__push(a, val);
  };
}
void array_sort_with_compare(array *a, void *compare) {

  qsort(a->data, a->len, a->element_size, compare);
}
void array_insert(array *a, int i, void *val) {

  if (i >= a->len) {
    /*if*/

    v_panic(tos2("array.insert: index larger than length"));

    return;
  };

  array__push(a, val);

  int size = a->element_size;

  memmove(a->data + (/*lpar*/ i + 1) * size, a->data + i * size,
          (/*lpar*/ a->len - i) * size);

  array_set(a, i, val);
}
void array_prepend(array *a, void *val) { array_insert(a, 0, val); }
void array_delete(array *a, int idx) {

  int size = a->element_size;

  memmove(a->data + idx * size, a->data + (/*lpar*/ idx + 1) * size,
          (/*lpar*/ a->len - idx) * size);

  a->len--;

  a->cap--;
}
void *array__get(array a, int i) {

  if (i < 0 || i >= a.len) {
    /*if*/

    v_panic(_STR("array index out of range: %d/%d", i, a.len));
  };

  return a.data + i * a.element_size;
}
void *array_first(array a) {

  if (a.len == 0) {
    /*if*/

    v_panic(tos2("array.first: empty array"));
  };

  return a.data + 0;
}
void *array_last(array a) {

  if (a.len == 0) {
    /*if*/

    v_panic(tos2("array.last: empty array"));
  };

  return a.data + (/*lpar*/ a.len - 1) * a.element_size;
}
array array_left(array s, int n) {

  if (n >= s.len) {
    /*if*/

    return s;
  };

  return array_slice(s, 0, n);
}
array array_right(array s, int n) {

  if (n >= s.len) {
    /*if*/

    return s;
  };

  return array_slice(s, n, s.len);
}
array array_slice(array s, int start, int _end) {

  int end = _end;

  if (start > end) {
    /*if*/

    v_panic(_STR("invalid slice index: %d > %d", start, end));
  };

  if (end >= s.len) {
    /*if*/

    end = s.len;
  };

  int l = end - start;

  array res = (array){.element_size = s.element_size,
                      .data = s.data + start * s.element_size,
                      .len = l,
                      .cap = l};

  return res;
}
void array_set(array *a, int idx, void *val) {

  if (idx < 0 || idx >= a->len) {
    /*if*/

    v_panic(_STR("array index out of range: %d / %d", idx, a->len));
  };

  memcpy(a->data + a->element_size * idx, val, a->element_size);
}
void array__push(array *arr, void *val) {

  if (arr->len >= arr->cap - 1) {
    /*if*/

    int cap = (/*lpar*/ arr->len + 1) * 2;

    if (arr->cap == 0) {
      /*if*/

      arr->data = v_malloc(cap * arr->element_size);

    } else {
      /*else if*/

      arr->data = realloc(arr->data, cap * arr->element_size);
    };

    arr->cap = cap;
  };

  memcpy(arr->data + arr->element_size * arr->len, val, arr->element_size);

  arr->len++;
}
void array__push_many(array *arr, void *val, int size) {

  if (arr->len >= arr->cap - size) {
    /*if*/

    int cap = (/*lpar*/ arr->len + size) * 2;

    if (arr->cap == 0) {
      /*if*/

      arr->data = v_malloc(cap * arr->element_size);

    } else {
      /*else if*/

      arr->data = realloc(arr->data, cap * arr->element_size);
    };

    arr->cap = cap;
  };

  memcpy(arr->data + arr->element_size * arr->len, val,
         arr->element_size * size);

  arr->len = arr->len + size;
}
string array_int_str(array_int a) {

  string res = tos2("[");

  for (int i = 0; i < a.len; i++) {

    int val = (*(int *)array__get(a, i));

    res = string_add(res, _STR("%d", val));

    if (i < a.len - 1) {
      /*if*/

      res = string_add(res, tos2(", "));
    };
  };

  res = string_add(res, tos2("]"));

  return res;
}
void v_array_int_free(array_int a) { free(a.data); }
string array_string_str(array_string a) {

  string res = tos2("[");

  for (int i = 0; i < a.len; i++) {

    string val = (*(string *)array__get(a, i));

    res = string_add(res, _STR("\"%.*s\"", val.len, val.str));

    if (i < a.len - 1) {
      /*if*/

      res = string_add(res, tos2(", "));
    };
  };

  res = string_add(res, tos2("]"));

  return res;
}
void v_free(void *a) { free(a); }
void todo() {}
string tos(byte *s, int len) {

  if (isnil(s)) {
    /*if*/

    v_panic(tos2("tos(): nil string"));
  };

  return (string){.str = s, .len = len};
}
string tos_clone(byte *s) {

  if (isnil(s)) {
    /*if*/

    v_panic(tos2("tos: nil string"));

    return (string){.str = 0, .len = 0};
  };

  int len = strlen(s);

  string res = tos(s, len);

  return string_clone(res);
}
string tos2(byte *s) {

  if (isnil(s)) {
    /*if*/

    v_panic(tos2("tos2: nil string"));

    return (string){.str = 0, .len = 0};
  };

  int len = strlen(s);

  string res = tos(s, len);

  return res;
}
string string_clone(string a) {

  string b = (string){.len = a.len, .str = v_malloc(a.len + 1)};

  for (int i = 0; i < a.len; i++) {

    b.str[i] /*rbyte 1*/ = a.str[i] /*rbyte 0*/;
  };

  b.str[a.len] /*rbyte 1*/ = '\0';

  return b;
}
byte *string_cstr(string s) {

  string clone = string_clone(s);

  return clone.str;
}
string string_replace(string s, string rep, string with) {

  if (s.len == 0 || rep.len == 0) {
    /*if*/

    return s;
  };

  if (!string_contains(s, rep)) {
    /*if*/

    return s;
  };

  array_int idxs = new_array_from_c_array(0, 0, sizeof(int), (int[]){});

  {}

  for (int i = 0; i < s.len; i++) {

    int rep_i = 0;

    int j = i;

    while (rep_i < rep.len && j < s.len &&
           s.str[j] /*rbyte 0*/ == rep.str[rep_i] /*rbyte 0*/) {

      rep_i++;

      j++;
    };

    if (rep_i == rep.len) {
      /*if*/

      _PUSH(&idxs, (i), tmp12, int);
    };
  };

  if (idxs.len == 0) {
    /*if*/

    return s;
  };

  int new_len = s.len + idxs.len * (/*lpar*/ with.len - rep.len);

  byte *b = v_malloc(new_len + 1);

  int idx_pos = 0;

  int cur_idx = (*(int *)array__get(idxs, idx_pos));

  int b_i = 0;

  for (int i = 0; i < s.len; i++) {

    if (i == cur_idx) {
      /*if*/

      for (int j = 0; j < with.len; j++) {

        b[/*ptr*/ b_i] /*rbyte 1*/ = with.str[j] /*rbyte 0*/;

        b_i++;
      };

      i = i + rep.len - 1;

      idx_pos++;

      if (idx_pos < idxs.len) {
        /*if*/

        cur_idx = (*(int *)array__get(idxs, idx_pos));
      };

    } else {
      /*else if*/

      b[/*ptr*/ b_i] /*rbyte 1*/ = s.str[i] /*rbyte 0*/;

      b_i++;
    };
  };

  b[/*ptr*/ new_len] /*rbyte 1*/ = '\0';

  return tos(b, new_len);
}
int string_int(string s) { return atoi(s.str); }
f32 string_f32(string s) { return atof(s.str); }
bool string_eq(string s, string a) {

  if (isnil(s.str)) {
    /*if*/

    v_panic(tos2("string.eq(): nil string"));
  };

  if (s.len != a.len) {
    /*if*/

    return 0;
  };

  for (int i = 0; i < s.len; i++) {

    if (s.str[i] /*rbyte 0*/ != a.str[i] /*rbyte 0*/) {
      /*if*/

      return 0;
    };
  };

  return 1;
}
bool string_ne(string s, string a) { return !string_eq(s, a); }
bool string_lt(string s, string a) {

  for (int i = 0; i < s.len; i++) {

    if (i >= a.len || s.str[i] /*rbyte 0*/ > a.str[i] /*rbyte 0*/) {
      /*if*/

      return 0;

    } else if (s.str[i] /*rbyte 0*/ < a.str[i] /*rbyte 0*/) {
      /*if*/

      return 1;
    };
  };

  if (s.len < a.len) {
    /*if*/

    return 1;
  };

  return 0;
}
bool string_le(string s, string a) {

  return string_lt(s, a) || string_eq(s, a);
}
bool string_gt(string s, string a) { return !string_le(s, a); }
bool string_ge(string s, string a) { return !string_lt(s, a); }
string string_add(string s, string a) {

  int new_len = a.len + s.len;

  string res = (string){.len = new_len, .str = v_malloc(new_len + 1)};

  for (int j = 0; j < s.len; j++) {

    res.str[j] /*rbyte 1*/ = s.str[j] /*rbyte 0*/;
  };

  for (int j = 0; j < a.len; j++) {

    res.str[s.len + j] /*rbyte 1*/ = a.str[j] /*rbyte 0*/;
  };

  res.str[new_len] /*rbyte 1*/ = '\0';

  return res;
}
array_string string_split(string s, string delim) {

  array_string res = new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  if (delim.len == 0) {
    /*if*/

    _PUSH(&res, (s), tmp31, string);

    return res;
  };

  if (delim.len == 1) {
    /*if*/

    return string_split_single(s, delim.str[0] /*rbyte 0*/);
  };

  int i = 0;

  int start = 0;

  while (i < s.len) {

    bool a = s.str[i] /*rbyte 0*/ == delim.str[0] /*rbyte 0*/;

    int j = 1;

    while (j < delim.len && a) {

      a = a && s.str[i + j] /*rbyte 0*/ == delim.str[j] /*rbyte 0*/;

      j++;
    };

    bool last = i == s.len - 1;

    if (a || last) {
      /*if*/

      if (last) {
        /*if*/

        i++;
      };

      string val = string_substr(s, start, i);

      if (val.len > 0) {
        /*if*/

        if (string_starts_with(val, delim)) {
          /*if*/

          val = string_right(val, delim.len);
        };

        _PUSH(&res, (string_trim_space(val)), tmp38, string);
      };

      start = i;
    };

    i++;
  };

  return res;
}
array_string string_split_single(string s, byte delim) {

  array_string res = new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  if (((int)(delim)) == 0) {
    /*if*/

    _PUSH(&res, (s), tmp40, string);

    return res;
  };

  int i = 0;

  int start = 0;

  while (i < s.len) {

    bool a = s.str[i] /*rbyte 0*/ == delim;

    bool b = i == s.len - 1;

    if (a || b) {
      /*if*/

      if (i == s.len - 1) {
        /*if*/

        i++;
      };

      string val = string_substr(s, start, i);

      if (val.len > 0) {
        /*if*/

        _PUSH(&res, (string_trim_space(val)), tmp46, string);
      };

      start = i + 1;
    };

    i++;
  };

  return res;
}
array_string string_split_into_lines(string s) {

  array_string res = new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  if (s.len == 0) {
    /*if*/

    return res;
  };

  int start = 0;

  for (int i = 0; i < s.len; i++) {

    bool last = i == s.len - 1;

    if (((int)(s.str[i] /*rbyte 0*/)) == 10 || last) {
      /*if*/

      if (last) {
        /*if*/

        i++;
      };

      string line = string_substr(s, start, i);

      _PUSH(&res, (line), tmp52, string);

      start = i + 1;
    };
  };

  return res;
}
string string_left(string s, int n) {

  if (n >= s.len) {
    /*if*/

    return s;
  };

  return string_substr(s, 0, n);
}
string string_right(string s, int n) {

  if (n >= s.len) {
    /*if*/

    return tos2("");
  };

  return string_substr(s, n, s.len);
}
string string_substr(string s, int start, int end) {

  if (start >= s.len) {
    /*if*/

    return tos2("");
  };

  int len = end - start;

  string res = (string){.str = s.str + start, .len = len};

  return res;
}
int string_index(string s, string p) {

  if (p.len > s.len) {
    /*if*/

    return -1;
  };

  array_int prefix = new_array_from_c_array(1, 1, sizeof(int), (int[]){0});

  int j = 0;

  for (int i = 1; i < p.len; i++) {

    while (p.str[j] /*rbyte 0*/ != p.str[i] /*rbyte 0*/ && j > 0) {

      j = (*(int *)array__get(prefix, j - 1));
    };

    if (p.str[j] /*rbyte 0*/ == p.str[i] /*rbyte 0*/) {
      /*if*/

      j++;
    };

    _PUSH(&prefix, (j), tmp60, int);
  };

  j = 0;

  for (int i = 0; i < s.len; i++) {

    while (p.str[j] /*rbyte 0*/ != s.str[i] /*rbyte 0*/ && j > 0) {

      j = (*(int *)array__get(prefix, j - 1));
    };

    if (p.str[j] /*rbyte 0*/ == s.str[i] /*rbyte 0*/) {
      /*if*/

      j++;
    };

    if (j == p.len) {
      /*if*/

      v_array_int_free(prefix);

      return i - p.len + 1;
    };
  };

  v_array_int_free(prefix);

  return -1;
}
int string_last_index(string s, string p) {

  if (p.len > s.len) {
    /*if*/

    return -1;
  };

  int i = s.len - p.len;

  while (i >= 0) {

    int j = 0;

    while (j < p.len && s.str[i + j] /*rbyte 0*/ == p.str[j] /*rbyte 0*/) {

      j++;
    };

    if (j == p.len) {
      /*if*/

      return i;
    };

    i--;
  };

  return -1;
}
int string_index_after(string s, string p, int start) {

  if (p.len > s.len) {
    /*if*/

    return -1;
  };

  int strt = start;

  if (start < 0) {
    /*if*/

    strt = 0;
  };

  if (start >= s.len) {
    /*if*/

    return -1;
  };

  int i = strt;

  while (i < s.len) {

    int j = 0;

    int ii = i;

    while (j < p.len && s.str[ii] /*rbyte 0*/ == p.str[j] /*rbyte 0*/) {

      j++;

      ii++;
    };

    if (j == p.len) {
      /*if*/

      return i;
    };

    i++;
  };

  return -1;
}
bool string_contains(string s, string p) {

  bool res = string_index(s, p) > 0 - 1;

  return res;
}
bool string_starts_with(string s, string p) {

  bool res = string_index(s, p) == 0;

  return res;
}
bool string_ends_with(string s, string p) {

  if (p.len > s.len) {
    /*if*/

    return 0;
  };

  bool res = string_last_index(s, p) == s.len - p.len;

  return res;
}
string string_to_lower(string s) {

  byte *b = v_malloc(s.len);

  for (int i = 0; i < s.len; i++) {

    b[/*ptr*/ i] /*rbyte 1*/ = tolower(s.str[/*ptr*/ i] /*rbyte 0*/);
  };

  return tos(b, s.len);
}
string string_to_upper(string s) {

  byte *b = v_malloc(s.len);

  for (int i = 0; i < s.len; i++) {

    b[/*ptr*/ i] /*rbyte 1*/ = toupper(s.str[/*ptr*/ i] /*rbyte 0*/);
  };

  return tos(b, s.len);
}
string string_find_between(string s, string start, string end) {

  int start_pos = string_index(s, start);

  if (start_pos == -1) {
    /*if*/

    return tos2("");
  };

  string val = string_right(s, start_pos + start.len);

  int end_pos = string_index(val, end);

  if (end_pos == -1) {
    /*if*/

    return val;
  };

  return string_left(val, end_pos);
}
bool array_string_contains(array_string ar, string val) {

  array_string tmp80 = ar;
  ;
  for (int tmp81 = 0; tmp81 < tmp80.len; tmp81++) {
    string s = ((string *)tmp80.data)[tmp81];

    if (string_eq(s, val)) {
      /*if*/

      return 1;
    };
  };

  return 0;
}
bool array_int_contains(array_int ar, int val) {

  array_int tmp82 = ar;
  ;
  for (int i = 0; i < tmp82.len; i++) {
    int s = ((int *)tmp82.data)[i];

    if (s == val) {
      /*if*/

      return 1;
    };
  };

  return 0;
}
bool is_space(byte c) { return isspace(c); }
bool byte_is_space(byte c) { return is_space(c); }
string string_trim_space(string s) {

  if (string_eq(s, tos2(""))) {
    /*if*/

    return tos2("");
  };

  int i = 0;

  while (i < s.len && is_space(s.str[i] /*rbyte 0*/)) {

    i++;
  };

  string res = string_right(s, i);

  int end = res.len - 1;

  while (end >= 0 && is_space(res.str[end] /*rbyte 1*/)) {

    end--;
  };

  res = string_left(res, end + 1);

  return res;
}
string string_trim(string s, byte c) {

  if (string_eq(s, tos2(""))) {
    /*if*/

    return tos2("");
  };

  int i = 0;

  while (i < s.len && c == s.str[i] /*rbyte 0*/) {

    i++;
  };

  string res = string_right(s, i);

  int end = res.len - 1;

  while (end >= 0 && c == res.str[end] /*rbyte 1*/) {

    end--;
  };

  res = string_left(res, end + 1);

  return res;
}
string string_trim_left(string s, string cutset) {

  int start = string_index(s, cutset);

  if (start != 0) {
    /*if*/

    return s;
  };

  while (start < s.len - 1 &&
         s.str[start] /*rbyte 0*/ == cutset.str[0] /*rbyte 0*/) {

    start++;
  };

  return string_right(s, start);
}
string string_trim_right(string s, string cutset) {

  int pos = string_last_index(s, cutset);

  if (pos == -1) {
    /*if*/

    return s;
  };

  return string_left(s, pos);
}
int compare_strings(string *a, string *b) {

  if (string_lt(*a, *b)) {
    /*if*/

    return -1;
  };

  if (string_gt(*a, *b)) {
    /*if*/

    return 1;
  };

  return 0;
}
int compare_strings_by_len(string *a, string *b) {

  if (a->len < b->len) {
    /*if*/

    return -1;
  };

  if (a->len > b->len) {
    /*if*/

    return 1;
  };

  return 0;
}
int compare_lower_strings(string *a, string *b) {

  string aa = string_to_lower(*a);

  string bb = string_to_lower(*b);

  return compare_strings(&/*11 EXP:"string*" GOT:"string" */ aa,
                         &/*11 EXP:"string*" GOT:"string" */ bb);
}
void array_string_sort(array_string *s) {

  array_sort_with_compare(s, compare_strings);
}
void array_string_sort_ignore_case(array_string *s) {

  array_sort_with_compare(s, compare_lower_strings);
}
void array_string_sort_by_len(array_string *s) {

  array_sort_with_compare(s, compare_strings_by_len);
}
ustring string_ustring(string s) {

  ustring res =
      (ustring){.s = s, .runes = new_array(0, s.len, sizeof(int)), .len = 0};

  for (int i = 0; i < s.len; i++) {

    int char_len = utf8_char_len(s.str[/*ptr*/ i] /*rbyte 0*/);

    _PUSH(&res.runes, (i), tmp96, int);

    i = i + char_len - 1;

    res.len++;
  };

  return res;
}
ustring string_ustring_tmp(string s) {

  ustring res = (ustring){.s = s, .runes = 0, .len = 0};

  res.runes = g_ustring_runes;

  res.runes.len = s.len;

  int j = 0;

  for (int i = 0; i < s.len; i++) {

    int char_len = utf8_char_len(s.str[/*ptr*/ i] /*rbyte 0*/);
    int tmp101 = i;

    array_set(&/*q*/ res.runes, j, &tmp101);

    j++;

    i = i + char_len - 1;

    res.len++;
  };

  return res;
}
string ustring_substr(ustring u, int start, int end) {

  start = (*(int *)array__get(u.runes, start));

  if (end >= u.runes.len) {
    /*if*/

    end = u.s.len;

  } else {
    /*else if*/

    end = (*(int *)array__get(u.runes, end));
  };

  return string_substr(u.s, start, end);
}
string ustring_left(ustring u, int pos) { return ustring_substr(u, 0, pos); }
string ustring_right(ustring u, int pos) {

  return ustring_substr(u, pos, u.len);
}
byte string_at(string s, int idx) {

  if (idx < 0 || idx >= s.len) {
    /*if*/

    v_panic(_STR("string index out of range: %d / %d", idx, s.len));
  };

  return s.str[/*ptr*/ idx] /*rbyte 0*/;
}
string ustring_at(ustring u, int idx) {

  return ustring_substr(u, idx, idx + 1);
}
void v_ustring_free(ustring u) { v_array_int_free(u.runes); }
int abs(int a) {

  if (a >= 0) {
    /*if*/

    return a;
  };

  return -a;
}
bool byte_is_digit(byte c) { return c >= '0' && c <= '9'; }
bool byte_is_letter(byte c) {

  return (/*lpar*/ c >= 'a' && c <= 'z') || (/*lpar*/ c >= 'A' && c <= 'Z');
}
void v_string_free(string s) { free(s.str); }
void v_array_string_free(array_string arr) {

  array_string tmp106 = arr;
  ;
  for (int tmp107 = 0; tmp107 < tmp106.len; tmp107++) {
    string s = ((string *)tmp106.data)[tmp107];

    v_string_free(s);
  };

  free(arr.data);
}
string string_all_before(string s, string dot) {

  int pos = string_index(s, dot);

  if (pos == -1) {
    /*if*/

    return s;
  };

  return string_left(s, pos);
}
string string_all_before_last(string s, string dot) {

  int pos = string_last_index(s, dot);

  if (pos == -1) {
    /*if*/

    return s;
  };

  return string_left(s, pos);
}
string string_all_after(string s, string dot) {

  int pos = string_last_index(s, dot);

  if (pos == -1) {
    /*if*/

    return s;
  };

  return string_right(s, pos + dot.len);
}
string array_string_join(array_string a, string del) {

  if (a.len == 0) {
    /*if*/

    return tos2("");
  };

  int len = 0;

  array_string tmp112 = a;
  ;
  for (int i = 0; i < tmp112.len; i++) {
    string val = ((string *)tmp112.data)[i];

    len = len + val.len + del.len;
  };

  len = len - del.len;

  string res = tos2("");

  res.len = len;

  res.str = v_malloc(res.len + 1);

  int idx = 0;

  array_string tmp115 = a;
  ;
  for (int i = 0; i < tmp115.len; i++) {
    string val = ((string *)tmp115.data)[i];

    for (int j = 0; j < val.len; j++) {

      byte c = val.str[j] /*rbyte 0*/;

      res.str[/*ptr*/ idx] /*rbyte 1*/ = val.str[/*ptr*/ j] /*rbyte 0*/;

      idx++;
    };

    if (i != a.len - 1) {
      /*if*/

      for (int k = 0; k < del.len; k++) {

        res.str[/*ptr*/ idx] /*rbyte 1*/ = del.str[/*ptr*/ k] /*rbyte 0*/;

        idx++;
      };
    };
  };

  res.str[/*ptr*/ res.len] /*rbyte 1*/ = '\0';

  return res;
}
string array_string_join_lines(array_string s) {

  return array_string_join(s, tos2("\n"));
}
string string_reverse(string s) {

  string res = (string){.len = s.len, .str = v_malloc(s.len + 1)};

  for (int i = s.len - 1; i >= 0; i--) {

    res.str[s.len - i - 1] /*rbyte 1*/ = s.str[i] /*rbyte 0*/;
  };

  return res;
}
string string_limit(string s, int max) {

  ustring u = string_ustring(s);

  if (u.len <= max) {
    /*if*/

    return s;
  };

  return ustring_substr(u, 0, max);
}
bool byte_is_white(byte c) {

  int i = ((int)(c));

  return i == 10 || i == 32 || i == 9 || i == 13 || c == '\r';
}
string repeat_char(byte c, int n) {

  if (n <= 0) {
    /*if*/

    return tos2("");
  };

  byte *arr = v_malloc(n + 1);

  for (int i = 0; i < n; i++) {

    arr[/*ptr*/ i] /*rbyte 1*/ = c;
  };

  arr[/*ptr*/ n] /*rbyte 1*/ = '\0';

  return tos(arr, n);
}
int string_hash(string s) {

  int hash = ((int)(0));

  for (int i = 0; i < s.len; i++) {

    hash = hash * ((int)(31)) + ((int)(s.str[/*ptr*/ i] /*rbyte 0*/));
  };

  return hash;
}
void v_exit(int code) { exit(code); }
bool isnil(void *v) { return v == 0; }
void on_panic(int (*f)(int /*FFF*/)) {}
void print_backtrace() {

  return;

#ifdef __APPLE__

  voidptr buffer[100] = {} /* arkek init*/;

  void *nr_ptrs = backtrace(buffer, 100);

  backtrace_symbols_fd(buffer, nr_ptrs, 1);

#endif
  ;
}
void v_panic(string s) {

  println(_STR("V panic: %.*s", s.len, s.str));

  print_backtrace();

  exit(1);
}
void println(string s) {

  if (isnil(s.str)) {
    /*if*/

    v_panic(tos2("println(NIL)"));
  };

  printf("%.*s\n", s.len, s.str);
}
void eprintln(string s) {

  if (isnil(s.str)) {
    /*if*/

    v_panic(tos2("eprintln(NIL)"));
  };

#ifdef __APPLE__

  fprintf(stderr, "%.*s\n", s.len, s.str);

  ;

#else

  println(s);

#endif
  ;
}
void v_print(string s) { printf("%.*s", s.len, s.str); }
byte *v_malloc(int n) {

  if (n < 0) {
    /*if*/

    v_panic(tos2("malloc(<0)"));
  };

  byte *ptr = malloc(n);

  if (isnil(ptr)) {
    /*if*/

    v_panic(_STR("malloc(%d) failed", n));
  };

  return ptr;
}
byte *v_calloc(int n) {

  if (n < 0) {
    /*if*/

    v_panic(tos2("calloc(<0)"));
  };

  return calloc(n, 1);
}
int _strlen(byte *s) { return strlen(s); }
Option opt_ok(void *data) {

  return (Option){
      .data = data,
      .ok = 1,
      .error = tos("", 0),
  };
}
void *memdup(void *src, int sz) {

  byte *mem = v_malloc(sz);

  return memcpy(mem, src, sz);
}
Option v_error(string s) { return (Option){.error = s, .data = 0, .ok = 0}; }
string double_str(double d) {

  byte *buf = v_malloc(sizeof(double) * 5 + 1);

  sprintf(buf, "%f", d);

  return tos(buf, _strlen(buf));
}
string f64_str(f64 d) {

  byte *buf = v_malloc(sizeof(double) * 5 + 1);

  sprintf(buf, "%f", d);

  return tos(buf, _strlen(buf));
}
string f32_str(f32 d) {

  byte *buf = v_malloc(sizeof(double) * 5 + 1);

  sprintf(buf, "%f", d);

  return tos(buf, _strlen(buf));
}
string ptr_str(void *ptr) {

  byte *buf = v_malloc(sizeof(double) * 5 + 1);

  sprintf(buf, "%p", ptr);

  return tos(buf, _strlen(buf));
}
string int_str(int nn) {

  int n = nn;

  if (n == 0) {
    /*if*/

    return tos2("0");
  };

  int max = 16;

  byte *buf = v_malloc(max);

  int len = 0;

  bool is_neg = 0;

  if (n < 0) {
    /*if*/

    n = -n;

    is_neg = 1;
  };

  while (n > 0) {

    int d = n % 10;

    buf[/*ptr*/ max - len - 1] /*rbyte 1*/ = d + ((int)('0'));

    len++;

    n = n / 10;
  };

  if (is_neg) {
    /*if*/

    buf[/*ptr*/ max - len - 1] /*rbyte 1*/ = '-';

    len++;
  };

  return tos(buf + max - len, len);
}
string u8_str(u8 nn) {

  u8 n = nn;

  if (n == ((u8)(0))) {
    /*if*/

    return tos2("0");
  };

  int max = 5;

  byte *buf = v_malloc(max);

  int len = 0;

  bool is_neg = 0;

  if (n < ((u8)(0))) {
    /*if*/

    n = -n;

    is_neg = 1;
  };

  while (n > ((u8)(0))) {

    u8 d = n % ((u8)(10));

    buf[/*ptr*/ max - len - 1] /*rbyte 1*/ = d + ((u8)('0'));

    len++;

    n = n / ((u8)(10));
  };

  if (is_neg) {
    /*if*/

    buf[/*ptr*/ max - len - 1] /*rbyte 1*/ = '-';

    len++;
  };

  return tos(buf + max - len, len);
}
string i64_str(i64 nn) {

  i64 n = nn;

  if (n == ((i64)(0))) {
    /*if*/

    return tos2("0");
  };

  int max = 32;

  byte *buf = v_malloc(max);

  int len = 0;

  bool is_neg = 0;

  if (n < ((i64)(0))) {
    /*if*/

    n = -n;

    is_neg = 1;
  };

  while (n > ((i64)(0))) {

    int d = ((int)(n % ((i64)(10))));

    buf[/*ptr*/ max - len - 1] /*rbyte 1*/ = d + ((int)('0'));

    len++;

    n = n / ((i64)(10));
  };

  if (is_neg) {
    /*if*/

    buf[/*ptr*/ max - len - 1] /*rbyte 1*/ = '-';

    len++;
  };

  return tos(buf + max - len, len);
}
string bool_str(bool b) {

  if (b) {
    /*if*/

    return tos2("true");
  };

  return tos2("false");
}
string int_hex(int n) {

  string s = int_str(n);

  byte *hex = v_malloc(s.len + 3);

  sprintf(hex, "0x%x", n);

  return tos(hex, s.len + 3);
}
string i64_hex(i64 n) {

  string s = i64_str(n);

  byte *hex = v_malloc(s.len + 3);

  sprintf(hex, "0x%x", n);

  return tos(hex, s.len + 3);
}
bool array_byte_contains(array_byte a, byte val) {

  array_byte tmp27 = a;
  ;
  for (int tmp28 = 0; tmp28 < tmp27.len; tmp28++) {
    byte aa = ((byte *)tmp27.data)[tmp28];

    if (aa == val) {
      /*if*/

      return 1;
    };
  };

  return 0;
}
string byte_str(byte c) {

  string str = (string){.len = 1, .str = v_malloc(2)};

  str.str[/*ptr*/ 0] /*rbyte 1*/ = c;

  str.str[/*ptr*/ 1] /*rbyte 1*/ = '\0';

  return str;
}
int utf8_char_len(byte b) {

  return (/*lpar*/ (/*lpar*/ 0xe5000000 >>
                    (/*lpar*/ (/*lpar*/ b >> 3) & 0x1e)) &
          3) +
         1;
}
string utf32_to_str(u32 code) {

  int icode = ((int)(code));

  byte *buffer = v_malloc(5);

  if (icode <= 127) {
    /*if*/

    buffer[/*ptr*/ 0] /*rbyte 1*/ = icode;

    return tos(buffer, 1);
  };

  if ((/*lpar*/ icode <= 2047)) {
    /*if*/

    buffer[/*ptr*/ 0] /*rbyte 1*/ = 192 | (/*lpar*/ icode >> 6);

    buffer[/*ptr*/ 1] /*rbyte 1*/ = 128 | (/*lpar*/ icode & 63);

    return tos(buffer, 2);
  };

  if ((/*lpar*/ icode <= 65535)) {
    /*if*/

    buffer[/*ptr*/ 0] /*rbyte 1*/ = 224 | (/*lpar*/ icode >> 12);

    buffer[/*ptr*/ 1] /*rbyte 1*/ = 128 | (/*lpar*/ (/*lpar*/ icode >> 6) & 63);

    buffer[/*ptr*/ 2] /*rbyte 1*/ = 128 | (/*lpar*/ icode & 63);

    return tos(buffer, 3);
  };

  if ((/*lpar*/ icode <= 1114111)) {
    /*if*/

    buffer[/*ptr*/ 0] /*rbyte 1*/ = 240 | (/*lpar*/ icode >> 18);

    buffer[/*ptr*/ 1] /*rbyte 1*/ =
        128 | (/*lpar*/ (/*lpar*/ icode >> 12) & 63);

    buffer[/*ptr*/ 2] /*rbyte 1*/ = 128 | (/*lpar*/ (/*lpar*/ icode >> 6) & 63);

    buffer[/*ptr*/ 3] /*rbyte 1*/ = 128 | (/*lpar*/ icode & 63);

    return tos(buffer, 4);
  };

  return tos2("");
}
string utf32_to_str_no_malloc(u32 code, void *buf) {

  int icode = ((int)(code));

  byteptr buffer = ((byteptr)(buf));

  if (icode <= 127) {
    /*if*/

    buffer[/*ptr*/ 0] /*rbyteptr 1*/ = icode;

    return tos(&/*11 EXP:"byte*" GOT:"byteptr" */ buffer, 1);
  };

  if ((/*lpar*/ icode <= 2047)) {
    /*if*/

    buffer[/*ptr*/ 0] /*rbyteptr 1*/ = 192 | (/*lpar*/ icode >> 6);

    buffer[/*ptr*/ 1] /*rbyteptr 1*/ = 128 | (/*lpar*/ icode & 63);

    return tos(&/*11 EXP:"byte*" GOT:"byteptr" */ buffer, 2);
  };

  if ((/*lpar*/ icode <= 65535)) {
    /*if*/

    buffer[/*ptr*/ 0] /*rbyteptr 1*/ = 224 | (/*lpar*/ icode >> 12);

    buffer[/*ptr*/ 1] /*rbyteptr 1*/ =
        128 | (/*lpar*/ (/*lpar*/ icode >> 6) & 63);

    buffer[/*ptr*/ 2] /*rbyteptr 1*/ = 128 | (/*lpar*/ icode & 63);

    return tos(&/*11 EXP:"byte*" GOT:"byteptr" */ buffer, 3);
  };

  if ((/*lpar*/ icode <= 1114111)) {
    /*if*/

    buffer[/*ptr*/ 0] /*rbyteptr 1*/ = 240 | (/*lpar*/ icode >> 18);

    buffer[/*ptr*/ 1] /*rbyteptr 1*/ =
        128 | (/*lpar*/ (/*lpar*/ icode >> 12) & 63);

    buffer[/*ptr*/ 2] /*rbyteptr 1*/ =
        128 | (/*lpar*/ (/*lpar*/ icode >> 6) & 63);

    buffer[/*ptr*/ 3] /*rbyteptr 1*/ = 128 | (/*lpar*/ icode & 63);

    return tos(&/*11 EXP:"byte*" GOT:"byteptr" */ buffer, 4);
  };

  return tos2("");
}
int string_utf32_code(string _rune) {

  if (_rune.len == 0) {
    /*if*/

    return 0;
  };

  if (_rune.len == 1) {
    /*if*/

    return ((int)(_rune.str[0] /*rbyte 0*/));
  };

  byte b = ((byte)(((int)(_rune.str[0] /*rbyte 0*/))));

  b = b << _rune.len;

  int res = ((int)(b));

  int shift = 6 - _rune.len;

  for (int i = 1; i < _rune.len; i++) {

    int c = ((int)(_rune.str[i] /*rbyte 0*/));

    res = res << shift;

    res = res | c & 63;

    shift = 6;
  };

  return res;
}
map new_map(int cap, int elm_size) {

  map res = (map){.element_size = elm_size,
                  .entries = new_array(0, 1, sizeof(Entry)),
                  .is_sorted = 0};

  return res;
}
Entry map_new_entry(map *m, string key, void *val) {

  Entry new_e = (Entry){.key = key, .val = v_malloc(m->element_size)};

  memcpy(new_e.val, val, m->element_size);

  return new_e;
}
void map__set(map *m, string key, void *val) {

  Entry e = map_new_entry(&/* ? */ *m, key, val);

  for (int i = 0; i < m->entries.len; i++) {

    Entry entry = (*(Entry *)array__get(m->entries, i));

    if (string_eq(entry.key, key)) {
      /*if*/
      Entry tmp8 = e;

      array_set(&/*q*/ m->entries, i, &tmp8);

      return;
    };
  };

  _PUSH(&m->entries, (e), tmp9, Entry);

  m->is_sorted = 0;
}
int volt_abs(int n) {

  if (n < 0) {
    /*if*/

    return -n;
  };

  return n;
}
void map_bs(map m, string query, int start, int end, void *out) {

  int mid = start + (/*lpar*/ (/*lpar*/ end - start) / 2);

  if (end - start == 0) {
    /*if*/

    Entry last = (*(Entry *)array__get(m.entries, end));

    memcpy(out, last.val, m.element_size);

    return;
  };

  if (end - start == 1) {
    /*if*/

    Entry first = (*(Entry *)array__get(m.entries, start));

    memcpy(out, first.val, m.element_size);

    return;
  };

  if (mid >= m.entries.len) {
    /*if*/

    return;
  };

  Entry mid_msg = (*(Entry *)array__get(m.entries, mid));

  if (string_lt(query, mid_msg.key)) {
    /*if*/

    map_bs(m, query, start, mid, out);

    return;
  };

  map_bs(m, query, mid, end, out);
}
int compare_map(Entry *a, Entry *b) {

  if (string_lt(a->key, b->key)) {
    /*if*/

    return -1;
  };

  if (string_gt(a->key, b->key)) {
    /*if*/

    return 1;
  };

  return 0;
}
void map_sort(map *m) {

  array_sort_with_compare(&/* ? */ m->entries, compare_map);

  m->is_sorted = 1;
}
array_string map_keys(map m) {

  array_string keys =
      new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  {}

  for (int i = 0; i < m.entries.len; i++) {

    Entry entry = (*(Entry *)array__get(m.entries, i));

    _PUSH(&keys, (entry.key), tmp25, string);
  };

  return keys;
}
bool map_get(map m, string key, void *out) {

  if (m.is_sorted) {
    /*if*/

    map_bs(m, key, 0, m.entries.len, out);

    return 1;
  };

  for (int i = 0; i < m.entries.len; i++) {

    Entry entry = (*(Entry *)array__get(m.entries, i));

    if (string_eq(entry.key, key)) {
      /*if*/

      memcpy(out, entry.val, m.element_size);

      return 1;
    };
  };

  return 0;
}
bool map_exists(map m, string key) {

  for (int i = 0; i < m.entries.len; i++) {

    Entry entry = (*(Entry *)array__get(m.entries, i));

    if (string_eq(entry.key, key)) {
      /*if*/

      return 1;
    };
  };

  return 0;
}
void v_map_print(map m) {

  println(tos2("<<<<<<<<"));

  for (int i = 0; i < m.entries.len; i++) {
  };

  println(tos2(">>>>>>>>>>"));
}
void v_map_free(map m) {}
string map_string_str(map_string m) {

  if (m.entries.len == 0) {
    /*if*/

    return tos2("{}");
  };

  string s = tos2("{\n");

  array_Entry tmp36 = m.entries;
  ;
  for (int tmp37 = 0; tmp37 < tmp36.len; tmp37++) {
    Entry entry = ((Entry *)tmp36.data)[tmp37];
    string tmp38 = tos("", 0);
    bool tmp39 = map_get(m, entry.key, &tmp38);
    if (!tmp39)
      tmp38 = tos("", 0);

    string val = tmp38;

    s = string_add(s, _STR("  \"%.*s\" => \"%.*s\"\n", entry.key.len,
                           entry.key.str, val.len, val.str));
  };

  s = string_add(s, tos2("}"));

  return s;
}
StringBuilder new_string_builder(int initial_size) {

  return (StringBuilder){.buf = new_array(0, initial_size, sizeof(byte)),
                         .len = 0};
}
void StringBuilder_write(StringBuilder *b, string s) {

  array__push_many(&/* ? */ b->buf, s.str, s.len);

  b->len = b->len + s.len;
}
void StringBuilder_writeln(StringBuilder *b, string s) {

  array__push_many(&/* ? */ b->buf, s.str, s.len);

  _PUSH(&b->buf, ('\n'), tmp1, byte);

  b->len = b->len + s.len + 1;
}
string StringBuilder_str(StringBuilder b) { return tos(b.buf.data, b.len); }
void StringBuilder_cut(StringBuilder b, int n) { b.len = b.len - n; }
void v_StringBuilder_free(StringBuilder *b) { free(b->buf.data); }
void os__todo_remove() {}
array_string os__init_os_args(int argc, byteptr *argv) {

  array_string args =
      new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  for (int i = 0; i < argc; i++) {

    _PUSH(&args, ((tos2(argv[/*ptr*/ i] /*rbyteptr 0*/))), tmp3, string);
  };

  return args;
}
array_string os__parse_windows_cmd_line(byte *cmd) {

  string s = (tos2(cmd));

  return string_split(s, tos2(" "));
}
Option_string os__read_file(string path) {

  string res = tos2("");

  byte *cpath = string_cstr(path);

  void *fp = fopen(cpath, "r");

  if (isnil(fp)) {
    /*if*/

    return v_error(_STR("failed to open file \"%.*s\"", path.len, path.str));
  };

  fseek(fp, 0, SEEK_END);

  int fsize = ftell(fp);

  rewind(fp);

  byte *str = v_malloc(fsize + 1);

  fread(str, fsize, 1, fp);

  fclose(fp);

  str[/*ptr*/ fsize] /*rbyte 1*/ = 0;

  res = tos(str, fsize);

  return opt_ok(&res);
}
int os__file_size(string path) {
  struct /*c struct init*/

      stat s = (struct stat){.st_size = 0, .st_mode = 0};

  stat(path.str, &/*vvar*/ s);

  return s.st_size;
}
void os__mv(string old, string new) {

  rename(string_cstr(old), string_cstr(new));
}
array_string os__read_lines(string path) {

  array_string res = new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  byte buf[1000] = {} /* arkek init*/;

  byte *cpath = string_cstr(path);

  void *fp = fopen(cpath, "rb");

  if (isnil(fp)) {
    /*if*/

    return res;
  };

  while (fgets(buf, 1000, fp) != 0) {

    string val = tos2("");

    buf[strlen(buf) - 1] /*rbyte 1*/ = '\0';

#ifdef _WIN32

    if (buf[strlen(buf) - 2] /*rbyte 1*/ == 13) {
      /*if*/

      buf[strlen(buf) - 2] /*rbyte 1*/ = '\0';
    };

#endif
    ;

    _PUSH(&res, (tos_clone(buf)), tmp16, string);
  };

  fclose(fp);

  return res;
}
array_ustring os__read_ulines(string path) {

  array_string lines = os__read_lines(path);

  array_ustring ulines =
      new_array_from_c_array(0, 0, sizeof(ustring), (ustring[]){});

  array_string tmp19 = lines;
  ;
  for (int tmp20 = 0; tmp20 < tmp19.len; tmp20++) {
    string myline = ((string *)tmp19.data)[tmp20];

    _PUSH(&ulines, (string_ustring(myline)), tmp21, ustring);
  };

  return ulines;
}
os__File os__open(string path) { return os__open_file(path); }
os__File os__open_file(string file) {

  return os__create_file2(file, tos2("r"));
}
os__File os__create(string path) { return os__create_file(path); }
os__File os__open_append(string path) { return os__create_file(path); }
os__File os__create_file(string file) {

  return os__create_file2(file, tos2("w"));
}
os__File os__create_file_a(string file) {

  return os__create_file2(file, tos2("a"));
}
os__File os__open_file_a(string file) {

  return os__create_file2(file, tos2("a"));
}
os__File os__create_file2(string file, string mode) {

  os__File res =
      (os__File){.cfile = fopen(string_cstr(file), string_cstr(mode))};

  if (isnil(res.cfile)) {
    /*if*/

    println(_STR("coudlnt create file \"%.*s\"", file.len, file.str));
  };

  return res;
}
void os__File_append(os__File f, string s) {

  string ss = string_clone(s);

  fputs(string_cstr(ss), f.cfile);
}
void os__File_write_bytes(os__File f, void *data, int size) {

  fwrite(data, 1, size, f.cfile);
}
void os__File_write_bytes_at(os__File f, void *data, int size, int pos) {

  fseek(f.cfile, pos, SEEK_SET);

  fwrite(data, 1, size, f.cfile);

  fseek(f.cfile, 0, SEEK_END);
}
void os__File_appendln(os__File f, string s) {

  fputs(string_cstr(s), f.cfile);

  fputs("\n", f.cfile);
}
void os__File_close(os__File f) { fclose(f.cfile); }
void os__close_file(os__FILE *fp) {

#ifdef _WIN32

#endif
  ;

  if (isnil(fp)) {
    /*if*/

    return;
  };

  fclose(fp);
}
int os__system(string cmd) {

  void *ret = system(string_cstr(cmd));

  if (ret == -1) {
    /*if*/

    os__print_c_errno();
  };

  return ret;
}
os__FILE *os__popen(string path) {

  byte *cpath = string_cstr(path);

#ifdef _WIN32

  return _popen(cpath, "r");

  ;

#else

  return popen(cpath, "r");

#endif
  ;
}
string os__exec(string cmd) {

  cmd = _STR("%.*s 2>&1", cmd.len, cmd.str);

  os__FILE *f = os__popen(cmd);

  if (isnil(f)) {
    /*if*/

    println(_STR("popen %.*s failed", cmd.len, cmd.str));

    return tos2("");
  };

  byte buf[1000] = {} /* arkek init*/;

  string res = tos2("");

  while (fgets(buf, 1000, f) != 0) {

    res = string_add(res, tos(buf, strlen(buf)));
  };

  return string_trim_space(res);
}
string os__getenv(string key) {

  byte *s = getenv(string_cstr(key));

  if (isnil(s)) {
    /*if*/

    return tos2("");
  };

  return (tos2(s));
}
int os__setenv(string name, string value, bool overwrite) {

#ifdef _WIN32

  ;

#else

  return setenv(string_cstr(name), string_cstr(value), overwrite);

#endif
  ;
}
int os__unsetenv(string name) {

#ifdef _WIN32

  ;

#else

  return unsetenv(string_cstr(name));

#endif
  ;
}
bool os__file_exists(string path) {

#ifdef _WIN32

  return _access(path.str, 0) != -1;

#endif
  ;

  return access(path.str, 0) != -1;
}
bool os__dir_exists(string path) {

  void *dir = opendir(string_cstr(path));

  bool res = !isnil(dir);

  if (res) {
    /*if*/

    closedir(dir);
  };

  return res;
}
void os__mkdir(string path) {

#ifdef _WIN32

  path = string_replace(path, tos2("/"), tos2("\\"));

  CreateDirectory(string_cstr(path), 0);

  ;

#else

  mkdir(string_cstr(path), 511);

#endif
  ;
}
void os__rm(string path) {

#ifdef _WIN32

  ;

#else

  remove(string_cstr(path));

#endif
  ;
}
void os__print_c_errno() {}
string os__ext(string path) {

  int pos = string_last_index(path, tos2("."));

  if (pos == -1) {
    /*if*/

    return tos2("");
  };

  return string_right(path, pos);
}
string os__path_sans_ext(string path) {

  int pos = string_last_index(path, tos2("."));

  if (pos == -1) {
    /*if*/

    return path;
  };

  return string_left(path, pos);
}
string os__basedir(string path) {

  int pos = string_last_index(path, tos2("/"));

  if (pos == -1) {
    /*if*/

    return path;
  };

  return string_left(path, pos + 1);
}
string os__filename(string path) { return string_all_after(path, tos2("/")); }
string os__get_line() {

#ifdef _WIN32

  v_panic(tos2("get_line() not implemented on Windows yet, sorry!"));

  ;

#else

  u64 max = ((u64)(256));

  byte *buf = v_malloc(((int)(max)));

  int nr_chars = getline(&/*vvar*/ buf, &/*vvar*/ max, stdin);

  if (nr_chars == 0) {
    /*if*/

    return tos2("");
  };

  if (buf[/*ptr*/ nr_chars - 1] /*rbyte 0*/ == '\n') {
    /*if*/

    return tos(buf, nr_chars - 1);
  };

  return tos(buf, nr_chars);

#endif
  ;
}
string os__get_raw_line() {

#ifdef _WIN32

  v_panic(tos2("get_raw_line() not implemented on Windows yet, sorry!"));

  ;

#else

  u64 max = ((u64)(256));

  byte *buf = v_malloc(((int)(max)));

  int nr_chars = getline(&/*vvar*/ buf, &/*vvar*/ max, stdin);

  if (nr_chars == 0) {
    /*if*/

    return tos2("");
  };

  return tos(buf, nr_chars);

#endif
  ;
}
string os__user_os() {

#ifdef __linux__

  return tos2("linux");

#endif
  ;

#ifdef __APPLE__

  return tos2("mac");

#endif
  ;

#ifdef _WIN32

  return tos2("windows");

#endif
  ;

  return tos2("unknown");
}
string os__home_dir() {

  string home = os__getenv(tos2("HOME"));

#ifdef _WIN32

  home = os__getenv(tos2("HOMEDRIVE"));

  home = string_add(home, os__getenv(tos2("HOMEPATH")));

#endif
  ;

  home = string_add(home, tos2("/"));

  return home;
}
void os__write_file(string path, string text) {

  os__File f = os__create(path);

  os__File_appendln(f, text);

  os__File_close(f);
}
void os__clear() {

  ;

  ;
}
void os__on_segfault(void *f) {

#ifdef _WIN32

  return;

#endif
  ;

#ifdef __APPLE__
  struct /*c struct init*/

      sigaction sa =
          (struct sigaction){.sa_mask = 0, .sa_sigaction = 0, .sa_flags = 0};

  memset(&/*vvar*/ sa, 0, sizeof(sigaction));

  sigemptyset(&/*vvar*/ sa.sa_mask);

  sa.sa_sigaction = f;

  sa.sa_flags = SA_SIGINFO;

  sigaction(SIGSEGV, &/*vvar*/ sa, 0);

#endif
  ;
}
string os__getexepath() {

  byte result[4096] = {} /* arkek init*/;

#ifdef __linux__

  int count = ((int)(readlink("/proc/self/exe", result, os__MAX_PATH)));

  if ((/*lpar*/ count < 0)) {
    /*if*/

    v_panic(tos2("error reading /proc/self/exe to get exe path"));
  };

  return tos(result, count);

#endif
  ;

#ifdef _WIN32

  return tos(result, GetModuleFileName(0, result, os__MAX_PATH));

#endif
  ;

#ifdef __APPLE__

  return tos2("");

#endif
  ;
}
void os__log(string s) {}
bool os__is_dir(string path) {
  struct /*c struct init*/

      stat statbuf = (struct stat){.st_size = 0, .st_mode = 0};

  byte *cstr = string_cstr(path);

  if (stat(cstr, &/*vvar*/ statbuf) != 0) {
    /*if*/

    return 0;
  };

  return statbuf.st_mode & S_IFMT == S_IFDIR;
}
void os__chdir(string path) { chdir(string_cstr(path)); }
string os__getwd() {

  byte *cwd = v_malloc(512);

  if (getcwd(cwd, 512) == 0) {
    /*if*/

    return tos2("");
  };

  return (tos2(cwd));
}
array_string os__ls(string path) {

  array_string res = new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  void *dir = opendir(path.str);

  if (isnil(dir)) {
    /*if*/

    println(_STR("ls() couldnt open dir \"%.*s\"", path.len, path.str));

    os__print_c_errno();

    return res;
  };
  struct /*c struct init*/

      dirent *ent = 0;

  while (1) {
    ent = readdir(dir);

    if (isnil(ent)) {
      /*if*/

      break;
    };

    string name = tos_clone(ent->d_name);

    if (string_ne(name, tos2(".")) && string_ne(name, tos2("..")) &&
        string_ne(name, tos2(""))) {
      /*if*/

      _PUSH(&res, (name), tmp8, string);
    };
  };

  closedir(dir);

  return res;
}
void os__print_backtrace() {}
void time__remove_me_when_c_bug_is_fixed() {}
time__Time time__now() {

  void *t = time(0);
  struct /*c struct init*/

      tm *now = 0;

  now = localtime(&/*vvar*/ t);

  return time__convert_ctime(*now);
}
time__Time time__random() {

  return (struct time__Time){.year = rand__next(2) + 201,
                             .month = rand__next(12) + 1,
                             .day = rand__next(30) + 1,
                             .hour = rand__next(24),
                             .minute = rand__next(60),
                             .second = rand__next(60),
                             .uni = 0};
}
time__Time time__unix(int u) {
  struct /*c struct init*/

      tm *t = 0;

  t = localtime(&/*vvar*/ u);

  return time__convert_ctime(*t);
}
time__Time time__convert_ctime(struct /*TM*/ tm t) {

  return (struct time__Time){.year = t.tm_year + 1900,
                             .month = t.tm_mon + 1,
                             .day = t.tm_mday,
                             .hour = t.tm_hour,
                             .minute = t.tm_min,
                             .second = t.tm_sec,
                             .uni = 0};
}
string time__Time_format_ss(time__Time t) {

  return _STR("%d-%02d-%02d %02d:%02d:%02d", t.year, t.month, t.day, t.hour,
              t.minute, t.second);
}
string time__Time_format(time__Time t) {

  return _STR("%d-%02d-%02d %02d:%02d", t.year, t.month, t.day, t.hour,
              t.minute);
}
string time__Time_smonth(time__Time t) {

  int i = t.month - 1;

  return string_substr(time__Months, i * 3, (/*lpar*/ i + 1) * 3);
}
string time__Time_hhmm(time__Time t) {

  return _STR("%02d:%02d", t.hour, t.minute);
}
string time__Time_hhmm12(time__Time t) {

  string am = tos2("am");

  int hour = t.hour;

  if (t.hour > 11) {
    /*if*/

    am = tos2("pm");
  };

  if (t.hour > 12) {
    /*if*/

    hour = hour - 12;
  };

  if (t.hour == 0) {
    /*if*/

    hour = 12;
  };

  return _STR("%d:%02d %.*s", hour, t.minute, am.len, am.str);
}
string time__Time_hhmmss(time__Time t) {

  return _STR("%02d:%02d:%02d", t.hour, t.minute, t.second);
}
string time__Time_ymmdd(time__Time t) {

  return _STR("%d-%02d-%02d", t.year, t.month, t.day);
}
string time__Time_md(time__Time t) {

  string s = _STR("%.*s %d", time__Time_smonth(t).len, time__Time_smonth(t).str,
                  t.day);

  return s;
}
string time__Time_clean(time__Time t) {

  time__Time nowe = time__now();

  if (t.month == nowe.month && t.year == nowe.year && t.day == nowe.day) {
    /*if*/

    return time__Time_hhmm(t);
  };

  if (t.year == nowe.year) {
    /*if*/

    return _STR("%.*s %d %.*s", time__Time_smonth(t).len,
                time__Time_smonth(t).str, t.day, time__Time_hhmm(t).len,
                time__Time_hhmm(t).str);
  };

  return time__Time_format(t);
}
string time__Time_clean12(time__Time t) {

  time__Time nowe = time__now();

  if (t.month == nowe.month && t.year == nowe.year && t.day == nowe.day) {
    /*if*/

    return time__Time_hhmm12(t);
  };

  if (t.year == nowe.year) {
    /*if*/

    return _STR("%.*s %d %.*s", time__Time_smonth(t).len,
                time__Time_smonth(t).str, t.day, time__Time_hhmm12(t).len,
                time__Time_hhmm12(t).str);
  };

  return time__Time_format(t);
}
time__Time time__parse(string s) {

  int pos = string_index(s, tos2(" "));

  if (pos <= 0) {
    /*if*/

    println(tos2("bad time format"));

    return time__now();
  };

  string symd = string_left(s, pos);

  array_string ymd = string_split(symd, tos2("-"));

  if (ymd.len != 3) {
    /*if*/

    println(tos2("bad time format"));

    return time__now();
  };

  string shms = string_right(s, pos);

  array_string hms = string_split(shms, tos2(":"));

  string hour = (*(string *)array__get(hms, 0));

  string minute = (*(string *)array__get(hms, 1));

  string second = (*(string *)array__get(hms, 2));

  return time__new_time(
      (time__Time){.year = string_int((*(string *)array__get(ymd, 0))),
                   .month = string_int((*(string *)array__get(ymd, 1))),
                   .day = string_int((*(string *)array__get(ymd, 2))),
                   .hour = string_int(hour),
                   .minute = string_int(minute),
                   .second = string_int(second),
                   .uni = 0});
}
time__Time time__new_time(time__Time t) {

  return (time__Time){
      .uni = time__Time_calc_unix(&/* ? */ t),
      .year = t.year,
      .month = t.month,
      .day = t.day,
      .hour = t.hour,
      .minute = t.minute,
      .second = t.second,
  };
}
int time__Time_calc_unix(time__Time *t) {

  if (t->uni != 0) {
    /*if*/

    return t->uni;
  };

  struct /*TM*/ tm tt = (struct tm){.tm_sec = t->second,
                                    .tm_min = t->minute,
                                    .tm_hour = t->hour,
                                    .tm_mday = t->day,
                                    .tm_mon = t->month - 1,
                                    .tm_year = t->year - 1900};

  return mktime(&/*vvar*/ tt);
}
time__Time time__Time_add_seconds(time__Time t, int seconds) {

  return time__unix(t.uni + seconds);
}
int time__since(time__Time t) { return 0; }
string time__Time_relative(time__Time t) {

  time__Time now = time__now();

  int secs = now.uni - t.uni;

  if (secs <= 30) {
    /*if*/

    return tos2("now");
  };

  if (secs < 60) {
    /*if*/

    return tos2("1m");
  };

  if (secs < 3600) {
    /*if*/

    return _STR("%dm", secs / 60);
  };

  if (secs < 3600 * 24) {
    /*if*/

    return _STR("%dh", secs / 3600);
  };

  if (secs < 3600 * 24 * 5) {
    /*if*/

    return _STR("%dd", secs / 3600 / 24);
  };

  if (secs > 3600 * 24 * 10000) {
    /*if*/

    return tos2("");
  };

  return time__Time_md(t);
}
int time__day_of_week(int y, int m, int d) { return 0; }
int time__Time_day_of_week(time__Time t) {

  return time__day_of_week(t.year, t.month, t.day);
}
string time__Time_weekday_str(time__Time t) {

  int i = time__Time_day_of_week(t) - 1;

  return string_substr(time__Days, i * 3, (/*lpar*/ i + 1) * 3);
}
f64 time__ticks() {

#ifdef _WIN32

  return GetTickCount();

#endif
  ;

  v_panic(tos2("not implemented"));

  return ((f64)(0));
}
void time__sleep(int seconds) {

#ifdef _WIN32

  _sleep(seconds * 1000);

  ;

#else

  sleep(seconds);

#endif
  ;
}
void time__usleep(int n) { usleep(n); }
void time__sleep_ms(int n) {

#ifdef _WIN32

  Sleep(n);

  ;

#else

  usleep(n * 1000);

#endif
  ;
}
void rand__seed() { srand(time__now().uni); }
int rand__next(int max) { return rand() % max; }
CGen *new_cgen(string out_name_c) {

  CGen *gen = ALLOC_INIT(
      CGen,
      {.out_path = _STR("%.*s/%.*s", main__TmpPath.len, main__TmpPath.str,
                        out_name_c.len, out_name_c.str),
       .out = os__create(_STR("%.*s/%.*s", main__TmpPath.len, main__TmpPath.str,
                              out_name_c.len, out_name_c.str)),
       .typedefs = new_array(0, 1, sizeof(string)),
       .type_aliases = new_array(0, 1, sizeof(string)),
       .includes = new_array(0, 1, sizeof(string)),
       .types = new_array(0, 1, sizeof(string)),
       .thread_args = new_array(0, 1, sizeof(string)),
       .thread_fns = new_array(0, 1, sizeof(string)),
       .consts = new_array(0, 1, sizeof(string)),
       .fns = new_array(0, 1, sizeof(string)),
       .so_fns = new_array(0, 1, sizeof(string)),
       .consts_init = new_array(0, 1, sizeof(string)),
       .lines = new_array(0, 1, sizeof(string)),
       .is_user = 0,
       .nogen = 0,
       .tmp_line = tos("", 0),
       .cur_line = tos("", 0),
       .prev_line = tos("", 0),
       .is_tmp = 0,
       .fn_main = tos("", 0),
       .stash = tos("", 0)});

  return gen;
}
void CGen_genln(CGen *g, string s) {

  if (g->nogen || g->run == RUN_DECLS) {
    /*if*/

    return;
  };

  if (g->is_tmp) {
    /*if*/

    g->tmp_line =
        _STR("%.*s %.*s\n", g->tmp_line.len, g->tmp_line.str, s.len, s.str);

    return;
  };

  g->cur_line =
      _STR("%.*s %.*s", g->cur_line.len, g->cur_line.str, s.len, s.str);

  if (string_ne(g->cur_line, tos2(""))) {
    /*if*/

    _PUSH(&g->lines, (g->cur_line), tmp2, string);

    g->prev_line = g->cur_line;

    g->cur_line = tos2("");
  };
}
void CGen_gen(CGen *g, string s) {

  if (g->nogen || g->run == RUN_DECLS) {
    /*if*/

    return;
  };

  if (g->is_tmp) {
    /*if*/

    g->tmp_line =
        _STR("%.*s %.*s", g->tmp_line.len, g->tmp_line.str, s.len, s.str);

  } else {
    /*else if*/

    g->cur_line =
        _STR("%.*s %.*s", g->cur_line.len, g->cur_line.str, s.len, s.str);
  };
}
void CGen_save(CGen *g) {

  string s = array_string_join(g->lines, tos2("\n"));

  os__File_appendln(g->out, s);

  os__File_close(g->out);
}
void CGen_start_tmp(CGen *g) {

  if (g->is_tmp) {
    /*if*/

    println(g->tmp_line);

    println(_STR("start_tmp() already started. cur_line=\"%.*s\"",
                 g->cur_line.len, g->cur_line.str));

    v_exit(1);
  };

  g->tmp_line = tos2("");

  g->is_tmp = 1;
}
string CGen_end_tmp(CGen *g) {

  g->is_tmp = 0;

  string res = g->tmp_line;

  g->tmp_line = tos2("");

  return res;
}
int CGen_add_placeholder(CGen *g) {

  if (g->is_tmp) {
    /*if*/

    return g->tmp_line.len;
  };

  return g->cur_line.len;
}
void CGen_set_placeholder(CGen *g, int pos, string val) {

  if (g->nogen) {
    /*if*/

    return;
  };

  if (g->is_tmp) {
    /*if*/

    string left = string_left(g->tmp_line, pos);

    string right = string_right(g->tmp_line, pos);

    g->tmp_line = _STR("%.*s%.*s%.*s", left.len, left.str, val.len, val.str,
                       right.len, right.str);

    return;
  };

  string left = string_left(g->cur_line, pos);

  string right = string_right(g->cur_line, pos);

  g->cur_line = _STR("%.*s%.*s%.*s", left.len, left.str, val.len, val.str,
                     right.len, right.str);
}
int CGen_add_placeholder2(CGen *g) {

  if (g->is_tmp) {
    /*if*/

    println(tos2("tmp in addp2"));

    v_exit(1);
  };

  _PUSH(&g->lines, (tos2("")), tmp9, string);

  return g->lines.len - 1;
}
void CGen_set_placeholder2(CGen *g, int pos, string val) {

  if (g->nogen) {
    /*if*/

    return;
  };

  if (g->is_tmp) {
    /*if*/

    println(tos2("tmp in setp2"));

    v_exit(1);
  };
  string tmp10 = val;

  array_set(&/*q*/ g->lines, pos, &tmp10);
}
void CGen_insert_before(CGen *g, string val) {

  array_insert(&/* ? */ g->lines, g->lines.len - 1,
               &/*11 EXP:"void*" GOT:"string" */ val);
}
void CGen_register_thread_fn(CGen *g, string wrapper_name, string wrapper_text,
                             string struct_text) {

  array_string tmp11 = g->thread_args;
  ;
  for (int tmp12 = 0; tmp12 < tmp11.len; tmp12++) {
    string arg = ((string *)tmp11.data)[tmp12];

    if (string_contains(arg, wrapper_name)) {
      /*if*/

      return;
    };
  };

  _PUSH(&g->thread_args, (struct_text), tmp13, string);

  _PUSH(&g->thread_args, (wrapper_text), tmp14, string);
}
string V_prof_counters(V *c) {

  array_string res = new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  array_Fn tmp16 = c->table->fns;
  ;
  for (int tmp17 = 0; tmp17 < tmp16.len; tmp17++) {
    Fn f = ((Fn *)tmp16.data)[tmp17];

    _PUSH(&res,
          (_STR("double %.*s_time;",
                Table_cgen_name(c->table, &/*11 EXP:"Fn*" GOT:"Fn" */ f).len,
                Table_cgen_name(c->table, &/*11 EXP:"Fn*" GOT:"Fn" */ f).str)),
          tmp18, string);
  };

  array_Type tmp19 = c->table->types;
  ;
  for (int tmp20 = 0; tmp20 < tmp19.len; tmp20++) {
    Type typ = ((Type *)tmp19.data)[tmp20];

    array_Fn tmp21 = typ.methods;
    ;
    for (int tmp22 = 0; tmp22 < tmp21.len; tmp22++) {
      Fn f = ((Fn *)tmp21.data)[tmp22];

      _PUSH(
          &res,
          (_STR("double %.*s_time;",
                Table_cgen_name(c->table, &/*11 EXP:"Fn*" GOT:"Fn" */ f).len,
                Table_cgen_name(c->table, &/*11 EXP:"Fn*" GOT:"Fn" */ f).str)),
          tmp23, string);
    };
  };

  return array_string_join(res, tos2(";\n"));
}
string Parser_print_prof_counters(Parser *p) {

  array_string res = new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  array_Fn tmp25 = p->table->fns;
  ;
  for (int tmp26 = 0; tmp26 < tmp25.len; tmp26++) {
    Fn f = ((Fn *)tmp25.data)[tmp26];

    string counter =
        _STR("%.*s_time",
             Table_cgen_name(p->table, &/*11 EXP:"Fn*" GOT:"Fn" */ f).len,
             Table_cgen_name(p->table, &/*11 EXP:"Fn*" GOT:"Fn" */ f).str);

    _PUSH(&res,
          (_STR("if (%.*s) printf(\"%%f : %.*s \\n\", %.*s);", counter.len,
                counter.str, f.name.len, f.name.str, counter.len, counter.str)),
          tmp28, string);
  };

  array_Type tmp29 = p->table->types;
  ;
  for (int tmp30 = 0; tmp30 < tmp29.len; tmp30++) {
    Type typ = ((Type *)tmp29.data)[tmp30];

    array_Fn tmp31 = typ.methods;
    ;
    for (int tmp32 = 0; tmp32 < tmp31.len; tmp32++) {
      Fn f = ((Fn *)tmp31.data)[tmp32];

      string counter =
          _STR("%.*s_time",
               Table_cgen_name(p->table, &/*11 EXP:"Fn*" GOT:"Fn" */ f).len,
               Table_cgen_name(p->table, &/*11 EXP:"Fn*" GOT:"Fn" */ f).str);

      _PUSH(&res,
            (_STR("if (%.*s) printf(\"%%f : %.*s \\n\", %.*s);", counter.len,
                  counter.str,
                  Table_cgen_name(p->table, &/*11 EXP:"Fn*" GOT:"Fn" */ f).len,
                  Table_cgen_name(p->table, &/*11 EXP:"Fn*" GOT:"Fn" */ f).str,
                  counter.len, counter.str)),
            tmp34, string);
    };
  };

  return array_string_join(res, tos2(";\n"));
}
void Parser_gen_type(Parser *p, string s) {

  if (!Parser_first_run(&/* ? */ *p)) {
    /*if*/

    return;
  };

  _PUSH(&p->cgen->types, (s), tmp35, string);
}
void Parser_gen_typedef(Parser *p, string s) {

  if (!Parser_first_run(&/* ? */ *p)) {
    /*if*/

    return;
  };

  _PUSH(&p->cgen->typedefs, (s), tmp36, string);
}
void Parser_gen_type_alias(Parser *p, string s) {

  if (!Parser_first_run(&/* ? */ *p)) {
    /*if*/

    return;
  };

  _PUSH(&p->cgen->type_aliases, (s), tmp37, string);
}
void CGen_add_to_main(CGen *g, string s) {

  println(tos2("add to main"));

  g->fn_main = string_add(g->fn_main, s);
}
Var Fn_find_var(Fn *f, string name) {

  int tmp1 = 0;
  ;
  for (int tmp2 = tmp1; tmp2 < f->var_idx; tmp2++) {
    int i = tmp2;

    if (string_eq((*(Var *)array__get(f->local_vars, i)).name, name)) {
      /*if*/

      return (*(Var *)array__get(f->local_vars, i));
    };
  };

  return (Var){.typ = tos("", 0),
               .name = tos("", 0),
               .is_arg = 0,
               .is_const = 0,
               .is_import_const = 0,
               .args = new_array(0, 1, sizeof(Var)),
               .attr = tos("", 0),
               .is_mut = 0,
               .ptr = 0,
               .ref = 0,
               .parent_fn = tos("", 0),
               .pkg = tos("", 0),
               .line_nr = 0,
               .is_global = 0,
               .is_used = 0,
               .scope_level = 0};
}
void Fn_open_scope(Fn *f) { f->scope_level++; }
void Fn_close_scope(Fn *f) {

  int i = f->var_idx - 1;

  for (; i >= 0; i--) {

    Var v = (*(Var *)array__get(f->local_vars, i));

    if (v.scope_level != f->scope_level) {
      /*if*/

      break;
    };
  };

  f->var_idx = i + 1;

  f->scope_level--;
}
void Fn_mark_var_used(Fn *f, Var v) {

  array_Var tmp11 = f->local_vars;
  ;
  for (int i = 0; i < tmp11.len; i++) {
    Var vv = ((Var *)tmp11.data)[i];

    if (string_eq(vv.name, v.name)) {
      /*if*/

      Var *ptr = &/*vvar*/ (*(Var *)array__get(f->local_vars, i));

      ptr->is_used = 1;
    };
  };
}
bool Fn_known_var(Fn *f, string name) {

  Var v = Fn_find_var(&/* ? */ *f, name);

  return v.name.len > 0;
}
void Fn_register_var(Fn *f, Var v) {

  Var new_var = (Var){
      .scope_level = f->scope_level,
      .typ = v.typ,
      .name = v.name,
      .is_arg = v.is_arg,
      .is_const = v.is_const,
      .is_import_const = v.is_import_const,
      .args = v.args,
      .attr = v.attr,
      .is_mut = v.is_mut,
      .ptr = v.ptr,
      .ref = v.ref,
      .parent_fn = v.parent_fn,
      .pkg = v.pkg,
      .line_nr = v.line_nr,
      .access_mod = v.access_mod,
      .is_global = v.is_global,
      .is_used = v.is_used,
  };

  if (f->var_idx >= f->local_vars.len) {
    /*if*/

    _PUSH(&f->local_vars, (new_var), tmp17, Var);

  } else {
    /*else if*/
    Var tmp18 = new_var;

    array_set(&/*q*/ f->local_vars, f->var_idx, &tmp18);
  };

  f->var_idx++;
}
void Fn_clear_vars(Fn *f) {

  f->var_idx = 0;

  f->local_vars = new_array_from_c_array(0, 0, sizeof(Var), (Var[]){});
}
bool Parser_is_sig(Parser *p) {

  return (/*lpar*/ p->build_mode == DEFAULT_MODE || p->build_mode == BUILD) &&
         (/*lpar*/ string_contains(p->file_path, main__TmpPath));
}
Fn *new_fn(string pkg, bool is_public) {
  Var tmp19 = (Var){.typ = tos("", 0),
                    .name = tos("", 0),
                    .is_arg = 0,
                    .is_const = 0,
                    .is_import_const = 0,
                    .args = new_array(0, 1, sizeof(Var)),
                    .attr = tos("", 0),
                    .is_mut = 0,
                    .ptr = 0,
                    .ref = 0,
                    .parent_fn = tos("", 0),
                    .pkg = tos("", 0),
                    .line_nr = 0,
                    .is_global = 0,
                    .is_used = 0,
                    .scope_level = 0};

  Fn *f = ALLOC_INIT(
      Fn, {.pkg = pkg,
           .local_vars = array_repeat(&tmp19, main__MaxLocalVars, sizeof(Var)),
           .is_public = is_public,
           .var_idx = 0,
           .args = new_array(0, 1, sizeof(Var)),
           .is_interface = 0,
           .scope_level = 0,
           .typ = tos("", 0),
           .name = tos("", 0),
           .is_c = 0,
           .receiver_typ = tos("", 0),
           .is_method = 0,
           .returns_error = 0,
           .is_decl = 0,
           .defer = tos("", 0)});

  return f;
}
void Parser_fn_decl(Parser *p) {

  Parser_fgen(p, tos2("fn "));

  bool is_pub = p->tok == PUB;

  if (is_pub) {
    /*if*/

    Parser_next(p);
  };

  p->returns = 0;

  Parser_next(p);

  Fn *f = new_fn(p->pkg, is_pub);

  string receiver_typ = tos2("");

  if (p->tok == LPAR) {
    /*if*/

    f->is_method = 1;

    Parser_check(p, LPAR);

    string receiver_name = Parser_check_name(p);

    bool is_mut = p->tok == MUT;

    bool is_amp = p->tok == AMP;

    if (is_mut || is_amp) {
      /*if*/

      Parser_next(p);
    };

    receiver_typ = Parser_get_type(p);

    Type *T = Table_find_type(&/* ? */ *p->table, receiver_typ);

    if (T->is_interface) {
      /*if*/

      Parser_error(p,
                   _STR("invalid receiver type `%.*s` (`%.*s` is an interface)",
                        receiver_typ.len, receiver_typ.str, receiver_typ.len,
                        receiver_typ.str));
    };

    if (!Parser_first_run(&/* ? */ *p) && !p->builtin_pkg &&
        string_ne(T->pkg, p->pkg)) {
      /*if*/

      println(_STR("T.pkg=%.*s", T->pkg.len, T->pkg.str));

      println(_STR("pkg=%.*s", p->pkg.len, p->pkg.str));

      Parser_error(p, _STR("cannot define new methods on non-local type `%.*s`",
                           receiver_typ.len, receiver_typ.str));
    };

    if (!p->builtin_pkg && string_contains(receiver_typ, tos2("*"))) {
      /*if*/

      string t = string_replace(receiver_typ, tos2("*"), tos2(""));

      Parser_error(p, _STR("use `(%.*s mut %.*s)` instead of `(%.*s *%.*s)`",
                           receiver_name.len, receiver_name.str, t.len, t.str,
                           receiver_name.len, receiver_name.str, t.len, t.str));
    };

    f->receiver_typ = receiver_typ;

    if (is_mut || is_amp) {
      /*if*/

      receiver_typ = string_add(receiver_typ, tos2("*"));
    };

    Parser_check(p, RPAR);

    Var receiver = (Var){.name = receiver_name,
                         .is_arg = 1,
                         .typ = receiver_typ,
                         .is_mut = is_mut,
                         .ref = is_amp,
                         .ptr = is_mut,
                         .line_nr = p->scanner->line_nr,
                         .is_const = 0,
                         .is_import_const = 0,
                         .args = new_array(0, 1, sizeof(Var)),
                         .attr = tos("", 0),
                         .parent_fn = tos("", 0),
                         .pkg = tos("", 0),
                         .is_global = 0,
                         .is_used = 0,
                         .scope_level = 0};

    _PUSH(&f->args, (receiver), tmp30, Var);

    Fn_register_var(f, receiver);
  };

  if (p->tok == PLUS || p->tok == MINUS || p->tok == MUL) {
    /*if*/

    f->name = Token_str(p->tok);

    Parser_next(p);

  } else {
    /*else if*/

    f->name = Parser_check_name(p);
  };

  bool is_c = string_eq(f->name, tos2("C")) && p->tok == DOT;

  bool is_sig = Parser_is_sig(p);

  if (is_c) {
    /*if*/

    Parser_check(p, DOT);

    f->name = Parser_check_name(p);

    f->is_c = 1;

  } else if (!p->translated && !string_contains(p->file_path, tos2("view.v"))) {
    /*if*/

    if (contains_capital(f->name)) {
      /*if*/

      Parser_error(p, tos2("function names cannot contain uppercase letters, "
                           "use snake_case instead"));
    };

    if (string_contains(f->name, tos2("__"))) {
      /*if*/

      Parser_error(p, tos2("function names cannot contain double underscores "
                           "(\"__\"), use single underscores instead"));
    };
  };

  bool has_receiver = receiver_typ.len > 0;

  if (string_ne(receiver_typ, tos2(""))) {
    /*if*/
  };

  if (!is_c && !p->builtin_pkg && string_ne(p->pkg, tos2("main")) &&
      receiver_typ.len == 0) {
    /*if*/

    f->name = Parser_prepend_pkg(&/* ? */ *p, f->name);
  };

  if (Parser_first_run(&/* ? */ *p) &&
      Table_known_fn(&/* ? */ *p->table, f->name) && receiver_typ.len == 0) {
    /*if*/

    Fn existing_fn = Table_find_fn(&/* ? */ *p->table, f->name);

    if (!existing_fn.is_decl) {
      /*if*/

      Parser_error(p, _STR("redefinition of `%.*s`", f->name.len, f->name.str));
    };
  };

  bool is_generic = 0;

  if (p->tok == LT) {
    /*if*/

    Parser_next(p);

    string gen_type = Parser_check_name(p);

    if (string_ne(gen_type, tos2("T"))) {
      /*if*/

      Parser_error(p, tos2("only `T` is allowed as a generic type for now"));
    };

    Parser_check(p, GT);

    is_generic = 1;
  };

  Parser_fn_args(p, f);

  if (p->tok == NOT) {
    /*if*/

    Parser_next(p);

    f->returns_error = 1;
  };

  string typ = tos2("void");

  if (p->tok == NAME || p->tok == MUL || p->tok == AMP || p->tok == LSBR ||
      p->tok == QUESTION) {
    /*if*/

    Parser_fgen(p, tos2(" "));

    typ = Parser_get_type(p);
  };

  bool is_fn_header = !is_c && !is_sig &&
                      (/*lpar*/ p->translated || p->is_test) &&
                      (/*lpar*/ p->tok != LCBR);

  if (is_fn_header) {
    /*if*/

    f->is_decl = 1;
  };

  if (!is_c && !is_sig && !is_fn_header) {
    /*if*/

    Parser_fgen(p, tos2(" "));

    Parser_check(p, LCBR);
  };

  if (string_starts_with(typ, tos2("Option_"))) {
    /*if*/

    _PUSH(&p->cgen->typedefs, (_STR("typedef Option %.*s;", typ.len, typ.str)),
          tmp39, string);
  };

  f->typ = typ;

  string str_args = Fn_str_args(&/* ? */ *f, p->table);

  if (string_eq(f->name, tos2("main")) && !has_receiver) {
    /*if*/

    if (string_ne(str_args, tos2(""))) {
      /*if*/

      Parser_error(p,
                   tos2("fn main must have no arguments and no return values"));
    };

    typ = tos2("int");

    str_args = tos2("int argc, char** argv");
  };

  string fn_name_cgen = Table_cgen_name(p->table, f);

  bool is_live = p->is_live && string_ne(f->name, tos2("main")) &&
                 string_ne(f->name, tos2("reload_so"));

  bool skip_main_in_test = string_eq(f->name, tos2("main")) && p->is_test;

  if (!is_c && !is_live && !is_sig && !is_fn_header && !skip_main_in_test) {
    /*if*/

    if (p->obfuscate) {
      /*if*/

      Parser_genln(p, _STR("; // %.*s", f->name.len, f->name.str));
    };

    Parser_genln(p,
                 _STR("%.*s %.*s(%.*s) {", typ.len, typ.str, fn_name_cgen.len,
                      fn_name_cgen.str, str_args.len, str_args.str));
  };

  if (is_fn_header) {
    /*if*/

    Parser_genln(p, _STR("%.*s %.*s(%.*s);", typ.len, typ.str, fn_name_cgen.len,
                         fn_name_cgen.str, str_args.len, str_args.str));

    Parser_fgenln(p, tos2(""));
  };

  if (is_c) {
    /*if*/

    Parser_fgenln(p, tos2("\n"));
  };

  p->cur_fn = f;

  if (string_ne(receiver_typ, tos2(""))) {
    /*if*/

    Type *receiver_T = Table_find_type(&/* ? */ *p->table, receiver_typ);

    if (Parser_first_run(&/* ? */ *p) &&
        string_eq(receiver_T->name, tos2(""))) {
      /*if*/

      Type ttyp = (Type){
          .name = string_replace(receiver_typ, tos2("*"), tos2("")),
          .pkg = p->pkg,
          .is_placeholder = 1,
          .fields = new_array(0, 1, sizeof(Var)),
          .methods = new_array(0, 1, sizeof(Fn)),
          .parent = tos("", 0),
          .gen_types = new_array(0, 1, sizeof(string)),
          .is_c = 0,
          .is_interface = 0,
          .is_enum = 0,
      };

      Table_register_type2(p->table, ttyp);
    };

    Type_add_method(receiver_T, *f);

  } else {
    /*else if*/

    Table_register_fn(p->table, *f);
  };

  if (is_sig || Parser_first_run(&/* ? */ *p) || is_live || is_fn_header ||
      skip_main_in_test) {
    /*if*/

    if (!is_sig && !is_fn_header) {
      /*if*/

      while (1) {
        Parser_next(p);

        if (Token_is_decl(p->tok)) {
          /*if*/

          break;
        };
      };
    };

    if (is_live && Parser_first_run(&/* ? */ *p)) {
      /*if*/

      _PUSH(&p->cgen->so_fns, (fn_name_cgen), tmp46, string);

      fn_name_cgen = _STR("(* %.*s )", fn_name_cgen.len, fn_name_cgen.str);
    };

    string fn_decl = _STR("%.*s %.*s(%.*s)", typ.len, typ.str, fn_name_cgen.len,
                          fn_name_cgen.str, str_args.len, str_args.str);

    if (p->obfuscate) {
      /*if*/

      fn_decl =
          string_add(fn_decl, _STR("; // %.*s", f->name.len, f->name.str));
    };

    if (!is_c && string_ne(f->name, tos2("main")) &&
        Parser_first_run(&/* ? */ *p)) {
      /*if*/

      if (string_eq(f->name, tos2("darwin__nsstring")) &&
          p->build_mode == DEFAULT_MODE) {
        /*if*/

        return;
      };

      _PUSH(&p->cgen->fns, (string_add(fn_decl, tos2(";"))), tmp48, string);
    };

    Parser_fgenln(p, tos2("\n"));

    return;
  };

  if (string_eq(f->name, tos2("main")) || string_eq(f->name, tos2("WinMain"))) {
    /*if*/

    Parser_genln(p, tos2("init_consts();"));

    if (array_string_contains(p->table->imports, tos2("os"))) {
      /*if*/

      if (string_eq(f->name, tos2("main"))) {
        /*if*/

        Parser_genln(p, tos2("os__args = os__init_os_args(argc, argv);"));

      } else if (string_eq(f->name, tos2("WinMain"))) {
        /*if*/

        Parser_genln(p,
                     tos2("os__args = os__parse_windows_cmd_line(pCmdLine);"));
      };
    };

    if (p->is_live) {
      /*if*/

      Parser_genln(p, tos2(" \nload_so(\"bounce.so\"); \npthread_t "
                           "_thread_so;\npthread_create(&_thread_so , NULL, "
                           "&reload_so, NULL); "));
    };

    if (p->is_test && !string_contains(p->scanner->file_path, tos2("/volt"))) {
      /*if*/

      Parser_error(p, tos2("tests cannot have function `main`"));
    };
  };

  if (is_c || is_sig || is_fn_header) {
    /*if*/

    Parser_fgenln(p, tos2("\n"));

    return;
  };

  if (p->is_prof && string_ne(f->name, tos2("main")) &&
      string_ne(f->name, tos2("time__ticks"))) {
    /*if*/

    Parser_genln(p, _STR("double _PROF_START = time__ticks();//%.*s",
                         f->name.len, f->name.str));

    string cgen_name = Table_cgen_name(p->table, f);

    f->defer = _STR("  %.*s_time += time__ticks() - _PROF_START;",
                    cgen_name.len, cgen_name.str);
  };

  Parser_statements_no_curly_end(p);

  if (p->is_prof && string_eq(f->name, tos2("main"))) {
    /*if*/

    Parser_genln(p, Parser_print_prof_counters(p));
  };

  Parser_genln(p, f->defer);

  if (string_ne(typ, tos2("void")) && !p->returns &&
      string_ne(f->name, tos2("main")) && string_ne(f->name, tos2("WinMain"))) {
    /*if*/

    Parser_error(p, _STR("%.*s must return \"%.*s\"", f->name.len, f->name.str,
                         typ.len, typ.str));
  };

  if (string_eq(p->pkg, tos2("main"))) {
    /*if*/
  };

  if (p->cur_fn->scope_level > 2) {
    /*if*/
  };

  if (string_ne(p->pkg, tos2("main"))) {
    /*if*/

    Parser_genln(p, tos2("}"));

    Parser_fgenln(p, tos2("\n"));

    return;
  };

  Parser_check_unused_variables(p);

  p->cur_fn = main__EmptyFn;

  Parser_fgenln(p, tos2("\n"));

  Parser_genln(p, tos2("}"));
}
void Parser_check_unused_variables(Parser *p) {

  array_Var tmp50 = p->cur_fn->local_vars;
  ;
  for (int tmp51 = 0; tmp51 < tmp50.len; tmp51++) {
    Var var = ((Var *)tmp50.data)[tmp51];

    if (string_eq(var.name, tos2(""))) {
      /*if*/

      break;
    };

    if (!var.is_used && !var.is_arg && !p->translated &&
        string_ne(var.name, tos2("_"))) {
      /*if*/

      p->scanner->line_nr = var.line_nr - 1;

      Parser_error(
          p, _STR("`%.*s` declared and not used", var.name.len, var.name.str));
    };

    if (p->is_test && string_contains(var.typ, tos2("array_"))) {
      /*if*/
    };
  };
}
void Parser_async_fn_call(Parser *p, Fn f, int method_ph, string receiver_var,
                          string receiver_type) {

  string thread_name = tos2("");

  string fn_name = f.name;

  if (f.is_method) {
    /*if*/

    receiver_type = string_replace(receiver_type, tos2("*"), tos2(""));

    fn_name = _STR("%.*s_%.*s", receiver_type.len, receiver_type.str,
                   f.name.len, f.name.str);
  };

  string arg_struct_name = _STR("thread_arg_%.*s", fn_name.len, fn_name.str);

  string tmp_struct = Parser_get_tmp(p);

  Parser_genln(p,
               _STR("%.*s * %.*s = malloc(sizeof(%.*s));", arg_struct_name.len,
                    arg_struct_name.str, tmp_struct.len, tmp_struct.str,
                    arg_struct_name.len, arg_struct_name.str));

  string arg_struct = _STR("typedef struct  %.*s   { ", arg_struct_name.len,
                           arg_struct_name.str);

  Parser_next(p);

  Parser_check(p, LPAR);

  string str_args = tos2("");

  array_Var tmp58 = f.args;
  ;
  for (int i = 0; i < tmp58.len; i++) {
    Var arg = ((Var *)tmp58.data)[i];

    arg_struct =
        string_add(arg_struct, _STR("%.*s %.*s ;", arg.typ.len, arg.typ.str,
                                    arg.name.len, arg.name.str));

    str_args =
        string_add(str_args, _STR("arg->%.*s", arg.name.len, arg.name.str));

    if (i == 0 && f.is_method) {
      /*if*/

      Parser_genln(p, _STR("%.*s -> %.*s =  %.*s ;", tmp_struct.len,
                           tmp_struct.str, arg.name.len, arg.name.str,
                           receiver_var.len, receiver_var.str));

      if (i < f.args.len - 1) {
        /*if*/

        str_args = string_add(str_args, tos2(","));
      };

      continue;
    };

    Parser_genln(p, _STR("%.*s -> %.*s =  ", tmp_struct.len, tmp_struct.str,
                         arg.name.len, arg.name.str));

    Parser_expression(p);

    Parser_genln(p, tos2(";"));

    if (i < f.args.len - 1) {
      /*if*/

      Parser_check(p, COMMA);

      str_args = string_add(str_args, tos2(","));
    };
  };

  arg_struct = string_add(
      arg_struct, _STR("} %.*s ;", arg_struct_name.len, arg_struct_name.str));

  fn_name = Table_cgen_name(p->table, &/*11 EXP:"Fn*" GOT:"Fn" */ f);

  string wrapper_name = _STR("%.*s_thread_wrapper", fn_name.len, fn_name.str);

  string wrapper_text =
      _STR("void* %.*s(%.*s * arg) {%.*s( /*f*/%.*s );  }", wrapper_name.len,
           wrapper_name.str, arg_struct_name.len, arg_struct_name.str,
           fn_name.len, fn_name.str, str_args.len, str_args.str);

  CGen_register_thread_fn(p->cgen, wrapper_name, wrapper_text, arg_struct);

  int tmp_nr = Parser_get_tmp_counter(p);

  thread_name = _STR("_thread%d", tmp_nr);

  if (p->os != WINDOWS) {
    /*if*/

    Parser_genln(p, _STR("pthread_t %.*s;", thread_name.len, thread_name.str));
  };

  string tmp2 = Parser_get_tmp(p);

  string parg = tos2("NULL");

  if (f.args.len > 0) {
    /*if*/

    parg = _STR(" %.*s", tmp_struct.len, tmp_struct.str);
  };

  if (p->os == WINDOWS) {
    /*if*/

    Parser_genln(p,
                 _STR(" CreateThread(0,0, %.*s, %.*s, 0,0);", wrapper_name.len,
                      wrapper_name.str, parg.len, parg.str));

  } else {
    /*else if*/

    Parser_genln(p,
                 _STR("int %.*s = pthread_create(& %.*s, NULL, %.*s, %.*s);",
                      tmp2.len, tmp2.str, thread_name.len, thread_name.str,
                      wrapper_name.len, wrapper_name.str, parg.len, parg.str));
  };

  Parser_check(p, RPAR);
}
void Parser_fn_call(Parser *p, Fn f, int method_ph, string receiver_var,
                    string receiver_type) {

  if (!f.is_public && !f.is_c && !p->is_test && string_ne(f.pkg, p->pkg)) {
    /*if*/

    Parser_error(p, _STR("function `%.*s` is private", f.name.len, f.name.str));
  };

  p->calling_c = f.is_c;

  bool is_print = p->is_prod && !p->is_test && !p->builtin_pkg && f.is_c &&
                  string_eq(f.name, tos2("printf"));

  if (!p->cgen->nogen) {
    /*if*/

    p->cgen->nogen = is_print;
  };

  string cgen_name = Table_cgen_name(p->table, &/*11 EXP:"Fn*" GOT:"Fn" */ f);

  if (!f.is_method) {
    /*if*/

    Parser_gen(p, cgen_name);

    Parser_gen(p, tos2("("));

  } else {
    /*else if*/

    string method_call = _STR("%.*s(", cgen_name.len, cgen_name.str);

    Var receiver = *(Var *)array_first(f.args);

    if (receiver.is_mut && !p->expr_var.is_mut) {
      /*if*/

      println(_STR("%.*s  recv=%.*s recv_mut=%d", method_call.len,
                   method_call.str, receiver.name.len, receiver.name.str,
                   receiver.is_mut));

      Parser_error(p, _STR("`%.*s` is immutable", p->expr_var.name.len,
                           p->expr_var.name.str));
    };

    if (receiver.ref || (/*lpar*/ receiver.is_mut &&
                         !string_contains(receiver_type, tos2("*")))) {
      /*if*/

      method_call = string_add(method_call, tos2("& /* ? */"));
    };

    if (!receiver.is_mut && string_contains(receiver_type, tos2("*"))) {
      /*if*/

      method_call = string_add(method_call, tos2("*"));
    };

    string cast = tos2("");

    if (string_eq(f.typ, tos2("void*"))) {
      /*if*/

      cast = string_all_after(receiver_type, tos2("_"));

      cast = _STR("*(%.*s*) ", cast.len, cast.str);
    };

    CGen_set_placeholder(p->cgen, method_ph,
                         _STR("%.*s %.*s", cast.len, cast.str, method_call.len,
                              method_call.str));
  };

  Parser_next(p);

  Parser_fn_call_args(p, &/*11 EXP:"Fn*" GOT:"Fn" */ f);

  Parser_gen(p, tos2(")"));

  p->calling_c = 0;

  if (is_print) {
    /*if*/

    p->cgen->nogen = 0;
  };
}
void Parser_fn_args(Parser *p, Fn *f) {

  Parser_check(p, LPAR);

  if (f->is_interface) {
    /*if*/

    Var int_arg = (Var){.typ = f->receiver_typ,
                        .name = tos("", 0),
                        .is_arg = 0,
                        .is_const = 0,
                        .is_import_const = 0,
                        .args = new_array(0, 1, sizeof(Var)),
                        .attr = tos("", 0),
                        .is_mut = 0,
                        .ptr = 0,
                        .ref = 0,
                        .parent_fn = tos("", 0),
                        .pkg = tos("", 0),
                        .line_nr = 0,
                        .is_global = 0,
                        .is_used = 0,
                        .scope_level = 0};

    _PUSH(&f->args, (int_arg), tmp70, Var);
  };

  bool types_only = p->tok == MUL ||
                    (/*lpar*/ Parser_peek(p) == COMMA &&
                     Table_known_type(&/* ? */ *p->table, p->lit)) ||
                    Parser_peek(p) == RPAR;

  if (types_only) {
    /*if*/

    while (p->tok != RPAR) {

      string typ = Parser_get_type(p);

      Var v = (Var){.typ = typ,
                    .is_arg = 1,
                    .line_nr = p->scanner->line_nr,
                    .name = tos("", 0),
                    .is_const = 0,
                    .is_import_const = 0,
                    .args = new_array(0, 1, sizeof(Var)),
                    .attr = tos("", 0),
                    .is_mut = 0,
                    .ptr = 0,
                    .ref = 0,
                    .parent_fn = tos("", 0),
                    .pkg = tos("", 0),
                    .is_global = 0,
                    .is_used = 0,
                    .scope_level = 0};

      _PUSH(&f->args, (v), tmp74, Var);

      if (p->tok == COMMA) {
        /*if*/

        Parser_next(p);
      };
    };
  };

  while (p->tok != RPAR) {

    array_string names = new_array_from_c_array(
        1, 1, sizeof(string), (string[]){Parser_check_name(p)});

    while (p->tok == COMMA) {

      Parser_check(p, COMMA);

      Parser_fspace(p);

      _PUSH(&names, (Parser_check_name(p)), tmp76, string);
    };

    Parser_fspace(p);

    bool is_mut = p->tok == MUT;

    if (is_mut) {
      /*if*/

      Parser_next(p);
    };

    string typ2 = Parser_get_type(p);

    array_string tmp79 = names;
    ;
    for (int tmp80 = 0; tmp80 < tmp79.len; tmp80++) {
      string name = ((string *)tmp79.data)[tmp80];

      if (!Parser_first_run(&/* ? */ *p) &&
          !Table_known_type(&/* ? */ *p->table, typ2)) {
        /*if*/

        Parser_error(p, _STR("fn_args: unknown type %.*s", typ2.len, typ2.str));
      };

      if (is_mut) {
        /*if*/

        typ2 = string_add(typ2, tos2("*"));
      };

      Var v = (Var){.name = name,
                    .typ = typ2,
                    .is_arg = 1,
                    .is_mut = is_mut,
                    .ptr = is_mut,
                    .line_nr = p->scanner->line_nr,
                    .is_const = 0,
                    .is_import_const = 0,
                    .args = new_array(0, 1, sizeof(Var)),
                    .attr = tos("", 0),
                    .ref = 0,
                    .parent_fn = tos("", 0),
                    .pkg = tos("", 0),
                    .is_global = 0,
                    .is_used = 0,
                    .scope_level = 0};

      Fn_register_var(f, v);

      _PUSH(&f->args, (v), tmp82, Var);
    };

    if (p->tok == COMMA) {
      /*if*/

      Parser_next(p);
    };

    if (p->tok == DOTDOT) {
      /*if*/

      _PUSH(&f->args,
            ((Var){.name = tos2(".."),
                   .typ = tos("", 0),
                   .is_arg = 0,
                   .is_const = 0,
                   .is_import_const = 0,
                   .args = new_array(0, 1, sizeof(Var)),
                   .attr = tos("", 0),
                   .is_mut = 0,
                   .ptr = 0,
                   .ref = 0,
                   .parent_fn = tos("", 0),
                   .pkg = tos("", 0),
                   .line_nr = 0,
                   .is_global = 0,
                   .is_used = 0,
                   .scope_level = 0}),
            tmp83, Var);

      Parser_next(p);
    };
  };

  Parser_check(p, RPAR);
}
Fn *Parser_fn_call_args(Parser *p, Fn *f) {

  Parser_check(p, LPAR);

  if (f->is_c) {
    /*if*/

    while (p->tok != RPAR) {

      Parser_bool_expression(p);

      if (p->tok == COMMA) {
        /*if*/

        Parser_gen(p, tos2(", "));

        Parser_check(p, COMMA);
      };
    };

    Parser_check(p, RPAR);

    return f;
  };

  array_Var tmp84 = f->args;
  ;
  for (int i = 0; i < tmp84.len; i++) {
    Var arg = ((Var *)tmp84.data)[i];

    if (i == 0 && f->is_method) {
      /*if*/

      if (f->args.len > 1) {
        /*if*/

        Parser_gen(p, tos2(","));
      };

      continue;
    };

    if (i == f->args.len - 1 && string_eq(arg.name, tos2(".."))) {
      /*if*/

      break;
    };

    int amp_ph = CGen_add_placeholder(p->cgen);

    if (p->tok == RPAR) {
      /*if*/

      string str_args = Fn_str_args(&/* ? */ *f, p->table);

      Parser_error(p,
                   _STR("not enough arguments in call to `%.*s (%.*s)`",
                        f->name.len, f->name.str, str_args.len, str_args.str));
    };

    if (arg.is_mut) {
      /*if*/

      if (p->tok != MUT) {
        /*if*/

        Parser_error(p, _STR("`%.*s` is a mutable argument, you need to "
                             "provide `mut`: `%.*s(...mut a...)`",
                             arg.name.len, arg.name.str, f->name.len,
                             f->name.str));
      };

      if (Parser_peek(p) != NAME) {
        /*if*/

        Parser_error(
            p, _STR("`%.*s` is a mutable argument, you need to provide a "
                    "variable to modify: `%.*s(... mut a...)`",
                    arg.name.len, arg.name.str, f->name.len, f->name.str));
      };

      Parser_check(p, MUT);
    };

    string typ = Parser_bool_expression(p);

    if (i == 0 && string_eq(f->name, tos2("println")) &&
        string_ne(typ, tos2("string")) && string_ne(typ, tos2("void"))) {
      /*if*/

      Type *T = Table_find_type(&/* ? */ *p->table, typ);

      if (string_eq(typ, tos2("u8"))) {
        /*if*/

        CGen_set_placeholder(p->cgen, amp_ph, tos2("u8_str("));

      } else if (string_eq(T->parent, tos2("int"))) {
        /*if*/

        CGen_set_placeholder(p->cgen, amp_ph, tos2("int_str("));

      } else if (string_ends_with(typ, tos2("*"))) {
        /*if*/

        CGen_set_placeholder(p->cgen, amp_ph, tos2("ptr_str("));

      } else {
        /*else if*/

        if (!Type_has_method(&/* ? */ *T, tos2("str"))) {
          /*if*/

          if (T->fields.len > 0) {
            /*if*/

            int index = p->cgen->cur_line.len - 1;

            while (index > 0 && string_at(p->cgen->cur_line, index) != ' ') {

              index--;
            };

            string name = string_right(p->cgen->cur_line, index + 1);

            if (string_eq(name, tos2("}"))) {
              /*if*/

              Parser_error(p, _STR("`%.*s` needs to have method `str() string` "
                                   "to be printable",
                                   typ.len, typ.str));
            };

            p->cgen->cur_line = string_left(p->cgen->cur_line, index);

            Parser_create_type_string(p, *T, name);

            string_replace(p->cgen->cur_line, typ, tos2(""));

            Parser_next(p);

            return Parser_fn_call_args(p, f);
          };

          Parser_error(
              p,
              _STR("`%.*s` needs to have method `str() string` to be printable",
                   typ.len, typ.str));
        };

        CGen_set_placeholder(p->cgen, amp_ph,
                             _STR("%.*s_str(", typ.len, typ.str));
      };

      Parser_gen(p, tos2(")"));

      continue;
    };

    string got = typ;

    string expected = arg.typ;

    if (!Parser_check_types_no_throw(p, got, expected)) {
      /*if*/

      string err =
          _STR("Fn \"%.*s\" wrong arg #%d. ", f->name.len, f->name.str, i + 1);

      err = string_add(err, _STR("Expected \"%.*s\" (%.*s)  but got \"%.*s\"",
                                 arg.typ.len, arg.typ.str, arg.name.len,
                                 arg.name.str, typ.len, typ.str));

      Parser_error(p, err);
    };

    bool is_interface = Table_is_interface(&/* ? */ *p->table, arg.typ);

    if (!is_interface) {
      /*if*/

      if (string_contains(got, tos2("*")) &&
          !string_contains(expected, tos2("*"))) {
        /*if*/

        CGen_set_placeholder(p->cgen, amp_ph, tos2("*"));
      };

      if (!string_contains(got, tos2("*")) &&
          string_contains(expected, tos2("*")) &&
          string_ne(got, tos2("voidptr"))) {
        /*if*/

        if (!(/*lpar*/ string_eq(expected, tos2("void*")) &&
              string_eq(got, tos2("int"))) &&
            !(/*lpar*/ string_eq(expected, tos2("byte*")) &&
              string_contains(got, tos2("]byte"))) &&
            !(/*lpar*/ string_eq(expected, tos2("byte*")) &&
              string_eq(got, tos2("string")))) {
          /*if*/

          CGen_set_placeholder(p->cgen, amp_ph,
                               _STR("& /*11 EXP:\"%.*s\" GOT:\"%.*s\" */",
                                    expected.len, expected.str, got.len,
                                    got.str));
        };
      };
    };

    if (is_interface) {
      /*if*/

      if (!string_contains(got, tos2("*"))) {
        /*if*/

        CGen_set_placeholder(p->cgen, amp_ph, tos2("&"));
      };

      Type *interface_type = Table_find_type(&/* ? */ *p->table, arg.typ);

      array_Fn tmp98 = interface_type->methods;
      ;
      for (int tmp99 = 0; tmp99 < tmp98.len; tmp99++) {
        Fn method = ((Fn *)tmp98.data)[tmp99];

        Parser_gen(p, _STR(", %.*s_%.*s ", typ.len, typ.str, method.name.len,
                           method.name.str));
      };
    };

    if (i < f->args.len - 1) {
      /*if*/

      bool is_vararg =
          i == f->args.len - 2 &&
          string_eq((*(Var *)array__get(f->args, i + 1)).name, tos2(".."));

      if (p->tok != COMMA && !is_vararg) {
        /*if*/

        Parser_error(p, _STR("wrong number of arguments for %d,%.*s fn `%.*s`: "
                             "expected %d, but got less",
                             i, arg.name.len, arg.name.str, f->name.len,
                             f->name.str, f->args.len));
      };

      if (p->tok == COMMA) {
        /*if*/

        Parser_fgen(p, tos2(", "));
      };

      if (!is_vararg) {
        /*if*/

        Parser_next(p);

        Parser_gen(p, tos2(","));
      };
    };
  };

  if (f->args.len > 0) {
    /*if*/

    Var last_arg = *(Var *)array_last(f->args);

    if (string_eq(last_arg.name, tos2(".."))) {
      /*if*/

      println(tos2("GOT VAR ARGS AFTER"));

      while (p->tok != RPAR) {

        if (p->tok == COMMA) {
          /*if*/

          Parser_gen(p, tos2(","));

          Parser_check(p, COMMA);
        };

        Parser_bool_expression(p);
      };
    };
  };

  if (p->tok == COMMA) {
    /*if*/

    Parser_error(p, _STR("wrong number of arguments for fn `%.*s`: expected "
                         "%d, but got more",
                         f->name.len, f->name.str, f->args.len));
  };

  Parser_check(p, RPAR);
}
bool contains_capital(string s) {

  for (int i = 0; i < s.len; i++) {

    byte c = string_at(s, i);

    if (c >= 'A' && c <= 'Z') {
      /*if*/

      return 1;
    };
  };

  return 0;
}
string Fn_typ_str(Fn f) {

  StringBuilder sb = new_string_builder(50);

  StringBuilder_write(&/* ? */ sb, tos2("fn ("));

  array_Var tmp109 = f.args;
  ;
  for (int i = 0; i < tmp109.len; i++) {
    Var arg = ((Var *)tmp109.data)[i];

    StringBuilder_write(&/* ? */ sb, arg.typ);

    if (i < f.args.len - 1) {
      /*if*/

      StringBuilder_write(&/* ? */ sb, tos2(","));
    };
  };

  StringBuilder_write(&/* ? */ sb, tos2(")"));

  if (string_ne(f.typ, tos2("void"))) {
    /*if*/

    StringBuilder_write(&/* ? */ sb, _STR(" %.*s", f.typ.len, f.typ.str));
  };

  return StringBuilder_str(sb);
}
string Fn_str_args(Fn *f, Table *table) {

  string s = tos2("");

  array_Var tmp111 = f->args;
  ;
  for (int i = 0; i < tmp111.len; i++) {
    Var arg = ((Var *)tmp111.data)[i];

    if (Table_is_interface(&/* ? */ *table, arg.typ)) {
      /*if*/

      s = string_add(s, _STR(" void* %.*s", arg.name.len, arg.name.str));

      Type *interface_type = Table_find_type(&/* ? */ *table, arg.typ);

      array_Fn tmp113 = interface_type->methods;
      ;
      for (int tmp114 = 0; tmp114 < tmp113.len; tmp114++) {
        Fn method = ((Fn *)tmp113.data)[tmp114];

        s = string_add(s, _STR(", %.*s (*%.*s_%.*s)(void*) ", method.typ.len,
                               method.typ.str, arg.typ.len, arg.typ.str,
                               method.name.len, method.name.str));
      };

    } else if (string_eq(arg.name, tos2(".."))) {
      /*if*/

      s = string_add(s, tos2("..."));

    } else {
      /*else if*/

      s = string_add(
          s, Table_cgen_name_type_pair(&/* ? */ *table, arg.name, arg.typ));
    };

    if (i < f->args.len - 1) {
      /*if*/

      s = string_add(s, tos2(", "));
    };
  };

  return s;
}
void Parser_gen_json_for_type(Parser *p, Type typ) {

  string dec = tos2("");

  string enc = tos2("");

  string t = typ.name;

  if (string_eq(t, tos2("int")) || string_eq(t, tos2("string")) ||
      string_eq(t, tos2("bool"))) {
    /*if*/

    return;
  };

  if (Parser_first_run(&/* ? */ *p)) {
    /*if*/

    return;
  };

  Fn dec_fn = (Fn){.pkg = p->pkg,
                   .typ = _STR("Option_%.*s", typ.name.len, typ.name.str),
                   .name = js_dec_name(t),
                   .local_vars = new_array(0, 1, sizeof(Var)),
                   .var_idx = 0,
                   .args = new_array(0, 1, sizeof(Var)),
                   .is_interface = 0,
                   .scope_level = 0,
                   .is_c = 0,
                   .receiver_typ = tos("", 0),
                   .is_public = 0,
                   .is_method = 0,
                   .returns_error = 0,
                   .is_decl = 0,
                   .defer = tos("", 0)};

  if (Table_known_fn(&/* ? */ *p->table, dec_fn.name)) {
    /*if*/

    return;
  };

  Var arg = (Var){.typ = tos2("cJSON*"),
                  .name = tos("", 0),
                  .is_arg = 0,
                  .is_const = 0,
                  .is_import_const = 0,
                  .args = new_array(0, 1, sizeof(Var)),
                  .attr = tos("", 0),
                  .is_mut = 0,
                  .ptr = 0,
                  .ref = 0,
                  .parent_fn = tos("", 0),
                  .pkg = tos("", 0),
                  .line_nr = 0,
                  .is_global = 0,
                  .is_used = 0,
                  .scope_level = 0};

  _PUSH(&dec_fn.args, (arg), tmp6, Var);

  Table_register_fn(p->table, dec_fn);

  Fn enc_fn = (Fn){.pkg = p->pkg,
                   .typ = tos2("cJSON*"),
                   .name = js_enc_name(t),
                   .local_vars = new_array(0, 1, sizeof(Var)),
                   .var_idx = 0,
                   .args = new_array(0, 1, sizeof(Var)),
                   .is_interface = 0,
                   .scope_level = 0,
                   .is_c = 0,
                   .receiver_typ = tos("", 0),
                   .is_public = 0,
                   .is_method = 0,
                   .returns_error = 0,
                   .is_decl = 0,
                   .defer = tos("", 0)};

  Var enc_arg = (Var){.typ = t,
                      .name = tos("", 0),
                      .is_arg = 0,
                      .is_const = 0,
                      .is_import_const = 0,
                      .args = new_array(0, 1, sizeof(Var)),
                      .attr = tos("", 0),
                      .is_mut = 0,
                      .ptr = 0,
                      .ref = 0,
                      .parent_fn = tos("", 0),
                      .pkg = tos("", 0),
                      .line_nr = 0,
                      .is_global = 0,
                      .is_used = 0,
                      .scope_level = 0};

  _PUSH(&enc_fn.args, (enc_arg), tmp9, Var);

  Table_register_fn(p->table, enc_fn);

  dec = string_add(
      dec,
      _STR(
          "\n//%.*s %.*s(cJSON* root) {  \nOption %.*s(cJSON* root, %.*s* res) "
          "{  \n//  %.*s res; \n  if (!root) {\n    const char *error_ptr = "
          "cJSON_GetErrorPtr();\n    if (error_ptr != NULL)	{\n      "
          "fprintf(stderr, \"Error in decode() for %.*s error_ptr=: %%s\\n\", "
          "error_ptr);\n//      printf(\"\\nbad js=%%s\\n\", js.str); \n      "
          "return v_error(tos2(error_ptr));\n    }\n  }\n",
          t.len, t.str, dec_fn.name.len, dec_fn.name.str, dec_fn.name.len,
          dec_fn.name.str, t.len, t.str, t.len, t.str, t.len, t.str));

  enc =
      string_add(enc, _STR("\ncJSON* %.*s(%.*s val) {  \ncJSON *o = "
                           "cJSON_CreateObject();\nstring res = tos2(\"\"); \n",
                           enc_fn.name.len, enc_fn.name.str, t.len, t.str));

  if (string_starts_with(t, tos2("array_"))) {
    /*if*/

    dec = string_add(dec, Parser_decode_array(p, t));

    enc = string_add(enc, Parser_encode_array(&/* ? */ *p, t));
  };

  array_Var tmp10 = typ.fields;
  ;
  for (int tmp11 = 0; tmp11 < tmp10.len; tmp11++) {
    Var field = ((Var *)tmp10.data)[tmp11];

    if (string_eq(field.attr, tos2("skip"))) {
      /*if*/

      continue;
    };

    Type *field_type = Table_find_type(&/* ? */ *p->table, field.typ);

    Parser_gen_json_for_type(p, *field_type);

    string name = field.name;

    string _typ = string_replace(field.typ, tos2("*"), tos2(""));

    string enc_name = js_enc_name(_typ);

    string dec_name = js_dec_name(_typ);

    if (is_js_prim(_typ)) {
      /*if*/

      dec = string_add(
          dec, _STR(" /*prim*/ res->%.*s = %.*s(js_get(root, \"%.*s\"))",
                    name.len, name.str, dec_name.len, dec_name.str,
                    field.name.len, field.name.str));

    } else {
      /*else if*/

      dec = string_add(
          dec, _STR(" /*!!*/ %.*s(js_get(root, \"%.*s\"), & (res->%.*s))",
                    dec_name.len, dec_name.str, field.name.len, field.name.str,
                    name.len, name.str));
    };

    dec = string_add(dec, tos2(";\n"));

    enc = string_add(
        enc, _STR("  cJSON_AddItemToObject(o,  \"%.*s\", %.*s(val.%.*s)); \n",
                  name.len, name.str, enc_name.len, enc_name.str, name.len,
                  name.str));
  };

  _PUSH(&p->cgen->fns, (_STR("%.*s return opt_ok(res); \n}", dec.len, dec.str)),
        tmp17, string);

  _PUSH(&p->cgen->fns,
        (_STR("/*enc start*/ %.*s return o;}", enc.len, enc.str)), tmp18,
        string);
}
bool is_js_prim(string typ) {

  return string_eq(typ, tos2("int")) || string_eq(typ, tos2("string")) ||
         string_eq(typ, tos2("bool")) || string_eq(typ, tos2("f32")) ||
         string_eq(typ, tos2("f64")) || string_eq(typ, tos2("i8")) ||
         string_eq(typ, tos2("i16")) || string_eq(typ, tos2("i32")) ||
         string_eq(typ, tos2("i64"));
}
string Parser_decode_array(Parser *p, string typ) {

  typ = string_replace(typ, tos2("array_"), tos2(""));

  Type *t = Table_find_type(&/* ? */ *p->table, typ);

  string fn_name = js_dec_name(typ);

  Parser_gen_json_for_type(p, *t);

  string s = tos2("");

  if (is_js_prim(typ)) {
    /*if*/

    s = _STR("%.*s val= %.*s(jsval); ", typ.len, typ.str, fn_name.len,
             fn_name.str);

  } else {
    /*else if*/

    s = _STR("  %.*s val; %.*s(jsval, &val); ", typ.len, typ.str, fn_name.len,
             fn_name.str);
  };

  return _STR("\n*res = new_array(0, 0, sizeof(%.*s));\nconst cJSON *jsval = "
              "NULL;\ncJSON_ArrayForEach(jsval, root)\n{\n%.*s \n  "
              "array__push(res, &val);\n}\n",
              typ.len, typ.str, s.len, s.str);
}
string js_enc_name(string typ) {

  string name = _STR("json__jsencode_%.*s", typ.len, typ.str);

  return name;
}
string js_dec_name(string typ) {

  string name = _STR("json__jsdecode_%.*s", typ.len, typ.str);

  return name;
}
string Parser_encode_array(Parser *p, string typ) {

  typ = string_replace(typ, tos2("array_"), tos2(""));

  string fn_name = js_enc_name(typ);

  return _STR(
      "\no = cJSON_CreateArray();\nfor (int i = 0; i < val.len; i++){\n  "
      "cJSON_AddItemToArray(o, %.*s(  ((%.*s*)val.data)[i]  ));\n} \n",
      fn_name.len, fn_name.str, typ.len, typ.str);
}
string vtmp_path() { return string_add(os__home_dir(), tos2("/.vlang/")); }
int main(int argc, char **argv) {
  init_consts();
  os__args = os__init_os_args(argc, argv);

  array_string args = os__args;

  if (_IN(string, tos2("-v"), args) || _IN(string, tos2("version"), args)) {
    /*if*/

    println(_STR("V %.*s", main__Version.len, main__Version.str));

    return 0;
  };

  if (_IN(string, tos2("-h"), args) || _IN(string, tos2("--help"), args) ||
      _IN(string, tos2("help"), args)) {
    /*if*/

    println(main__HelpText);

    return 0;
  };

  if (_IN(string, tos2("translate"), args)) {
    /*if*/

    println(tos2("Translating C to V will be available in V 0.3"));

    return 0;
  };

  if (!os__file_exists(main__TmpPath)) {
    /*if*/

    os__mkdir(main__TmpPath);
  };

  if (array_string_contains(args, tos2("fmt"))) {
    /*if*/

    string file = *(string *)array_last(args);

    if (!os__file_exists(file)) {
      /*if*/

      println(_STR("\"%.*s\" does not exist", file.len, file.str));

      v_exit(1);
    };

    if (!string_ends_with(file, tos2(".v"))) {
      /*if*/

      println(tos2("v fmt can only be used on .v files"));

      v_exit(1);
    };

    println(tos2("vfmt is temporarily disabled"));

    return 0;
  };

  if (args.len < 2 ||
      (/*lpar*/ args.len == 2 &&
       string_eq((*(string *)array__get(args, 1)), tos2("-")))) {
    /*if*/

    run_repl();

    return 0;
  };

  V *c = new_v(args);

  if (c->is_verbose) {
    /*if*/

    println(array_string_str(args));
  };

  if (array_string_contains(args, tos2("doc"))) {
    /*if*/

    v_exit(0);
  };

  V_compile(c);
}
void V_compile(V *c) {

  CGen *cgen = c->cgen;

  CGen_genln(cgen, tos2("// Generated by V"));

  V_add_user_v_files(c);

  if (c->is_verbose) {
    /*if*/

    println(tos2("all .v files:"));

    println(array_string_str(c->files));
  };

  array_string tmp7 = c->files;
  ;
  for (int tmp8 = 0; tmp8 < tmp7.len; tmp8++) {
    string file = ((string *)tmp7.data)[tmp8];

    Parser p = V_new_parser(c, file, RUN_DECLS);

    Parser_parse(&/* ? */ p);
  };

  cgen->run = RUN_MAIN;

  if (c->is_play) {
    /*if*/

    CGen_genln(cgen, tos2("#define VPLAY (1) "));
  };

  CGen_genln(
      cgen,
      tos2(
          "   \n#include <stdio.h>  // TODO remove all these includes, define "
          "all function signatures and types manually \n#include "
          "<stdlib.h>\n#include <signal.h>\n#include <stdarg.h> // for va_list "
          "\n#include <inttypes.h>  // int64_t etc \n\n\n#ifdef __linux__ "
          "\n#include <pthread.h> \n#endif \n\n\n#ifdef __APPLE__ \n\n#endif "
          "\n\n\n#ifdef _WIN32 \n#include <windows.h>\n//#include <WinSock2.h> "
          "\n#endif \n\n//================================== TYPEDEFS "
          "================================*/ \n\ntypedef unsigned char "
          "byte;\ntypedef unsigned int uint;\ntypedef int64_t i64;\ntypedef "
          "int32_t i32;\ntypedef int16_t i16;\ntypedef int8_t i8;\ntypedef "
          "uint64_t u64;\ntypedef uint32_t u32;\ntypedef uint16_t "
          "u16;\ntypedef uint8_t u8;\ntypedef uint32_t rune;\ntypedef float "
          "f32;\ntypedef double f64; \ntypedef unsigned char* "
          "byteptr;\ntypedef int* intptr;\ntypedef void* voidptr;\ntypedef "
          "struct array array;\ntypedef struct map map;\ntypedef array "
          "array_string; \ntypedef array array_int; \ntypedef array "
          "array_byte; \ntypedef array array_uint; \ntypedef array "
          "array_float; \ntypedef map map_int; \ntypedef map map_string; "
          "\n#ifndef bool\n	typedef int bool;\n	#define true "
          "1\n	#define false 0\n#endif\n\n//============================== "
          "HELPER C MACROS =============================*/ \n\n#define "
          "_PUSH(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); "
          "array__push(arr, &tmp);}\n#define _IN(typ, val, arr) "
          "array_##typ##_contains(arr, val) \n#define ALLOC_INIT(type, ...) "
          "(type *)memdup((type[]){ __VA_ARGS__ }, sizeof(type)) \n#define "
          "UTF8_CHAR_LEN( byte ) (( 0xE5000000 >> (( byte >> 3 ) & 0x1e )) & 3 "
          ") + 1 \n\n//================================== GLOBALS "
          "=================================*/   \n//int V_ZERO = 0; \nbyteptr "
          "g_str_buf; \nint load_so(byteptr);\nvoid reload_so();\nvoid "
          "init_consts();"));

  bool imports_json = array_string_contains(c->table->imports, tos2("json"));

  if (c->os == MAC &&
      (/*lpar*/ (/*lpar*/ c->build_mode == EMBED_VLIB &&
                 array_string_contains(c->table->imports, tos2("ui"))) ||
       (/*lpar*/ c->build_mode == BUILD &&
        string_contains(c->dir, tos2("/ui"))))) {
    /*if*/

    CGen_genln(cgen, tos2("id defaultFont = 0; // main.v"));
  };

  if (imports_json && c->build_mode == EMBED_VLIB ||
      (/*lpar*/ c->build_mode == BUILD &&
       string_contains(c->out_name, tos2("json.o")))) {
    /*if*/

    CGen_genln(cgen, tos2("#include \"cJSON.c\" "));
  };

  if (c->build_mode == DEFAULT_MODE) {
    /*if*/

    if (imports_json) {
      /*if*/

      CGen_genln(cgen, tos2("#include \"cJSON.h\""));
    };
  };

  if (c->build_mode == EMBED_VLIB || c->build_mode == DEFAULT_MODE) {
    /*if*/

    CGen_genln(cgen, tos2("int g_test_ok = 1; "));

    if (array_string_contains(c->table->imports, tos2("json"))) {
      /*if*/

      CGen_genln(cgen,
                 tos2(" \n#define js_get(object, key) "
                      "cJSON_GetObjectItemCaseSensitive((object), (key))\n"));
    };
  };

  if (array_string_contains(os__args, tos2("-debug_alloc"))) {
    /*if*/

    CGen_genln(cgen, tos2("#define DEBUG_ALLOC 1"));
  };

  CGen_genln(cgen, tos2("/*================================== FNS "
                        "=================================*/"));

  CGen_genln(cgen, tos2("this line will be replaced with definitions"));

  int defs_pos = cgen->lines.len - 1;

  array_string tmp12 = c->files;
  ;
  for (int tmp13 = 0; tmp13 < tmp12.len; tmp13++) {
    string file = ((string *)tmp12.data)[tmp13];

    Parser p = V_new_parser(c, file, RUN_MAIN);

    Parser_parse(&/* ? */ p);

    if (!c->nofmt && !string_contains(file, tos2("/vlib/"))) {
      /*if*/
    };
  };

  V_log(&/* ? */ *c, tos2("Done parsing."));

  StringBuilder d = new_string_builder(10000);

  StringBuilder_writeln(&/* ? */ d, array_string_join_lines(cgen->includes));

  StringBuilder_writeln(&/* ? */ d, array_string_join_lines(cgen->typedefs));

  StringBuilder_writeln(&/* ? */ d, array_string_join_lines(cgen->types));

  StringBuilder_writeln(&/* ? */ d, tos2("\nstring _STR(const char*, ...);\n"));

  StringBuilder_writeln(&/* ? */ d,
                        tos2("\nstring _STR_TMP(const char*, ...);\n"));

  StringBuilder_writeln(&/* ? */ d, array_string_join_lines(cgen->fns));

  StringBuilder_writeln(&/* ? */ d, array_string_join_lines(cgen->consts));

  StringBuilder_writeln(&/* ? */ d, array_string_join_lines(cgen->thread_args));

  if (c->is_prof) {
    /*if*/

    StringBuilder_writeln(&/* ? */ d, tos2("; // Prof counters:"));

    StringBuilder_writeln(&/* ? */ d, V_prof_counters(c));
  };

  string dd = StringBuilder_str(d);

  array_set(&/* ? */ cgen->lines, defs_pos,
            &/*11 EXP:"void*" GOT:"string" */ dd);

  if (c->build_mode == DEFAULT_MODE || c->build_mode == EMBED_VLIB) {
    /*if*/

    CGen_genln(cgen, _STR("void init_consts() { g_str_buf=malloc(1000); %.*s }",
                          array_string_join_lines(cgen->consts_init).len,
                          array_string_join_lines(cgen->consts_init).str));

    CGen_genln(
        cgen,
        tos2(
            "\nstring _STR(const char *fmt, ...) {\n	va_list "
            "argptr;\n	va_start(argptr, fmt);\n	size_t len = "
            "vsnprintf(0, 0, fmt, argptr) + 1;  \n	"
            "va_end(argptr);\n	byte* buf = malloc(len);  \n	"
            "va_start(argptr, fmt);\n	vsprintf(buf, fmt, argptr);\n	"
            "va_end(argptr);\n#ifdef DEBUG_ALLOC \n	puts(\"_STR:\"); "
            "\n	puts(buf); \n#endif \n	return tos2(buf);\n}\n\nstring "
            "_STR_TMP(const char *fmt, ...) {\n	va_list argptr;\n	"
            "va_start(argptr, fmt);\n	size_t len = vsnprintf(0, 0, fmt, "
            "argptr) + 1;  \n	va_end(argptr);\n	va_start(argptr, "
            "fmt);\n	vsprintf(g_str_buf, fmt, argptr);\n	"
            "va_end(argptr);\n#ifdef DEBUG_ALLOC \n	//puts(\"_STR_TMP:\"); "
            "\n	//puts(g_str_buf); \n#endif \n	return "
            "tos2(g_str_buf);\n}\n\n"));
  };

  if (c->build_mode != BUILD) {
    /*if*/

    if (!Table_main_exists(&/* ? */ *c->table) && !c->is_test) {
      /*if*/

      if (c->is_script) {
        /*if*/

        CGen_genln(cgen, _STR("int main() { %.*s; return 0; }",
                              cgen->fn_main.len, cgen->fn_main.str));

      } else {
        /*else if*/

        println(
            tos2("panic: function `main` is undeclared in the main module"));
      };

    } else if (c->is_test) {
      /*if*/

      CGen_genln(cgen, tos2("int main() { init_consts();"));

      array_Fn tmp17 = c->table->fns;
      ;
      for (int tmp18 = 0; tmp18 < tmp17.len; tmp18++) {
        Fn v = ((Fn *)tmp17.data)[tmp18];

        if (string_starts_with(v.name, tos2("test_"))) {
          /*if*/

          CGen_genln(cgen, _STR("%.*s();", v.name.len, v.name.str));
        };
      };

      CGen_genln(cgen, tos2("return g_test_ok == 0; }"));
    };
  };

  if (c->is_live) {
    /*if*/

    CGen_genln(cgen,
               tos2(" int load_so(byteptr path) {\n	 printf(\"load_so "
                    "%s\\n\", path); dlclose(live_lib); live_lib = "
                    "dlopen(path, RTLD_LAZY);\n	 if (!live_lib) {puts(\"open "
                    "failed\"); exit(1); return 0;}\n	 "));

    array_string tmp19 = cgen->so_fns;
    ;
    for (int tmp20 = 0; tmp20 < tmp19.len; tmp20++) {
      string so_fn = ((string *)tmp19.data)[tmp20];

      CGen_genln(cgen, _STR("%.*s = dlsym(live_lib, \"%.*s\");  ", so_fn.len,
                            so_fn.str, so_fn.len, so_fn.str));
    };

    CGen_genln(cgen, tos2("return 1; }"));
  };

  CGen_save(cgen);

  if (c->is_verbose) {
    /*if*/

    V_log(&/* ? */ *c, tos2("flags="));

    println(array_string_str(c->table->flags));
  };

  V_cc(c);

  if (c->is_test || c->is_run) {
    /*if*/

    if (1 || c->is_verbose) {
      /*if*/

      println(_STR("============ running %.*s ============", c->out_name.len,
                   c->out_name.str));
    };

    string cmd = (string_starts_with(c->out_name, tos2("/")))
                     ? (c->out_name)
                     : (string_add(tos2("./"), c->out_name));

    if (os__args.len > 3) {
      /*if*/

      cmd = string_add(string_add(cmd, tos2(" ")),
                       array_string_join(array_right(os__args, 3), tos2(" ")));
    };

    int ret = os__system(cmd);

    if (ret != 0) {
      /*if*/

      string s = os__exec(cmd);

      println(s);

      println(tos2("ret not 0, exiting"));

      v_exit(1);
    };
  };
}
void V_cc(V *c) {

  bool linux_host = string_eq(os__user_os(), tos2("linux"));

  V_log(&/* ? */ *c, _STR("cc() isprod=%d outname=%.*s", c->is_prod,
                          c->out_name.len, c->out_name.str));

  array_string a =
      new_array_from_c_array(1, 1, sizeof(string), (string[]){tos2("-w")});

  string flags = array_string_join(c->table->flags, tos2(" "));

  if (c->is_prod) {
    /*if*/

    _PUSH(&a, (tos2("-O2")), tmp27, string);

  } else {
    /*else if*/

    _PUSH(&a, (tos2("-g")), tmp28, string);
  };

  string libs = tos2("");

  if (c->build_mode == BUILD) {
    /*if*/

    _PUSH(&a, (tos2("-c")), tmp30, string);

  } else if (c->build_mode == EMBED_VLIB) {
    /*if*/

  } else if (c->build_mode == DEFAULT_MODE) {
    /*if*/

    libs = _STR("%.*s/vlib/builtin.o", main__TmpPath.len, main__TmpPath.str);

    if (!os__file_exists(libs)) {
      /*if*/

      println(tos2("`builtin.o` not found"));

      v_exit(1);
    };

    array_string tmp31 = c->table->imports;
    ;
    for (int tmp32 = 0; tmp32 < tmp31.len; tmp32++) {
      string imp = ((string *)tmp31.data)[tmp32];

      if (string_eq(imp, tos2("webview"))) {
        /*if*/

        continue;
      };

      libs = string_add(libs, _STR(" %.*s/vlib/%.*s.o", main__TmpPath.len,
                                   main__TmpPath.str, imp.len, imp.str));
    };
  };

  if (c->sanitize) {
    /*if*/

    _PUSH(&a, (tos2("-fsanitize=leak")), tmp33, string);
  };

  string sysroot = tos2("/Users/alex/tmp/lld/linuxroot/");

  if (c->os == LINUX && !linux_host) {
    /*if*/

    _PUSH(&a,
          (_STR("-c --sysroot=%.*s -target x86_64-linux-gnu", sysroot.len,
                sysroot.str)),
          tmp35, string);

    if (!string_ends_with(c->out_name, tos2(".o"))) {
      /*if*/

      c->out_name = string_add(c->out_name, tos2(".o"));
    };
  };

  _PUSH(&a, (_STR("-o %.*s", c->out_name.len, c->out_name.str)), tmp36, string);

  _PUSH(&a,
        (_STR("%.*s/%.*s", main__TmpPath.len, main__TmpPath.str,
              c->out_name_c.len, c->out_name_c.str)),
        tmp37, string);

  if (c->os == MAC) {
    /*if*/

    _PUSH(&a, (tos2("-mmacosx-version-min=10.7")), tmp38, string);
  };

  _PUSH(&a, (flags), tmp39, string);

  _PUSH(&a, (libs), tmp40, string);

  if (c->os == MAC) {
    /*if*/

    _PUSH(&a, (tos2("-x objective-c")), tmp41, string);
  };

  if (c->os == LINUX && c->build_mode != BUILD) {
    /*if*/

    _PUSH(&a, (tos2("-lm -ldl -lpthread")), tmp42, string);
  };

  string fast_clang = tos2("/usr/local/Cellar/llvm/8.0.0/bin/clang");

  string args = array_string_join(a, tos2(" "));

  string cmd = (os__file_exists(fast_clang))
                   ? (_STR("%.*s -I. %.*s", fast_clang.len, fast_clang.str,
                           args.len, args.str))
                   : (_STR("cc -I. %.*s", args.len, args.str));

  if (c->show_c_cmd || c->is_verbose) {
    /*if*/

    println(_STR("\n==========\n%.*s\n=========\n", cmd.len, cmd.str));
  };

  string res = os__exec(cmd);

  if (string_contains(res, tos2("error: "))) {
    /*if*/

    println(res);

    v_panic(tos2("clang error"));
  };

  if (c->os == LINUX && !linux_host && c->build_mode != BUILD) {
    /*if*/

    c->out_name = string_replace(c->out_name, tos2(".o"), tos2(""));

    string obj_file = string_add(c->out_name, tos2(".o"));

    println(_STR("linux obj_file=%.*s out_name=%.*s", obj_file.len,
                 obj_file.str, c->out_name.len, c->out_name.str));

    string ress = os__exec(string_add(
        string_add(
            string_add(
                string_add(
                    string_add(
                        string_add(
                            string_add(
                                string_add(_STR("/usr/local/Cellar/llvm/8.0.0/"
                                                "bin/ld.lld --sysroot=%.*s ",
                                                sysroot.len, sysroot.str),
                                           _STR("-v -o %.*s ", c->out_name.len,
                                                c->out_name.str)),
                                tos2("-m elf_x86_64 -dynamic-linker "
                                     "/lib64/ld-linux-x86-64.so.2 ")),
                            tos2("/usr/lib/x86_64-linux-gnu/crt1.o ")),
                        _STR("%.*s/lib/x86_64-linux-gnu/libm-2.28.a ",
                             sysroot.len, sysroot.str)),
                    tos2("/usr/lib/x86_64-linux-gnu/crti.o ")),
                obj_file),
            tos2(" /usr/lib/x86_64-linux-gnu/libc.so ")),
        tos2("/usr/lib/x86_64-linux-gnu/crtn.o")));

    println(ress);

    if (string_contains(ress, tos2("error:"))) {
      /*if*/

      v_exit(1);
    };

    println(_STR("linux cross compilation done. resulting binary: \"%.*s\"",
                 c->out_name.len, c->out_name.str));
  };
}
array_string V_v_files_from_dir(V *c, string dir) {

  array_string res = new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  if (!os__file_exists(dir)) {
    /*if*/

    v_panic(_STR("%.*s doesn\'t exist", dir.len, dir.str));

  } else if (!os__dir_exists(dir)) {
    /*if*/

    v_panic(_STR("%.*s isn\'t a directory", dir.len, dir.str));
  };

  array_string files = os__ls(dir);

  if (c->is_verbose) {
    /*if*/

    println(_STR("v_files_from_dir (\"%.*s\")", dir.len, dir.str));
  };

  array_string_sort(&/* ? */ files);

  array_string tmp51 = files;
  ;
  for (int tmp52 = 0; tmp52 < tmp51.len; tmp52++) {
    string file = ((string *)tmp51.data)[tmp52];

    V_log(&/* ? */ *c, _STR("F=%.*s", file.len, file.str));

    if (!string_ends_with(file, tos2(".v")) &&
        !string_ends_with(file, tos2(".vh"))) {
      /*if*/

      continue;
    };

    if (string_ends_with(file, tos2("_test.v"))) {
      /*if*/

      continue;
    };

    if (string_ends_with(file, tos2("_win.v")) && c->os != WINDOWS) {
      /*if*/

      continue;
    };

    if (string_ends_with(file, tos2("_lin.v")) && c->os != LINUX) {
      /*if*/

      continue;
    };

    if (string_ends_with(file, tos2("_mac.v")) && c->os != MAC) {
      /*if*/

      string lin_file = string_replace(file, tos2("_mac.v"), tos2("_lin.v"));

      if (os__file_exists(_STR("%.*s/%.*s", dir.len, dir.str, lin_file.len,
                               lin_file.str))) {
        /*if*/

        continue;

      } else if (c->os == WINDOWS) {
        /*if*/

        continue;

      } else {
        /*else if*/
      };
    };

    _PUSH(&res, (_STR("%.*s/%.*s", dir.len, dir.str, file.len, file.str)),
          tmp54, string);
  };

  return res;
}
void V_add_user_v_files(V *c) {

  string dir = c->dir;

  V_log(&/* ? */ *c, _STR("add_v_files(%.*s)", dir.len, dir.str));

  array_string user_files =
      new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  bool is_test_with_imports = string_ends_with(dir, tos2("_test.v")) &&
                              (/*lpar*/ string_contains(dir, tos2("/volt")) ||
                               string_contains(dir, tos2("/c2volt")));

  if (is_test_with_imports) {
    /*if*/

    _PUSH(&user_files, (dir), tmp58, string);

    int pos = string_last_index(dir, tos2("/"));

    dir = string_add(string_left(dir, pos), tos2("/"));
  };

  if (string_ends_with(dir, tos2(".v"))) {
    /*if*/

    _PUSH(&user_files, (dir), tmp60, string);

    dir = string_all_before(dir, tos2("/"));

  } else {
    /*else if*/

    array_string files = V_v_files_from_dir(&/* ? */ *c, dir);

    array_string tmp62 = files;
    ;
    for (int tmp63 = 0; tmp63 < tmp62.len; tmp63++) {
      string file = ((string *)tmp62.data)[tmp63];

      _PUSH(&user_files, (file), tmp64, string);
    };
  };

  if (user_files.len == 0) {
    /*if*/

    println(tos2("No input .v files"));

    v_exit(1);
  };

  if (c->is_verbose) {
    /*if*/

    V_log(&/* ? */ *c, tos2("user_files:"));

    println(array_string_str(user_files));
  };

  array_string tmp65 = user_files;
  ;
  for (int tmp66 = 0; tmp66 < tmp65.len; tmp66++) {
    string file = ((string *)tmp65.data)[tmp66];

    Parser p = V_new_parser(c, file, RUN_IMPORTS);

    Parser_parse(&/* ? */ p);
  };

  if (c->build_mode == DEFAULT_MODE) {
    /*if*/

    for (int i = 0; i < c->table->imports.len; i++) {

      string pkg = (*(string *)array__get(c->table->imports, i));

      array_string vfiles = V_v_files_from_dir(
          &/* ? */ *c, _STR("%.*s/vlib/%.*s", main__TmpPath.len,
                            main__TmpPath.str, pkg.len, pkg.str));

      array_string tmp73 = vfiles;
      ;
      for (int tmp74 = 0; tmp74 < tmp73.len; tmp74++) {
        string file = ((string *)tmp73.data)[tmp74];

        Parser p = V_new_parser(c, file, RUN_IMPORTS);

        Parser_parse(&/* ? */ p);
      };
    };

  } else {
    /*else if*/

    for (int i = 0; i < c->table->imports.len; i++) {

      string pkg = (*(string *)array__get(c->table->imports, i));

      array_string vfiles = V_v_files_from_dir(
          &/* ? */ *c, _STR("%.*s/%.*s", c->lang_dir.len, c->lang_dir.str,
                            pkg.len, pkg.str));

      array_string tmp81 = vfiles;
      ;
      for (int tmp82 = 0; tmp82 < tmp81.len; tmp82++) {
        string file = ((string *)tmp81.data)[tmp82];

        Parser p = V_new_parser(c, file, RUN_IMPORTS);

        Parser_parse(&/* ? */ p);
      };
    };
  };

  if (c->is_verbose) {
    /*if*/

    V_log(&/* ? */ *c, tos2("imports:"));

    println(array_string_str(c->table->imports));
  };

  array_string tmp84 = c->table->imports;
  ;
  for (int tmp85 = 0; tmp85 < tmp84.len; tmp85++) {
    string pkg = ((string *)tmp84.data)[tmp85];

    string module_path =
        _STR("%.*s/%.*s", c->lang_dir.len, c->lang_dir.str, pkg.len, pkg.str);

    if (c->build_mode == DEFAULT_MODE || c->build_mode == BUILD) {
      /*if*/

      module_path = _STR("%.*s/vlib/%.*s", main__TmpPath.len, main__TmpPath.str,
                         pkg.len, pkg.str);
    };

    array_string vfiles = V_v_files_from_dir(&/* ? */ *c, module_path);

    array_string tmp88 = vfiles;
    ;
    for (int tmp89 = 0; tmp89 < tmp88.len; tmp89++) {
      string vfile = ((string *)tmp88.data)[tmp89];

      _PUSH(&c->files, (vfile), tmp90, string);
    };
  };

  array_string tmp91 = user_files;
  ;
  for (int tmp92 = 0; tmp92 < tmp91.len; tmp92++) {
    string file = ((string *)tmp91.data)[tmp92];

    _PUSH(&c->files, (file), tmp93, string);
  };
}
string get_arg(string joined_args, string arg, string def) {

  string key = _STR("-%.*s ", arg.len, arg.str);

  int pos = string_index(joined_args, key);

  if (pos == -1) {
    /*if*/

    return def;
  };

  pos = pos + key.len;

  int space = string_index_after(joined_args, tos2(" "), pos);

  if (space == -1) {
    /*if*/

    space = joined_args.len;
  };

  string res = string_substr(joined_args, pos, space);

  return res;
}
void V_log(V *c, string s) {

  if (!c->is_verbose) {
    /*if*/

    return;
  };

  println(s);
}
V *new_v(array_string args) {

  string dir = *(string *)array_last(args);

  if (array_string_contains(args, tos2("run"))) {
    /*if*/

    dir = (*(string *)array__get(args, 2));
  };

  if (args.len < 2) {
    /*if*/

    dir = tos2("");
  };

  string joined_args = array_string_join(args, tos2(" "));

  string target_os = get_arg(joined_args, tos2("os"), tos2(""));

  string out_name = get_arg(joined_args, tos2("o"), tos2("a.out"));

  BuildMode build_mode = DEFAULT_MODE;

  if (array_string_contains(args, tos2("-lib"))) {
    /*if*/

    build_mode = BUILD;

    string base = string_all_after(dir, tos2("/"));

    println(_STR("Building module %.*s...", base.len, base.str));

    out_name = _STR("%.*s/vlib/%.*s.o", main__TmpPath.len, main__TmpPath.str,
                    base.len, base.str);

    if (string_ne(target_os, os__user_os())) {
      /*if*/

      os__mkdir(_STR("%.*s/vlib/%.*s", main__TmpPath.len, main__TmpPath.str,
                     target_os.len, target_os.str));

      out_name =
          _STR("%.*s/vlib/%.*s/%.*s.o", main__TmpPath.len, main__TmpPath.str,
               target_os.len, target_os.str, base.len, base.str);

      println(_STR("Cross compiling %.*s", out_name.len, out_name.str));
    };

  } else if (!array_string_contains(args, tos2("-embed_vlib"))) {
    /*if*/

    build_mode = EMBED_VLIB;
  };

  bool is_test = string_ends_with(dir, tos2("_test.v"));

  bool is_script = string_ends_with(dir, tos2(".v"));

  if (is_script && !os__file_exists(dir)) {
    /*if*/

    println(_STR("`%.*s` does not exist", dir.len, dir.str));

    v_exit(1);
  };

  if (string_eq(out_name, tos2("a.out")) && string_ends_with(dir, tos2(".v"))) {
    /*if*/

    out_name = string_left(dir, dir.len - 2);
  };

  if (string_eq(dir, tos2(".")) && string_eq(out_name, tos2("a.out"))) {
    /*if*/

    string base = string_all_after(os__getwd(), tos2("/"));

    out_name = string_trim_space(base);
  };

  Os _os = MAC;

  if (string_eq(target_os, tos2(""))) {
    /*if*/

#ifdef __linux__

    _os = LINUX;

#endif
    ;

#ifdef __APPLE__

    _os = MAC;

#endif
    ;

#ifdef _WIN32

    _os = WINDOWS;

#endif
    ;

  } else {
    /*else if*/

    if (string_eq(target_os, tos2("linux"))) { /* case */

      _os = LINUX;

    } else if (string_eq(target_os, tos2("windows"))) { /* case */

      _os = WINDOWS;

    } else if (string_eq(target_os, tos2("mac"))) { /* case */

      _os = MAC;
    };
  };

  array_string builtins = new_array_from_c_array(8, 8, sizeof(string),
                                                 (string[]){
                                                     tos2("array.v"),
                                                     tos2("string.v"),
                                                     tos2("builtin.v"),
                                                     tos2("int.v"),
                                                     tos2("utf8.v"),
                                                     tos2("map.v"),
                                                     tos2("option.v"),
                                                     tos2("string_builder.v"),
                                                 });

  string lang_dir = tos2("");

  while (1) {
    string vroot_path = string_add(main__TmpPath, tos2("/VROOT"));

    if (os__file_exists(vroot_path)) {
      /*if*/

      Option_string tmp113 = os__read_file(vroot_path);
      if (!tmp113.ok) {

        break;
      }
      string vroot = *(string *)tmp113.data;
      ;

      vroot = string_trim_space(vroot);

      if (os__dir_exists(vroot) &&
          os__dir_exists(string_add(vroot, tos2("/builtin")))) {
        /*if*/

        lang_dir = vroot;
      };
    };

    break;
  };

  if (string_eq(lang_dir, tos2(""))) {
    /*if*/

    println(tos2("Looks like you are running V for the first time."));

    string cur_dir = os__getwd();

    lang_dir = string_all_before_last(cur_dir, tos2("/"));

    if (os__dir_exists(_STR("%.*s/builtin", lang_dir.len, lang_dir.str))) {
      /*if*/

      println(_STR("Setting VROOT to \"%.*s\".", lang_dir.len, lang_dir.str));

      os__write_file(string_add(main__TmpPath, tos2("/VROOT")), lang_dir);

    } else {
      /*else if*/

      println(tos2("V repo not found. Cloning..."));

      os__mv(tos2("v"), tos2("v.bin"));

      os__exec(tos2("git clone https://github.com/vlang/v"));

      if (!os__dir_exists(tos2("v"))) {
        /*if*/

        println(tos2("failed to clone github.com/vlang/v"));

        v_exit(1);
      };

      os__mv(tos2("v.bin"), tos2("v/compiler/v"));

      println(tos2("Re-launch V from v/compiler"));

      v_exit(1);
    };
  };

  string out_name_c =
      string_add(string_all_after(out_name, tos2("/")), tos2(".c"));

  array_string files =
      new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  if (!string_contains(out_name, tos2("builtin.o"))) {
    /*if*/

    array_string tmp117 = builtins;
    ;
    for (int tmp118 = 0; tmp118 < tmp117.len; tmp118++) {
      string builtin = ((string *)tmp117.data)[tmp118];

      string f = _STR("%.*s/builtin/%.*s", lang_dir.len, lang_dir.str,
                      builtin.len, builtin.str);

      if (build_mode == DEFAULT_MODE || build_mode == BUILD) {
        /*if*/

        f = _STR("%.*s/vlib/builtin/%.*sh", main__TmpPath.len,
                 main__TmpPath.str, builtin.len, builtin.str);
      };

      _PUSH(&files, (f), tmp120, string);
    };
  };

  bool obfuscate = array_string_contains(args, tos2("-obf"));

  return ALLOC_INIT(
      V, {
             .os = _os,
             .out_name = out_name,
             .files = files,
             .dir = dir,
             .lang_dir = lang_dir,
             .table = new_table(obfuscate),
             .out_name = out_name,
             .out_name_c = out_name_c,
             .is_test = is_test,
             .is_script = is_script,
             .is_so = array_string_contains(args, tos2("-shared")),
             .is_play = array_string_contains(args, tos2("play")),
             .is_prod = array_string_contains(args, tos2("-prod")),
             .is_verbose = array_string_contains(args, tos2("-verbose")),
             .obfuscate = obfuscate,
             .is_prof = array_string_contains(args, tos2("-prof")),
             .is_live = array_string_contains(args, tos2("-live")),
             .sanitize = array_string_contains(args, tos2("-sanitize")),
             .nofmt = array_string_contains(args, tos2("-nofmt")),
             .show_c_cmd = array_string_contains(args, tos2("-show_c_cmd")),
             .translated = array_string_contains(args, tos2("translated")),
             .cgen = new_cgen(out_name_c),
             .build_mode = build_mode,
             .is_run = array_string_contains(args, tos2("run")),
             .is_repl = array_string_contains(args, tos2("-repl")),
             .vroot = lang_dir,
         });
}
array_string run_repl() {

#ifdef _WIN32

  println(tos2("REPL does not work on Windows yet, sorry!"));

  v_exit(1);

#endif
  ;

  println(_STR("V %.*s", main__Version.len, main__Version.str));

  println(tos2("Use Ctrl-D to exit"));

  println(tos2("For now you have to use println() to print values, this will "
               "be fixed soon\n"));

  string file = string_add(main__TmpPath, tos2("/vrepl.v"));

  array_string lines =
      new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  while (1) {
    v_print(tos2(">>> "));

    string line = os__get_raw_line();

    if (string_eq(string_trim_space(line), tos2("")) &&
        string_ends_with(line, tos2("\n"))) {
      /*if*/

      continue;
    };

    line = string_trim_space(line);

    if (string_eq(line, tos2(""))) {
      /*if*/

      break;
    };

    if (string_starts_with(line, tos2("print"))) {
      /*if*/

      string void_line =
          string_substr(line, string_index(line, tos2("(")) + 1, line.len - 1);

      _PUSH(&lines, (void_line), tmp126, string);

      string source_code = string_add(
          string_add(array_string_join(lines, tos2("\n")), tos2("\n")), line);

      os__write_file(file, source_code);

      V *v = new_v(new_array_from_c_array(
          3, 3, sizeof(string), (string[]){tos2("v"), tos2("-repl"), file}));

      V_compile(v);

      string s = os__exec(string_add(main__TmpPath, tos2("/vrepl")));

      println(s);

    } else {
      /*else if*/

      _PUSH(&lines, (line), tmp130, string);
    };
  };

  return lines;
}
Parser V_new_parser(V *c, string path, Pass run) {

  V_log(&/* ? */ *c, _STR("new_parser(\"%.*s\")", path.len, path.str));

  c->cgen->run = run;

  Parser p =
      (Parser){.file_path = path,
               .file_name = string_all_after(path, tos2("/")),
               .scanner = new_scanner(path),
               .table = c->table,
               .cur_fn = main__EmptyFn,
               .cgen = c->cgen,
               .is_test = c->is_test,
               .is_script = (/*lpar*/ c->is_script && string_eq(path, c->dir)),
               .is_so = c->is_so,
               .os = c->os,
               .is_prof = c->is_prof,
               .is_prod = c->is_prod,
               .is_play = c->is_play,
               .translated = c->translated,
               .obfuscate = c->obfuscate,
               .is_verbose = c->is_verbose,
               .build_mode = c->build_mode,
               .is_repl = c->is_repl,
               .run = run,
               .vroot = c->vroot,
               .token_idx = 0,
               .lit = tos("", 0),
               .pkg = tos("", 0),
               .inside_const = 0,
               .assigned_type = tos("", 0),
               .tmp_cnt = 0,
               .is_live = 0,
               .builtin_pkg = 0,
               .vh_lines = new_array(0, 1, sizeof(string)),
               .inside_if_expr = 0,
               .is_struct_init = 0,
               .if_expr_cnt = 0,
               .for_expr_cnt = 0,
               .ptr_cast = 0,
               .calling_c = 0,
               .returns = 0,
               .is_c_struct_init = 0,
               .can_chash = 0};

  Parser_next(&/* ? */ p);

  return p;
}
void Parser_next(Parser *p) {

  p->prev_tok2 = p->prev_tok;

  p->prev_tok = p->tok;

  ScanRes res = Scanner_scan(p->scanner);

  p->tok = res.tok;

  p->lit = res.lit;
}
void Parser_log(Parser *p, string s) {

  if (!p->is_verbose) {
    /*if*/

    return;
  };

  println(s);
}
void Parser_parse(Parser *p) {

  Parser_log(&/* ? */ *p, _STR("\nparse() run=%d file=%.*s tok=%.*s", p->run,
                               p->file_name.len, p->file_name.str,
                               Parser_strtok(&/* ? */ *p).len,
                               Parser_strtok(&/* ? */ *p).str));

  if (p->is_script || p->is_test) {
    /*if*/

    p->pkg = tos2("main");

    if (p->tok == PACKAGE) {
      /*if*/

      Parser_next(p);

      Parser_fgen(p, tos2("module "));

      p->pkg = Parser_check_name(p);
    };

  } else {
    /*else if*/

    Parser_check(p, PACKAGE);

    p->pkg = Parser_check_name(p);
  };

  Parser_fgenln(p, tos2("\n"));

  p->builtin_pkg = string_eq(p->pkg, tos2("builtin"));

  p->can_chash =
      string_eq(p->pkg, tos2("gg")) || string_eq(p->pkg, tos2("glm")) ||
      string_eq(p->pkg, tos2("gl")) || string_eq(p->pkg, tos2("http")) ||
      string_eq(p->pkg, tos2("glfw"));

  Table_register_package(p->table, p->pkg);

  if (p->run == RUN_IMPORTS) {
    /*if*/

    while (p->tok == IMPORT && Parser_peek(p) != CONST) {

      Parser_import_statement(p);
    };

    return;
  };

  while (1) {
    if ((p->tok == IMPORT)) { /* case */

      if (Parser_peek(p) == CONST) {
        /*if*/

        Parser_const_decl(p);

      } else {
        /*else if*/

        Parser_import_statement(p);
      };

    } else if ((p->tok == ENUM)) { /* case */

      Parser_next(p);

      if (p->tok == NAME) {
        /*if*/

        Parser_fgen(p, tos2("enum "));

        string name = Parser_check_name(p);

        Parser_fgen(p, tos2(" "));

        Parser_enum_decl(p, name);

      } else if (p->translated) {
        /*if*/

        Parser_enum_decl(p, tos2("int"));

      } else {
        /*else if*/

        Parser_check(p, NAME);
      };

    } else if ((p->tok == PUB)) { /* case */

      if (Parser_peek(p) == FUNC) {
        /*if*/

        Parser_fn_decl(p);

      } else if (Parser_peek(p) == STRUCT) {
        /*if*/

        Parser_error(p, tos2("structs can\'t be declared public *yet*"));

      } else {
        /*else if*/

        Parser_error(p, tos2("wrong pub keyword usage"));
      };

    } else if ((p->tok == FUNC)) { /* case */

      Parser_fn_decl(p);

    } else if ((p->tok == TIP)) { /* case */

      Parser_type_decl(p);

    } else if ((p->tok == STRUCT) || (p->tok == INTERFACE) ||
               (p->tok == UNION) || (p->tok == LSBR)) { /* case */

      Parser_struct_decl(p);

    } else if ((p->tok == CONST)) { /* case */

      Parser_const_decl(p);

    } else if ((p->tok == HASH)) { /* case */

      Parser_chash(p);

    } else if ((p->tok == DOLLAR)) { /* case */

      Parser_comp_time(p);

    } else if ((p->tok == GLOBAL)) { /* case */

      if (!p->translated && !p->builtin_pkg &&
          !Parser_building_v(&/* ? */ *p)) {
        /*if*/

        Parser_error(p, tos2("__global is only allowed in translated code"));
      };

      Parser_next(p);

      string name = Parser_check_name(p);

      string typ = Parser_get_type(p);

      Parser_register_global(p, name, typ);

      string g = Table_cgen_name_type_pair(&/* ? */ *p->table, name, typ);

      if (p->tok == ASSIGN) {
        /*if*/

        Parser_next(p);

        g = string_add(g, tos2(" = "));

        CGen_start_tmp(p->cgen);

        Parser_bool_expression(p);

        g = string_add(g, CGen_end_tmp(p->cgen));
      };

      g = string_add(g, tos2("; // global"));

      _PUSH(&p->cgen->consts, (g), tmp7, string);

    } else if ((p->tok == EOF)) { /* case */

      Parser_log(&/* ? */ *p, tos2("end of parse()"));

      if (p->is_script && !p->is_test) {
        /*if*/

        p->cur_fn = main__MainFn;

        Parser_check_unused_variables(p);
      };

      if (1 && !Parser_first_run(&/* ? */ *p) &&
          Parser_fileis(&/* ? */ *p, tos2("test"))) {
        /*if*/

        os__File out = os__create(tos2("/var/tmp/fmt.v"));

        os__File_appendln(out, StringBuilder_str(p->scanner->fmt_out));

        os__File_close(out);
      };

      return;

    } else { // default:

      if (p->is_script && !p->is_test) {
        /*if*/

        if (Parser_first_run(&/* ? */ *p)) {
          /*if*/

          if (string_eq(p->cur_fn->name, tos2(""))) {
            /*if*/

            p->cur_fn = main__MainFn;
          };

          return;
        };

        if (string_eq(p->cur_fn->name, tos2(""))) {
          /*if*/

          p->cur_fn = main__MainFn;

          if (p->is_repl) {
            /*if*/

            Fn_clear_vars(p->cur_fn);
          };
        };

        int start = p->cgen->lines.len;

        Parser_statement(p, 1);

        Parser_genln(p, tos2(""));

        int end = p->cgen->lines.len;

        array_string lines = array_slice(p->cgen->lines, start, end);

        p->cgen->fn_main =
            string_add(p->cgen->fn_main, array_string_join(lines, tos2("\n")));

        p->cgen->cur_line = tos2("");

        for (int i = start; i < end; i++) {
          string tmp13 = tos2("");

          array_set(&/*q*/ p->cgen->lines, i, &tmp13);
        };

      } else {
        /*else if*/

        Parser_error(p, _STR("unexpected token `%.*s`",
                             Parser_strtok(&/* ? */ *p).len,
                             Parser_strtok(&/* ? */ *p).str));
      };
    };
  };
}
void Parser_import_statement(Parser *p) {

  Parser_check(p, IMPORT);

  if (p->tok == LPAR) {
    /*if*/

    Parser_check(p, LPAR);

    while (p->tok != RPAR && p->tok != EOF) {

      string pkg = string_trim_space(p->lit);

      Parser_next(p);

      if (array_string_contains(p->table->imports, pkg)) {
        /*if*/

        continue;
      };

      _PUSH(&p->table->imports, (pkg), tmp15, string);

      Table_register_package(p->table, pkg);
    };

    Parser_check(p, RPAR);

    return;
  };

  if (p->tok != NAME) {
    /*if*/

    Parser_error(p, tos2("bad import format"));
  };

  string pkg = string_trim_space(p->lit);

  Parser_next(p);

  Parser_fgenln(p, string_add(tos2(" "), pkg));

  if (array_string_contains(p->table->imports, pkg)) {
    /*if*/

    return;
  };

  Parser_log(&/* ? */ *p, _STR("adding import %.*s", pkg.len, pkg.str));

  _PUSH(&p->table->imports, (pkg), tmp17, string);

  Table_register_package(p->table, pkg);
}
void Parser_const_decl(Parser *p) {

  bool is_import = p->tok == IMPORT;

  p->inside_const = 1;

  if (is_import) {
    /*if*/

    Parser_next(p);
  };

  Parser_check(p, CONST);

  Parser_fspace(p);

  Parser_check(p, LPAR);

  Parser_fgenln(p, tos2(""));

  p->scanner->fmt_indent++;

  while (p->tok == NAME) {

    string name = Parser_check_name(p);

    if (p->is_play &&
        !(/*lpar*/ string_at(name, 0) >= 'A' && string_at(name, 0) <= 'Z')) {
      /*if*/

      Parser_error(p, tos2("const name must be capitalized"));
    };

    if (!is_import) {
      /*if*/

      name = Parser_prepend_pkg(&/* ? */ *p, name);
    };

    string typ = tos2("int");

    if (!is_import) {
      /*if*/

      Parser_check_space(p, ASSIGN);

      typ = Parser_expression(p);
    };

    if (Parser_first_run(&/* ? */ *p) && !is_import &&
        Table_known_const(&/* ? */ *p->table, name)) {
      /*if*/

      Parser_error(p, _STR("redefinition of `%.*s`", name.len, name.str));
    };

    Table_register_const(p->table, name, typ, p->pkg, is_import);

    if (p->run == RUN_MAIN && !is_import) {
      /*if*/

      if (is_compile_time_const(p->cgen->cur_line)) {
        /*if*/

        _PUSH(&p->cgen->consts,
              (_STR("#define %.*s %.*s", name.len, name.str,
                    p->cgen->cur_line.len, p->cgen->cur_line.str)),
              tmp25, string);

        p->cgen->cur_line = tos2("");

        Parser_fgenln(p, tos2(""));

        continue;
      };

      if (string_starts_with(typ, tos2("["))) {
        /*if*/

        _PUSH(&p->cgen->consts,
              (string_add(
                  Table_cgen_name_type_pair(&/* ? */ *p->table, name, typ),
                  _STR(" = %.*s;", p->cgen->cur_line.len,
                       p->cgen->cur_line.str))),
              tmp26, string);

      } else {
        /*else if*/

        _PUSH(&p->cgen->consts,
              (string_add(
                  Table_cgen_name_type_pair(&/* ? */ *p->table, name, typ),
                  tos2(";"))),
              tmp27, string);

        _PUSH(&p->cgen->consts_init,
              (_STR("%.*s = %.*s;", name.len, name.str, p->cgen->cur_line.len,
                    p->cgen->cur_line.str)),
              tmp28, string);
      };

      p->cgen->cur_line = tos2("");
    };

    Parser_fgenln(p, tos2(""));
  };

  p->scanner->fmt_indent--;

  Parser_check(p, RPAR);

  Parser_fgenln(p, tos2("\n"));

  p->inside_const = 0;
}
void Parser_type_decl(Parser *p) {

  Parser_check(p, TIP);

  string name = Parser_check_name(p);

  string parent = Parser_get_type(p);

  string nt_pair = Table_cgen_name_type_pair(&/* ? */ *p->table, name, parent);

  string _struct = (!string_contains(parent, tos2("[")) &&
                    !string_starts_with(parent, tos2("fn ")) &&
                    !Table_known_type(&/* ? */ *p->table, parent))
                       ? (tos2("struct"))
                       : (tos2(""));

  Parser_gen_typedef(
      p, _STR("typedef %.*s %.*s; // type alias name=\"%.*s\" parent=\"%.*s\"",
              _struct.len, _struct.str, nt_pair.len, nt_pair.str, name.len,
              name.str, parent.len, parent.str));

  Table_register_type_with_parent(p->table, name, parent);
}
void Parser_struct_decl(Parser *p) {

  string objc_parent = tos2("");

  bool is_objc = 0;

  if (p->tok == LSBR) {
    /*if*/

    Parser_check(p, LSBR);

    is_objc = p->tok == INTERFACE;

    Parser_next(p);

    if (is_objc) {
      /*if*/

      Parser_check(p, COLON);

      objc_parent = Parser_check_name(p);
    };

    Parser_check(p, RSBR);
  };

  bool is_interface = p->tok == INTERFACE;

  bool is_union = p->tok == UNION;

  bool is_struct = p->tok == STRUCT;

  Parser_fgen(p, string_add(Token_str(p->tok), tos2(" ")));

  Parser_next(p);

  string name = Parser_check_name(p);

  if (string_contains(name, tos2("_")) && !p->translated) {
    /*if*/

    Parser_error(p, tos2("type names cannot contain `_`"));
  };

  if (is_interface && !string_ends_with(name, tos2("er"))) {
    /*if*/

    Parser_error(p, tos2("interface names temporarily have to end with `er` "
                         "(e.g. `Speaker`, `Reader`)"));
  };

  bool is_c = string_eq(name, tos2("C")) && p->tok == DOT;

  if (is_c) {
    /*if*/

    Parser_check(p, DOT);

    name = Parser_check_name(p);
  };

  if (!is_c && !p->builtin_pkg && string_ne(p->pkg, tos2("main"))) {
    /*if*/

    name = Parser_prepend_pkg(&/* ? */ *p, name);
  };

  if (p->run == RUN_DECLS && Table_known_type(&/* ? */ *p->table, name)) {
    /*if*/

    Parser_error(p, _STR("`%.*s` redeclared", name.len, name.str));
  };

  if (is_objc) {
    /*if*/

    Parser_gen_type(p, _STR("@interface %.*s : %.*s { @public", name.len,
                            name.str, objc_parent.len, objc_parent.str));

  } else {
    /*else if*/

    if (!is_c) {
      /*if*/

      string kind = (is_union) ? (tos2("union")) : (tos2("struct"));

      Parser_gen_typedef(p, _STR("typedef %.*s %.*s %.*s;", kind.len, kind.str,
                                 name.len, name.str, name.len, name.str));

      Parser_gen_type(p, _STR("%.*s /*kind*/ %.*s {", kind.len, kind.str,
                              name.len, name.str));
    };
  };

  if (!is_c && p->tok == STRUCT) {
    /*if*/

    Parser_error(p, _STR("use `struct %.*s {` instead of `type %.*s struct {`",
                         name.len, name.str, name.len, name.str));
  };

  Type *typ = Table_find_type(&/* ? */ *p->table, name);

  bool is_ph = 0;

  if (typ->is_placeholder) {
    /*if*/

    is_ph = 1;

    typ->name = name;

    typ->pkg = p->pkg;

    typ->is_c = is_c;

    typ->is_placeholder = 0;

  } else {
    /*else if*/

    typ = ALLOC_INIT(Type, {.name = name,
                            .pkg = p->pkg,
                            .is_c = is_c,
                            .is_interface = is_interface,
                            .fields = new_array(0, 1, sizeof(Var)),
                            .methods = new_array(0, 1, sizeof(Fn)),
                            .parent = tos("", 0),
                            .gen_types = new_array(0, 1, sizeof(string)),
                            .is_enum = 0,
                            .is_placeholder = 0});
  };

  if (is_c && is_struct && p->tok != LCBR) {
    /*if*/

    Table_register_type2(p->table, *typ);

    return;
  };

  Parser_fgen(p, tos2(" "));

  Parser_check(p, LCBR);

  bool is_pub = 0;

  bool is_mut = 0;

  array_string names =
      new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  while (p->tok != RCBR) {

    if (p->tok == PUB) {
      /*if*/

      if (is_pub) {
        /*if*/

        Parser_error(p, tos2("structs can only have one `pub:`, all public "
                             "fields have to be grouped"));
      };

      is_pub = 1;

      p->scanner->fmt_indent--;

      Parser_check(p, PUB);

      if (p->tok != MUT) {
        /*if*/

        Parser_check(p, COLON);
      };

      p->scanner->fmt_indent++;

      Parser_fgenln(p, tos2(""));
    };

    if (p->tok == MUT) {
      /*if*/

      if (is_mut) {
        /*if*/

        Parser_error(p, tos2("structs can only have one `mut:`, all private "
                             "mutable fields have to be grouped"));
      };

      is_mut = 1;

      p->scanner->fmt_indent--;

      Parser_check(p, MUT);

      if (p->tok != MUT) {
        /*if*/

        Parser_check(p, COLON);
      };

      p->scanner->fmt_indent++;

      Parser_fgenln(p, tos2(""));
    };

    string field_name = Parser_check_name(p);

    if (_IN(string, field_name, names)) {
      /*if*/

      Parser_error(
          p, _STR("duplicate field `%.*s`", field_name.len, field_name.str));
    };

    _PUSH(&names, (field_name), tmp47, string);

    if (is_interface) {
      /*if*/

      Fn *interface_method =
          ALLOC_INIT(Fn, {.name = field_name,
                          .is_interface = 1,
                          .is_method = 1,
                          .receiver_typ = name,
                          .pkg = tos("", 0),
                          .local_vars = new_array(0, 1, sizeof(Var)),
                          .var_idx = 0,
                          .args = new_array(0, 1, sizeof(Var)),
                          .scope_level = 0,
                          .typ = tos("", 0),
                          .is_c = 0,
                          .is_public = 0,
                          .returns_error = 0,
                          .is_decl = 0,
                          .defer = tos("", 0)});

      println(_STR("is interface. field=%.*s run=%d", field_name.len,
                   field_name.str, p->run));

      Parser_fn_args(p, interface_method);

      Parser_fspace(p);

      interface_method->typ = Parser_get_type(p);

      Type_add_method(typ, *interface_method);

      Parser_fgenln(p, tos2(""));

      continue;
    };

    AccessMod access_mod = (is_pub) ? (PUBLIC) : (PRIVATE);

    Parser_fgen(p, tos2(" "));

    string field_type = Parser_get_type(p);

    bool is_atomic = p->tok == ATOMIC;

    if (is_atomic) {
      /*if*/

      Parser_next(p);

      Parser_gen_type(p, tos2("_Atomic "));
    };

    if (!is_c) {
      /*if*/

      Parser_gen_type(
          p, string_add(Table_cgen_name_type_pair(&/* ? */ *p->table,
                                                  field_name, field_type),
                        tos2(";")));
    };

    string attr = tos2("");

    if (p->tok == LSBR) {
      /*if*/

      Parser_next(p);

      attr = Parser_check_name(p);

      Parser_check(p, RSBR);
    };

    Type_add_field(typ, field_name, field_type, is_mut, attr, access_mod);

    Parser_fgenln(p, tos2(""));
  };

  if (!is_ph && Parser_first_run(&/* ? */ *p)) {
    /*if*/

    Table_register_type2(p->table, *typ);
  };

  Parser_check(p, RCBR);

  if (!is_c) {
    /*if*/

    Parser_gen_type(p, tos2("}; "));
  };

  if (is_objc) {
    /*if*/

    Parser_gen_type(p, tos2("@end"));
  };

  Parser_fgenln(p, tos2("\n"));
}
void Parser_enum_decl(Parser *p, string _enum_name) {

  string enum_name = _enum_name;

  if (!p->builtin_pkg && string_ne(p->pkg, tos2("main"))) {
    /*if*/

    enum_name = Parser_prepend_pkg(&/* ? */ *p, enum_name);
  };

  Table_register_type2(
      p->table, *ALLOC_INIT(Type, {.name = enum_name,
                                   .pkg = p->pkg,
                                   .parent = tos2("int"),
                                   .is_enum = 1,
                                   .fields = new_array(0, 1, sizeof(Var)),
                                   .methods = new_array(0, 1, sizeof(Fn)),
                                   .gen_types = new_array(0, 1, sizeof(string)),
                                   .is_c = 0,
                                   .is_interface = 0,
                                   .is_placeholder = 0}));

  if (string_ne(enum_name, tos2("int"))) {
    /*if*/

    _PUSH(&p->cgen->typedefs,
          (_STR("typedef int %.*s ;\n", enum_name.len, enum_name.str)), tmp54,
          string);
  };

  Parser_check(p, LCBR);

  int val = 0;

  while (p->tok == NAME) {

    string field = Parser_check_name(p);

    string name = _STR("%.*s", field.len, field.str);

    Parser_fgenln(p, tos2(""));

    if (p->run == RUN_MAIN) {
      /*if*/

      _PUSH(&p->cgen->consts,
            (_STR("#define %.*s %d \n", name.len, name.str, val)), tmp58,
            string);
    };

    if (p->tok == COMMA) {
      /*if*/

      Parser_next(p);
    };

    Table_register_const(p->table, name, enum_name, p->pkg, 0);

    val++;
  };

  Parser_check(p, RCBR);

  Parser_fgenln(p, tos2("\n"));
}
string Parser_check_name(Parser *p) {

  string name = p->lit;

  Parser_check(p, NAME);

  return name;
}
string Parser_check_string(Parser *p) {

  string s = p->lit;

  Parser_check(p, STRING);

  return s;
}
string Parser_strtok(Parser *p) {

  if (p->tok == NAME) {
    /*if*/

    return p->lit;
  };

  if (p->tok == STRING) {
    /*if*/

    return _STR("\"%.*s\"", p->lit.len, p->lit.str);
  };

  string res = Token_str(p->tok);

  if (string_eq(res, tos2(""))) {
    /*if*/

    int n = ((int)(p->tok));

    return int_str(n);
  };

  return res;
}
void Parser_check_space(Parser *p, Token expected) {

  Parser_fspace(p);

  Parser_check(p, expected);

  Parser_fspace(p);
}
void Parser_check(Parser *p, Token expected) {

  if (p->tok != expected) {
    /*if*/

    println(tos2("check()"));

    string s = _STR("expected `%.*s` but got `%.*s`", Token_str(expected).len,
                    Token_str(expected).str, Parser_strtok(&/* ? */ *p).len,
                    Parser_strtok(&/* ? */ *p).str);

    Parser_next(p);

    println(_STR("next token = `%.*s`", Parser_strtok(&/* ? */ *p).len,
                 Parser_strtok(&/* ? */ *p).str));

    print_backtrace();

    Parser_error(p, s);
  };

  if (expected == RCBR) {
    /*if*/

    p->scanner->fmt_indent--;
  };

  Parser_fgen(p, Parser_strtok(&/* ? */ *p));

  if (expected == LCBR &&
      string_at(p->scanner->text, p->scanner->pos + 1) != '}') {
    /*if*/

    Parser_fgenln(p, tos2(""));

    p->scanner->fmt_indent++;
  };

  Parser_next(p);
}
void Parser_error(Parser *p, string s) {

  if (0) {
    /*if*/

    os__File file_types =
        os__create(_STR("%.*s/types", main__TmpPath.len, main__TmpPath.str));

    os__File file_vars =
        os__create(_STR("%.*s/vars", main__TmpPath.len, main__TmpPath.str));

    os__File_close(file_types);

    os__File_close(file_vars);
  };

  if (!p->is_repl) {
    /*if*/

    println(_STR("pass=%d fn=`%.*s`", p->run, p->cur_fn->name.len,
                 p->cur_fn->name.str));
  };

  CGen_save(p->cgen);

  string cur_path = os__getwd();

  if (!p->is_repl &&
      (/*lpar*/ string_contains(p->file_path, tos2("v/compiler")) ||
       string_contains(cur_path, tos2("v/compiler")))) {
    /*if*/

    println(tos2("\n========================="));

    println(tos2("It looks like you are building V. It is being frequently "
                 "updated every day."));

    println(tos2("If you didn\'t modify the compiler\'s code, most likely "
                 "there was a change that "));

    println(tos2("lead to this error."));

    println(tos2("\nRun `git pull && make`, that will most likely fix it."));

    println(tos2("\nIf this doesn\'t help, please create a GitHub issue."));

    println(tos2("=========================\n"));
  };

  Scanner_error(&/* ? */ *p->scanner,
                string_replace(string_replace(s, tos2("array_"), tos2("[]")),
                               tos2("__"), tos2(".")));
}
bool Parser_first_run(Parser *p) { return p->run == RUN_DECLS; }
string Parser_get_type(Parser *p) {

  bool debug = Parser_fileis(&/* ? */ *p, tos2("fn_test")) && 0;

  bool mul = 0;

  int nr_muls = 0;

  string typ = tos2("");

  if (p->tok == FUNC) {
    /*if*/

    if (debug) {
      /*if*/

      println(_STR("\nget_type() GOT FN TYP line=%d", p->scanner->line_nr));
    };

    Fn f = (Fn){.name = tos2("_"),
                .pkg = p->pkg,
                .local_vars = new_array(0, 1, sizeof(Var)),
                .var_idx = 0,
                .args = new_array(0, 1, sizeof(Var)),
                .is_interface = 0,
                .scope_level = 0,
                .typ = tos("", 0),
                .is_c = 0,
                .receiver_typ = tos("", 0),
                .is_public = 0,
                .is_method = 0,
                .returns_error = 0,
                .is_decl = 0,
                .defer = tos("", 0)};

    Parser_next(p);

    int line_nr = p->scanner->line_nr;

    Parser_fn_args(p, &/*11 EXP:"Fn*" GOT:"Fn" */ f);

    if (p->scanner->line_nr == line_nr) {
      /*if*/

      if (debug) {
        /*if*/

        println(tos2("same line getting type"));
      };

      f.typ = Parser_get_type(p);

    } else {
      /*else if*/

      f.typ = tos2("void");
    };

    Type fn_typ = (Type){.name = Fn_typ_str(f),
                         .pkg = p->pkg,
                         .func = f,
                         .fields = new_array(0, 1, sizeof(Var)),
                         .methods = new_array(0, 1, sizeof(Fn)),
                         .parent = tos("", 0),
                         .gen_types = new_array(0, 1, sizeof(string)),
                         .is_c = 0,
                         .is_interface = 0,
                         .is_enum = 0,
                         .is_placeholder = 0};

    Table_register_type2(p->table, fn_typ);

    return Fn_typ_str(f);
  };

  bool is_arr = 0;

  bool is_arr2 = 0;

  bool is_question = p->tok == QUESTION;

  if (is_question) {
    /*if*/

    Parser_check(p, QUESTION);
  };

  if (p->tok == LSBR) {
    /*if*/

    Parser_check(p, LSBR);

    if (p->tok == INT) {
      /*if*/

      typ = _STR("[%.*s]", p->lit.len, p->lit.str);

      Parser_next(p);

    } else {
      /*else if*/

      is_arr = 1;
    };

    Parser_check(p, RSBR);

    if (p->tok == LSBR) {
      /*if*/

      Parser_next(p);

      if (p->tok == INT) {
        /*if*/

        typ = string_add(typ, _STR("[%.*s]", p->lit.len, p->lit.str));

        Parser_check(p, INT);

      } else {
        /*else if*/

        is_arr2 = 1;
      };

      Parser_check(p, RSBR);
    };
  };

  while (p->tok == MUL) {

    mul = 1;

    nr_muls++;

    Parser_next(p);
  };

  if (p->tok == AMP) {
    /*if*/

    mul = 1;

    nr_muls++;

    Parser_next(p);
  };

  typ = string_add(typ, p->lit);

  if (!p->is_struct_init) {
    /*if*/

    Parser_fgen(p, p->lit);
  };

  if (string_eq(p->lit, tos2("C")) && Parser_peek(p) == DOT) {
    /*if*/

    Parser_next(p);

    Parser_check(p, DOT);

    typ = p->lit;

  } else {
    /*else if*/

    if (Parser_peek(p) == DOT) {
      /*if*/

      Parser_next(p);

      Parser_check(p, DOT);

      typ = string_add(typ, _STR("__%.*s", p->lit.len, p->lit.str));
    };

    Type *t = Table_find_type(&/* ? */ *p->table, typ);

    if (string_eq(t->name, tos2("")) && !p->builtin_pkg) {
      /*if*/

      if (!string_contains(typ, tos2("array_")) &&
          string_ne(p->pkg, tos2("main")) &&
          !string_contains(typ, tos2("__"))) {
        /*if*/

        typ = Parser_prepend_pkg(&/* ? */ *p, typ);
      };

      t = Table_find_type(&/* ? */ *p->table, typ);

      if (string_eq(t->name, tos2("")) && !p->translated &&
          !Parser_first_run(&/* ? */ *p) &&
          !string_starts_with(typ, tos2("["))) {
        /*if*/

        println(tos2("get_type() bad type"));

        Parser_error(p, _STR("unknown type `%.*s`", typ.len, typ.str));
      };
    };
  };

  if (string_eq(typ, tos2("void"))) {
    /*if*/

    Parser_error(p, _STR("unknown type `%.*s`", typ.len, typ.str));
  };

  if (mul) {
    /*if*/

    typ = string_add(typ, repeat_char('*', nr_muls));
  };

  if (is_arr2) {
    /*if*/

    typ = _STR("array_array_%.*s", typ.len, typ.str);

    Parser_register_array(p, typ);

  } else if (is_arr) {
    /*if*/

    typ = _STR("array_%.*s", typ.len, typ.str);

    Parser_register_array(p, typ);
  };

  Parser_next(p);

  if (p->tok == QUESTION || is_question) {
    /*if*/

    typ = _STR("Option_%.*s", typ.len, typ.str);

    Table_register_type_with_parent(p->table, typ, tos2("Option"));

    if (p->tok == QUESTION) {
      /*if*/

      Parser_next(p);
    };
  };

  if (string_eq(typ, tos2("byteptr"))) {
    /*if*/

    return tos2("byte*");
  };

  if (string_eq(typ, tos2("voidptr"))) {
    /*if*/

    return tos2("void*");
  };

  if (string_last_index(typ, tos2("__")) > string_index(typ, tos2("__"))) {
    /*if*/

    Parser_error(p, _STR("2 __ in gettype(): typ=\"%.*s\"", typ.len, typ.str));
  };

  return typ;
}
void Parser_print_tok(Parser *p) {

  if (p->tok == NAME) {
    /*if*/

    println(p->lit);

    return;
  };

  if (p->tok == STRING) {
    /*if*/

    println(_STR("\"%.*s\"", p->lit.len, p->lit.str));

    return;
  };

  println(Token_str(p->tok));
}
string Parser_statements(Parser *p) {

  Parser_log(&/* ? */ *p, tos2("statements()"));

  string typ = Parser_statements_no_curly_end(p);

  if (!p->inside_if_expr) {
    /*if*/

    Parser_genln(p, tos2("}"));
  };

  if (Parser_fileis(&/* ? */ *p, tos2("if_expr"))) {
    /*if*/

    println(_STR("statements() ret=%.*s line=%d", typ.len, typ.str,
                 p->scanner->line_nr));
  };

  return typ;
}
string Parser_statements_no_curly_end(Parser *p) {

  Fn_open_scope(p->cur_fn);

  if (!p->inside_if_expr) {
    /*if*/

    Parser_genln(p, tos2(""));
  };

  int i = 0;

  string last_st_typ = tos2("");

  while (p->tok != RCBR && p->tok != EOF && p->tok != CASE &&
         p->tok != DEFAULT) {

    last_st_typ = Parser_statement(p, 1);

    if (!p->inside_if_expr) {
      /*if*/

      Parser_genln(p, tos2(""));

      Parser_fgenln(p, tos2(""));
    };

    i++;

    if (i > 50000) {
      /*if*/

      CGen_save(p->cgen);

      Parser_error(p, _STR("more than 50 000 statements in function `%.*s`",
                           p->cur_fn->name.len, p->cur_fn->name.str));
    };
  };

  if (p->tok != CASE && p->tok != DEFAULT) {
    /*if*/

    Parser_check(p, RCBR);

  } else {
    /*else if*/
  };

  p->scanner->fmt_indent--;

  Fn_close_scope(p->cur_fn);

  return last_st_typ;
}
void Parser_genln(Parser *p, string s) { CGen_genln(p->cgen, s); }
void Parser_gen(Parser *p, string s) { CGen_gen(p->cgen, s); }
void Parser_vh_genln(Parser *p, string s) {

  _PUSH(&p->vh_lines, (s), tmp83, string);
}
void Parser_fmt_inc(Parser *p) { p->scanner->fmt_indent++; }
void Parser_fmt_dec(Parser *p) { p->scanner->fmt_indent--; }
string Parser_statement(Parser *p, bool add_semi) {

  p->cgen->is_tmp = 0;

  Token tok = p->tok;

  string q = tos2("");

  if ((tok == NAME)) { /* case */

    Token next = Parser_peek(p);

    if (p->is_verbose) {
      /*if*/

      println(Token_str(next));
    };

    if (Parser_peek(p) == COLON) {
      /*if*/

      Parser_fmt_dec(p);

      string label = Parser_check_name(p);

      Parser_fmt_inc(p);

      Parser_genln(p, string_add(label, tos2(":")));

      Parser_check(p, COLON);

      return tos2("");

    } else if (Parser_peek(p) == DECL_ASSIGN) {
      /*if*/

      Parser_log(&/* ? */ *p, tos2("var decl"));

      Parser_var_decl(p);

    } else if (string_eq(p->lit, tos2("jsdecode"))) {
      /*if*/

      Parser_js_decode(p);

    } else {
      /*else if*/

      q = Parser_bool_expression(p);
    };

  } else if ((tok == GOTO)) { /* case */

    Parser_check(p, GOTO);

    Parser_fgen(p, tos2(" "));

    string label = Parser_check_name(p);

    Parser_genln(p, _STR("goto %.*s;", label.len, label.str));

    return tos2("");

  } else if ((tok == HASH)) { /* case */

    Parser_chash(p);

    return tos2("");

  } else if ((tok == DOLLAR)) { /* case */

    Parser_comp_time(p);

  } else if ((tok == IF)) { /* case */

    Parser_if_st(p, 0);

  } else if ((tok == FOR)) { /* case */

    Parser_for_st(p);

  } else if ((tok == SWITCH) || (tok == MATCH)) { /* case */

    Parser_switch_statement(p);

  } else if ((tok == MUT) || (tok == STATIC)) { /* case */

    Parser_var_decl(p);

  } else if ((tok == RETURN)) { /* case */

    Parser_return_st(p);

  } else if ((tok == LCBR)) { /* case */

    Parser_next(p);

    Parser_genln(p, tos2("{"));

    Parser_statements(p);

    return tos2("");

  } else if ((tok == CONTINUE)) { /* case */

    if (p->for_expr_cnt == 0) {
      /*if*/

      Parser_error(p, tos2("`continue` statement outside `for`"));
    };

    Parser_genln(p, tos2("continue"));

    Parser_next(p);

  } else if ((tok == BREAK)) { /* case */

    if (p->for_expr_cnt == 0) {
      /*if*/

      Parser_error(p, tos2("`break` statement outside `for`"));
    };

    Parser_genln(p, tos2("break"));

    Parser_next(p);

  } else if ((tok == GO)) { /* case */

    Parser_go_statement(p);

  } else if ((tok == ASSERT)) { /* case */

    Parser_assert_statement(p);

  } else { // default:

    string typ = Parser_expression(p);

    if (p->inside_if_expr) {
      /*if*/

    } else {
      /*else if*/

      Parser_genln(p, tos2("; "));
    };

    return typ;
  };

  if (p->inside_if_expr && p->tok != RCBR) {
    /*if*/

    Parser_gen(p, tos2(", "));
  };

  if (add_semi && !p->inside_if_expr) {
    /*if*/

    Parser_genln(p, tos2(";"));
  };

  return q;
}
void Parser_assign_statement(Parser *p, Var v, int ph, bool is_map) {

  Parser_log(&/* ? */ *p,
             _STR("assign_statement() name=%.*s tok=", v.name.len, v.name.str));

  Token tok = p->tok;

  if (!v.is_mut && !v.is_arg && !p->translated && !v.is_global) {
    /*if*/

    Parser_error(p, _STR("`%.*s` is immutable", v.name.len, v.name.str));
  };

  bool is_str = string_eq(v.typ, tos2("string"));

  if ((tok == ASSIGN)) { /* case */

    if (!is_map) {
      /*if*/

      Parser_gen(p, tos2(" = "));
    };

  } else if ((tok == PLUS_ASSIGN)) { /* case */

    if (is_str) {
      /*if*/

      Parser_gen(p, _STR("= string_add(%.*s, ", v.name.len, v.name.str));

    } else if (!is_map) {
      /*if*/

      Parser_gen(p, tos2(" += "));
    };

  } else { // default:

    if (tok != MINUS_ASSIGN && tok != MULT_ASSIGN && tok != XOR_ASSIGN &&
        tok != MOD_ASSIGN && tok != AND_ASSIGN && tok != OR_ASSIGN &&
        tok != RIGHT_SHIFT_ASSIGN && tok != LEFT_SHIFT_ASSIGN &&
        tok != DIV_ASSIGN) {
      /*if*/

      Parser_gen(
          p, string_add(string_add(tos2(" "), Token_str(p->tok)), tos2(" ")));
    };
  };

  Parser_fgen(p,
              string_add(string_add(tos2(" "), Token_str(p->tok)), tos2(" ")));

  Parser_next(p);

  int pos = p->cgen->cur_line.len;

  string expr_type = Parser_bool_expression(p);

  if (string_starts_with(p->assigned_type, tos2("Option_")) &&
      string_eq(expr_type,
                string_right(p->assigned_type, tos2("Option_").len))) {
    /*if*/

    println(tos2("allowing option asss"));

    string expr = string_right(p->cgen->cur_line, pos);

    string left = string_left(p->cgen->cur_line, pos);

    p->cgen->cur_line =
        string_add(left, _STR("opt_ok(%.*s)", expr.len, expr.str));

  } else if (!p->builtin_pkg &&
             !Parser_check_types_no_throw(p, expr_type, p->assigned_type)) {
    /*if*/

    p->scanner->line_nr--;

    Parser_error(p, _STR("cannot use type `%.*s` as type `%.*s` in assignment",
                         expr_type.len, expr_type.str, p->assigned_type.len,
                         p->assigned_type.str));
  };

  if (is_str && tok == PLUS_ASSIGN) {
    /*if*/

    Parser_gen(p, tos2(")"));
  };

  p->assigned_type = tos2("");

  if (!v.is_used) {
    /*if*/

    Fn_mark_var_used(&/* ? */ *p->cur_fn, v);
  };
}
void Parser_var_decl(Parser *p) {

  bool is_mut = p->tok == MUT || p->prev_tok == FOR;

  bool is_static = p->tok == STATIC;

  if (p->tok == MUT) {
    /*if*/

    Parser_check(p, MUT);

    Parser_fspace(p);
  };

  if (p->tok == STATIC) {
    /*if*/

    Parser_check(p, STATIC);

    Parser_fspace(p);
  };

  string name = Parser_check_name(p);

  if (!p->builtin_pkg && Fn_known_var(&/* ? */ *p->cur_fn, name)) {
    /*if*/

    Var v = Fn_find_var(&/* ? */ *p->cur_fn, name);

    Parser_error(p, _STR("redefinition of `%.*s`", name.len, name.str));
  };

  Parser_check_space(p, DECL_ASSIGN);

  int pos = CGen_add_placeholder(p->cgen);

  string typ = Parser_bool_expression(p);

  bool or_else = p->tok == OR_ELSE;

  string tmp = Parser_get_tmp(p);

  if (or_else) {
    /*if*/

    CGen_set_placeholder(
        p->cgen, pos, _STR("%.*s %.*s = ", typ.len, typ.str, tmp.len, tmp.str));

    Parser_gen(p, tos2(";"));

    typ = string_replace(typ, tos2("Option_"), tos2(""));

    Parser_next(p);

    Parser_check(p, LCBR);

    Parser_genln(p, _STR("if (!%.*s .ok) {", tmp.len, tmp.str));

    Parser_statements(p);

    Parser_genln(p,
                 _STR("%.*s %.*s = *(%.*s*) %.*s . data;", typ.len, typ.str,
                      name.len, name.str, typ.len, typ.str, tmp.len, tmp.str));

    if (!p->returns && p->prev_tok2 != CONTINUE && p->prev_tok2 != BREAK) {
      /*if*/

      println(int_str(p->prev_tok2));

      Parser_error(p, tos2("`or` statement must return/continue/break"));
    };
  };

  Parser_register_var(p, (Var){.name = name,
                               .typ = typ,
                               .is_mut = is_mut,
                               .is_arg = 0,
                               .is_const = 0,
                               .is_import_const = 0,
                               .args = new_array(0, 1, sizeof(Var)),
                               .attr = tos("", 0),
                               .ptr = 0,
                               .ref = 0,
                               .parent_fn = tos("", 0),
                               .pkg = tos("", 0),
                               .line_nr = 0,
                               .is_global = 0,
                               .is_used = 0,
                               .scope_level = 0});

  string cgen_typ = typ;

  if (!or_else) {
    /*if*/

    string gen_name = Table_var_cgen_name(p->table, name);

    string nt_gen = string_add(
        Table_cgen_name_type_pair(&/* ? */ *p->table, gen_name, cgen_typ),
        tos2("="));

    if (is_static) {
      /*if*/

      nt_gen = _STR("static %.*s", nt_gen.len, nt_gen.str);
    };

    CGen_set_placeholder(p->cgen, pos, nt_gen);
  };
}
string Parser_bool_expression(Parser *p) {

  Token tok = p->tok;

  string typ = Parser_bterm(p);

  while (p->tok == AND || p->tok == OR) {

    Parser_gen(p, _STR(" %.*s ", Token_str(p->tok).len, Token_str(p->tok).str));

    Parser_next(p);

    Parser_check_types(p, Parser_bterm(p), typ);
  };

  if (string_eq(typ, tos2(""))) {
    /*if*/

    println(tos2("curline:"));

    println(p->cgen->cur_line);

    println(Token_str(tok));

    Parser_error(p, tos2("expr() returns empty type"));
  };

  return typ;
}
string Parser_bterm(Parser *p) {

  int ph = CGen_add_placeholder(p->cgen);

  string typ = Parser_expression(p);

  bool is_str = string_eq(typ, tos2("string"));

  Token tok = p->tok;

  if (tok == EQ || tok == GT || tok == LT || tok == LE || tok == GE ||
      tok == NE) {
    /*if*/

    Parser_fgen(p,
                _STR(" %.*s ", Token_str(p->tok).len, Token_str(p->tok).str));

    if (is_str) {
      /*if*/

      Parser_gen(p, tos2(","));

    } else {
      /*else if*/

      Parser_gen(p, Token_str(tok));
    };

    Parser_next(p);

    Parser_check_types(p, Parser_expression(p), typ);

    typ = tos2("bool");

    if (is_str) {
      /*if*/

      Parser_gen(p, tos2(")"));

      if ((tok == EQ)) { /* case */

        CGen_set_placeholder(p->cgen, ph, tos2("string_eq("));

      } else if ((tok == NE)) { /* case */

        CGen_set_placeholder(p->cgen, ph, tos2("string_ne("));

      } else if ((tok == LE)) { /* case */

        CGen_set_placeholder(p->cgen, ph, tos2("string_le("));

      } else if ((tok == GE)) { /* case */

        CGen_set_placeholder(p->cgen, ph, tos2("string_ge("));

      } else if ((tok == GT)) { /* case */

        CGen_set_placeholder(p->cgen, ph, tos2("string_gt("));

      } else if ((tok == LT)) { /* case */

        CGen_set_placeholder(p->cgen, ph, tos2("string_lt("));
      };
    };
  };

  return typ;
}
string Parser_name_expr(Parser *p) {

  Parser_log(&/* ? */ *p, _STR("\nname expr() pass=%d tok=%.*s %.*s", p->run,
                               Token_str(p->tok).len, Token_str(p->tok).str,
                               p->lit.len, p->lit.str));

  int hack_pos = p->scanner->pos;

  Token hack_tok = p->tok;

  string hack_lit = p->lit;

  bool ptr = p->tok == AMP;

  bool deref = p->tok == MUL;

  if (ptr || deref) {
    /*if*/

    Parser_next(p);
  };

  if (deref) {
    /*if*/

    if (p->is_play && !p->builtin_pkg) {
      /*if*/

      Parser_error(p, tos2("dereferencing is temporarily disabled on the "
                           "playground, will be fixed soon"));
    };
  };

  string name = p->lit;

  Parser_fgen(p, name);

  string orig_name = name;

  bool is_c = string_eq(name, tos2("C")) && Parser_peek(p) == DOT;

  bool is_c_struct_init = is_c && ptr;

  if (is_c) {
    /*if*/

    Parser_next(p);

    Parser_check(p, DOT);

    name = p->lit;

    Parser_fgen(p, name);

    if (!is_c_struct_init && Parser_peek(p) == LCBR) {
      /*if*/

      is_c_struct_init = 1;
    };
  };

  if (Table_known_pkg(&/* ? */ *p->table, name) &&
      !Fn_known_var(&/* ? */ *p->cur_fn, name) && !is_c) {
    /*if*/

    string pkg = name;

    Parser_next(p);

    Parser_check(p, DOT);

    name = p->lit;

    Parser_fgen(p, name);

    name = prepend_pkg(pkg, name);

  } else if (!Table_known_type(&/* ? */ *p->table, name) &&
             !Fn_known_var(&/* ? */ *p->cur_fn, name) &&
             !Table_known_fn(&/* ? */ *p->table, name) &&
             !Table_known_const(&/* ? */ *p->table, name) && !is_c) {
    /*if*/

    name = Parser_prepend_pkg(&/* ? */ *p, name);
  };

  Var v = Fn_find_var(&/* ? */ *p->cur_fn, name);

  if (v.name.len != 0) {
    /*if*/

    deref = deref || (/*lpar*/ v.is_arg && v.is_mut && is_mutable_type(v.typ));

    if (ptr) {
      /*if*/

      Parser_gen(p, tos2("& /*vvar*/ "));

    } else if (deref) {
      /*if*/

      Parser_gen(p, tos2("*"));
    };

    string typ = Parser_var_expr(p, v);

    if (deref) {
      /*if*/

      if (!string_contains(typ, tos2("*")) &&
          !string_ends_with(typ, tos2("ptr"))) {
        /*if*/

        println(_STR("name=\"%.*s\", t=%.*s", name.len, name.str, v.typ.len,
                     v.typ.str));

        Parser_error(p, _STR("dereferencing requires a pointer, but got `%.*s`",
                             typ.len, typ.str));
      };

      typ = string_replace(typ, tos2("ptr"), tos2(""));

      typ = string_replace(typ, tos2("*"), tos2(""));

    } else if (ptr) {
      /*if*/

      typ = string_add(typ, tos2("*"));
    };

    return typ;
  };

  if (Table_known_type(&/* ? */ *p->table, name)) {
    /*if*/

    if (!is_c && (/*lpar*/ Parser_peek(p) == LPAR ||
                  (/*lpar*/ deref && Parser_peek(p) == RPAR))) {
      /*if*/

      if (deref) {
        /*if*/

        name = string_add(name, tos2("*"));

      } else if (ptr) {
        /*if*/

        name = string_add(name, tos2("*"));
      };

      Parser_gen(p, tos2("("));

      string typ = Parser_cast(p, name);

      Parser_gen(p, tos2(")"));

      while (p->tok == DOT) {

        typ = Parser_dot(p, typ, 0);
      };

      return typ;

    } else if (Parser_peek(p) == DOT) {
      /*if*/

      Type *enum_type = Table_find_type(&/* ? */ *p->table, name);

      if (!enum_type->is_enum) {
        /*if*/

        Parser_error(p, _STR("`%.*s` is not an enum", name.len, name.str));
      };

      Parser_next(p);

      Parser_check(p, DOT);

      string val = p->lit;

      Parser_gen(
          p, string_add(string_add(string_add(string_add(p->pkg, tos2("__")),
                                              enum_type->name),
                                   tos2("_")),
                        val));

      Parser_next(p);

      return enum_type->name;

    } else if (Parser_peek(p) == LCBR) {
      /*if*/

      p->scanner->pos = hack_pos;

      p->tok = hack_tok;

      p->lit = hack_lit;

      if (is_c_struct_init) {
        /*if*/

        p->is_c_struct_init = 1;

        CGen_insert_before(p->cgen, tos2("struct /*c struct init*/"));
      };

      return Parser_struct_init(p, is_c_struct_init);
    };
  };

  if (is_c) {
    /*if*/

    Fn f = (Fn){.name = name,
                .is_c = 1,
                .pkg = tos("", 0),
                .local_vars = new_array(0, 1, sizeof(Var)),
                .var_idx = 0,
                .args = new_array(0, 1, sizeof(Var)),
                .is_interface = 0,
                .scope_level = 0,
                .typ = tos("", 0),
                .receiver_typ = tos("", 0),
                .is_public = 0,
                .is_method = 0,
                .returns_error = 0,
                .is_decl = 0,
                .defer = tos("", 0)};

    Parser_fn_call(p, f, 0, tos2(""), tos2(""));

    Fn cfn = Table_find_fn(&/* ? */ *p->table, name);

    if (string_eq(cfn.name, tos2(""))) {
      /*if*/

      return tos2("void*");
    };

    return cfn.typ;
  };

  Var c = Table_find_const(&/* ? */ *p->table, name);

  if (string_ne(c.name, tos2("")) && ptr && !c.is_global) {
    /*if*/

    Parser_error(p, _STR("cannot take the address of constant `%.*s`",
                         c.name.len, c.name.str));
  };

  if (c.name.len != 0) {
    /*if*/

    if (ptr) {
      /*if*/

      Parser_gen(p, tos2("& /*const*/ "));
    };

    Parser_log(&/* ? */ *p, tos2("calling var expr"));

    string typ = Parser_var_expr(p, c);

    if (ptr) {
      /*if*/

      typ = string_add(typ, tos2("*"));
    };

    return typ;
  };

  Fn f = Table_find_fn(&/* ? */ *p->table, name);

  if (string_eq(f.name, tos2(""))) {
    /*if*/

    if (!Parser_first_run(&/* ? */ *p)) {
      /*if*/

      if (Table_known_pkg(&/* ? */ *p->table, orig_name)) {
        /*if*/

        name = string_replace(name, tos2("__"), tos2("."));

        Parser_error(p, _STR("undefined: `%.*s`", name.len, name.str));

      } else {
        /*else if*/

        Parser_error(p,
                     _STR("undefined: `%.*s`", orig_name.len, orig_name.str));
      };
    };

    Parser_next(p);

    return tos2("void");
  };

  if (Parser_peek(p) != LPAR) {
    /*if*/

    Parser_gen(p, Table_cgen_name(p->table, &/*11 EXP:"Fn*" GOT:"Fn" */ f));

    Parser_next(p);

    return tos2("void*");
  };

  if (string_eq(f.typ, tos2("void")) && !p->inside_if_expr) {
    /*if*/
  };

  Parser_log(&/* ? */ *p, tos2("calling function"));

  Parser_fn_call(p, f, 0, tos2(""), tos2(""));

  if (p->tok == DOT) {
    /*if*/

    string typ = tos2("");

    while (p->tok == DOT) {

      typ = Parser_dot(p, f.typ, 0);
    };

    return typ;
  };

  Parser_log(&/* ? */ *p, tos2("end of name_expr"));

  return f.typ;
}
string Parser_var_expr(Parser *p, Var v) {

  Parser_log(&/* ? */ *p, _STR("\nvar_expr() v.name=\"%.*s\" v.typ=\"%.*s\"",
                               v.name.len, v.name.str, v.typ.len, v.typ.str));

  Fn_mark_var_used(&/* ? */ *p->cur_fn, v);

  int fn_ph = CGen_add_placeholder(p->cgen);

  p->expr_var = v;

  Parser_gen(p, Table_var_cgen_name(p->table, v.name));

  Parser_next(p);

  string typ = v.typ;

  if (string_starts_with(typ, tos2("fn "))) {
    /*if*/

    println(tos2("CALLING FN PTR"));

    Parser_print_tok(&/* ? */ *p);

    Type *T = Table_find_type(&/* ? */ *p->table, typ);

    Parser_gen(p, tos2("("));

    Parser_fn_call_args(p, &/*11 EXP:"Fn*" GOT:"Fn" */ T->func);

    Parser_gen(p, tos2(")"));

    typ = T->func.typ;
  };

  if (p->tok == LSBR) {
    /*if*/

    typ = Parser_index_expr(p, typ, fn_ph);
  };

  while (p->tok == DOT) {

    typ = Parser_dot(p, typ, fn_ph);

    Parser_log(&/* ? */ *p, _STR("typ after dot=%.*s", typ.len, typ.str));

    if (p->tok == LSBR) {
      /*if*/
    };
  };

  if (p->tok == INC || p->tok == DEC) {
    /*if*/

    if (!v.is_mut && !v.is_arg && !p->translated) {
      /*if*/

      Parser_error(p, _STR("`%.*s` is immutable", v.name.len, v.name.str));
    };

    if (string_ne(typ, tos2("int"))) {
      /*if*/

      if (!p->translated && !is_number_type(typ)) {
        /*if*/

        Parser_error(
            p, _STR("cannot ++/-- value of type `%.*s`", typ.len, typ.str));
      };
    };

    Parser_gen(p, Token_str(p->tok));

    Parser_fgen(p, Token_str(p->tok));

    Parser_next(p);

    if (p->translated) {
      /*if*/

      return Parser_index_expr(p, typ, fn_ph);

    } else {
      /*else if*/

      return tos2("void");
    };
  };

  typ = Parser_index_expr(p, typ, fn_ph);

  return typ;
}
bool Parser_fileis(Parser *p, string s) {

  return string_contains(p->scanner->file_path, s);
}
string Parser_dot(Parser *p, string str_typ, int method_ph) {

  Parser_check(p, DOT);

  string field_name = p->lit;

  Parser_fgen(p, field_name);

  Parser_log(&/* ? */ *p, _STR("dot() field_name=%.*s typ=%.*s", field_name.len,
                               field_name.str, str_typ.len, str_typ.str));

  if (Parser_fileis(&/* ? */ *p, tos2("hi_test"))) {
    /*if*/

    println(_STR("dot() field_name=%.*s typ=%.*s", field_name.len,
                 field_name.str, str_typ.len, str_typ.str));
  };

  Type *typ = Parser_find_type(&/* ? */ *p, str_typ);

  if (typ->name.len == 0) {
    /*if*/

    Parser_error(
        p, _STR("dot(): cannot find type `%.*s`", str_typ.len, str_typ.str));
  };

  bool has_field = Table_type_has_field(&/* ? */ *p->table, typ, field_name);

  bool has_method = Table_type_has_method(&/* ? */ *p->table, typ, field_name);

  if (!typ->is_c && !has_field && !has_method &&
      !Parser_first_run(&/* ? */ *p)) {
    /*if*/

    if (string_starts_with(typ->name, tos2("Option_"))) {
      /*if*/

      string opt_type = string_substr(typ->name, 7, typ->name.len);

      Parser_error(
          p, _STR("unhandled option type: %.*s?", opt_type.len, opt_type.str));
    };

    println(tos2("dot():"));

    println(tos2("fields:"));

    array_Var tmp142 = typ->fields;
    ;
    for (int tmp143 = 0; tmp143 < tmp142.len; tmp143++) {
      Var field = ((Var *)tmp142.data)[tmp143];

      println(field.name);
    };

    println(tos2("methods:"));

    array_Fn tmp144 = typ->methods;
    ;
    for (int tmp145 = 0; tmp145 < tmp144.len; tmp145++) {
      Fn field = ((Fn *)tmp144.data)[tmp145];

      println(field.name);
    };

    println(_STR("str_typ==\"%.*s\"", str_typ.len, str_typ.str));

    Parser_error(p, _STR("type `%.*s`  has no field or method `%.*s`",
                         typ->name.len, typ->name.str, field_name.len,
                         field_name.str));
  };

  string dot = tos2(".");

  if (string_contains(str_typ, tos2("*"))) {
    /*if*/

    dot = tos2("->");
  };

  if (has_field) {
    /*if*/

    Var field = Table_find_field(&/* ? */ *p->table, typ, field_name);

    Token next = Parser_peek(p);

    bool modifying = Token_is_assign(next) || next == INC || next == DEC;

    bool is_vi = Parser_fileis(&/* ? */ *p, tos2("vi"));

    if (!p->builtin_pkg && !p->translated && modifying && !field.is_mut &&
        !is_vi) {
      /*if*/

      Parser_error(p, _STR("cannot modify immutable field `%.*s` (type `%.*s`)",
                           field_name.len, field_name.str, typ->name.len,
                           typ->name.str));
    };

    if (!p->builtin_pkg && string_ne(p->pkg, typ->pkg)) {
      /*if*/
    };

    if (field.access_mod == PRIVATE && !p->builtin_pkg && !p->translated &&
        string_ne(p->pkg, typ->pkg)) {
      /*if*/

      Parser_error(p,
                   _STR("cannot refer to unexported field `%.*s` (type `%.*s`)",
                        field_name.len, field_name.str, typ->name.len,
                        typ->name.str));
    };

    if (field.access_mod == PUBLIC && !p->builtin_pkg &&
        string_ne(p->pkg, typ->pkg)) {
      /*if*/

      if (!field.is_mut && !p->translated && modifying) {
        /*if*/

        Parser_error(
            p,
            _STR("cannot modify public immutable field `%.*s` (type `%.*s`)",
                 field_name.len, field_name.str, typ->name.len, typ->name.str));
      };
    };

    Parser_gen(
        p, _STR("%.*s%.*s", dot.len, dot.str, field_name.len, field_name.str));

    Parser_next(p);

    return field.typ;
  };

  Fn method = Table_find_method(&/* ? */ *p->table, typ, field_name);

  Parser_fn_call(p, method, method_ph, tos2(""), str_typ);

  if (string_eq(method.typ, tos2("array")) &&
      string_starts_with(typ->name, tos2("array_"))) {
    /*if*/

    return typ->name;
  };

  if (string_eq(method.typ, tos2("void*")) &&
      string_starts_with(typ->name, tos2("array_"))) {
    /*if*/

    return string_right(typ->name, 6);
  };

  if (0 && p->tok == LSBR) {
    /*if*/

    return Parser_index_expr(p, method.typ, method_ph);
  };

  return method.typ;
}
string Parser_index_expr(Parser *p, string typ, int fn_ph) {

  if (Parser_fileis(&/* ? */ *p, tos2("int_test"))) {
    /*if*/

    println(_STR("index expr typ=%.*s", typ.len, typ.str));
  };

  Var v = p->expr_var;

  bool is_map = string_starts_with(typ, tos2("map_"));

  bool is_str = string_eq(typ, tos2("string"));

  bool is_arr0 = string_starts_with(typ, tos2("array_"));

  bool is_arr = is_arr0 || string_eq(typ, tos2("array"));

  bool is_ptr = string_eq(typ, tos2("byte*")) ||
                string_eq(typ, tos2("byteptr")) ||
                string_contains(typ, tos2("*"));

  bool is_indexer = p->tok == LSBR;

  bool close_bracket = 0;

  if (is_indexer) {
    /*if*/

    bool is_fixed_arr = string_at(typ, 0) == '[';

    if (!is_str && !is_arr && !is_map && !is_ptr && !is_fixed_arr) {
      /*if*/

      Parser_error(p, _STR("Cant [] non-array/string/map. Got type \"%.*s\"",
                           typ.len, typ.str));
    };

    Parser_check(p, LSBR);

    if (is_str) {
      /*if*/

      typ = tos2("byte");

      Parser_fgen(p, tos2("["));

      if (p->builtin_pkg) {
        /*if*/

        Parser_gen(p, tos2(".str["));

        close_bracket = 1;

      } else {
        /*else if*/

        Parser_gen(p, tos2(","));
      };
    };

    if (is_fixed_arr) {
      /*if*/

      if (string_contains(typ, tos2("]["))) {
        /*if*/

        int pos = string_index_after(typ, tos2("["), 1);

        typ = string_right(typ, pos);

      } else {
        /*else if*/

        typ = string_all_after(typ, tos2("]"));
      };

      Parser_gen(p, tos2("["));

      close_bracket = 1;

    } else if (is_ptr) {
      /*if*/

      typ = string_replace(typ, tos2("*"), tos2(""));

      if (!is_arr) {
        /*if*/

        Parser_gen(p, tos2("[/*ptr*/"));

        close_bracket = 1;
      };
    };

    if (is_arr) {
      /*if*/

      Parser_fgen(p, tos2("["));

      if (is_arr0) {
        /*if*/

        if (Parser_fileis(&/* ? */ *p, tos2("int_test"))) {
          /*if*/

          println(_STR("\nRRRR0 %.*s", typ.len, typ.str));
        };

        typ = string_right(typ, 6);

        if (Parser_fileis(&/* ? */ *p, tos2("int_test"))) {
          /*if*/

          println(_STR("RRRR %.*s", typ.len, typ.str));
        };
      };

      if (string_eq(typ, tos2("array"))) {
        /*if*/

        typ = tos2("void*");
      };

      if (p->translated) {
        /*if*/

        CGen_set_placeholder(p->cgen, fn_ph,
                             _STR("((%.*s*)(", typ.len, typ.str));

        Parser_gen(p, tos2(".data))["));

      } else {
        /*else if*/

        Parser_gen(p, tos2(","));
      };
    };

    if (is_map) {
      /*if*/

      typ = string_replace(typ, tos2("map_"), tos2(""));

      if (string_eq(typ, tos2("map"))) {
        /*if*/

        typ = tos2("void*");
      };

      Parser_gen(p, tos2(","));
    };

    if (is_arr) {
      /*if*/

      Type *T = Table_find_type(&/* ? */ *p->table, Parser_expression(p));

      if (string_ne(T->parent, tos2("int"))) {
        /*if*/

        Parser_check_types(p, T->name, tos2("int"));
      };

    } else {
      /*else if*/

      Parser_expression(p);
    };

    Parser_check(p, RSBR);

    if (close_bracket) {
      /*if*/

      Parser_gen(p, _STR("]/*r%.*s %d*/", typ.len, typ.str, v.is_mut));
    };
  };

  if (p->tok == ASSIGN || p->tok == PLUS_ASSIGN || p->tok == MINUS_ASSIGN ||
      p->tok == MULT_ASSIGN || p->tok == DIV_ASSIGN || p->tok == XOR_ASSIGN ||
      p->tok == MOD_ASSIGN || p->tok == OR_ASSIGN || p->tok == AND_ASSIGN ||
      p->tok == RIGHT_SHIFT_ASSIGN || p->tok == LEFT_SHIFT_ASSIGN) {
    /*if*/

    if (is_map || is_arr) {
      /*if*/
    };

    if (is_indexer && is_str && !p->builtin_pkg) {
      /*if*/

      Parser_error(p, tos2("strings are immutable"));
    };

    int assign_pos = p->cgen->cur_line.len;

    p->assigned_type = typ;

    Parser_assign_statement(p, v, fn_ph,
                            is_indexer && (/*lpar*/ is_map || is_arr));

    if (is_indexer && (/*lpar*/ is_map || is_arr)) {
      /*if*/

      string tmp = Parser_get_tmp(p);

      string tmp_val = string_right(p->cgen->cur_line, assign_pos);

      p->cgen->cur_line = string_left(p->cgen->cur_line, assign_pos);

      if (is_map) {
        /*if*/

        CGen_set_placeholder(p->cgen, fn_ph, tos2("map__set(&"));

      } else {
        /*else if*/

        if (is_ptr) {
          /*if*/

          CGen_set_placeholder(p->cgen, fn_ph, tos2("array_set("));

        } else {
          /*else if*/

          CGen_set_placeholder(p->cgen, fn_ph, tos2("array_set(&/*q*/"));
        };
      };

      Parser_gen(p, _STR(", & %.*s)", tmp.len, tmp.str));

      CGen_insert_before(p->cgen,
                         _STR("%.*s %.*s = %.*s;", typ.len, typ.str, tmp.len,
                              tmp.str, tmp_val.len, tmp_val.str));
    };

    return typ;

    return tos2("void");

  } else if ((/*lpar*/ is_map || is_arr ||
              (/*lpar*/ is_str && !p->builtin_pkg)) &&
             is_indexer) {
    /*if*/

    string index_expr = string_right(p->cgen->cur_line, fn_ph);

    p->cgen->cur_line = string_left(p->cgen->cur_line, fn_ph);

    string tmp = Parser_get_tmp(p);

    string tmp_ok = Parser_get_tmp(p);

    if (is_map) {
      /*if*/

      Parser_gen(p, _STR("%.*s", tmp.len, tmp.str));

      string def = type_default(typ);

      CGen_insert_before(
          p->cgen,
          _STR("%.*s %.*s = %.*s; bool %.*s = map_get(%.*s, & %.*s);", typ.len,
               typ.str, tmp.len, tmp.str, def.len, def.str, tmp_ok.len,
               tmp_ok.str, index_expr.len, index_expr.str, tmp.len, tmp.str));

    } else if (is_arr) {
      /*if*/

      if (p->translated) {
        /*if*/

        Parser_gen(p, _STR("%.*s ]", index_expr.len, index_expr.str));

      } else {
        /*else if*/

        Parser_gen(p, _STR("( *(%.*s*) array__get(%.*s) )", typ.len, typ.str,
                           index_expr.len, index_expr.str));
      };

    } else if (is_str && !p->builtin_pkg) {
      /*if*/

      Parser_gen(p, _STR("string_at(%.*s)", index_expr.len, index_expr.str));
    };

    if (is_map && string_eq(typ, tos2("string"))) {
      /*if*/

      CGen_insert_before(p->cgen,
                         _STR("if (!%.*s) %.*s = tos(\"\", 0);", tmp_ok.len,
                              tmp_ok.str, tmp.len, tmp.str));
    };
  };

  return typ;
}
string Parser_expression(Parser *p) {

  if (string_contains(p->scanner->file_path, tos2("test_test"))) {
    /*if*/

    println(_STR("epxression() pass=%d tok=", p->run));

    Parser_print_tok(&/* ? */ *p);
  };

  p->cgen;

  (/*lpar*/ tos2("/* expr start*/"));

  int ph = CGen_add_placeholder(p->cgen);

  string typ = Parser_term(p);

  bool is_str = string_eq(typ, tos2("string"));

  if (p->tok == LEFT_SHIFT) {
    /*if*/

    if (string_contains(typ, tos2("array_"))) {
      /*if*/

      string tmp = Parser_get_tmp(p);

      string tmp_typ = string_right(typ, 6);

      Parser_next(p);

      Parser_gen(p, tos2(", ("));

      if (!p->expr_var.is_mut && !p->translated) {
        /*if*/

        Parser_error(p, _STR("`%.*s` is immutable (can\'t <<)",
                             p->expr_var.name.len, p->expr_var.name.str));
      };

      Parser_check_types(p, Parser_expression(p), tmp_typ);

      Parser_gen(p, _STR("), %.*s, %.*s)", tmp.len, tmp.str, tmp_typ.len,
                         tmp_typ.str));

      string push_call = (string_contains(typ, tos2("*"))) ? (tos2("_PUSH("))
                                                           : (tos2("_PUSH(&"));

      CGen_set_placeholder(p->cgen, ph, push_call);

      return tos2("void");

    } else {
      /*else if*/

      Parser_next(p);

      Parser_gen(p, tos2(" << "));

      Parser_check_types(p, Parser_expression(p), typ);

      return tos2("int");
    };
  };

  if (p->tok == IN) {
    /*if*/

    Parser_fgen(p, tos2(" "));

    Parser_check(p, IN);

    Parser_fgen(p, tos2(" "));

    Parser_gen(p, tos2(", "));

    string arr_typ = Parser_expression(p);

    if (!string_starts_with(arr_typ, tos2("array_"))) {
      /*if*/

      Parser_error(p, tos2("`in` requires an array"));
    };

    Type *T = Table_find_type(&/* ? */ *p->table, arr_typ);

    if (!Type_has_method(&/* ? */ *T, tos2("contains"))) {
      /*if*/

      Parser_error(
          p, _STR("%.*s has no method `contains`", arr_typ.len, arr_typ.str));
    };

    CGen_set_placeholder(p->cgen, ph, _STR("_IN(%.*s, ", typ.len, typ.str));

    Parser_gen(p, tos2(")"));

    return tos2("bool");
  };

  if (p->tok == RIGHT_SHIFT) {
    /*if*/

    Parser_next(p);

    Parser_gen(p, tos2(" >> "));

    Parser_check_types(p, Parser_expression(p), typ);

    return tos2("int");
  };

  if (p->tok == DOT) {
    /*if*/

    while (p->tok == DOT) {

      typ = Parser_dot(p, typ, 0);
    };
  };

  while (p->tok == PLUS || p->tok == MINUS || p->tok == PIPE || p->tok == AMP ||
         p->tok == XOR) {

    Token tok_op = p->tok;

    bool is_num = string_eq(typ, tos2("void*")) ||
                  string_eq(typ, tos2("byte*")) || is_number_type(typ);

    Parser_next(p);

    if (is_str && tok_op == PLUS) {
      /*if*/

      CGen_set_placeholder(p->cgen, ph, tos2("string_add("));

      Parser_gen(p, tos2(","));

    } else if (is_num) {
      /*if*/

      Parser_gen(p, Token_str(tok_op));

    } else {
      /*else if*/

      if (p->translated) {
        /*if*/

        Parser_gen(p, string_add(Token_str(tok_op), tos2(" /*doom hack*/")));

      } else {
        /*else if*/

        Parser_gen(p, tos2(","));
      };
    };

    Parser_check_types(p, Parser_term(p), typ);

    if (is_str && tok_op == PLUS) {
      /*if*/

      Parser_gen(p, tos2(")"));
    };

    if (!p->translated && !is_str && !is_num) {
      /*if*/

      Type *T = Table_find_type(&/* ? */ *p->table, typ);

      if (tok_op == PLUS) {
        /*if*/

        if (Type_has_method(&/* ? */ *T, tos2("+"))) {
          /*if*/

          CGen_set_placeholder(p->cgen, ph, string_add(typ, tos2("_plus(")));

          Parser_gen(p, tos2(")"));

        } else {
          /*else if*/

          Parser_error(
              p, _STR("operator + not defined on `%.*s`", typ.len, typ.str));
        };

      } else if (tok_op == MINUS) {
        /*if*/

        if (Type_has_method(&/* ? */ *T, tos2("-"))) {
          /*if*/

          CGen_set_placeholder(p->cgen, ph,
                               _STR("%.*s_minus(", typ.len, typ.str));

          Parser_gen(p, tos2(")"));

        } else {
          /*else if*/

          Parser_error(
              p, _STR("operator - not defined on `%.*s`", typ.len, typ.str));
        };
      };
    };
  };

  return typ;
}
string Parser_term(Parser *p) {

  int line_nr = p->scanner->line_nr;

  if (Parser_fileis(&/* ? */ *p, tos2("fn_test"))) {
    /*if*/

    println(_STR("\nterm() %d", line_nr));
  };

  string typ = Parser_unary(p);

  if (Parser_fileis(&/* ? */ *p, tos2("fn_test"))) {
    /*if*/

    println(_STR("2: %d", line_nr));
  };

  if (p->tok == MUL && line_nr != p->scanner->line_nr) {
    /*if*/

    return typ;
  };

  while (p->tok == MUL || p->tok == DIV || p->tok == MOD) {

    Token tok = p->tok;

    bool is_div = tok == DIV;

    bool is_mod = tok == MOD;

    Parser_next(p);

    Parser_gen(p, Token_str(tok));

    Parser_fgen(p,
                string_add(string_add(tos2(" "), Token_str(tok)), tos2(" ")));

    if (is_div && p->tok == INT && string_eq(p->lit, tos2("0"))) {
      /*if*/

      Parser_error(p, tos2("division by zero"));
    };

    if (is_mod && (/*lpar*/ is_float_type(typ) || !is_number_type(typ))) {
      /*if*/

      Parser_error(p, tos2("operator MOD requires integer types"));
    };

    Parser_check_types(p, Parser_unary(p), typ);
  };

  return typ;
}
string Parser_unary(Parser *p) {

  string typ = tos2("");

  Token tok = p->tok;

  if ((tok == NOT)) { /* case */

    Parser_gen(p, tos2("!"));

    Parser_next(p);

    typ = tos2("bool");

    Parser_bool_expression(p);

  } else if ((tok == BIT_NOT)) { /* case */

    Parser_gen(p, tos2("~"));

    Parser_next(p);

    typ = Parser_bool_expression(p);

  } else { // default:

    typ = Parser_factor(p);
  };

  return typ;
}
string Parser_factor(Parser *p) {

  string typ = tos2("");

  Token tok = p->tok;

  if ((tok == INT)) { /* case */

    typ = tos2("int");

    if ((/*lpar*/ string_contains(p->lit, tos2(".")) ||
         string_contains(p->lit, tos2("e"))) &&
        !(/*lpar*/ string_at(p->lit, 0) == '0' &&
          string_at(p->lit, 1) == 'x')) {
      /*if*/

      typ = tos2("f32");
    };

    Parser_gen(p, p->lit);

    Parser_fgen(p, p->lit);

  } else if ((tok == MINUS)) { /* case */

    Parser_gen(p, tos2("-"));

    Parser_fgen(p, tos2("-"));

    Parser_next(p);

    return Parser_factor(p);

  } else if ((tok == SIZEOF)) { /* case */

    Parser_gen(p, tos2("sizeof("));

    Parser_fgen(p, tos2("sizeof("));

    Parser_next(p);

    Parser_check(p, LPAR);

    string sizeof_typ = Parser_get_type(p);

    if (string_ends_with(sizeof_typ, tos2("*"))) {
      /*if*/

      sizeof_typ =
          string_add(tos2("*"), string_left(sizeof_typ, sizeof_typ.len - 1));
    };

    Parser_check(p, RPAR);

    Parser_gen(p, _STR("%.*s)", sizeof_typ.len, sizeof_typ.str));

    Parser_fgen(p, _STR("%.*s)", sizeof_typ.len, sizeof_typ.str));

    return tos2("int");

  } else if ((tok == AMP)) { /* case */

    return Parser_name_expr(p);

  } else if ((tok == DOT)) { /* case */

    return Parser_name_expr(p);

  } else if ((tok == MUL)) { /* case */

    return Parser_name_expr(p);

  } else if ((tok == NAME)) { /* case */

    if (string_eq(p->lit, tos2("map")) && Parser_peek(p) == LSBR) {
      /*if*/

      return Parser_map_init(p);
    };

    if (string_eq(p->lit, tos2("json")) && Parser_peek(p) == DOT) {
      /*if*/

      return Parser_js_decode(p);
    };

    typ = Parser_name_expr(p);

    return typ;

  } else if ((tok == DEFAULT)) { /* case */

    Parser_next(p);

    Parser_next(p);

    string name = Parser_check_name(p);

    if (string_ne(name, tos2("T"))) {
      /*if*/

      Parser_error(p, tos2("default needs T"));
    };

    Parser_gen(p, tos2("default(T)"));

    Parser_next(p);

    return tos2("T");

  } else if ((tok == LPAR)) { /* case */

    Parser_gen(p, tos2("(/*lpar*/"));

    Parser_next(p);

    typ = Parser_bool_expression(p);

    if (!p->ptr_cast) {
      /*if*/

      Parser_check(p, RPAR);
    };

    p->ptr_cast = 0;

    Parser_gen(p, tos2(")"));

    return typ;

  } else if ((tok == CHAR)) { /* case */

    Parser_char_expr(p);

    typ = tos2("byte");

    return typ;

  } else if ((tok == STRING)) { /* case */

    Parser_string_expr(p);

    typ = tos2("string");

    return typ;

  } else if ((tok == FALSE)) { /* case */

    typ = tos2("bool");

    Parser_gen(p, tos2("0"));

    Parser_fgen(p, tos2("false"));

  } else if ((tok == TRUE)) { /* case */

    typ = tos2("bool");

    Parser_gen(p, tos2("1"));

    Parser_fgen(p, tos2("true"));

  } else if ((tok == LSBR)) { /* case */

    return Parser_array_init(p);

  } else if ((tok == LCBR)) { /* case */

    return Parser_assoc(p);

  } else if ((tok == IF)) { /* case */

    typ = Parser_if_st(p, 1);

    return typ;

  } else { // default:

    Token next = Parser_peek(p);

    println(_STR("PREV=%.*s", Token_str(p->prev_tok).len,
                 Token_str(p->prev_tok).str));

    println(_STR("NEXT=%.*s", Token_str(next).len, Token_str(next).str));

    Parser_error(p, _STR("unexpected token: `%.*s`", Token_str(p->tok).len,
                         Token_str(p->tok).str));
  };

  Parser_next(p);

  return typ;
}
string Parser_assoc(Parser *p) {

  Parser_next(p);

  string name = Parser_check_name(p);

  if (!Fn_known_var(&/* ? */ *p->cur_fn, name)) {
    /*if*/

    Parser_error(p, _STR("unknown variable `%.*s`", name.len, name.str));
  };

  Var var = Fn_find_var(&/* ? */ *p->cur_fn, name);

  Parser_check(p, PIPE);

  Parser_gen(p, _STR("(%.*s){", var.typ.len, var.typ.str));

  array_string fields =
      new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  while (p->tok != RCBR) {

    string field = Parser_check_name(p);

    _PUSH(&fields, (field), tmp203, string);

    Parser_gen(p, _STR(".%.*s = ", field.len, field.str));

    Parser_check(p, COLON);

    Parser_bool_expression(p);

    Parser_gen(p, tos2(","));

    if (p->tok != RCBR) {
      /*if*/

      Parser_check(p, COMMA);
    };
  };

  Type *T = Table_find_type(&/* ? */ *p->table, var.typ);

  array_Var tmp205 = T->fields;
  ;
  for (int tmp206 = 0; tmp206 < tmp205.len; tmp206++) {
    Var ffield = ((Var *)tmp205.data)[tmp206];

    string f = ffield.name;

    if (_IN(string, f, fields)) {
      /*if*/

      continue;
    };

    Parser_gen(p, _STR(".%.*s = %.*s . %.*s,", f.len, f.str, name.len, name.str,
                       f.len, f.str));
  };

  Parser_check(p, RCBR);

  Parser_gen(p, tos2("}"));

  return var.typ;
}
void Parser_char_expr(Parser *p) {

  Parser_gen(p, _STR("\'%.*s\'", p->lit.len, p->lit.str));

  Parser_next(p);
}
string format_str(string str) {

  str = string_replace(str, tos2("\""), tos2("\\\""));

  str = string_replace(str, tos2("\n"), tos2("\\n"));

  return str;
}
string Parser_typ_to_fmt(Parser *p, string typ) {

  Type *t = Table_find_type(&/* ? */ *p->table, typ);

  if (string_eq(t->parent, tos2("int"))) {
    /*if*/

    return tos2("%d");
  };

  if (string_eq(typ, tos2("string"))) { /* case */

    return tos2("%.*s");

  } else if (string_eq(typ, tos2("ustring"))) { /* case */

    return tos2("%.*s");

  } else if (string_eq(typ, tos2("byte"))) { /* case */

    return tos2("%d");

  } else if (string_eq(typ, tos2("int"))) { /* case */

    return tos2("%d");

  } else if (string_eq(typ, tos2("char"))) { /* case */

    return tos2("%d");

  } else if (string_eq(typ, tos2("byte"))) { /* case */

    return tos2("%d");

  } else if (string_eq(typ, tos2("bool"))) { /* case */

    return tos2("%d");

  } else if (string_eq(typ, tos2("u32"))) { /* case */

    return tos2("%d");

  } else if (string_eq(typ, tos2("f64")) ||
             string_eq(typ, tos2("f32"))) { /* case */

    return tos2("%f");

  } else if (string_eq(typ, tos2("i64"))) { /* case */

    return tos2("%lld");

  } else if (string_eq(typ, tos2("byte*")) ||
             string_eq(typ, tos2("byteptr"))) { /* case */

    return tos2("%s");

  } else if (string_eq(typ, tos2("void"))) { /* case */

    Parser_error(p, tos2("cannot interpolate this value"));

  } else { // default:

    if (string_ends_with(typ, tos2("*"))) {
      /*if*/

      return tos2("%p");
    };

    Parser_error(p,
                 _STR("unhandled sprintf format \"%.*s\" ", typ.len, typ.str));
  };

  return tos2("");
}
void Parser_string_expr(Parser *p) {

  string str = p->lit;

  Parser_fgen(p, _STR("\'%.*s\'", str.len, str.str));

  if (Parser_peek(p) != DOLLAR) {
    /*if*/

    string f = format_str(str);

    if (p->calling_c || p->translated) {
      /*if*/

      Parser_gen(p, _STR("\"%.*s\"", f.len, f.str));

    } else {
      /*else if*/

      Parser_gen(p, _STR("tos2(\"%.*s\")", f.len, f.str));
    };

    Parser_next(p);

    return;
  };

  string args = tos2("\"");

  string format = tos2("\"");

  while (p->tok == STRING) {

    format = string_add(format, format_str(p->lit));

    Parser_next(p);

    if (p->tok != DOLLAR) {
      /*if*/

      continue;
    };

    Parser_next(p);

    CGen_start_tmp(p->cgen);

    string typ = Parser_bool_expression(p);

    string val = CGen_end_tmp(p->cgen);

    val = string_trim_space(val);

    args = string_add(args, _STR(", %.*s", val.len, val.str));

    if (string_eq(typ, tos2("string"))) {
      /*if*/

      args = string_add(args, _STR(".len, %.*s.str", val.len, val.str));
    };

    if (string_eq(typ, tos2("ustring"))) {
      /*if*/

      args = string_add(args, _STR(".len, %.*s.s.str", val.len, val.str));
    };

    bool custom = p->tok == COLON;

    if (custom) {
      /*if*/

      format = string_add(format, tos2("%"));

      Parser_next(p);

      if (p->tok == DOT) {
        /*if*/

        format = string_add(format, tos2("."));

        Parser_next(p);
      };

      format = string_add(format, p->lit);

      Parser_next(p);

      format = string_add(format, p->lit);

      Parser_next(p);

    } else {
      /*else if*/

      format = string_add(format, Parser_typ_to_fmt(p, typ));
    };
  };

  if (p->cgen->nogen) {
    /*if*/

    return;
  };

  string cur_line = string_trim_space(p->cgen->cur_line);

  if (string_contains(cur_line, tos2("println(")) && p->tok != PLUS &&
      !p->is_prod && !string_contains(cur_line, tos2("string_add"))) {
    /*if*/

    p->cgen->cur_line =
        string_replace(cur_line, tos2("println("), tos2("printf("));

    Parser_gen(p,
               _STR("%.*s\\n%.*s", format.len, format.str, args.len, args.str));

    return;
  };

  if (p->tok == NOT) {
    /*if*/

    Parser_next(p);

    Parser_gen(p, _STR("_STR_TMP(%.*s%.*s)", format.len, format.str, args.len,
                       args.str));

  } else {
    /*else if*/

    Parser_gen(
        p, _STR("_STR(%.*s%.*s)", format.len, format.str, args.len, args.str));
  };
}
string Parser_map_init(Parser *p) {

  Parser_next(p);

  Parser_check(p, LSBR);

  string key_type = Parser_check_name(p);

  if (string_ne(key_type, tos2("string"))) {
    /*if*/

    Parser_error(p, tos2("only string key maps allowed for now"));
  };

  Parser_check(p, RSBR);

  string val_type = Parser_check_name(p);

  if (!Table_known_type(&/* ? */ *p->table, val_type)) {
    /*if*/

    Parser_error(
        p, _STR("map init unknown type \"%.*s\"", val_type.len, val_type.str));
  };

  Parser_gen(p, _STR("new_map(1, sizeof(%.*s))", val_type.len, val_type.str));

  Parser_check(p, LCBR);

  Parser_check(p, RCBR);

  return _STR("map_%.*s", val_type.len, val_type.str);
}
string Parser_array_init(Parser *p) {

  Parser_check(p, LSBR);

  bool is_integer = p->tok == INT;

  string lit = p->lit;

  string typ = tos2("");

  int new_arr_ph = CGen_add_placeholder(p->cgen);

  int i = 0;

  int pos = p->cgen->cur_line.len;

  while (p->tok != RSBR) {

    string val_typ = Parser_bool_expression(p);

    if (i == 0) {
      /*if*/

      typ = val_typ;

      if (is_integer && p->tok == RSBR && Parser_peek(p) == NAME) {
        /*if*/

        byte nextc = string_at(p->scanner->text, p->scanner->pos + 1);

        if (!byte_is_space(nextc)) {
          /*if*/

          Parser_check(p, RSBR);

          string name = Parser_check_name(p);

          if (Table_known_type(&/* ? */ *p->table, name)) {
            /*if*/

            p->cgen->cur_line = tos2("");

            Parser_gen(p, tos2("{} /* arkek init*/"));

            return _STR("[%.*s]%.*s", lit.len, lit.str, name.len, name.str);

          } else {
            /*else if*/

            Parser_error(p, _STR("bad type `%.*s`", name.len, name.str));
          };
        };
      };
    };

    if (string_ne(val_typ, typ)) {
      /*if*/

      if (!Parser_check_types_no_throw(p, val_typ, typ)) {
        /*if*/

        Parser_error(p, _STR("bad array element type `%.*s` instead of `%.*s`",
                             val_typ.len, val_typ.str, typ.len, typ.str));
      };
    };

    if (p->tok != RSBR && p->tok != SEMICOLON) {
      /*if*/

      Parser_gen(p, tos2(","));

      Parser_check(p, COMMA);
    };

    i++;

    if (i == 1 && p->tok == SEMICOLON) {
      /*if*/

      Parser_check_space(p, SEMICOLON);

      string val = string_right(p->cgen->cur_line, pos);

      p->cgen->cur_line = string_left(p->cgen->cur_line, pos);

      if (0 && string_eq(string_trim_space(val), tos2("0"))) {
        /*if*/

        Parser_gen(p, tos2("array_repeat( & V_ZERO, "));

      } else {
        /*else if*/

        string tmp = Parser_get_tmp(p);

        CGen_insert_before(p->cgen, _STR("%.*s %.*s = %.*s;", typ.len, typ.str,
                                         tmp.len, tmp.str, val.len, val.str));

        Parser_gen(p, _STR("array_repeat(&%.*s, ", tmp.len, tmp.str));
      };

      Parser_check_types(p, Parser_bool_expression(p), tos2("int"));

      Parser_gen(p, _STR(", sizeof(%.*s) )", typ.len, typ.str));

      Parser_check(p, RSBR);

      return _STR("array_%.*s", typ.len, typ.str);
    };
  };

  Parser_check(p, RSBR);

  if (p->tok != NAME && i == 0) {
    /*if*/

    Parser_error(p, tos2("specify array type: `[]typ` instead of `[]`"));
  };

  if (p->tok == NAME && i == 0) {
    /*if*/

    typ = Parser_get_type(p);
  };

  bool no_alloc = p->tok == NOT;

  if (no_alloc) {
    /*if*/

    Parser_next(p);
  };

  bool is_fixed_size = p->tok == NOT;

  if (is_fixed_size) {
    /*if*/

    Parser_next(p);

    Parser_gen(p, tos2(" }"));

    if (!Parser_first_run(&/* ? */ *p)) {
      /*if*/

      if (p->inside_const) {
        /*if*/

        CGen_set_placeholder(p->cgen, new_arr_ph, tos2("{ "));

      } else {
        /*else if*/

        CGen_set_placeholder(p->cgen, new_arr_ph,
                             _STR("(%.*s[]) { ", typ.len, typ.str));
      };
    };

    return _STR("[%d]%.*s", i, typ.len, typ.str);
  };

  string new_arr = tos2("new_array_from_c_array");

  if (no_alloc) {
    /*if*/

    new_arr = string_add(new_arr, tos2("_no_alloc"));
  };

  Parser_gen(p, tos2(" })"));

  if (!Parser_first_run(&/* ? */ *p)) {
    /*if*/

    CGen_set_placeholder(p->cgen, new_arr_ph,
                         _STR("%.*s(%d, %d, sizeof(%.*s), (%.*s[]) { ",
                              new_arr.len, new_arr.str, i, i, typ.len, typ.str,
                              typ.len, typ.str));
  };

  typ = _STR("array_%.*s", typ.len, typ.str);

  Parser_register_array(p, typ);

  return typ;
}
void Parser_register_array(Parser *p, string typ) {

  if (string_contains(typ, tos2("*"))) {
    /*if*/

    println(_STR("bad arr %.*s", typ.len, typ.str));

    return;
  };

  if (!Table_known_type(&/* ? */ *p->table, typ)) {
    /*if*/

    Parser_register_type_with_parent(p, typ, tos2("array"));

    _PUSH(&p->cgen->typedefs, (_STR("typedef array %.*s;", typ.len, typ.str)),
          tmp235, string);
  };
}
string Parser_struct_init(Parser *p, bool is_c_struct_init) {

  p->is_struct_init = 1;

  string typ = Parser_get_type(p);

  StringBuilder_cut(p->scanner->fmt_out, typ.len);

  bool ptr = string_contains(typ, tos2("*"));

  if (string_eq(typ, tos2("tm"))) {
    /*if*/
    string tmp238 = tos2("");

    array_set(&/*q*/ p->cgen->lines, p->cgen->lines.len - 1, &tmp238);
    string tmp239 = tos2("");

    array_set(&/*q*/ p->cgen->lines, p->cgen->lines.len - 2, &tmp239);
  };

  Parser_check(p, LCBR);

  if (!ptr) {
    /*if*/

    if (p->is_c_struct_init) {
      /*if*/

      Parser_gen(p, _STR("(struct %.*s) {", typ.len, typ.str));

      p->is_c_struct_init = 0;

    } else {
      /*else if*/

      Parser_gen(p, _STR("(%.*s) {", typ.len, typ.str));
    };

  } else {
    /*else if*/

    if (p->tok == NOT) {
      /*if*/

      Parser_next(p);

      Parser_gen(p, tos2("0"));

      Parser_check(p, RCBR);

      return typ;
    };

    string no_star = string_replace(typ, tos2("*"), tos2(""));

    Parser_gen(p, _STR("ALLOC_INIT(%.*s, {", no_star.len, no_star.str));
  };

  array_string inited_fields =
      new_array_from_c_array(0, 0, sizeof(string), (string[]){});

  Token peek = Parser_peek(p);

  if (peek == COLON || p->tok == RCBR) {
    /*if*/

    Type *t = Table_find_type(&/* ? */ *p->table, typ);

    while (p->tok != RCBR) {

      string field = Parser_check_name(p);

      if (!Type_has_field(&/* ? */ *t, field)) {
        /*if*/

        Parser_error(p, _STR("`%.*s` has no field `%.*s`", t->name.len,
                             t->name.str, field.len, field.str));
      };

      _PUSH(&inited_fields, (field), tmp245, string);

      Parser_gen(p, _STR(".%.*s = ", field.len, field.str));

      Parser_check(p, COLON);

      Parser_fspace(p);

      Parser_expression(p);

      if (p->tok == COMMA) {
        /*if*/

        Parser_next(p);
      };

      if (p->tok != RCBR) {
        /*if*/

        Parser_gen(p, tos2(","));
      };

      Parser_fgenln(p, tos2(""));
    };

    if (t->fields.len != inited_fields.len && inited_fields.len > 0) {
      /*if*/

      Parser_gen(p, tos2(","));
    };

    array_Var tmp246 = t->fields;
    ;
    for (int i = 0; i < tmp246.len; i++) {
      Var field = ((Var *)tmp246.data)[i];

      if (array_string_contains(inited_fields, field.name)) {
        /*if*/

        continue;
      };

      string field_typ = field.typ;

      if (!p->builtin_pkg && string_ends_with(field_typ, tos2("*")) &&
          string_contains(field_typ, tos2("Cfg"))) {
        /*if*/

        Parser_error(p, _STR("pointer field `%.*s.%.*s` must be initialized",
                             typ.len, typ.str, field.name.len, field.name.str));
      };

      string def_val = type_default(field_typ);

      if (string_ne(def_val, tos2(""))) {
        /*if*/

        Parser_gen(p, _STR(".%.*s = %.*s", field.name.len, field.name.str,
                           def_val.len, def_val.str));

        if (i != t->fields.len - 1) {
          /*if*/

          Parser_gen(p, tos2(","));
        };
      };
    };

  } else {
    /*else if*/

    Type *T = Table_find_type(&/* ? */ *p->table, typ);

    if (T->fields.len == 0 && string_ne(T->parent, tos2(""))) {
      /*if*/

      T = Table_find_type(&/* ? */ *p->table, T->parent);
    };

    array_Var tmp250 = T->fields;
    ;
    for (int i = 0; i < tmp250.len; i++) {
      Var ffield = ((Var *)tmp250.data)[i];

      string expr_typ = Parser_bool_expression(p);

      if (!Parser_check_types_no_throw(p, expr_typ, ffield.typ)) {
        /*if*/

        Parser_error(
            p, _STR("field value #%d `%.*s` has type `%.*s`, got `%.*s` ",
                    i + 1, ffield.name.len, ffield.name.str, ffield.typ.len,
                    ffield.typ.str, expr_typ.len, expr_typ.str));
      };

      if (i < T->fields.len - 1) {
        /*if*/

        if (p->tok != COMMA) {
          /*if*/

          Parser_error(
              p, _STR("too few values in `%.*s` literal (%d instead of %d)",
                      typ.len, typ.str, i + 1, T->fields.len));
        };

        Parser_gen(p, tos2(","));

        Parser_next(p);
      };
    };

    if (p->tok == COMMA) {
      /*if*/

      Parser_next(p);
    };

    if (p->tok != RCBR) {
      /*if*/

      Parser_error(p,
                   _STR("too many fields initialized: `%.*s` has %d field(s)",
                        typ.len, typ.str, T->fields.len));
    };
  };

  Parser_gen(p, tos2("}"));

  if (ptr) {
    /*if*/

    Parser_gen(p, tos2(")"));
  };

  Parser_check(p, RCBR);

  p->is_struct_init = 0;

  return typ;
}
string Parser_cast(Parser *p, string typ) {

  Parser_next(p);

  int pos = CGen_add_placeholder(p->cgen);

  if (p->tok == RPAR) {
    /*if*/

    p->ptr_cast = 1;

    Parser_next(p);
  };

  Parser_check(p, LPAR);

  string expr_typ = Parser_bool_expression(p);

  Parser_check(p, RPAR);

  if (string_eq(typ, tos2("string")) &&
      (/*lpar*/ string_eq(expr_typ, tos2("byte*")) ||
       string_eq(expr_typ, tos2("byteptr")))) {
    /*if*/

    CGen_set_placeholder(p->cgen, pos, tos2("tos2("));

  } else if (string_eq(typ, tos2("string")) &&
             string_eq(expr_typ, tos2("int"))) {
    /*if*/

    Parser_error(
        p, _STR("cannot cast `%.*s` to `%.*s`, use `str()` method instead",
                expr_typ.len, expr_typ.str, typ.len, typ.str));

  } else {
    /*else if*/

    CGen_set_placeholder(p->cgen, pos, _STR("(%.*s)(", typ.len, typ.str));
  };

  Parser_gen(p, tos2(")"));

  return typ;
}
string Parser_get_tmp(Parser *p) {

  p->tmp_cnt++;

  return _STR("tmp%d", p->tmp_cnt);
}
int Parser_get_tmp_counter(Parser *p) {

  p->tmp_cnt++;

  return p->tmp_cnt;
}
string os_name_to_ifdef(string name) {

  if (string_eq(name, tos2("windows"))) { /* case */

    return tos2("_WIN32");

  } else if (string_eq(name, tos2("mac"))) { /* case */

    return tos2("__APPLE__");

  } else if (string_eq(name, tos2("linux"))) { /* case */

    return tos2("__linux__");
  };

  v_panic(_STR("bad os ifdef name \"%.*s\"", name.len, name.str));

  return tos2("");
}
void Parser_comp_time(Parser *p) {

  Parser_next(p);

  if (p->tok == IF) {
    /*if*/

    Parser_next(p);

    bool not = p->tok == NOT;

    if (not) {
      /*if*/

      Parser_next(p);
    };

    string name = Parser_check_name(p);

    if (_IN(string, name, main__SupportedPlatforms)) {
      /*if*/

      string ifdef_name = os_name_to_ifdef(name);

      if (not) {
        /*if*/

        Parser_genln(p, _STR("#ifndef %.*s", ifdef_name.len, ifdef_name.str));

      } else {
        /*else if*/

        Parser_genln(p, _STR("#ifdef %.*s", ifdef_name.len, ifdef_name.str));
      };

      Parser_check(p, LCBR);

      Parser_statements_no_curly_end(p);

      if (!(/*lpar*/ p->tok == DOLLAR && Parser_peek(p) == ELSE)) {
        /*if*/

        Parser_genln(p, tos2("#endif"));
      };

    } else {
      /*else if*/

      println(tos2("Supported platforms:"));

      println(array_string_str(main__SupportedPlatforms));

      Parser_error(p, _STR("unknown platform `%.*s`", name.len, name.str));
    };

  } else if (p->tok == FOR) {
    /*if*/

    Parser_next(p);

    string name = Parser_check_name(p);

    if (string_ne(name, tos2("field"))) {
      /*if*/

      Parser_error(p, tos2("for field only"));
    };

    Parser_check(p, IN);

    Parser_check_name(p);

    Parser_check(p, DOT);

    Parser_check_name(p);

    Parser_check(p, LCBR);

    string res_name = Parser_check_name(p);

    println(res_name);

    Parser_check(p, DOT);

    Parser_check(p, DOLLAR);

    Parser_check(p, NAME);

    Parser_check(p, ASSIGN);

    CGen_start_tmp(p->cgen);

    Parser_bool_expression(p);

    string val = CGen_end_tmp(p->cgen);

    println(val);

    Parser_check(p, RCBR);

  } else if (p->tok == ELSE) {
    /*if*/

    Parser_next(p);

    Parser_check(p, LCBR);

    Parser_genln(p, tos2("#else"));

    Parser_statements_no_curly_end(p);

    Parser_genln(p, tos2("#endif"));

  } else {
    /*else if*/

    Parser_error(p, tos2("bad comptime expr"));
  };
}
void Parser_chash(Parser *p) {

  string hash = string_trim_space(p->lit);

  Parser_next(p);

  bool is_sig = Parser_is_sig(p);

  if (is_sig) {
    /*if*/
  };

  if (string_eq(hash, tos2("live"))) {
    /*if*/

    if (p->is_so) {
      /*if*/

      return;
    };

    p->is_live = 1;

    return;
  };

  if (string_starts_with(hash, tos2("flag "))) {
    /*if*/

    string flag = string_right(hash, 5);

    if (string_contains(hash, tos2("linux")) && p->os != LINUX) {
      /*if*/

      return;

    } else if (string_contains(hash, tos2("darwin")) && p->os != MAC) {
      /*if*/

      return;

    } else if (string_contains(hash, tos2("windows")) && p->os != WINDOWS) {
      /*if*/

      return;
    };

    if (string_contains(flag, tos2("linux")) ||
        string_contains(flag, tos2("darwin")) ||
        string_contains(flag, tos2("windows"))) {
      /*if*/

      int pos = string_index(flag, tos2(" "));

      flag = string_right(flag, pos);
    };

    flag = string_replace(string_trim_space(flag), tos2("@VROOT"), p->vroot);

    if (array_string_contains(p->table->flags, flag)) {
      /*if*/

      return;
    };

    Parser_log(&/* ? */ *p, _STR("adding flag \"%.*s\"", flag.len, flag.str));

    _PUSH(&p->table->flags, (flag), tmp264, string);

    return;
  };

  if (string_starts_with(hash, tos2("include"))) {
    /*if*/

    if (Parser_first_run(&/* ? */ *p) && !is_sig) {
      /*if*/

      _PUSH(&p->cgen->includes, (_STR("#%.*s", hash.len, hash.str)), tmp265,
            string);

      return;
    };

  } else if (string_starts_with(hash, tos2("typedef"))) {
    /*if*/

    if (Parser_first_run(&/* ? */ *p)) {
      /*if*/

      _PUSH(&p->cgen->typedefs, (_STR("%.*s", hash.len, hash.str)), tmp266,
            string);
    };

  } else if (string_contains(hash, tos2("embed"))) {
    /*if*/

    int pos = string_index(hash, tos2("embed")) + 5;

    string file = string_right(hash, pos);

    if (p->build_mode != DEFAULT_MODE) {
      /*if*/

      Parser_genln(p, _STR("#include %.*s", file.len, file.str));
    };

  } else if (string_contains(hash, tos2("define"))) {
    /*if*/

    _PUSH(&p->cgen->includes, (_STR("#%.*s", hash.len, hash.str)), tmp269,
          string);

  } else {
    /*else if*/

    if (!p->can_chash) {
      /*if*/

      Parser_error(
          p, tos2("bad token `#` (embedding C code is no longer supported)"));
    };

    Parser_genln(p, hash);
  };
}
string Parser_if_st(Parser *p, bool is_expr) {

  if (is_expr) {
    /*if*/

    if (Parser_fileis(&/* ? */ *p, tos2("if_expr"))) {
      /*if*/

      println(tos2("IF EXPR"));
    };

    p->inside_if_expr = 1;

    Parser_gen(p, tos2("("));

  } else {
    /*else if*/

    Parser_gen(p, tos2("if ("));

    Parser_fgen(p, tos2("if "));
  };

  Parser_next(p);

  Parser_check_types(p, Parser_bool_expression(p), tos2("bool"));

  if (is_expr) {
    /*if*/

    Parser_gen(p, tos2(") ? ("));

  } else {
    /*else if*/

    Parser_genln(p, tos2(") {"));

    Parser_fgenln(p, tos2("{"));

    Parser_genln(p, tos2("/*if*/"));
  };

  Parser_fgen(p, tos2(" "));

  Parser_check(p, LCBR);

  string typ = tos2("");

  if (p->tok == IF && p->inside_if_expr) {
    /*if*/

    println(tos2("AAAWWFAFAF"));

    typ = Parser_factor(p);

    println(_STR("QWEWQE typ=%.*s", typ.len, typ.str));

    Parser_next(p);

  } else {
    /*else if*/

    typ = Parser_statements(p);
  };

  if (p->tok == ELSE) {
    /*if*/

    Parser_next(p);

    if (p->tok == IF) {
      /*if*/

      Parser_gen(p, tos2(" else "));

      return Parser_if_st(p, is_expr);
    };

    if (is_expr) {
      /*if*/

      Parser_gen(p, tos2(") : ("));

    } else {
      /*else if*/

      Parser_genln(p, tos2(" else { "));

      Parser_genln(p, tos2("/*else if*/"));
    };

    Parser_check(p, LCBR);

    typ = Parser_statements(p);

    p->inside_if_expr = 0;

    if (is_expr) {
      /*if*/

      Parser_gen(p, tos2(")"));
    };

    return typ;
  };

  p->inside_if_expr = 0;

  if (Parser_fileis(&/* ? */ *p, tos2("test_test"))) {
    /*if*/

    println(_STR("if ret typ=\"%.*s\" line=%d", typ.len, typ.str,
                 p->scanner->line_nr));
  };

  return typ;
}
void Parser_for_st(Parser *p) {

  Parser_check(p, FOR);

  Parser_fgen(p, tos2(" "));

  p->for_expr_cnt++;

  Token next_tok = Parser_peek(p);

  bool debug = string_contains(p->scanner->file_path, tos2("r_draw"));

  if (debug) {
    /*if*/

    println(tos2("\n\nFOR {"));
  };

  Fn_open_scope(p->cur_fn);

  if (p->tok == LCBR) {
    /*if*/

    Parser_gen(p, tos2("while (1) {"));

  } else if (p->tok == MUT) {
    /*if*/

    Parser_error(p, tos2("`mut` is not required in for loops"));

  } else if (next_tok == DECL_ASSIGN || next_tok == ASSIGN ||
             p->tok == SEMICOLON) {
    /*if*/

    if (debug) {
      /*if*/

      println(tos2("for 1"));
    };

    Parser_genln(p, tos2("for ("));

    if (next_tok == DECL_ASSIGN) {
      /*if*/

      Parser_var_decl(p);

    } else if (p->tok != SEMICOLON) {
      /*if*/

      Parser_statement(p, 0);
    };

    if (debug) {
      /*if*/

      println(tos2("for 2"));
    };

    Parser_check(p, SEMICOLON);

    Parser_gen(p, tos2(" ; "));

    Parser_fgen(p, tos2(" "));

    if (p->tok != SEMICOLON) {
      /*if*/

      Parser_bool_expression(p);
    };

    if (debug) {
      /*if*/

      println(tos2("for 3"));
    };

    Parser_check(p, SEMICOLON);

    Parser_gen(p, tos2(" ; "));

    Parser_fgen(p, tos2(" "));

    if (p->tok != LCBR) {
      /*if*/

      Parser_statement(p, 0);
    };

    if (debug) {
      /*if*/

      println(tos2("for 4"));
    };

    Parser_fgen(p, tos2(" "));

    Parser_genln(p, tos2(") { "));

  } else if (Parser_peek(p) == COMMA) {
    /*if*/

    string i = Parser_check_name(p);

    Parser_check(p, COMMA);

    string val = Parser_check_name(p);

    Parser_fgen(p, tos2(" "));

    Parser_check(p, IN);

    Parser_fgen(p, tos2(" "));

    string tmp = Parser_get_tmp(p);

    CGen_start_tmp(p->cgen);

    string typ = Parser_bool_expression(p);

    string expr = CGen_end_tmp(p->cgen);

    Parser_genln(p, _STR("%.*s %.*s = %.*s ;", typ.len, typ.str, tmp.len,
                         tmp.str, expr.len, expr.str));

    string var_typ = string_right(typ, 6);

    Var val_var = (Var){.name = val,
                        .typ = var_typ,
                        .ptr = string_contains(typ, tos2("*")),
                        .is_arg = 0,
                        .is_const = 0,
                        .is_import_const = 0,
                        .args = new_array(0, 1, sizeof(Var)),
                        .attr = tos("", 0),
                        .is_mut = 0,
                        .ref = 0,
                        .parent_fn = tos("", 0),
                        .pkg = tos("", 0),
                        .line_nr = 0,
                        .is_global = 0,
                        .is_used = 0,
                        .scope_level = 0};

    Parser_register_var(p, val_var);

    Var i_var = (Var){.name = i,
                      .typ = tos2("int"),
                      .is_mut = 1,
                      .is_arg = 0,
                      .is_const = 0,
                      .is_import_const = 0,
                      .args = new_array(0, 1, sizeof(Var)),
                      .attr = tos("", 0),
                      .ptr = 0,
                      .ref = 0,
                      .parent_fn = tos("", 0),
                      .pkg = tos("", 0),
                      .line_nr = 0,
                      .is_global = 0,
                      .is_used = 0,
                      .scope_level = 0};

    Parser_register_var(p, i_var);

    Parser_genln(p, _STR(";\nfor (int %.*s = 0; %.*s < %.*s .len; %.*s ++) {",
                         i.len, i.str, i.len, i.str, tmp.len, tmp.str, i.len,
                         i.str));

    Parser_genln(p,
                 _STR("%.*s %.*s = ((%.*s *) %.*s . data)[%.*s];", var_typ.len,
                      var_typ.str, val.len, val.str, var_typ.len, var_typ.str,
                      tmp.len, tmp.str, i.len, i.str));

  } else if (Parser_peek(p) == IN) {
    /*if*/

    string val = Parser_check_name(p);

    Parser_fgen(p, tos2(" "));

    Parser_check(p, IN);

    Parser_fspace(p);

    string tmp = Parser_get_tmp(p);

    CGen_start_tmp(p->cgen);

    string typ = Parser_bool_expression(p);

    string expr = CGen_end_tmp(p->cgen);

    bool is_range = p->tok == DOTDOT;

    string range_end = tos2("");

    if (is_range) {
      /*if*/

      Parser_check_types(p, typ, tos2("int"));

      Parser_check_space(p, DOTDOT);

      CGen_start_tmp(p->cgen);

      Parser_check_types(p, Parser_bool_expression(p), tos2("int"));

      range_end = CGen_end_tmp(p->cgen);
    };

    bool is_arr = string_contains(typ, tos2("array"));

    bool is_str = string_eq(typ, tos2("string"));

    if (!is_arr && !is_str && !is_range) {
      /*if*/

      Parser_error(p,
                   _STR("`for in` requires an array or a string but got `%.*s`",
                        typ.len, typ.str));
    };

    Parser_genln(p, _STR("%.*s %.*s = %.*s;", typ.len, typ.str, tmp.len,
                         tmp.str, expr.len, expr.str));

    string var_type = tos2("");

    if (is_arr) {
      /*if*/

      var_type = string_right(typ, 6);

    } else if (is_str) {
      /*if*/

      var_type = tos2("byte");

    } else if (is_range) {
      /*if*/

      var_type = tos2("int");
    };

    Var val_var = (Var){.name = val,
                        .typ = var_type,
                        .ptr = string_contains(typ, tos2("*")),
                        .is_arg = 0,
                        .is_const = 0,
                        .is_import_const = 0,
                        .args = new_array(0, 1, sizeof(Var)),
                        .attr = tos("", 0),
                        .is_mut = 0,
                        .ref = 0,
                        .parent_fn = tos("", 0),
                        .pkg = tos("", 0),
                        .line_nr = 0,
                        .is_global = 0,
                        .is_used = 0,
                        .scope_level = 0};

    Parser_register_var(p, val_var);

    string i = Parser_get_tmp(p);

    if (is_range) {
      /*if*/

      Parser_genln(p, _STR(";\nfor (int %.*s = %.*s; %.*s < %.*s; %.*s++) {",
                           i.len, i.str, tmp.len, tmp.str, i.len, i.str,
                           range_end.len, range_end.str, i.len, i.str));

    } else {
      /*else if*/

      Parser_genln(p, _STR(";\nfor (int %.*s = 0; %.*s < %.*s .len; %.*s ++) {",
                           i.len, i.str, i.len, i.str, tmp.len, tmp.str, i.len,
                           i.str));
    };

    if (is_arr) {
      /*if*/

      Parser_genln(p,
                   _STR("%.*s %.*s = ((%.*s *) %.*s.data)[%.*s];", var_type.len,
                        var_type.str, val.len, val.str, var_type.len,
                        var_type.str, tmp.len, tmp.str, i.len, i.str));

    } else if (is_str) {
      /*if*/

      Parser_genln(p,
                   _STR("%.*s %.*s = ((%.*s *) %.*s.str)[%.*s];", var_type.len,
                        var_type.str, val.len, val.str, var_type.len,
                        var_type.str, tmp.len, tmp.str, i.len, i.str));

    } else if (is_range) {
      /*if*/

      Parser_genln(p, _STR("%.*s %.*s = %.*s;", var_type.len, var_type.str,
                           val.len, val.str, i.len, i.str));
    };

  } else {
    /*else if*/

    Parser_gen(p, tos2("while ("));

    Parser_check_types(p, Parser_bool_expression(p), tos2("bool"));

    Parser_genln(p, tos2(") {"));
  };

  Parser_check(p, LCBR);

  Parser_statements(p);

  Fn_close_scope(p->cur_fn);

  p->for_expr_cnt--;
}
void Parser_switch_statement(Parser *p) {

  Parser_next(p);

  CGen_start_tmp(p->cgen);

  string typ = Parser_bool_expression(p);

  string expr = CGen_end_tmp(p->cgen);

  Parser_check(p, LCBR);

  int i = 0;

  while (p->tok == CASE || p->tok == DEFAULT) {

    if (p->tok == DEFAULT) {
      /*if*/

      Parser_genln(p, tos2("else  { // default:"));

      Parser_next(p);

      Parser_check(p, COLON);

      Parser_statements(p);

      break;
    };

    if (i > 0) {
      /*if*/

      Parser_gen(p, tos2("else "));
    };

    Parser_gen(p, tos2("if ("));

    bool got_comma = 0;

    while (1) {
      if (got_comma) {
        /*if*/

        Parser_gen(p, tos2(") ||  "));
      };

      if (string_eq(typ, tos2("string"))) {
        /*if*/

        Parser_gen(p, _STR("string_eq(%.*s, ", expr.len, expr.str));

      } else {
        /*else if*/

        Parser_gen(p, _STR("(%.*s == ", expr.len, expr.str));
      };

      if (p->tok == CASE || p->tok == DEFAULT) {
        /*if*/

        Parser_next(p);
      };

      Parser_bool_expression(p);

      if (p->tok != COMMA) {
        /*if*/

        break;
      };

      Parser_check(p, COMMA);

      got_comma = 1;
    };

    Parser_check(p, COLON);

    Parser_gen(p, tos2(")) {"));

    Parser_genln(p, tos2("/* case */"));

    Parser_statements(p);

    i++;
  };
}
void Parser_assert_statement(Parser *p) {

  Parser_check(p, ASSERT);

  Parser_fspace(p);

  string tmp = Parser_get_tmp(p);

  Parser_gen(p, _STR("bool %.*s = ", tmp.len, tmp.str));

  Parser_check_types(p, Parser_bool_expression(p), tos2("bool"));

  string filename = p->file_path;

  Parser_genln(
      p,
      _STR(";\n \nif (!%.*s) { \n  puts(\"\\x1B[31mFAILED: %.*s() in "
           "%.*s:%d\\x1B[0m\");  \ng_test_ok = 0 ; \n	// TODO\n	// "
           "Maybe print all vars in a test function if it fails? \n} \nelse { "
           "\n  puts(\"\\x1B[32mPASSED: %.*s()\\x1B[0m\");\n}",
           tmp.len, tmp.str, p->cur_fn->name.len, p->cur_fn->name.str,
           filename.len, filename.str, p->scanner->line_nr, p->cur_fn->name.len,
           p->cur_fn->name.str));
}
void Parser_return_st(Parser *p) {

  CGen_insert_before(p->cgen, p->cur_fn->defer);

  Parser_gen(p, tos2("return "));

  if (string_eq(p->cur_fn->name, tos2("main"))) {
    /*if*/

    Parser_gen(p, tos2(" 0"));
  };

  Parser_check(p, RETURN);

  Parser_fgen(p, tos2(" "));

  bool fn_returns = string_ne(p->cur_fn->typ, tos2("void"));

  if (fn_returns) {
    /*if*/

    if (p->tok == RCBR) {
      /*if*/

      Parser_error(p, _STR("`%.*s` needs to return `%.*s`", p->cur_fn->name.len,
                           p->cur_fn->name.str, p->cur_fn->typ.len,
                           p->cur_fn->typ.str));

    } else {
      /*else if*/

      int ph = CGen_add_placeholder(p->cgen);

      string expr_type = Parser_bool_expression(p);

      if (string_ends_with(p->cur_fn->typ, expr_type) &&
          string_starts_with(p->cur_fn->typ, tos2("Option_"))) {
        /*if*/

        CGen_set_placeholder(p->cgen, ph, tos2("opt_ok(& "));

        Parser_gen(p, tos2(")"));
      };

      Parser_check_types(p, expr_type, p->cur_fn->typ);
    };

  } else {
    /*else if*/

    if (0 && p->tok == NAME || p->tok == INT) {
      /*if*/

      Parser_error(p, _STR("function `%.*s` does not return a value",
                           p->cur_fn->name.len, p->cur_fn->name.str));
    };
  };

  p->returns = 1;
}
string prepend_pkg(string pkg, string name) {

  return _STR("%.*s__%.*s", pkg.len, pkg.str, name.len, name.str);
}
string Parser_prepend_pkg(Parser *p, string name) {

  return prepend_pkg(p->pkg, name);
}
void Parser_go_statement(Parser *p) {

  Parser_check(p, GO);

  if (Parser_peek(p) == DOT) {
    /*if*/

    string var_name = p->lit;

    Var v = Fn_find_var(&/* ? */ *p->cur_fn, var_name);

    Fn_mark_var_used(&/* ? */ *p->cur_fn, v);

    Parser_next(p);

    Parser_check(p, DOT);

    Type *typ = Table_find_type(&/* ? */ *p->table, v.typ);

    Fn method = Table_find_method(&/* ? */ *p->table, typ, p->lit);

    Parser_async_fn_call(p, method, 0, var_name, v.typ);

  } else {
    /*else if*/

    Fn f = Table_find_fn(&/* ? */ *p->table, p->lit);

    if (string_eq(f.name, tos2("println"))) {
      /*if*/

      Parser_error(p, tos2("`go` cannot be used with `println`"));
    };

    Parser_async_fn_call(p, f, 0, tos2(""), tos2(""));
  };
}
void Parser_register_var(Parser *p, Var v) {

  if (v.line_nr == 0) {
    /*if*/

    v.line_nr = p->scanner->line_nr;
  };

  Fn_register_var(p->cur_fn, v);
}
string Parser_js_decode(Parser *p) {

  Parser_check(p, NAME);

  Parser_check(p, DOT);

  string op = Parser_check_name(p);

  if (string_eq(op, tos2("decode"))) {
    /*if*/

    Parser_check(p, LPAR);

    string typ = Parser_get_type(p);

    Parser_check(p, COMMA);

    CGen_start_tmp(p->cgen);

    Parser_check_types(p, Parser_bool_expression(p), tos2("string"));

    string expr = CGen_end_tmp(p->cgen);

    Parser_check(p, RPAR);

    string tmp = Parser_get_tmp(p);

    string cjson_tmp = Parser_get_tmp(p);

    string decl = _STR("%.*s %.*s; ", typ.len, typ.str, tmp.len, tmp.str);

    Type *T = Table_find_type(&/* ? */ *p->table, typ);

    array_Var tmp313 = T->fields;
    ;
    for (int tmp314 = 0; tmp314 < tmp313.len; tmp314++) {
      Var field = ((Var *)tmp313.data)[tmp314];

      string def_val = type_default(field.typ);

      if (string_ne(def_val, tos2(""))) {
        /*if*/

        decl = string_add(decl, _STR("%.*s . %.*s = %.*s;\n", tmp.len, tmp.str,
                                     field.name.len, field.name.str,
                                     def_val.len, def_val.str));
      };
    };

    Parser_gen_json_for_type(p, *T);

    decl = string_add(decl,
                      _STR("cJSON* %.*s = json__json_parse(%.*s);",
                           cjson_tmp.len, cjson_tmp.str, expr.len, expr.str));

    CGen_insert_before(p->cgen, decl);

    Parser_gen(p, _STR("json__jsdecode_%.*s(%.*s, &%.*s); cJSON_Delete(%.*s);",
                       typ.len, typ.str, cjson_tmp.len, cjson_tmp.str, tmp.len,
                       tmp.str, cjson_tmp.len, cjson_tmp.str));

    string opt_type = _STR("Option_%.*s", typ.len, typ.str);

    _PUSH(&p->cgen->typedefs,
          (_STR("typedef Option %.*s;", opt_type.len, opt_type.str)), tmp317,
          string);

    Table_register_type(p->table, opt_type);

    return opt_type;

  } else if (string_eq(op, tos2("encode"))) {
    /*if*/

    Parser_check(p, LPAR);

    CGen_start_tmp(p->cgen);

    string typ = Parser_bool_expression(p);

    Type *T = Table_find_type(&/* ? */ *p->table, typ);

    Parser_gen_json_for_type(p, *T);

    string expr = CGen_end_tmp(p->cgen);

    Parser_check(p, RPAR);

    Parser_gen(p, _STR("json__json_print(json__jsencode_%.*s(%.*s))", typ.len,
                       typ.str, expr.len, expr.str));

    return tos2("string");

  } else {
    /*else if*/

    Parser_error(p, _STR("bad json op \"%.*s\"", op.len, op.str));
  };

  return tos2("");
}
bool is_compile_time_const(string s) {

  s = string_trim_space(s);

  if (string_eq(s, tos2(""))) {
    /*if*/

    return 0;
  };

  if (string_contains(s, tos2("\'"))) {
    /*if*/

    return 1;
  };

  string tmp321 = s;
  ;
  for (int tmp322 = 0; tmp322 < tmp321.len; tmp322++) {
    byte c = ((byte *)tmp321.str)[tmp322];

    if (!(/*lpar*/ (/*lpar*/ c >= '0' && c <= '9') || c == '.')) {
      /*if*/

      return 0;
    };
  };

  return 1;
}
bool Parser_building_v(Parser *p) {

  string cur_dir = os__getwd();

  return string_contains(p->file_path, tos2("v/compiler")) ||
         string_contains(cur_dir, tos2("v/compiler"));
}
void Scanner_fgen(Scanner *scanner, string s) {}
void Scanner_fgenln(Scanner *scanner, string s) {}
void Parser_fgen(Parser *p, string s) {}
void Parser_fspace(Parser *p) {}
void Parser_fgenln(Parser *p, string s) {}
Scanner *new_scanner(string file_path) {

  if (!os__file_exists(file_path)) {
    /*if*/

    v_panic(_STR("\"%.*s\" doesn\'t exist", file_path.len, file_path.str));
  };

  Option_string tmp1 = os__read_file(file_path);
  if (!tmp1.ok) {

    v_panic(
        _STR("scanner: failed to open \"%.*s\"", file_path.len, file_path.str));

    return ALLOC_INIT(Scanner, {.file_path = tos("", 0),
                                .text = tos("", 0),
                                .pos = 0,
                                .line_nr = 0,
                                .inside_string = 0,
                                .dollar_start = 0,
                                .dollar_end = 0,
                                .debug = 0,
                                .line_comment = tos("", 0),
                                .started = 0,
                                .is_fmt = 0,
                                .fmt_indent = 0,
                                .fmt_line_empty = 0});
  }
  string text = *(string *)tmp1.data;
  ;

  Scanner *scanner = ALLOC_INIT(Scanner, {.file_path = file_path,
                                          .text = text,
                                          .fmt_out = new_string_builder(1000),
                                          .pos = 0,
                                          .line_nr = 0,
                                          .inside_string = 0,
                                          .dollar_start = 0,
                                          .dollar_end = 0,
                                          .debug = 0,
                                          .line_comment = tos("", 0),
                                          .started = 0,
                                          .is_fmt = 0,
                                          .fmt_indent = 0,
                                          .fmt_line_empty = 0});

  return scanner;
}
ScanRes scan_res(Token tok, string lit) { return (ScanRes){tok, lit}; }
bool is_white(byte c) { return byte_is_white(c); }
bool is_nl(byte c) { return c == '\r' || c == '\n'; }
string Scanner_ident_name(Scanner *s) {

  int start = s->pos;

  while (1) {
    s->pos++;

    if (s->pos >= s->text.len) {
      /*if*/

      break;
    };

    byte c = string_at(s->text, s->pos);

    if (!is_name_char(c) && !byte_is_digit(c)) {
      /*if*/

      break;
    };
  };

  string name = string_substr(s->text, start, s->pos);

  s->pos--;

  return name;
}
string Scanner_ident_number(Scanner *s) {

  int start = s->pos;

  bool is_hex = s->pos + 1 < s->text.len && string_at(s->text, s->pos) == '0' &&
                string_at(s->text, s->pos + 1) == 'x';

  bool is_oct = !is_hex && string_at(s->text, s->pos) == '0';

  bool is_float = 0;

  while (1) {
    s->pos++;

    if (s->pos >= s->text.len) {
      /*if*/

      break;
    };

    byte c = string_at(s->text, s->pos);

    if (c == '.') {
      /*if*/

      is_float = 1;
    };

    bool is_good_hex =
        is_hex && (/*lpar*/ c == 'x' || (/*lpar*/ c >= 'a' && c <= 'f'));

    if (!is_hex && c == 'e' && s->pos + 1 < s->text.len) {
      /*if*/

      byte next = string_at(s->text, s->pos + 1);

      if (next == '+' || next == '-' || byte_is_digit(next)) {
        /*if*/

        s->pos++;

        continue;
      };
    };

    if (!byte_is_digit(c) && c != '.' && !is_good_hex) {
      /*if*/

      break;
    };

    if (c == '.' && s->pos + 1 < s->text.len &&
        string_at(s->text, s->pos + 1) == '.') {
      /*if*/

      break;
    };

    if (is_oct && c >= '8' && !is_float) {
      /*if*/

      Scanner_error(&/* ? */ *s, tos2("malformed octal constant"));
    };
  };

  string number = string_substr(s->text, start, s->pos);

  s->pos--;

  return number;
}
void Scanner_skip_whitespace(Scanner *s) {

  while (s->pos < s->text.len && is_white(string_at(s->text, s->pos))) {

    if (is_nl(string_at(s->text, s->pos))) {
      /*if*/

      s->line_nr++;

      if (s->is_fmt) {
        /*if*/

        return;
      };
    };

    s->pos++;
  };
}
string Scanner_get_var_name(Scanner *s, int pos) {

  int pos_start = pos;

  for (; pos_start >= 0 && string_at(s->text, pos_start) != '\n' &&
         string_at(s->text, pos_start) != ';';
       pos_start--) {
  };

  pos_start++;

  return string_substr(s->text, pos_start, pos);
}
void Scanner_cao_change(Scanner *s, string operator) {

  s->text = string_add(
      string_add(
          string_add(
              string_add(
                  string_add(string_add(string_substr(s->text, 0,
                                                      s->pos - operator.len),
                                        tos2(" = ")),
                             Scanner_get_var_name(s, s->pos - operator.len)),
                  tos2(" ")),
              operator),
          tos2(" ")),
      string_substr(s->text, s->pos + 1, s->text.len));
}
ScanRes Scanner_scan(Scanner *s) {

  if (s->pos > 0) {
    /*if*/

    s->pos++;
  };

  s->started = 1;

  if (s->pos >= s->text.len) {
    /*if*/

    return scan_res(EOF, tos2(""));
  };

  if (!s->inside_string) {
    /*if*/

    Scanner_skip_whitespace(s);
  };

  if (s->is_fmt && string_at(s->text, s->pos) == '\n') {
    /*if*/

    return scan_res(NL, tos2(""));
  };

  if (!s->is_fmt && s->dollar_end) {
    /*if*/

    if (string_at(s->text, s->pos) == main__SINGLE_QUOTE) {
      /*if*/

      s->dollar_end = 0;

      return scan_res(STRING, tos2(""));
    };

    s->dollar_end = 0;

    return scan_res(STRING, Scanner_ident_string(s));
  };

  Scanner_skip_whitespace(s);

  if (s->pos >= s->text.len) {
    /*if*/

    return scan_res(EOF, tos2(""));
  };

  byte c = string_at(s->text, s->pos);

  byte nextc = '\0';

  if (s->pos + 1 < s->text.len) {
    /*if*/

    nextc = string_at(s->text, s->pos + 1);
  };

  if (is_name_char(c)) {
    /*if*/

    string name = Scanner_ident_name(s);

    byte next_char =
        (s->pos + 1 < s->text.len) ? (string_at(s->text, s->pos + 1)) : ('\0');

    if (is_key(name)) {
      /*if*/

      return scan_res(key_to_token(name), tos2(""));
    };

    if (s->inside_string) {
      /*if*/

      if (next_char == main__SINGLE_QUOTE) {
        /*if*/

        s->pos++;

        s->dollar_start = 0;

        s->inside_string = 0;
      };
    };

    if (s->dollar_start && next_char != '.') {
      /*if*/

      s->dollar_end = 1;

      s->dollar_start = 0;
    };

    if (s->pos == 0 && next_char == ' ') {
      /*if*/

      s->pos++;
    };

    return scan_res(NAME, name);

  } else if (byte_is_digit(c) || c == '.' && byte_is_digit(nextc)) {
    /*if*/

    string num = Scanner_ident_number(s);

    return scan_res(INT, num);
  };

  if ((c == '+')) { /* case */

    if (nextc == '+') {
      /*if*/

      s->pos++;

      return scan_res(INC, tos2(""));

    } else if (nextc == '=') {
      /*if*/

      s->pos++;

      Scanner_cao_change(s, tos2("+"));

      return scan_res(PLUS_ASSIGN, tos2(""));
    };

    return scan_res(PLUS, tos2(""));

  } else if ((c == '-')) { /* case */

    if (nextc == '-') {
      /*if*/

      s->pos++;

      return scan_res(DEC, tos2(""));

    } else if (nextc == '=') {
      /*if*/

      s->pos++;

      Scanner_cao_change(s, tos2("-"));

      return scan_res(MINUS_ASSIGN, tos2(""));
    };

    return scan_res(MINUS, tos2(""));

  } else if ((c == '*')) { /* case */

    if (nextc == '=') {
      /*if*/

      s->pos++;

      Scanner_cao_change(s, tos2("*"));

      return scan_res(MULT_ASSIGN, tos2(""));
    };

    return scan_res(MUL, tos2(""));

  } else if ((c == '^')) { /* case */

    if (nextc == '=') {
      /*if*/

      s->pos++;

      Scanner_cao_change(s, tos2("^"));

      return scan_res(XOR_ASSIGN, tos2(""));
    };

    return scan_res(XOR, tos2(""));

  } else if ((c == '%')) { /* case */

    if (nextc == '=') {
      /*if*/

      s->pos++;

      Scanner_cao_change(s, tos2("%"));

      return scan_res(MOD_ASSIGN, tos2(""));
    };

    return scan_res(MOD, tos2(""));

  } else if ((c == '?')) { /* case */

    return scan_res(QUESTION, tos2(""));

  } else if ((c == main__SINGLE_QUOTE)) { /* case */

    return scan_res(STRING, Scanner_ident_string(s));

  } else if ((c == '\`')) { /* case */

    return scan_res(CHAR, Scanner_ident_char(s));

  } else if ((c == '(')) { /* case */

    return scan_res(LPAR, tos2(""));

  } else if ((c == ')')) { /* case */

    return scan_res(RPAR, tos2(""));

  } else if ((c == '[')) { /* case */

    return scan_res(LSBR, tos2(""));

  } else if ((c == ']')) { /* case */

    return scan_res(RSBR, tos2(""));

  } else if ((c == '{')) { /* case */

    if (s->inside_string) {
      /*if*/

      return Scanner_scan(s);
    };

    return scan_res(LCBR, tos2(""));

  } else if ((c == '$')) { /* case */

    return scan_res(DOLLAR, tos2(""));

  } else if ((c == '}')) { /* case */

    if (s->inside_string) {
      /*if*/

      s->pos++;

      if (string_at(s->text, s->pos) == main__SINGLE_QUOTE) {
        /*if*/

        s->inside_string = 0;

        return scan_res(STRING, tos2(""));
      };

      return scan_res(STRING, Scanner_ident_string(s));

    } else {
      /*else if*/

      return scan_res(RCBR, tos2(""));
    };

  } else if ((c == '&')) { /* case */

    if (nextc == '=') {
      /*if*/

      s->pos++;

      Scanner_cao_change(s, tos2("&"));

      return scan_res(AND_ASSIGN, tos2(""));
    };

    if (nextc == '&') {
      /*if*/

      s->pos++;

      return scan_res(AND, tos2(""));
    };

    return scan_res(AMP, tos2(""));

  } else if ((c == '|')) { /* case */

    if (nextc == '|') {
      /*if*/

      s->pos++;

      return scan_res(OR, tos2(""));
    };

    if (nextc == '=') {
      /*if*/

      s->pos++;

      Scanner_cao_change(s, tos2("|"));

      return scan_res(OR_ASSIGN, tos2(""));
    };

    return scan_res(PIPE, tos2(""));

  } else if ((c == ',')) { /* case */

    return scan_res(COMMA, tos2(""));

  } else if ((c == '\r')) { /* case */

    if (nextc == '\n') {
      /*if*/

      s->pos++;

      return scan_res(NL, tos2(""));
    };

  } else if ((c == '\n')) { /* case */

    return scan_res(NL, tos2(""));

  } else if ((c == '.')) { /* case */

    if (nextc == '.') {
      /*if*/

      s->pos++;

      return scan_res(DOTDOT, tos2(""));
    };

    return scan_res(DOT, tos2(""));

  } else if ((c == '#')) { /* case */

    int start = s->pos + 1;

    while (s->pos < s->text.len && string_at(s->text, s->pos) != '\n') {

      s->pos++;
    };

    s->line_nr++;

    string hash = string_substr(s->text, start, s->pos);

    if (s->is_fmt) {
      /*if*/

      s->pos--;
    };

    return scan_res(HASH, string_trim_space(hash));

  } else if ((c == '>')) { /* case */

    if (nextc == '=') {
      /*if*/

      s->pos++;

      return scan_res(GE, tos2(""));

    } else if (nextc == '>') {
      /*if*/

      if (s->pos + 2 < s->text.len && string_at(s->text, s->pos + 2) == '=') {
        /*if*/

        s->pos = s->pos + 2;

        Scanner_cao_change(s, tos2(">>"));

        return scan_res(RIGHT_SHIFT_ASSIGN, tos2(""));
      };

      s->pos++;

      return scan_res(RIGHT_SHIFT, tos2(""));

    } else {
      /*else if*/

      return scan_res(GT, tos2(""));
    };

  } else if ((c == '<')) { /* case */

    if (nextc == '=') {
      /*if*/

      s->pos++;

      return scan_res(LE, tos2(""));

    } else if (nextc == '<') {
      /*if*/

      if (s->pos + 2 < s->text.len && string_at(s->text, s->pos + 2) == '=') {
        /*if*/

        s->pos = s->pos + 2;

        Scanner_cao_change(s, tos2("<<"));

        return scan_res(LEFT_SHIFT_ASSIGN, tos2(""));
      };

      s->pos++;

      return scan_res(LEFT_SHIFT, tos2(""));

    } else {
      /*else if*/

      return scan_res(LT, tos2(""));
    };

  } else if ((c == '=')) { /* case */

    if (nextc == '=') {
      /*if*/

      s->pos++;

      return scan_res(EQ, tos2(""));

    } else {
      /*else if*/

      return scan_res(ASSIGN, tos2(""));
    };

  } else if ((c == ':')) { /* case */

    if (nextc == '=') {
      /*if*/

      s->pos++;

      return scan_res(DECL_ASSIGN, tos2(""));

    } else {
      /*else if*/

      return scan_res(COLON, tos2(""));
    };

  } else if ((c == ';')) { /* case */

    return scan_res(SEMICOLON, tos2(""));

  } else if ((c == '!')) { /* case */

    if (nextc == '=') {
      /*if*/

      s->pos++;

      return scan_res(NE, tos2(""));

    } else {
      /*else if*/

      return scan_res(NOT, tos2(""));
    };

  } else if ((c == '~')) { /* case */

    return scan_res(BIT_NOT, tos2(""));

  } else if ((c == '/')) { /* case */

    if (nextc == '=') {
      /*if*/

      s->pos++;

      Scanner_cao_change(s, tos2("/"));

      return scan_res(DIV_ASSIGN, tos2(""));
    };

    if (nextc == '/') {
      /*if*/

      int start = s->pos + 1;

      while (s->pos < s->text.len && string_at(s->text, s->pos) != '\n') {

        s->pos++;
      };

      s->line_nr++;

      s->line_comment = string_substr(s->text, start + 1, s->pos);

      s->line_comment = string_trim_space(s->line_comment);

      Scanner_fgenln(s,
                     _STR("// %.*s", s->line_comment.len, s->line_comment.str));

      if (s->is_fmt) {
        /*if*/

        s->pos--;

      } else {
        /*else if*/

        return Scanner_scan(s);
      };

      return scan_res(LINE_COM, s->line_comment);
    };

    if (nextc == '*') {
      /*if*/

      int start = s->pos;

      while (!(/*lpar*/ string_at(s->text, s->pos) == '*' &&
               string_at(s->text, s->pos + 1) == '/')) {

        s->pos++;

        if (s->pos >= s->text.len) {
          /*if*/

          s->line_nr--;

          Scanner_error(&/* ? */ *s, tos2("comment not terminated"));
        };

        if (string_at(s->text, s->pos) == '\n') {
          /*if*/

          s->line_nr++;
        };
      };

      s->pos++;

      int end = s->pos + 1;

      string comm = string_substr(s->text, start, end);

      Scanner_fgenln(s, comm);

      if (s->is_fmt) {
        /*if*/

        return scan_res(MLINE_COM, comm);
      };

      return Scanner_scan(s);
    };

    return scan_res(DIV, tos2(""));
  };

  println(_STR("(char code=%d) pos=%d len=%d", c, s->pos, s->text.len));

  Scanner_error(&/* ? */ *s, _STR("invalid character `%.*s`", byte_str(c).len,
                                  byte_str(c).str));

  return scan_res(EOF, tos2(""));
}
void Scanner_error(Scanner *s, string msg) {

  string file = string_all_after(s->file_path, tos2("/"));

  println(_STR("panic: %.*s:%d", file.len, file.str, s->line_nr + 1));

  println(msg);

  v_exit(1);
}
string Scanner_ident_string(Scanner *s) {

  bool debug = string_contains(s->file_path, tos2("test_test"));

  if (debug) {
    /*if*/

    println(_STR("identStr() %.*s line=%d pos=%d", s->file_path.len,
                 s->file_path.str, s->line_nr, s->pos));
  };

  int start = s->pos;

  s->inside_string = 0;

  byte slash = '\\';

  while (1) {
    s->pos++;

    if (s->pos >= s->text.len) {
      /*if*/

      break;
    };

    byte c = string_at(s->text, s->pos);

    if (debug) {
      /*if*/

      println(byte_str(c));
    };

    byte prevc = string_at(s->text, s->pos - 1);

    if (c == main__SINGLE_QUOTE &&
        (/*lpar*/ prevc != slash ||
         (/*lpar*/ prevc == slash &&
          string_at(s->text, s->pos - 2) == slash))) {
      /*if*/

      break;
    };

    if (c == '\n') {
      /*if*/

      s->line_nr++;
    };

    if (c == '0' && s->pos > 2 && string_at(s->text, s->pos - 1) == '\\') {
      /*if*/

      Scanner_error(&/* ? */ *s, tos2("0 character in a string literal"));
    };

    if (c == '0' && s->pos > 5 && string_at(s->text, s->pos - 1) == '0' &&
        string_at(s->text, s->pos - 2) == 'x' &&
        string_at(s->text, s->pos - 3) == '\\') {
      /*if*/

      Scanner_error(&/* ? */ *s, tos2("0 character in a string literal"));
    };

    if (!s->is_fmt && c == '{' && prevc == '$') {
      /*if*/

      s->inside_string = 1;

      s->pos = s->pos - 2;

      break;
    };

    if (!s->is_fmt && (/*lpar*/ byte_is_letter(c) || c == '_') &&
        prevc == '$') {
      /*if*/

      s->inside_string = 1;

      s->dollar_start = 1;

      s->pos = s->pos - 2;

      break;
    };
  };

  string lit = tos2("");

  if (string_at(s->text, start) == main__SINGLE_QUOTE) {
    /*if*/

    start++;
  };

  int end = s->pos;

  if (s->inside_string) {
    /*if*/

    end++;
  };

  if (start > s->pos) {
    /*if*/

  } else {
    /*else if*/

    lit = string_substr(s->text, start, end);
  };

  return lit;
}
string Scanner_ident_char(Scanner *s) {

  int start = s->pos;

  byte slash = '\\';

  int len = 0;

  while (1) {
    s->pos++;

    if (s->pos >= s->text.len) {
      /*if*/

      break;
    };

    if (string_at(s->text, s->pos) != slash) {
      /*if*/

      len++;
    };

    bool double_slash = string_at(s->text, s->pos - 1) == slash &&
                        string_at(s->text, s->pos - 2) == slash;

    if (string_at(s->text, s->pos) == '\`' &&
        (/*lpar*/ string_at(s->text, s->pos - 1) != slash || double_slash)) {
      /*if*/

      if (double_slash) {
        /*if*/

        len++;
      };

      break;
    };
  };

  len--;

  string c = string_substr(s->text, start + 1, s->pos);

  if (len != 1) {
    /*if*/

    Scanner_error(
        &/* ? */ *s,
        _STR("invalid character literal (more than one character: %d)", len));
  };

  return c;
}
Token Parser_peek(Parser *p) {

  while (1) {
    Token tok = Scanner_peek(p->scanner);

    if (tok != NL) {
      /*if*/

      return tok;
    };
  };
}
Token Scanner_peek(Scanner *s) {

  int pos = s->pos;

  int line = s->line_nr;

  bool inside_string = s->inside_string;

  bool dollar_start = s->dollar_start;

  bool dollar_end = s->dollar_end;

  ScanRes res = Scanner_scan(s);

  Token tok = res.tok;

  s->pos = pos;

  s->line_nr = line;

  s->inside_string = inside_string;

  s->dollar_start = dollar_start;

  s->dollar_end = dollar_end;

  return tok;
}
void Scanner_debug_tokens(Scanner *s) {

  s->pos = 0;

  string fname = string_all_after(s->file_path, tos2("/"));

  println(_STR("\n===DEBUG TOKENS %.*s ============", fname.len, fname.str));

  s->debug = 1;

  while (1) {
    ScanRes res = Scanner_scan(s);

    Token tok = res.tok;

    string lit = res.lit;

    v_print(Token_str(tok));

    if (string_ne(lit, tos2(""))) {
      /*if*/

      println(_STR(" `%.*s`", lit.len, lit.str));

    } else {
      /*else if*/

      println(tos2(""));
    };

    if (tok == EOF) {
      /*if*/

      println(tos2("============ END OF DEBUG TOKENS =================="));

      break;
    };
  };
}
bool is_name_char(byte c) { return byte_is_letter(c) || c == '_'; }
int Scanner_get_opening_bracket(Scanner *s) {

  int pos = s->pos;

  int parentheses = 0;

  bool inside_string = 0;

  while (pos > 0 && string_at(s->text, pos) != '\n') {

    if (string_at(s->text, pos) == ')' && !inside_string) {
      /*if*/

      parentheses++;
    };

    if (string_at(s->text, pos) == '(' && !inside_string) {
      /*if*/

      parentheses--;
    };

    if (string_at(s->text, pos) == '\'' &&
        string_at(s->text, pos - 1) != '\\' &&
        string_at(s->text, pos - 1) != '\`') {
      /*if*/

      inside_string = !inside_string;
    };

    if (parentheses == 0) {
      /*if*/

      break;
    };

    pos--;
  };

  return pos;
}
void Scanner_create_type_string(Scanner *s, Type T, string name) {

  int line = s->line_nr;

  bool inside_string = s->inside_string;

  string newtext = tos2("\'{ ");

  int start = Scanner_get_opening_bracket(s) + 1;

  int end = s->pos;

  array_Var tmp145 = T.fields;
  ;
  for (int i = 0; i < tmp145.len; i++) {
    Var field = ((Var *)tmp145.data)[i];

    if (i != 0) {
      /*if*/

      newtext = string_add(newtext, tos2(", "));
    };

    newtext = string_add(
        string_add(newtext, _STR("%.*s: ", field.name.len, field.name.str)),
        _STR("$%.*s.%.*s", name.len, name.str, field.name.len, field.name.str));
  };

  newtext = string_add(newtext, tos2(" }\'"));

  s->text = string_add(string_add(string_substr(s->text, 0, start), newtext),
                       string_substr(s->text, end, s->text.len));

  s->pos = start - 2;

  s->line_nr = line;

  s->inside_string = inside_string;
}
void Parser_create_type_string(Parser *p, Type T, string name) {

  Scanner_create_type_string(p->scanner, T, name);
}
bool is_mutable_type(string typ) {

  if (string_eq(typ, tos2("bool*"))) {
    /*if*/

    return 1;
  };

  if (string_eq(typ, tos2("int*")) || string_eq(typ, tos2("rune*")) ||
      string_eq(typ, tos2("i8*")) || string_eq(typ, tos2("i16*")) ||
      string_eq(typ, tos2("i32*")) || string_eq(typ, tos2("i64*"))) {
    /*if*/

    return 1;
  };

  if (string_eq(typ, tos2("byte*")) || string_eq(typ, tos2("u8*")) ||
      string_eq(typ, tos2("u16*")) || string_eq(typ, tos2("u32*")) ||
      string_eq(typ, tos2("u64*"))) {
    /*if*/

    return 1;
  };

  if (string_eq(typ, tos2("f32*")) || string_eq(typ, tos2("f64*"))) {
    /*if*/

    return 1;
  };

  if (string_eq(typ, tos2("string*"))) {
    /*if*/

    return 1;
  };
}
string Type_str(Type t) {

  string s = _STR("type \"%.*s\" {", t.name.len, t.name.str);

  if (t.fields.len > 0) {
    /*if*/

    array_Var tmp2 = t.fields;
    ;
    for (int tmp3 = 0; tmp3 < tmp2.len; tmp3++) {
      Var field = ((Var *)tmp2.data)[tmp3];

      s = string_add(s, _STR("\n    %.*s %.*s", field.name.len, field.name.str,
                             field.typ.len, field.typ.str));
    };

    s = string_add(s, tos2("\n"));
  };

  if (t.methods.len > 0) {
    /*if*/

    array_Fn tmp4 = t.methods;
    ;
    for (int tmp5 = 0; tmp5 < tmp4.len; tmp5++) {
      Fn method = ((Fn *)tmp4.data)[tmp5];

      s = string_add(
          s, _STR("\n    %.*s", Fn_str(method).len, Fn_str(method).str));
    };

    s = string_add(s, tos2("\n"));
  };

  s = string_add(s, tos2("}\n"));

  return s;
}
string Fn_str(Fn f) {

  Table t = (Table){.types = new_array(0, 1, sizeof(Type)),
                    .consts = new_array(0, 1, sizeof(Var)),
                    .fns = new_array(0, 1, sizeof(Fn)),
                    .packages = new_array(0, 1, sizeof(string)),
                    .imports = new_array(0, 1, sizeof(string)),
                    .flags = new_array(0, 1, sizeof(string)),
                    .fn_cnt = 0,
                    .obfuscate = 0};

  string str_args =
      Fn_str_args(&/* ? */ f, &/*11 EXP:"Table*" GOT:"Table" */ t);

  return _STR("%.*s(%.*s) %.*s", f.name.len, f.name.str, str_args.len,
              str_args.str, f.typ.len, f.typ.str);
}
bool is_number_type(string typ) {

  return array_string_contains(main__NUMBER_TYPES, typ);
}
bool is_float_type(string typ) {

  return array_string_contains(main__FLOAT_TYPES, typ);
}
Table *new_table(bool obfuscate) {

  Table *t = ALLOC_INIT(Table, {
                                   .obf_ids = new_map(1, sizeof(int)),
                                   .obfuscate = obfuscate,
                                   .types = new_array(0, 1, sizeof(Type)),
                                   .consts = new_array(0, 1, sizeof(Var)),
                                   .fns = new_array(0, 1, sizeof(Fn)),
                                   .packages = new_array(0, 1, sizeof(string)),
                                   .imports = new_array(0, 1, sizeof(string)),
                                   .flags = new_array(0, 1, sizeof(string)),
                                   .fn_cnt = 0,
                               });

  Table_register_type(t, tos2("int"));

  Table_register_type(t, tos2("size_t"));

  Table_register_type_with_parent(t, tos2("i8"), tos2("int"));

  Table_register_type_with_parent(t, tos2("u8"), tos2("int"));

  Table_register_type_with_parent(t, tos2("i16"), tos2("int"));

  Table_register_type_with_parent(t, tos2("u16"), tos2("int"));

  Table_register_type_with_parent(t, tos2("i32"), tos2("int"));

  Table_register_type_with_parent(t, tos2("u32"), tos2("int"));

  Table_register_type_with_parent(t, tos2("byte"), tos2("int"));

  Table_register_type(t, tos2("i64"));

  Table_register_type_with_parent(t, tos2("u64"), tos2("int"));

  Table_register_type(t, tos2("byteptr"));

  Table_register_type(t, tos2("intptr"));

  Table_register_type(t, tos2("f32"));

  Table_register_type(t, tos2("f64"));

  Table_register_type(t, tos2("rune"));

  Table_register_type(t, tos2("bool"));

  Table_register_type(t, tos2("void"));

  Table_register_type(t, tos2("voidptr"));

  Table_register_type(t, tos2("va_list"));

  Table_register_const(t, tos2("stdin"), tos2("int"), tos2("main"), 0);

  Table_register_const(t, tos2("stdout"), tos2("int"), tos2("main"), 0);

  Table_register_const(t, tos2("stderr"), tos2("int"), tos2("main"), 0);

  Table_register_const(t, tos2("errno"), tos2("int"), tos2("main"), 0);

  Table_register_type_with_parent(t, tos2("map_string"), tos2("map"));

  Table_register_type_with_parent(t, tos2("map_int"), tos2("map"));

  return t;
}
string Table_var_cgen_name(Table *t, string name) {

  if (array_string_contains(main__CReserved, name)) {
    /*if*/

    return _STR("v_%.*s", name.len, name.str);

  } else {
    /*else if*/

    return name;
  };
}
void Table_register_package(Table *t, string pkg) {

  if (array_string_contains(t->packages, pkg)) {
    /*if*/

    return;
  };

  _PUSH(&t->packages, (pkg), tmp9, string);
}
bool Table_known_pkg(Table *table, string pkg) {

  return _IN(string, pkg, table->packages);
}
void Table_register_const(Table *t, string name, string typ, string pkg,
                          bool is_imported) {

  _PUSH(&t->consts,
        ((Var){.name = name,
               .typ = typ,
               .is_const = 1,
               .is_import_const = is_imported,
               .pkg = pkg,
               .is_arg = 0,
               .args = new_array(0, 1, sizeof(Var)),
               .attr = tos("", 0),
               .is_mut = 0,
               .ptr = 0,
               .ref = 0,
               .parent_fn = tos("", 0),
               .line_nr = 0,
               .is_global = 0,
               .is_used = 0,
               .scope_level = 0}),
        tmp10, Var);
}
void Parser_register_global(Parser *p, string name, string typ) {

  _PUSH(&p->table->consts,
        ((Var){.name = name,
               .typ = typ,
               .is_const = 1,
               .is_global = 1,
               .pkg = p->pkg,
               .is_arg = 0,
               .is_import_const = 0,
               .args = new_array(0, 1, sizeof(Var)),
               .attr = tos("", 0),
               .is_mut = 0,
               .ptr = 0,
               .ref = 0,
               .parent_fn = tos("", 0),
               .line_nr = 0,
               .is_used = 0,
               .scope_level = 0}),
        tmp11, Var);
}
void Table_register_fn(Table *t, Fn f) {

  array_Fn tmp12 = t->fns;
  ;
  for (int tmp13 = 0; tmp13 < tmp12.len; tmp13++) {
    Fn ff = ((Fn *)tmp12.data)[tmp13];

    if (string_eq(ff.name, f.name)) {
      /*if*/

      return;
    };
  };

  _PUSH(&t->fns, (f), tmp14, Fn);
}
bool Table_known_type(Table *table, string typ) {

  if (string_ends_with(typ, tos2("*")) && !string_contains(typ, tos2(" "))) {
    /*if*/

    typ = string_left(typ, typ.len - 1);
  };

  array_Type tmp15 = table->types;
  ;
  for (int tmp16 = 0; tmp16 < tmp15.len; tmp16++) {
    Type t = ((Type *)tmp15.data)[tmp16];

    if (string_eq(t.name, typ) && !t.is_placeholder) {
      /*if*/

      return 1;
    };
  };

  return 0;
}
Fn Table_find_fn(Table *t, string name) {

  array_Fn tmp17 = t->fns;
  ;
  for (int tmp18 = 0; tmp18 < tmp17.len; tmp18++) {
    Fn f = ((Fn *)tmp17.data)[tmp18];

    if (string_eq(f.name, name)) {
      /*if*/

      return f;
    };
  };

  return (Fn){.pkg = tos("", 0),
              .local_vars = new_array(0, 1, sizeof(Var)),
              .var_idx = 0,
              .args = new_array(0, 1, sizeof(Var)),
              .is_interface = 0,
              .scope_level = 0,
              .typ = tos("", 0),
              .name = tos("", 0),
              .is_c = 0,
              .receiver_typ = tos("", 0),
              .is_public = 0,
              .is_method = 0,
              .returns_error = 0,
              .is_decl = 0,
              .defer = tos("", 0)};
}
bool Table_known_fn(Table *t, string name) {

  array_Fn tmp19 = t->fns;
  ;
  for (int tmp20 = 0; tmp20 < tmp19.len; tmp20++) {
    Fn f = ((Fn *)tmp19.data)[tmp20];

    if (string_eq(f.name, name)) {
      /*if*/

      return 1;
    };
  };

  return 0;
}
bool Table_known_const(Table *t, string name) {

  Var v = Table_find_const(&/* ? */ *t, name);

  return v.name.len > 0;
}
void Table_register_type(Table *t, string typ) {

  if (typ.len == 0) {
    /*if*/

    return;
  };

  array_Type tmp22 = t->types;
  ;
  for (int tmp23 = 0; tmp23 < tmp22.len; tmp23++) {
    Type typ2 = ((Type *)tmp22.data)[tmp23];

    if (string_eq(typ2.name, typ)) {
      /*if*/

      return;
    };
  };

  _PUSH(&t->types,
        ((Type){.name = typ,
                .pkg = tos("", 0),
                .fields = new_array(0, 1, sizeof(Var)),
                .methods = new_array(0, 1, sizeof(Fn)),
                .parent = tos("", 0),
                .gen_types = new_array(0, 1, sizeof(string)),
                .is_c = 0,
                .is_interface = 0,
                .is_enum = 0,
                .is_placeholder = 0}),
        tmp24, Type);
}
void Parser_register_type_with_parent(Parser *p, string strtyp, string parent) {

  Type typ = (Type){.name = strtyp,
                    .parent = parent,
                    .pkg = p->pkg,
                    .fields = new_array(0, 1, sizeof(Var)),
                    .methods = new_array(0, 1, sizeof(Fn)),
                    .gen_types = new_array(0, 1, sizeof(string)),
                    .is_c = 0,
                    .is_interface = 0,
                    .is_enum = 0,
                    .is_placeholder = 0};

  Table_register_type2(p->table, typ);
}
void Table_register_type_with_parent(Table *t, string typ, string parent) {

  if (typ.len == 0) {
    /*if*/

    return;
  };

  array_Type tmp26 = t->types;
  ;
  for (int tmp27 = 0; tmp27 < tmp26.len; tmp27++) {
    Type typ2 = ((Type *)tmp26.data)[tmp27];

    if (string_eq(typ2.name, typ)) {
      /*if*/

      return;
    };
  };

  Type datyp = (Type){.name = typ,
                      .parent = parent,
                      .pkg = tos("", 0),
                      .fields = new_array(0, 1, sizeof(Var)),
                      .methods = new_array(0, 1, sizeof(Fn)),
                      .gen_types = new_array(0, 1, sizeof(string)),
                      .is_c = 0,
                      .is_interface = 0,
                      .is_enum = 0,
                      .is_placeholder = 0};

  _PUSH(&t->types, (datyp), tmp29, Type);
}
void Table_register_type2(Table *t, Type typ) {

  if (typ.name.len == 0) {
    /*if*/

    return;
  };

  array_Type tmp30 = t->types;
  ;
  for (int tmp31 = 0; tmp31 < tmp30.len; tmp31++) {
    Type typ2 = ((Type *)tmp30.data)[tmp31];

    if (string_eq(typ2.name, typ.name)) {
      /*if*/

      return;
    };
  };

  _PUSH(&t->types, (typ), tmp32, Type);
}
void Type_add_field(Type *t, string name, string typ, bool is_mut, string attr,
                    AccessMod access_mod) {

  Var v = (Var){.name = name,
                .typ = typ,
                .is_mut = is_mut,
                .attr = attr,
                .access_mod = access_mod,
                .is_arg = 0,
                .is_const = 0,
                .is_import_const = 0,
                .args = new_array(0, 1, sizeof(Var)),
                .ptr = 0,
                .ref = 0,
                .parent_fn = tos("", 0),
                .pkg = tos("", 0),
                .line_nr = 0,
                .is_global = 0,
                .is_used = 0,
                .scope_level = 0};

  _PUSH(&t->fields, (v), tmp34, Var);
}
bool Type_has_field(Type *t, string name) {

  Var field = Type_find_field(&/* ? */ *t, name);

  return (/*lpar*/ string_ne(field.name, tos2("")));
}
Var Type_find_field(Type *t, string name) {

  array_Var tmp36 = t->fields;
  ;
  for (int tmp37 = 0; tmp37 < tmp36.len; tmp37++) {
    Var field = ((Var *)tmp36.data)[tmp37];

    if (string_eq(field.name, name)) {
      /*if*/

      return field;
    };
  };

  return (Var){.typ = tos("", 0),
               .name = tos("", 0),
               .is_arg = 0,
               .is_const = 0,
               .is_import_const = 0,
               .args = new_array(0, 1, sizeof(Var)),
               .attr = tos("", 0),
               .is_mut = 0,
               .ptr = 0,
               .ref = 0,
               .parent_fn = tos("", 0),
               .pkg = tos("", 0),
               .line_nr = 0,
               .is_global = 0,
               .is_used = 0,
               .scope_level = 0};
}
bool Table_type_has_field(Table *table, Type *typ, string name) {

  Var field = Table_find_field(&/* ? */ *table, typ, name);

  return (/*lpar*/ string_ne(field.name, tos2("")));
}
Var Table_find_field(Table *table, Type *typ, string name) {

  Var field = Type_find_field(&/* ? */ *typ, name);

  if (field.name.len == 0 && typ->parent.len > 0) {
    /*if*/

    Type *parent = Table_find_type(&/* ? */ *table, typ->parent);

    return Type_find_field(&/* ? */ *parent, name);
  };

  return field;
}
void Type_add_method(Type *t, Fn f) { _PUSH(&t->methods, (f), tmp41, Fn); }
bool Type_has_method(Type *t, string name) {

  Fn method = Type_find_method(&/* ? */ *t, name);

  return (/*lpar*/ string_ne(method.name, tos2("")));
}
bool Table_type_has_method(Table *table, Type *typ, string name) {

  Fn method = Table_find_method(&/* ? */ *table, typ, name);

  return (/*lpar*/ string_ne(method.name, tos2("")));
}
Fn Table_find_method(Table *table, Type *typ, string name) {

  Fn method = Type_find_method(&/* ? */ *typ, name);

  if (method.name.len == 0 && typ->parent.len > 0) {
    /*if*/

    Type *parent = Table_find_type(&/* ? */ *table, typ->parent);

    return Type_find_method(&/* ? */ *parent, name);
  };

  return method;
}
Fn Type_find_method(Type *t, string name) {

  array_Fn tmp46 = t->methods;
  ;
  for (int tmp47 = 0; tmp47 < tmp46.len; tmp47++) {
    Fn method = ((Fn *)tmp46.data)[tmp47];

    if (string_eq(method.name, name)) {
      /*if*/

      return method;
    };
  };

  return (Fn){.pkg = tos("", 0),
              .local_vars = new_array(0, 1, sizeof(Var)),
              .var_idx = 0,
              .args = new_array(0, 1, sizeof(Var)),
              .is_interface = 0,
              .scope_level = 0,
              .typ = tos("", 0),
              .name = tos("", 0),
              .is_c = 0,
              .receiver_typ = tos("", 0),
              .is_public = 0,
              .is_method = 0,
              .returns_error = 0,
              .is_decl = 0,
              .defer = tos("", 0)};
}
void Type_add_gen_type(Type *t, string type_name) {

  if (array_string_contains(t->gen_types, type_name)) {
    /*if*/

    return;
  };

  _PUSH(&t->gen_types, (type_name), tmp48, string);
}
Type *Parser_find_type(Parser *p, string name) {

  Type *typ = Table_find_type(&/* ? */ *p->table, name);

  if (typ->name.len == 0) {
    /*if*/

    return Table_find_type(&/* ? */ *p->table,
                           Parser_prepend_pkg(&/* ? */ *p, name));
  };

  return typ;
}
Type *Table_find_type(Table *t, string name) {

  if (string_ends_with(name, tos2("*")) && !string_contains(name, tos2(" "))) {
    /*if*/

    name = string_left(name, name.len - 1);
  };

  array_Type tmp50 = t->types;
  ;
  for (int i = 0; i < tmp50.len; i++) {
    Type typ = ((Type *)tmp50.data)[i];

    if (string_eq(typ.name, name)) {
      /*if*/

      return &/*vvar*/ (*(Type *)array__get(t->types, i));
    };
  };

  return ALLOC_INIT(Type, {.pkg = tos("", 0),
                           .name = tos("", 0),
                           .fields = new_array(0, 1, sizeof(Var)),
                           .methods = new_array(0, 1, sizeof(Fn)),
                           .parent = tos("", 0),
                           .gen_types = new_array(0, 1, sizeof(string)),
                           .is_c = 0,
                           .is_interface = 0,
                           .is_enum = 0,
                           .is_placeholder = 0});
}
bool Parser__check_types(Parser *p, string got, string expected, bool throw) {

  Parser_log(&/* ? */ *p, _STR("check types got=\"%.*s\" exp=\"%.*s\"  ",
                               got.len, got.str, expected.len, expected.str));

  if (p->translated) {
    /*if*/

    return 1;
  };

  if (string_eq(got, tos2("int")) && string_eq(expected, tos2("f32"))) {
    /*if*/

    return 1;
  };

  if (string_eq(got, tos2("int")) && string_eq(expected, tos2("f64"))) {
    /*if*/

    return 1;
  };

  if (string_eq(got, tos2("f64")) && string_eq(expected, tos2("f32"))) {
    /*if*/

    return 1;
  };

  if (string_eq(got, tos2("f32")) && string_eq(expected, tos2("f64"))) {
    /*if*/

    return 1;
  };

  if (string_eq(got, tos2("int")) && string_eq(expected, tos2("i64"))) {
    /*if*/

    return 1;
  };

  if (string_eq(got, tos2("void*")) &&
      string_starts_with(expected, tos2("fn "))) {
    /*if*/

    return 1;
  };

  if (string_starts_with(got, tos2("[")) &&
      string_eq(expected, tos2("byte*"))) {
    /*if*/

    return 1;
  };

  if (string_eq(got, tos2("void*")) || string_eq(expected, tos2("void*"))) {
    /*if*/

    if (p->is_play) {
      /*if*/

      return 0;
    };

    return 1;
  };

  if (string_eq(got, tos2("int")) && string_eq(expected, tos2("byte"))) {
    /*if*/

    return 1;
  };

  if (string_eq(got, tos2("byteptr")) && string_eq(expected, tos2("byte*"))) {
    /*if*/

    return 1;
  };

  if (string_eq(got, tos2("int")) && string_eq(expected, tos2("byte*"))) {
    /*if*/

    return 1;
  };

  if (string_eq(got, tos2("int")) && string_eq(expected, tos2("byteptr"))) {
    /*if*/

    return 1;
  };

  if (string_eq(got, tos2("Option")) &&
      string_starts_with(expected, tos2("Option_"))) {
    /*if*/

    return 1;
  };

  if (string_eq(got, tos2("array")) &&
      string_starts_with(expected, tos2("array_"))) {
    /*if*/

    return 1;
  };

  if (string_starts_with(expected, tos2("Option_")) &&
      string_ends_with(expected, got)) {
    /*if*/

    return 1;
  };

  if (!p->is_play) {
    /*if*/

    if (string_ends_with(expected, tos2("*")) && string_eq(got, tos2("int"))) {
      /*if*/

      return 1;
    };

    if (string_eq(expected, tos2("void*")) && string_eq(got, tos2("int"))) {
      /*if*/

      return 1;
    };
  };

  expected = string_replace(expected, tos2("*"), tos2(""));

  got = string_replace(got, tos2("*"), tos2(""));

  if (string_ne(got, expected)) {
    /*if*/

    if (string_ends_with(expected, tos2("er"))) {
      /*if*/

      if (Parser_satisfies_interface(p, expected, got, throw)) {
        /*if*/

        return 1;
      };
    };

    if (!throw) {
      /*if*/

      return 0;

    } else {
      /*else if*/

      Parser_error(p, _STR("expected type `%.*s`, but got `%.*s`", expected.len,
                           expected.str, got.len, got.str));
    };
  };

  return 1;
}
bool Parser_check_types(Parser *p, string got, string expected) {

  return Parser__check_types(p, got, expected, 1);
}
bool Parser_check_types_no_throw(Parser *p, string got, string expected) {

  return Parser__check_types(p, got, expected, 0);
}
bool Parser_satisfies_interface(Parser *p, string interface_name, string _typ,
                                bool throw) {

  Type *int_typ = Table_find_type(&/* ? */ *p->table, interface_name);

  Type *typ = Table_find_type(&/* ? */ *p->table, _typ);

  array_Fn tmp55 = int_typ->methods;
  ;
  for (int tmp56 = 0; tmp56 < tmp55.len; tmp56++) {
    Fn method = ((Fn *)tmp55.data)[tmp56];

    if (!Type_has_method(&/* ? */ *typ, method.name)) {
      /*if*/

      Parser_error(p,
                   _STR("Type \"%.*s\" doesn\'t satisfy interface \"%.*s\" "
                        "(method \"%.*s\" is not implemented)",
                        _typ.len, _typ.str, interface_name.len,
                        interface_name.str, method.name.len, method.name.str));

      return 0;
    };
  };

  return 1;
}
string type_default(string typ) {

  if (string_starts_with(typ, tos2("array_"))) {
    /*if*/

    typ = string_right(typ, 6);

    return _STR("new_array(0, 1, sizeof(%.*s))", typ.len, typ.str);
  };

  if (string_ends_with(typ, tos2("*"))) {
    /*if*/

    return tos2("0");
  };

  if (string_contains(typ, tos2("__"))) {
    /*if*/

    return tos2("");
  };

  if (string_eq(typ, tos2("int"))) { /* case */

    return tos2("0");

  } else if (string_eq(typ, tos2("string"))) { /* case */

    return tos2("tos(\"\", 0)");

  } else if (string_eq(typ, tos2("void*"))) { /* case */

    return tos2("0");

  } else if (string_eq(typ, tos2("byte*"))) { /* case */

    return tos2("0");

  } else if (string_eq(typ, tos2("bool"))) { /* case */

    return tos2("0");
  };

  return tos2("");
}
bool Table_is_interface(Table *t, string name) {

  array_Type tmp57 = t->types;
  ;
  for (int tmp58 = 0; tmp58 < tmp57.len; tmp58++) {
    Type typ = ((Type *)tmp57.data)[tmp58];

    if (typ.is_interface && string_eq(typ.name, name)) {
      /*if*/

      return 1;
    };
  };

  return 0;
}
bool Table_main_exists(Table *t) {

  array_Fn tmp59 = t->fns;
  ;
  for (int tmp60 = 0; tmp60 < tmp59.len; tmp60++) {
    Fn f = ((Fn *)tmp59.data)[tmp60];

    if (string_eq(f.name, tos2("main"))) {
      /*if*/

      return 1;
    };
  };

  return 0;
}
Var Table_find_const(Table *t, string name) {

  array_Var tmp61 = t->consts;
  ;
  for (int tmp62 = 0; tmp62 < tmp61.len; tmp62++) {
    Var c = ((Var *)tmp61.data)[tmp62];

    if (string_eq(c.name, name)) {
      /*if*/

      return c;
    };
  };

  return (Var){.typ = tos("", 0),
               .name = tos("", 0),
               .is_arg = 0,
               .is_const = 0,
               .is_import_const = 0,
               .args = new_array(0, 1, sizeof(Var)),
               .attr = tos("", 0),
               .is_mut = 0,
               .ptr = 0,
               .ref = 0,
               .parent_fn = tos("", 0),
               .pkg = tos("", 0),
               .line_nr = 0,
               .is_global = 0,
               .is_used = 0,
               .scope_level = 0};
}
string Table_cgen_name(Table *table, Fn *f) {

  string name = f->name;

  if (f->is_method) {
    /*if*/

    name = _STR("%.*s_%.*s", f->receiver_typ.len, f->receiver_typ.str,
                f->name.len, f->name.str);

    name = string_replace(name, tos2(" "), tos2(""));

    name = string_replace(name, tos2("*"), tos2(""));

    name = string_replace(name, tos2("+"), tos2("plus"));

    name = string_replace(name, tos2("-"), tos2("minus"));
  };

  if (string_eq(f->pkg, tos2("builtin")) &&
      array_string_contains(main__CReserved, f->name)) {
    /*if*/

    return _STR("v_%.*s", name.len, name.str);
  };

  if (table->obfuscate && string_ne(f->name, tos2("main")) &&
      string_ne(f->name, tos2("WinMain")) &&
      string_ne(f->pkg, tos2("builtin")) && !f->is_c &&
      string_ne(f->pkg, tos2("darwin")) && string_ne(f->pkg, tos2("os")) &&
      !string_contains(f->name, tos2("window_proc")) &&
      string_ne(f->name, tos2("gg__vec2")) &&
      string_ne(f->name, tos2("build_token_str")) &&
      string_ne(f->name, tos2("build_keys")) &&
      string_ne(f->pkg, tos2("json")) &&
      !string_ends_with(name, tos2("_str")) &&
      !string_contains(name, tos2("contains"))) {
    /*if*/
    int tmp64 = 0;
    bool tmp65 = map_get(table->obf_ids, name, &tmp64);

    int idx = tmp64;

    if (idx == 0) {
      /*if*/

      table->fn_cnt++;
      int tmp67 = table->fn_cnt;

      map__set(&table->obf_ids, name, &tmp67);

      idx = table->fn_cnt;
    };

    string old = name;

    name = _STR("f_%d", idx);

    println(_STR("%.*s ==> %.*s", old.len, old.str, name.len, name.str));
  };

  return name;
}
string Table_cgen_name_type_pair(Table *table, string name, string typ) {

  if (typ.len > 0 && string_at(typ, 0) == '[') {
    /*if*/

    string tmp = string_all_after(typ, tos2("]"));

    string size = string_all_before(typ, tos2("]"));

    return _STR("%.*s %.*s  %.*s ]", tmp.len, tmp.str, name.len, name.str,
                size.len, size.str);

  } else if (string_starts_with(typ, tos2("fn ("))) {
    /*if*/

    Type *T = Table_find_type(&/* ? */ *table, typ);

    if (string_eq(T->name, tos2(""))) {
      /*if*/

      println(tos2("this should never happen"));

      v_exit(1);
    };

    string str_args = Fn_str_args(&/* ? */ T->func, table);

    return _STR("%.*s (*%.*s)( %.*s /*FFF*/ )", T->func.typ.len,
                T->func.typ.str, name.len, name.str, str_args.len,
                str_args.str);

  } else if (string_eq(typ, tos2("tm"))) {
    /*if*/

    return _STR("struct /*TM*/ tm %.*s", name.len, name.str);
  };

  return _STR("%.*s %.*s", typ.len, typ.str, name.len, name.str);
}
map_int build_keys() {

  map_int res = new_map(1, sizeof(int));

  for (int t = ((int)(keyword_beg)) + 1; t < ((int)(keyword_end)); t++) {

    string key = (*(string *)array__get(main__TOKENSTR, t));
    int tmp6 = ((int)(t));

    map__set(&res, key, &tmp6);
  };

  return res;
}
array_string build_token_str() {
  string tmp7 = tos2("");

  array_string s = array_repeat(&tmp7, 140, sizeof(string));
  string tmp9 = tos2("");

  array_set(&/*q*/ s, keyword_beg, &tmp9);
  string tmp10 = tos2("");

  array_set(&/*q*/ s, keyword_end, &tmp10);
  string tmp11 = tos2("EOF");

  array_set(&/*q*/ s, EOF, &tmp11);
  string tmp12 = tos2("NAME");

  array_set(&/*q*/ s, NAME, &tmp12);
  string tmp13 = tos2("INT");

  array_set(&/*q*/ s, INT, &tmp13);
  string tmp14 = tos2("STR");

  array_set(&/*q*/ s, STRING, &tmp14);
  string tmp15 = tos2("CHAR");

  array_set(&/*q*/ s, CHAR, &tmp15);
  string tmp16 = tos2("+");

  array_set(&/*q*/ s, PLUS, &tmp16);
  string tmp17 = tos2("-");

  array_set(&/*q*/ s, MINUS, &tmp17);
  string tmp18 = tos2("*");

  array_set(&/*q*/ s, MUL, &tmp18);
  string tmp19 = tos2("/");

  array_set(&/*q*/ s, DIV, &tmp19);
  string tmp20 = tos2("%");

  array_set(&/*q*/ s, MOD, &tmp20);
  string tmp21 = tos2("^");

  array_set(&/*q*/ s, XOR, &tmp21);
  string tmp22 = tos2("~");

  array_set(&/*q*/ s, BIT_NOT, &tmp22);
  string tmp23 = tos2("|");

  array_set(&/*q*/ s, PIPE, &tmp23);
  string tmp24 = tos2("#");

  array_set(&/*q*/ s, HASH, &tmp24);
  string tmp25 = tos2("&");

  array_set(&/*q*/ s, AMP, &tmp25);
  string tmp26 = tos2("++");

  array_set(&/*q*/ s, INC, &tmp26);
  string tmp27 = tos2("--");

  array_set(&/*q*/ s, DEC, &tmp27);
  string tmp28 = tos2("&&");

  array_set(&/*q*/ s, AND, &tmp28);
  string tmp29 = tos2("||");

  array_set(&/*q*/ s, OR, &tmp29);
  string tmp30 = tos2("!");

  array_set(&/*q*/ s, NOT, &tmp30);
  string tmp31 = tos2(".");

  array_set(&/*q*/ s, DOT, &tmp31);
  string tmp32 = tos2("..");

  array_set(&/*q*/ s, DOTDOT, &tmp32);
  string tmp33 = tos2(",");

  array_set(&/*q*/ s, COMMA, &tmp33);
  string tmp34 = tos2(";");

  array_set(&/*q*/ s, SEMICOLON, &tmp34);
  string tmp35 = tos2(":");

  array_set(&/*q*/ s, COLON, &tmp35);
  string tmp36 = tos2("=");

  array_set(&/*q*/ s, ASSIGN, &tmp36);
  string tmp37 = tos2(":=");

  array_set(&/*q*/ s, DECL_ASSIGN, &tmp37);
  string tmp38 = tos2("+=");

  array_set(&/*q*/ s, PLUS_ASSIGN, &tmp38);
  string tmp39 = tos2("-=");

  array_set(&/*q*/ s, MINUS_ASSIGN, &tmp39);
  string tmp40 = tos2("*=");

  array_set(&/*q*/ s, MULT_ASSIGN, &tmp40);
  string tmp41 = tos2("/=");

  array_set(&/*q*/ s, DIV_ASSIGN, &tmp41);
  string tmp42 = tos2("^=");

  array_set(&/*q*/ s, XOR_ASSIGN, &tmp42);
  string tmp43 = tos2("%=");

  array_set(&/*q*/ s, MOD_ASSIGN, &tmp43);
  string tmp44 = tos2("|=");

  array_set(&/*q*/ s, OR_ASSIGN, &tmp44);
  string tmp45 = tos2("&=");

  array_set(&/*q*/ s, AND_ASSIGN, &tmp45);
  string tmp46 = tos2(">>=");

  array_set(&/*q*/ s, RIGHT_SHIFT_ASSIGN, &tmp46);
  string tmp47 = tos2("<<=");

  array_set(&/*q*/ s, LEFT_SHIFT_ASSIGN, &tmp47);
  string tmp48 = tos2("{");

  array_set(&/*q*/ s, LCBR, &tmp48);
  string tmp49 = tos2("}");

  array_set(&/*q*/ s, RCBR, &tmp49);
  string tmp50 = tos2("(");

  array_set(&/*q*/ s, LPAR, &tmp50);
  string tmp51 = tos2(")");

  array_set(&/*q*/ s, RPAR, &tmp51);
  string tmp52 = tos2("[");

  array_set(&/*q*/ s, LSBR, &tmp52);
  string tmp53 = tos2("]");

  array_set(&/*q*/ s, RSBR, &tmp53);
  string tmp54 = tos2("==");

  array_set(&/*q*/ s, EQ, &tmp54);
  string tmp55 = tos2("!=");

  array_set(&/*q*/ s, NE, &tmp55);
  string tmp56 = tos2(">");

  array_set(&/*q*/ s, GT, &tmp56);
  string tmp57 = tos2("<");

  array_set(&/*q*/ s, LT, &tmp57);
  string tmp58 = tos2(">=");

  array_set(&/*q*/ s, GE, &tmp58);
  string tmp59 = tos2("<=");

  array_set(&/*q*/ s, LE, &tmp59);
  string tmp60 = tos2("?");

  array_set(&/*q*/ s, QUESTION, &tmp60);
  string tmp61 = tos2("<<");

  array_set(&/*q*/ s, LEFT_SHIFT, &tmp61);
  string tmp62 = tos2(">>");

  array_set(&/*q*/ s, RIGHT_SHIFT, &tmp62);
  string tmp63 = tos2("//");

  array_set(&/*q*/ s, LINE_COM, &tmp63);
  string tmp64 = tos2("NLL");

  array_set(&/*q*/ s, NL, &tmp64);
  string tmp65 = tos2("$");

  array_set(&/*q*/ s, DOLLAR, &tmp65);
  string tmp66 = tos2("assert");

  array_set(&/*q*/ s, ASSERT, &tmp66);
  string tmp67 = tos2("struct");

  array_set(&/*q*/ s, STRUCT, &tmp67);
  string tmp68 = tos2("if");

  array_set(&/*q*/ s, IF, &tmp68);
  string tmp69 = tos2("else");

  array_set(&/*q*/ s, ELSE, &tmp69);
  string tmp70 = tos2("return");

  array_set(&/*q*/ s, RETURN, &tmp70);
  string tmp71 = tos2("module");

  array_set(&/*q*/ s, PACKAGE, &tmp71);
  string tmp72 = tos2("sizeof");

  array_set(&/*q*/ s, SIZEOF, &tmp72);
  string tmp73 = tos2("go");

  array_set(&/*q*/ s, GO, &tmp73);
  string tmp74 = tos2("goto");

  array_set(&/*q*/ s, GOTO, &tmp74);
  string tmp75 = tos2("const");

  array_set(&/*q*/ s, CONST, &tmp75);
  string tmp76 = tos2("mut");

  array_set(&/*q*/ s, MUT, &tmp76);
  string tmp77 = tos2("type");

  array_set(&/*q*/ s, TIP, &tmp77);
  string tmp78 = tos2("for");

  array_set(&/*q*/ s, FOR, &tmp78);
  string tmp79 = tos2("switch");

  array_set(&/*q*/ s, SWITCH, &tmp79);
  string tmp80 = tos2("match");

  array_set(&/*q*/ s, MATCH, &tmp80);
  string tmp81 = tos2("case");

  array_set(&/*q*/ s, CASE, &tmp81);
  string tmp82 = tos2("fn");

  array_set(&/*q*/ s, FUNC, &tmp82);
  string tmp83 = tos2("true");

  array_set(&/*q*/ s, TRUE, &tmp83);
  string tmp84 = tos2("false");

  array_set(&/*q*/ s, FALSE, &tmp84);
  string tmp85 = tos2("continue");

  array_set(&/*q*/ s, CONTINUE, &tmp85);
  string tmp86 = tos2("break");

  array_set(&/*q*/ s, BREAK, &tmp86);
  string tmp87 = tos2("import");

  array_set(&/*q*/ s, IMPORT, &tmp87);
  string tmp88 = tos2("embed");

  array_set(&/*q*/ s, EMBED, &tmp88);
  string tmp89 = tos2("typeof");

  array_set(&/*q*/ s, TYPEOF, &tmp89);
  string tmp90 = tos2("default");

  array_set(&/*q*/ s, DEFAULT, &tmp90);
  string tmp91 = tos2("endif");

  array_set(&/*q*/ s, ENDIF, &tmp91);
  string tmp92 = tos2("enum");

  array_set(&/*q*/ s, ENUM, &tmp92);
  string tmp93 = tos2("interface");

  array_set(&/*q*/ s, INTERFACE, &tmp93);
  string tmp94 = tos2("pub");

  array_set(&/*q*/ s, PUB, &tmp94);
  string tmp95 = tos2("import_const");

  array_set(&/*q*/ s, IMPORT_CONST, &tmp95);
  string tmp96 = tos2("in");

  array_set(&/*q*/ s, IN, &tmp96);
  string tmp97 = tos2("atomic");

  array_set(&/*q*/ s, ATOMIC, &tmp97);
  string tmp98 = tos2("or");

  array_set(&/*q*/ s, OR_ELSE, &tmp98);
  string tmp99 = tos2("__global");

  array_set(&/*q*/ s, GLOBAL, &tmp99);
  string tmp100 = tos2("union");

  array_set(&/*q*/ s, UNION, &tmp100);
  string tmp101 = tos2("static");

  array_set(&/*q*/ s, STATIC, &tmp101);

  return s;
}
Token key_to_token(string key) {
  int tmp102 = 0;
  bool tmp103 = map_get(main__KEYWORDS, key, &tmp102);

  Token a = ((Token)(tmp102));

  return a;
}
bool is_key(string key) { return ((int)(key_to_token(key))) > 0; }
string Token_str(Token t) {

  return (*(string *)array__get(main__TOKENSTR, ((int)(t))));
}
bool Token_is_decl(Token t) {

  return t == ENUM || t == INTERFACE || t == FUNC || t == STRUCT || t == TIP ||
         t == CONST || t == IMPORT_CONST || t == PUB || t == EOF;
}
bool Token_is_assign(Token t) { return _IN(Token, t, main__AssignTokens); }
bool array_Token_contains(array_Token t, Token val) {

  array_Token tmp107 = t;
  ;
  for (int tmp108 = 0; tmp108 < tmp107.len; tmp108++) {
    Token tt = ((Token *)tmp107.data)[tmp108];

    if (tt == val) {
      /*if*/

      return 1;
    };
  };

  return 0;
}
void init_consts() {
  g_str_buf = malloc(1000);
  os__args = new_array_from_c_array(0, 0, sizeof(string), (string[]){});
  time__Months = tos2("JanFebMarAprMayJunJulAugSepOctNovDec");
  time__Days = tos2("MonTueWedThuFriSatSun");
  main__Version = tos2("0.1.8");
  main__SupportedPlatforms = new_array_from_c_array(
      3, 3, sizeof(string),
      (string[]){tos2("windows"), tos2("mac"), tos2("linux")});
  main__TmpPath = vtmp_path();
  main__HelpText = tos2(
      "\nUsage: v [options] [file | directory]\n\nOptions:\n  -                "
      " Read from stdin (Default; Interactive mode if in a tty)\n  -h, --help, "
      "help  Display this information.\n  -v, version       Display compiler "
      "version.\n  -prod             Build an optimized executable.\n  -o "
      "<file>         Place output into <file>.\n  -obf              Obfuscate "
      "the resulting binary.\n  run               Build and execute a V "
      "program.\n                    You can add arguments after file "
      "name.\n\nFiles:\n  <file>_test.v     Test file.\n");
  main__EmptyFn = ALLOC_INIT(Fn, {.pkg = tos("", 0),
                                  .local_vars = new_array(0, 1, sizeof(Var)),
                                  .var_idx = 0,
                                  .args = new_array(0, 1, sizeof(Var)),
                                  .is_interface = 0,
                                  .scope_level = 0,
                                  .typ = tos("", 0),
                                  .name = tos("", 0),
                                  .is_c = 0,
                                  .receiver_typ = tos("", 0),
                                  .is_public = 0,
                                  .is_method = 0,
                                  .returns_error = 0,
                                  .is_decl = 0,
                                  .defer = tos("", 0)});
  main__MainFn = ALLOC_INIT(Fn, {.name = tos2("main"),
                                 .pkg = tos("", 0),
                                 .local_vars = new_array(0, 1, sizeof(Var)),
                                 .var_idx = 0,
                                 .args = new_array(0, 1, sizeof(Var)),
                                 .is_interface = 0,
                                 .scope_level = 0,
                                 .typ = tos("", 0),
                                 .is_c = 0,
                                 .receiver_typ = tos("", 0),
                                 .is_public = 0,
                                 .is_method = 0,
                                 .returns_error = 0,
                                 .is_decl = 0,
                                 .defer = tos("", 0)});
  main__CReserved = new_array_from_c_array(
      10, 10, sizeof(string),
      (string[]){tos2("exit"), tos2("unix"), tos2("print"), tos2("error"),
                 tos2("malloc"), tos2("calloc"), tos2("char"), tos2("free"),
                 tos2("panic"), tos2("register")});
  main__NUMBER_TYPES = new_array_from_c_array(
      13, 13, sizeof(string),
      (string[]){tos2("number"), tos2("int"), tos2("i8"), tos2("u8"),
                 tos2("i16"), tos2("u16"), tos2("i32"), tos2("u32"),
                 tos2("byte"), tos2("i64"), tos2("u64"), tos2("f32"),
                 tos2("f64")});
  main__FLOAT_TYPES = new_array_from_c_array(
      2, 2, sizeof(string), (string[]){tos2("f32"), tos2("f64")});
  main__TOKENSTR = build_token_str();
  main__KEYWORDS = build_keys();
  main__AssignTokens = new_array_from_c_array(
      11, 11, sizeof(Token),
      (Token[]){ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN, MULT_ASSIGN, DIV_ASSIGN,
                XOR_ASSIGN, MOD_ASSIGN, OR_ASSIGN, AND_ASSIGN,
                RIGHT_SHIFT_ASSIGN, LEFT_SHIFT_ASSIGN});
}

string _STR(const char *fmt, ...) {
  va_list argptr;
  va_start(argptr, fmt);
  size_t len = vsnprintf(0, 0, fmt, argptr) + 1;
  va_end(argptr);
  byte *buf = malloc(len);
  va_start(argptr, fmt);
  vsprintf(buf, fmt, argptr);
  va_end(argptr);
#ifdef DEBUG_ALLOC
  puts("_STR:");
  puts(buf);
#endif
  return tos2(buf);
}

string _STR_TMP(const char *fmt, ...) {
  va_list argptr;
  va_start(argptr, fmt);
  size_t len = vsnprintf(0, 0, fmt, argptr) + 1;
  va_end(argptr);
  va_start(argptr, fmt);
  vsprintf(g_str_buf, fmt, argptr);
  va_end(argptr);
#ifdef DEBUG_ALLOC
  // puts("_STR_TMP:");
  // puts(g_str_buf);
#endif
  return tos2(g_str_buf);
}
